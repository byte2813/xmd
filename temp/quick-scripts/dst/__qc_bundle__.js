
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__qc_index__.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}
require('./assets/Scripts/Core/AchieveCond');
require('./assets/Scripts/Core/AdsMgr');
require('./assets/Scripts/Core/AdsParam');
require('./assets/Scripts/Core/AudioMgr');
require('./assets/Scripts/Core/Event');
require('./assets/Scripts/Core/Global');
require('./assets/Scripts/Core/GlobalEvent');
require('./assets/Scripts/Core/ItemType');
require('./assets/Scripts/Core/MateBonusType');
require('./assets/Scripts/Core/MateGetType');
require('./assets/Scripts/Core/MateUnLockType');
require('./assets/Scripts/Core/NoticeText');
require('./assets/Scripts/Core/PlatformController');
require('./assets/Scripts/Core/RewardType');
require('./assets/Scripts/Core/ShareInfos');
require('./assets/Scripts/Core/SkillType');
require('./assets/Scripts/Core/TutorialStep');
require('./assets/Scripts/Core/UserDataMgr');
require('./assets/Scripts/Core/UserState');
require('./assets/Scripts/DataMap/Achieve/AchieveCondData');
require('./assets/Scripts/DataMap/Achieve/AchieveData');
require('./assets/Scripts/DataMap/Achieve/AchieveMapDecoder');
require('./assets/Scripts/DataMap/Car/CarData');
require('./assets/Scripts/DataMap/Car/CarMapDecoder');
require('./assets/Scripts/DataMap/Company/CompanyData');
require('./assets/Scripts/DataMap/Company/CompanyMapDecoder');
require('./assets/Scripts/DataMap/Company/ProData');
require('./assets/Scripts/DataMap/EventData/EventCost');
require('./assets/Scripts/DataMap/EventData/EventMapDecoder');
require('./assets/Scripts/DataMap/EventData/EventResult');
require('./assets/Scripts/DataMap/EventData/EventTipData');
require('./assets/Scripts/DataMap/ExtraData');
require('./assets/Scripts/DataMap/Goods/GoodMapDecoder');
require('./assets/Scripts/DataMap/Goods/GoodsData');
require('./assets/Scripts/DataMap/Goods/PriceData');
require('./assets/Scripts/DataMap/House/HouseData');
require('./assets/Scripts/DataMap/House/HouseMapDecoder');
require('./assets/Scripts/DataMap/InitCash/CashData');
require('./assets/Scripts/DataMap/InitCash/CashMapDecoder');
require('./assets/Scripts/DataMap/MapDataMgr');
require('./assets/Scripts/DataMap/Mate/LovePointCost');
require('./assets/Scripts/DataMap/Mate/MateBonus');
require('./assets/Scripts/DataMap/Mate/MateData');
require('./assets/Scripts/DataMap/Mate/MateGetCond');
require('./assets/Scripts/DataMap/Mate/MateMapDecoder');
require('./assets/Scripts/DataMap/Skill/CostData');
require('./assets/Scripts/DataMap/Skill/SkillData');
require('./assets/Scripts/DataMap/Skill/SkillMapDecoder');
require('./assets/Scripts/OwnData/AchieveStruct');
require('./assets/Scripts/OwnData/CarStruct');
require('./assets/Scripts/OwnData/CompanyStruct');
require('./assets/Scripts/OwnData/GoodsStruct');
require('./assets/Scripts/OwnData/HouseStruct');
require('./assets/Scripts/OwnData/MateStruct');
require('./assets/Scripts/OwnData/Native');
require('./assets/Scripts/OwnData/RecordStruct');
require('./assets/Scripts/OwnData/SkillStruct');
require('./assets/Scripts/UI/AddCapacity');
require('./assets/Scripts/UI/AdsRetirePanel');
require('./assets/Scripts/UI/AppStart');
require('./assets/Scripts/UI/BelongItem');
require('./assets/Scripts/UI/BelongMateItem');
require('./assets/Scripts/UI/BetPanel');
require('./assets/Scripts/UI/BuyTipPanel');
require('./assets/Scripts/UI/CarItem');
require('./assets/Scripts/UI/CarPanel');
require('./assets/Scripts/UI/CommonBuyPanel');
require('./assets/Scripts/UI/CommonTipPanel');
require('./assets/Scripts/UI/CompanyBuyTipPanel');
require('./assets/Scripts/UI/CompanyCreateTipPanel');
require('./assets/Scripts/UI/CompanyItem');
require('./assets/Scripts/UI/CompanySaleTipPanel');
require('./assets/Scripts/UI/EnjoyPanel');
require('./assets/Scripts/UI/EventPanel');
require('./assets/Scripts/UI/EventResultPanel');
require('./assets/Scripts/UI/GameScene');
require('./assets/Scripts/UI/GoodsItem');
require('./assets/Scripts/UI/HistoryPanel');
require('./assets/Scripts/UI/HonorItem');
require('./assets/Scripts/UI/HonorPanel');
require('./assets/Scripts/UI/HouseItem');
require('./assets/Scripts/UI/HousePanel');
require('./assets/Scripts/UI/JoyPanel');
require('./assets/Scripts/UI/JoyTipPanel');
require('./assets/Scripts/UI/MarketTipItem');
require('./assets/Scripts/UI/MarketTipPanel');
require('./assets/Scripts/UI/MarryPanel');
require('./assets/Scripts/UI/MateItem');
require('./assets/Scripts/UI/MateItemPanel');
require('./assets/Scripts/UI/MateTipPanel');
require('./assets/Scripts/UI/OwnItem');
require('./assets/Scripts/UI/OwnedCarPanel');
require('./assets/Scripts/UI/OwnedHousePanel');
require('./assets/Scripts/UI/OwnedMatePanel');
require('./assets/Scripts/UI/OwnedPanel');
require('./assets/Scripts/UI/RankPanel');
require('./assets/Scripts/UI/RetirePanel');
require('./assets/Scripts/UI/RotationLoading');
require('./assets/Scripts/UI/SaleTipPanel');
require('./assets/Scripts/UI/SettingPanel');
require('./assets/Scripts/UI/SkillItem');
require('./assets/Scripts/UI/SkillPanel');
require('./assets/Scripts/UI/SkillUpPanel');
require('./assets/Scripts/UI/StartUpPanel');
require('./assets/Scripts/UI/TempBonus');
require('./assets/Scripts/UI/TimePanel');
require('./assets/Scripts/UI/TreatPanel');
require('./assets/Scripts/UI/TutorialPanel');
require('./assets/Scripts/UI/UnlockMatePanel');
require('./assets/Scripts/UI/WatchAdsPanel');
require('./assets/Scripts/sdk/EyouClientKs');
require('./assets/Scripts/sdk/EyouClientTiktok');
require('./assets/Scripts/sdk/eyouClient');
require('./assets/Scripts/utils/httpUtil');
require('./assets/migration/use_v2.0.x_cc.Toggle_event');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/migration/use_v2.0.x_cc.Toggle_event.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'dadb2rwvaBC9IYMLJA/Ijfp', 'use_v2.0.x_cc.Toggle_event');
// migration/use_v2.0.x_cc.Toggle_event.js

"use strict";

/*
 * This script is automatically generated by Cocos Creator and is only compatible with projects prior to v2.1.0.
 * You do not need to manually add this script in any other project.
 * If you don't use cc.Toggle in your project, you can delete this script directly.
 * If your project is hosted in VCS such as git, submit this script together.
 *
 * 此脚本由 Cocos Creator 自动生成，仅用于兼容 v2.1.0 之前版本的工程，
 * 你无需在任何其它项目中手动添加此脚本。
 * 如果你的项目中没用到 Toggle，可直接删除该脚本。
 * 如果你的项目有托管于 git 等版本库，请将此脚本一并上传。
 */

if (cc.Toggle) {
  // Whether the 'toggle' and 'checkEvents' events are fired when 'toggle.check() / toggle.uncheck()' is called in the code
  // 在代码中调用 'toggle.check() / toggle.uncheck()' 时是否触发 'toggle' 与 'checkEvents' 事件
  cc.Toggle._triggerEventInScript_check = true;
}

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcbWlncmF0aW9uXFx1c2VfdjIuMC54X2NjLlRvZ2dsZV9ldmVudC5qcyJdLCJuYW1lcyI6WyJjYyIsIlRvZ2dsZSIsIl90cmlnZ2VyRXZlbnRJblNjcmlwdF9jaGVjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlBLEVBQUUsQ0FBQ0MsTUFBTSxFQUFFO0VBQ1g7RUFDQTtFQUNBRCxFQUFFLENBQUNDLE1BQU0sQ0FBQ0MsMkJBQTJCLEdBQUcsSUFBSTtBQUNoRCIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFRoaXMgc2NyaXB0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IENvY29zIENyZWF0b3IgYW5kIGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIHByb2plY3RzIHByaW9yIHRvIHYyLjEuMC5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBtYW51YWxseSBhZGQgdGhpcyBzY3JpcHQgaW4gYW55IG90aGVyIHByb2plY3QuXG4gKiBJZiB5b3UgZG9uJ3QgdXNlIGNjLlRvZ2dsZSBpbiB5b3VyIHByb2plY3QsIHlvdSBjYW4gZGVsZXRlIHRoaXMgc2NyaXB0IGRpcmVjdGx5LlxuICogSWYgeW91ciBwcm9qZWN0IGlzIGhvc3RlZCBpbiBWQ1Mgc3VjaCBhcyBnaXQsIHN1Ym1pdCB0aGlzIHNjcmlwdCB0b2dldGhlci5cbiAqXG4gKiDmraTohJrmnKznlLEgQ29jb3MgQ3JlYXRvciDoh6rliqjnlJ/miJDvvIzku4XnlKjkuo7lhbzlrrkgdjIuMS4wIOS5i+WJjeeJiOacrOeahOW3peeoi++8jFxuICog5L2g5peg6ZyA5Zyo5Lu75L2V5YW25a6D6aG555uu5Lit5omL5Yqo5re75Yqg5q2k6ISa5pys44CCXG4gKiDlpoLmnpzkvaDnmoTpobnnm67kuK3msqHnlKjliLAgVG9nZ2xl77yM5Y+v55u05o6l5Yig6Zmk6K+l6ISa5pys44CCXG4gKiDlpoLmnpzkvaDnmoTpobnnm67mnInmiZjnrqHkuo4gZ2l0IOetieeJiOacrOW6k++8jOivt+WwhuatpOiEmuacrOS4gOW5tuS4iuS8oOOAglxuICovXG5cbmlmIChjYy5Ub2dnbGUpIHtcbiAgICAvLyBXaGV0aGVyIHRoZSAndG9nZ2xlJyBhbmQgJ2NoZWNrRXZlbnRzJyBldmVudHMgYXJlIGZpcmVkIHdoZW4gJ3RvZ2dsZS5jaGVjaygpIC8gdG9nZ2xlLnVuY2hlY2soKScgaXMgY2FsbGVkIGluIHRoZSBjb2RlXG4gICAgLy8g5Zyo5Luj56CB5Lit6LCD55SoICd0b2dnbGUuY2hlY2soKSAvIHRvZ2dsZS51bmNoZWNrKCknIOaXtuaYr+WQpuinpuWPkSAndG9nZ2xlJyDkuI4gJ2NoZWNrRXZlbnRzJyDkuovku7ZcbiAgICBjYy5Ub2dnbGUuX3RyaWdnZXJFdmVudEluU2NyaXB0X2NoZWNrID0gdHJ1ZTtcbn1cbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Achieve/AchieveMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '63e14JvuXxIE4rXB3/Zgd5X', 'AchieveMapDecoder');
// Scripts/DataMap/Achieve/AchieveMapDecoder.js

"use strict";

var AchieveCondData = require("AchieveCondData");
var AchieveData = require("AchieveData");
var AchieveMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "achieve",
    achieveList: {
      "default": [],
      type: [AchieveData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析成就数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.achieve;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var comData = new AchieveData();
        comData.Id = jsonRoot[i].Id;
        comData.name = jsonRoot[i].name;
        comData.icon = jsonRoot[i].icon;
        comData.desId = jsonRoot[i].desId;
        //完成条件
        for (var j = 0; j < jsonRoot[i].condList.length; j++) {
          var condData = new AchieveCondData();
          var dt = jsonRoot[i].condList[j];
          condData.condType = dt[0];
          condData.value = dt[1];
          comData.condList[j] = condData;
        }
        self.achieveList[i] = comData;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.achieveList.length - 1; i >= 0; i--) {
      if (name == this.achieveList[i].name) {
        data = this.achieveList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.achieveList.length - 1; i >= 0; i--) {
      if (itemId == this.achieveList[i].Id) {
        data = this.achieveList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.achieveList.length;
  },
  getDataList: function getDataList() {
    return this.achieveList;
  }
});
module.exports = AchieveMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQWNoaWV2ZVxcQWNoaWV2ZU1hcERlY29kZXIuanMiXSwibmFtZXMiOlsiQWNoaWV2ZUNvbmREYXRhIiwicmVxdWlyZSIsIkFjaGlldmVEYXRhIiwiQWNoaWV2ZU1hcERlY29kZXIiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImpzb25OYW1lIiwiYWNoaWV2ZUxpc3QiLCJ0eXBlIiwiRGVjb2RlSnNvbiIsImV2ZW50Iiwic2VsZiIsInJlQ2IiLCJsb2FkZXIiLCJsb2FkUmVzIiwiZXJyb3IiLCJvYmoiLCJqc29uUm9vdCIsImpzb24iLCJhY2hpZXZlIiwiaSIsImxlbmd0aCIsImNvbURhdGEiLCJJZCIsIm5hbWUiLCJpY29uIiwiZGVzSWQiLCJqIiwiY29uZExpc3QiLCJjb25kRGF0YSIsImR0IiwiY29uZFR5cGUiLCJ2YWx1ZSIsImdldERhdGFCeU5hbWUiLCJkYXRhIiwiZ2V0RGF0YUJ5SXRlbUlkIiwiaXRlbUlkIiwiZ2V0SnNvbkxlbmd0aCIsImdldERhdGFMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxlQUFlLEdBQUdDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztBQUNoRCxJQUFJQyxXQUFXLEdBQUdELE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDeEMsSUFBSUUsaUJBQWlCLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzdCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFFBQVEsRUFBQyxTQUFTO0lBQ2xCQyxXQUFXLEVBQUM7TUFDUixXQUFRLEVBQUU7TUFDVkMsSUFBSSxFQUFDLENBQUNSLFdBQVc7SUFDckI7RUFDSixDQUFDO0VBRUQ7RUFDQVMsVUFBVSxFQUFDLFNBQUFBLFdBQVVDLEtBQUssRUFBRTtJQUN4QjtJQUNBLElBQUlDLElBQUksR0FBRyxJQUFJO0lB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QUNmLENBQUM7RUFFREcsYUFBYSxFQUFDLFNBQUFBLGNBQUEsRUFBVTtJQUNwQixPQUFPLElBQUksQ0FBQzlCLFdBQVcsQ0FBQ2MsTUFBTTtFQUNsQyxDQUFDO0VBRURpQixXQUFXLEVBQUMsU0FBQUEsWUFBQSxFQUFVO0lBQ2xCLE9BQU8sSUFBSSxDQUFDL0IsV0FBVztFQUMzQjtBQUNKLENBQUMsQ0FBQztBQUNGZ0MsTUFBTSxDQUFDQyxPQUFPLEdBQUd2QyxpQkFBaUIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBBY2hpZXZlQ29uZERhdGEgPSByZXF1aXJlKFwiQWNoaWV2ZUNvbmREYXRhXCIpO1xyXG52YXIgQWNoaWV2ZURhdGEgPSByZXF1aXJlKFwiQWNoaWV2ZURhdGFcIik7XHJcbnZhciBBY2hpZXZlTWFwRGVjb2RlciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAganNvbk5hbWU6XCJhY2hpZXZlXCIsXHJcbiAgICAgICAgYWNoaWV2ZUxpc3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltBY2hpZXZlRGF0YV0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgLy/op6PmnpDmlbDmja5cclxuICAgIERlY29kZUpzb246ZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgLy9jYy5sb2coXCI9PT3op6PmnpDmiJDlsLHmlbDmja49PT1cIik7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYucmVDYiA9IGV2ZW50O1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKFwianNvbi9cIitzZWxmLmpzb25OYW1lLCBmdW5jdGlvbiAoZXJyb3IsIG9iaikge1xyXG4gICAgICAgICAgICBpZihlcnJvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCIrKyvop6PmnpDlh7rplJnvvIzmn6XkuItqc29uKysrXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlQ2IoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIganNvblJvb3QgPSBvYmouanNvbi5hY2hpZXZlO1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIj09PeaVsOaNrumVv+W6pj09PVwiICsganNvblJvb3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uUm9vdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbURhdGEgPSBuZXcgQWNoaWV2ZURhdGEoKTtcclxuICAgICAgICAgICAgICAgIGNvbURhdGEuSWQgPSBqc29uUm9vdFtpXS5JZDtcclxuICAgICAgICAgICAgICAgIGNvbURhdGEubmFtZSA9IGpzb25Sb290W2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBjb21EYXRhLmljb24gPSBqc29uUm9vdFtpXS5pY29uO1xyXG4gICAgICAgICAgICAgICAgY29tRGF0YS5kZXNJZCA9IGpzb25Sb290W2ldLmRlc0lkO1xyXG4gICAgICAgICAgICAgICAgLy/lrozmiJDmnaHku7ZcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwganNvblJvb3RbaV0uY29uZExpc3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZERhdGEgPSBuZXcgQWNoaWV2ZUNvbmREYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR0ID0ganNvblJvb3RbaV0uY29uZExpc3Rbal07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZERhdGEuY29uZFR5cGUgPSBkdFswXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25kRGF0YS52YWx1ZSA9IGR0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbURhdGEuY29uZExpc3Rbal0gPSBjb25kRGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc2VsZi5hY2hpZXZlTGlzdFtpXSA9IGNvbURhdGE7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYucmVDYih0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgJrov4flkI3lrZfmi7/liLDlvZPliY3nmoTmlbDmja4g5LiN5bu66K6u55So77yM5L2g6KaB55So5oiR5Lmf5rKh5Yqe5rOVXHJcbiAgICBnZXREYXRhQnlOYW1lOmZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmFjaGlldmVMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gdGhpcy5hY2hpZXZlTGlzdFtpXS5uYW1lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5hY2hpZXZlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+mAmui/h2l0ZW1pZOiOt+WPluaVsOaNrlxyXG4gICAgZ2V0RGF0YUJ5SXRlbUlkOmZ1bmN0aW9uKGl0ZW1JZCl7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmFjaGlldmVMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKGl0ZW1JZCA9PSB0aGlzLmFjaGlldmVMaXN0W2ldLklkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5hY2hpZXZlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRKc29uTGVuZ3RoOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNoaWV2ZUxpc3QubGVuZ3RoXHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGFMaXN0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNoaWV2ZUxpc3Q7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBBY2hpZXZlTWFwRGVjb2RlcjtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/Event.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '19fbasFZxBOI4hgnBazod2R', 'Event');
// Scripts/Core/Event.js

"use strict";

var Event = cc.Class({
  "extends": cc.Component,
  statics: {
    ParseFinish: "ParseFinish",
    //解析数据完毕
    //StartScene
    AchieveTip: "AchieveTip",
    OpenUpgradeSkill: "OpenUpgradeSkill",
    AddWareHouseCapacity: "AddWareHouseCapacity",
    //增加仓储容量
    OpenEventTip: "OpenEventTip",
    OpenStockBonus: "OpenStockBonus",
    RefreshCashAsset: "RefreshCashAsset",
    //提醒刷新 现金和资产

    //GameScene
    OpenBuyTip: "OpenBuyTip",
    //打开购买窗口
    OpenSaleTip: "OpenSaleTip",
    //打开出售窗口
    OpenCommonTip: "OpenCommonTip",
    OpenCompanyCreate: "OpenCompanyCreate",
    //创办公司
    OpenStuckBuyTip: "OpenStuckBuyTip",
    //买入公司股票
    OpenStuckSaleTip: "OpenStuckSaleTip",
    //出售公司股票
    BuySuccess: "BuySuccess",
    //
    SaleSuccess: "SaleSuccess",
    //
    CreateCompanySuccess: "CreateCompanySuccess",
    //创办公司成立
    BuyStockSuccess: "BuyStockSuccess",
    //购买股票成立
    SaleStockSuccess: "SaleStockSuccess",
    //抛售股票成立
    OpenMateTip: "OpenMateTip",
    //打开约会提示
    DateSuccess: "DateSuccess",
    //约上了
    OpenCommonBuy: "OpenCommonBuy",
    //打开公用购买 汽车和房子
    CommonBuySaleSuccess: "CommonBuySuccess",
    //通用购买 出售成功
    TreatSuccess: "TreatSuccess",
    //治疗成功
    OpenBetTip: "OpenBetTip",
    //打开赌博
    BetOk: "BetOk",
    //赌博完成
    Retire: "Retire",
    //退休
    OpenEventResult: "OpenEventResult",
    OpenMarry: "OpenMarry",
    OpenTutorial: "OpenTutorial",
    //通知打开引导窗口

    ClockEnd: "ClockEnd",
    //时间转圈结束
    UseRetireAdsSkill: "UseRetireAdsSkill",
    //使用退休广告加持

    RefreshAllUIShow: "RefreshAllUIShow",
    //刷新全部Ui
    OpenUnLockMate: "OpenUnLockMate",
    DateLater: "DateLater",
    ShowRank: "ShowRank",
    OpenEnjoy: "OpenEnjoy",
    //打开花钱面板

    ShareVideo: "ShareVideo" //分享录屏
  }
});

module.exports = Event;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcRXZlbnQuanMiXSwibmFtZXMiOlsiRXZlbnQiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50Iiwic3RhdGljcyIsIlBhcnNlRmluaXNoIiwiQWNoaWV2ZVRpcCIsIk9wZW5VcGdyYWRlU2tpbGwiLCJBZGRXYXJlSG91c2VDYXBhY2l0eSIsIk9wZW5FdmVudFRpcCIsIk9wZW5TdG9ja0JvbnVzIiwiUmVmcmVzaENhc2hBc3NldCIsIk9wZW5CdXlUaXAiLCJPcGVuU2FsZVRpcCIsIk9wZW5Db21tb25UaXAiLCJPcGVuQ29tcGFueUNyZWF0ZSIsIk9wZW5TdHVja0J1eVRpcCIsIk9wZW5TdHVja1NhbGVUaXAiLCJCdXlTdWNjZXNzIiwiU2FsZVN1Y2Nlc3MiLCJDcmVhdGVDb21wYW55U3VjY2VzcyIsIkJ1eVN0b2NrU3VjY2VzcyIsIlNhbGVTdG9ja1N1Y2Nlc3MiLCJPcGVuTWF0ZVRpcCIsIkRhdGVTdWNjZXNzIiwiT3BlbkNvbW1vbkJ1eSIsIkNvbW1vbkJ1eVNhbGVTdWNjZXNzIiwiVHJlYXRTdWNjZXNzIiwiT3BlbkJldFRpcCIsIkJldE9rIiwiUmV0aXJlIiwiT3BlbkV2ZW50UmVzdWx0IiwiT3Blbk1hcnJ5IiwiT3BlblR1dG9yaWFsIiwiQ2xvY2tFbmQiLCJVc2VSZXRpcmVBZHNTa2lsbCIsIlJlZnJlc2hBbGxVSVNob3ciLCJPcGVuVW5Mb2NrTWF0ZSIsIkRhdGVMYXRlciIsIlNob3dSYW5rIiwiT3BlbkVuam95IiwiU2hhcmVWaWRlbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsS0FBSyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNqQixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFDckJDLE9BQU8sRUFBQztJQUNKQyxXQUFXLEVBQUMsYUFBYTtJQUFDO0lBQzFCO0lBQ0FDLFVBQVUsRUFBQyxZQUFZO0lBQ3ZCQyxnQkFBZ0IsRUFBQyxrQkFBa0I7SUFDbkNDLG9CQUFvQixFQUFDLHNCQUFzQjtJQUFDO0lBQzVDQyxZQUFZLEVBQUMsY0FBYztJQUMzQkMsY0FBYyxFQUFDLGdCQUFnQjtJQUcvQkMsZ0JBQWdCLEVBQUMsa0JBQWtCO0lBQUM7O0lBRXBDO0lBQ0FDLFVBQVUsRUFBQyxZQUFZO0lBQUM7SUFDeEJDLFdBQVcsRUFBQyxhQUFhO0lBQUM7SUFDMUJDLGFBQWEsRUFBQyxlQUFlO0lBQzdCQyxpQkFBaUIsRUFBQyxtQkFBbUI7SUFBQztJQUN0Q0MsZUFBZSxFQUFDLGlCQUFpQjtJQUFDO0lBQ2xDQyxnQkFBZ0IsRUFBQyxrQkFBa0I7SUFBQztJQUNwQ0MsVUFBVSxFQUFDLFlBQVk7SUFBQztJQUN4QkMsV0FBVyxFQUFDLGFBQWE7SUFBQztJQUMxQkMsb0JBQW9CLEVBQUMsc0JBQXNCO0lBQUM7SUFDNUNDLGVBQWUsRUFBQyxpQkFBaUI7SUFBQztJQUNsQ0MsZ0JBQWdCLEVBQUMsa0JBQWtCO0lBQUM7SUFDcENDLFdBQVcsRUFBQyxhQUFhO0lBQUU7SUFDM0JDLFdBQVcsRUFBQyxhQUFhO0lBQUM7SUFDMUJDLGFBQWEsRUFBQyxlQUFlO0lBQUM7SUFDOUJDLG9CQUFvQixFQUFDLGtCQUFrQjtJQUFDO0lBQ3hDQyxZQUFZLEVBQUMsY0FBYztJQUFDO0lBQzVCQyxVQUFVLEVBQUMsWUFBWTtJQUFDO0lBQ3hCQyxLQUFLLEVBQUMsT0FBTztJQUFDO0lBQ2RDLE1BQU0sRUFBQyxRQUFRO0lBQUM7SUFDaEJDLGVBQWUsRUFBQyxpQkFBaUI7SUFFakNDLFNBQVMsRUFBQyxXQUFXO0lBRXJCQyxZQUFZLEVBQUMsY0FBYztJQUFFOztJQUU3QkMsUUFBUSxFQUFDLFVBQVU7SUFBQztJQUNwQkMsaUJBQWlCLEVBQUMsbUJBQW1CO0lBQUM7O0lBRXRDQyxnQkFBZ0IsRUFBQyxrQkFBa0I7SUFBRTtJQUNyQ0MsY0FBYyxFQUFDLGdCQUFnQjtJQUUvQkMsU0FBUyxFQUFDLFdBQVc7SUFFckJDLFFBQVEsRUFBQyxVQUFVO0lBRW5CQyxTQUFTLEVBQUMsV0FBVztJQUFDOztJQUV0QkMsVUFBVSxFQUFDLFlBQVksQ0FBQztFQUM1QjtBQUNKLENBQUMsQ0FBQzs7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUczQyxLQUFLIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIEV2ZW50ID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG4gICAgc3RhdGljczp7XHJcbiAgICAgICAgUGFyc2VGaW5pc2g6XCJQYXJzZUZpbmlzaFwiLC8v6Kej5p6Q5pWw5o2u5a6M5q+VXHJcbiAgICAgICAgLy9TdGFydFNjZW5lXHJcbiAgICAgICAgQWNoaWV2ZVRpcDpcIkFjaGlldmVUaXBcIixcclxuICAgICAgICBPcGVuVXBncmFkZVNraWxsOlwiT3BlblVwZ3JhZGVTa2lsbFwiLFxyXG4gICAgICAgIEFkZFdhcmVIb3VzZUNhcGFjaXR5OlwiQWRkV2FyZUhvdXNlQ2FwYWNpdHlcIiwvL+WinuWKoOS7k+WCqOWuuemHj1xyXG4gICAgICAgIE9wZW5FdmVudFRpcDpcIk9wZW5FdmVudFRpcFwiLFxyXG4gICAgICAgIE9wZW5TdG9ja0JvbnVzOlwiT3BlblN0b2NrQm9udXNcIixcclxuXHJcblxyXG4gICAgICAgIFJlZnJlc2hDYXNoQXNzZXQ6XCJSZWZyZXNoQ2FzaEFzc2V0XCIsLy/mj5DphpLliLfmlrAg546w6YeR5ZKM6LWE5LqnXHJcblxyXG4gICAgICAgIC8vR2FtZVNjZW5lXHJcbiAgICAgICAgT3BlbkJ1eVRpcDpcIk9wZW5CdXlUaXBcIiwvL+aJk+W8gOi0reS5sOeql+WPo1xyXG4gICAgICAgIE9wZW5TYWxlVGlwOlwiT3BlblNhbGVUaXBcIiwvL+aJk+W8gOWHuuWUrueql+WPo1xyXG4gICAgICAgIE9wZW5Db21tb25UaXA6XCJPcGVuQ29tbW9uVGlwXCIsXHJcbiAgICAgICAgT3BlbkNvbXBhbnlDcmVhdGU6XCJPcGVuQ29tcGFueUNyZWF0ZVwiLC8v5Yib5Yqe5YWs5Y+4XHJcbiAgICAgICAgT3BlblN0dWNrQnV5VGlwOlwiT3BlblN0dWNrQnV5VGlwXCIsLy/kubDlhaXlhazlj7jogqHnpahcclxuICAgICAgICBPcGVuU3R1Y2tTYWxlVGlwOlwiT3BlblN0dWNrU2FsZVRpcFwiLC8v5Ye65ZSu5YWs5Y+46IKh56WoXHJcbiAgICAgICAgQnV5U3VjY2VzczpcIkJ1eVN1Y2Nlc3NcIiwvL1xyXG4gICAgICAgIFNhbGVTdWNjZXNzOlwiU2FsZVN1Y2Nlc3NcIiwvL1xyXG4gICAgICAgIENyZWF0ZUNvbXBhbnlTdWNjZXNzOlwiQ3JlYXRlQ29tcGFueVN1Y2Nlc3NcIiwvL+WIm+WKnuWFrOWPuOaIkOeri1xyXG4gICAgICAgIEJ1eVN0b2NrU3VjY2VzczpcIkJ1eVN0b2NrU3VjY2Vzc1wiLC8v6LSt5Lmw6IKh56Wo5oiQ56uLXHJcbiAgICAgICAgU2FsZVN0b2NrU3VjY2VzczpcIlNhbGVTdG9ja1N1Y2Nlc3NcIiwvL+aKm+WUruiCoeelqOaIkOeri1xyXG4gICAgICAgIE9wZW5NYXRlVGlwOlwiT3Blbk1hdGVUaXBcIiwgLy/miZPlvIDnuqbkvJrmj5DnpLpcclxuICAgICAgICBEYXRlU3VjY2VzczpcIkRhdGVTdWNjZXNzXCIsLy/nuqbkuIrkuoZcclxuICAgICAgICBPcGVuQ29tbW9uQnV5OlwiT3BlbkNvbW1vbkJ1eVwiLC8v5omT5byA5YWs55So6LSt5LmwIOaxvei9puWSjOaIv+WtkFxyXG4gICAgICAgIENvbW1vbkJ1eVNhbGVTdWNjZXNzOlwiQ29tbW9uQnV5U3VjY2Vzc1wiLC8v6YCa55So6LSt5LmwIOWHuuWUruaIkOWKn1xyXG4gICAgICAgIFRyZWF0U3VjY2VzczpcIlRyZWF0U3VjY2Vzc1wiLC8v5rK755aX5oiQ5YqfXHJcbiAgICAgICAgT3BlbkJldFRpcDpcIk9wZW5CZXRUaXBcIiwvL+aJk+W8gOi1jOWNmlxyXG4gICAgICAgIEJldE9rOlwiQmV0T2tcIiwvL+i1jOWNmuWujOaIkFxyXG4gICAgICAgIFJldGlyZTpcIlJldGlyZVwiLC8v6YCA5LyRXHJcbiAgICAgICAgT3BlbkV2ZW50UmVzdWx0OlwiT3BlbkV2ZW50UmVzdWx0XCIsXHJcblxyXG4gICAgICAgIE9wZW5NYXJyeTpcIk9wZW5NYXJyeVwiLFxyXG5cclxuICAgICAgICBPcGVuVHV0b3JpYWw6XCJPcGVuVHV0b3JpYWxcIiwgLy/pgJrnn6XmiZPlvIDlvJXlr7znqpflj6NcclxuXHJcbiAgICAgICAgQ2xvY2tFbmQ6XCJDbG9ja0VuZFwiLC8v5pe26Ze06L2s5ZyI57uT5p2fXHJcbiAgICAgICAgVXNlUmV0aXJlQWRzU2tpbGw6XCJVc2VSZXRpcmVBZHNTa2lsbFwiLC8v5L2/55So6YCA5LyR5bm/5ZGK5Yqg5oyBXHJcblxyXG4gICAgICAgIFJlZnJlc2hBbGxVSVNob3c6XCJSZWZyZXNoQWxsVUlTaG93XCIsIC8v5Yi35paw5YWo6YOoVWlcclxuICAgICAgICBPcGVuVW5Mb2NrTWF0ZTpcIk9wZW5VbkxvY2tNYXRlXCIsXHJcblxyXG4gICAgICAgIERhdGVMYXRlcjpcIkRhdGVMYXRlclwiLFxyXG5cclxuICAgICAgICBTaG93UmFuazpcIlNob3dSYW5rXCIsXHJcblxyXG4gICAgICAgIE9wZW5FbmpveTpcIk9wZW5FbmpveVwiLC8v5omT5byA6Iqx6ZKx6Z2i5p2/XHJcblxyXG4gICAgICAgIFNoYXJlVmlkZW86XCJTaGFyZVZpZGVvXCIsLy/liIbkuqvlvZXlsY9cclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Car/CarMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4f440rFno5GEL3da5tzZDHV', 'CarMapDecoder');
// Scripts/DataMap/Car/CarMapDecoder.js

"use strict";

var CarData = require("CarData");
var CarMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "car",
    carList: {
      "default": [],
      type: [CarData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析汽车数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.car;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var carD = new CarData();
        carD.Id = jsonRoot[i].Id;
        carD.icon = jsonRoot[i].icon;
        carD.name = jsonRoot[i].name;
        carD.price = jsonRoot[i].price;
        carD.addBonus = jsonRoot[i].addBonus;
        carD.addHp = jsonRoot[i].addHp;
        carD.addDate = jsonRoot[i].addDate;
        self.carList[i] = carD;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.carList.length - 1; i >= 0; i--) {
      if (name == this.carList[i].name) {
        data = this.carList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.carList.length - 1; i >= 0; i--) {
      if (itemId == this.carList[i].Id) {
        data = this.carList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.carList.length;
  },
  getDataList: function getDataList() {
    return this.carList;
  }
});
module.exports = CarMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQ2FyXFxDYXJNYXBEZWNvZGVyLmpzIl0sIm5hbWVzIjpbIkNhckRhdGEiLCJyZXF1aXJlIiwiQ2FyTWFwRGVjb2RlciIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwianNvbk5hbWUiLCJjYXJMaXN0IiwidHlwZSIsIkRlY29kZUpzb24iLCJldmVudCIsInNlbGYiLCJyZUNiIiwibG9hZGVyIiwibG9hZFJlcyIsImVycm9yIiwib2JqIiwianNvblJvb3QiLCJqc29uIiwiY2FyIiwiaSIsImxlbmd0aCIsImNhckQiLCJJZCIsImljb24iLCJuYW1lIiwicHJpY2UiLCJhZGRCb251cyIsImFkZEhwIiwiYWRkRGF0ZSIsImdldERhdGFCeU5hbWUiLCJkYXRhIiwiZ2V0RGF0YUJ5SXRlbUlkIiwiaXRlbUlkIiwiZ2V0SnNvbkxlbmd0aCIsImdldERhdGFMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxPQUFPLEdBQUdDLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFDaEMsSUFBSUMsYUFBYSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN6QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxRQUFRLEVBQUMsS0FBSztJQUNkQyxPQUFPLEVBQUM7TUFDSixXQUFRLEVBQUU7TUFDVkMsSUFBSSxFQUFDLENBQUNULE9BQU87SUFDakI7RUFDSixDQUFDO0VBRUQ7RUFDQVUsVUFBVSxFQUFDLFNBQUFBLFdBQVVDLEtBQUssRUFBRTtJQUN4QjtJQUNBLElBQUlDLElBQUksR0FBRyxJQUFJO0lBQ2ZBLElBQUksQ0FBQ0MsSUFBSSxHQUFHRixLQUFLO0lBQ2pCUixFQUFFLENBQUNXLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sR0FBQ0gsSUFBSSxDQUFDTCxRQUFRLEVBQUUsVUFBVVMsS0FBSyxFQUFFQyxHQUFHLEVBQUU7TUFDM0QsSUFBR0QsS0FBSyxFQUNSO1FBQ0k7UUFDQUosSUFBSSxDQUFDQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ2hCO01BQ0o7TUFFQSxJQUFJSyxRQUFRLEdBQUdELEdBQUcsQ0FBQ0UsSUFBSSxDQUFDQyxHQUFHO01BQzNCO01BQ0EsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdILFFBQVEsQ0FBQ0ksTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtRQUN0QyxJQUFJRSxJQUFJLEdBQUcsSUFBSXZCLE9BQU8sRUFBRTtRQUN4QnVCLElBQUksQ0FBQ0MsRUFBRSxHQUFHTixRQUFRLENBQUNHLENBQUMsQ0FBQyxDQUFDRyxFQUFFO1FBQ3hCRCxJQUFJLENBQUNFLElBQUksR0FBR1AsUUFBUSxDQUFDRyxDQUFDLENBQUMsQ0FBQ0ksSUFBSTtRQUM1QkYsSUFBSSxDQUFDRyxJQUFJLEdBQUdSLFFBQVEsQ0FBQ0csQ0FBQyxDQUFDLENBQUNLLElBQUk7UUFDNUJILElBQUksQ0FBQ0ksS0FBSyxHQUFHVCxRQUFRLENBQUNHLENBQUMsQ0FBQyxDQUFDTSxLQUFLO1FBQzlCSixJQUFJLENBQUNLLFFBQVEsR0FBR1YsUUFBUSxDQUFDRyxDQUFDLENBQUMsQ0FBQ08sUUFBUTtRQUNwQ0wsSUFBSSxDQUFDTSxLQUFLLEdBQUdYLFFBQVEsQ0FBQ0csQ0FBQyxDQUFDLENBQUNRLEtBQUs7UUFDOUJOLElBQUksQ0FBQ08sT0FBTyxHQUFHWixRQUFRLENBQUNHLENBQUMsQ0FBQyxDQUFDUyxPQUFPO1FBQ2xDbEIsSUFBSSxDQUFDSixPQUFPLENBQUNhLENBQUMsQ0FBQyxHQUFHRSxJQUFJO01BQzFCO01BQ0FYLElBQUksQ0FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDLENBQUM7RUFDTixDQUFDO0VBRUQ7RUFDQWtCLGFBQWEsRUFBQyxTQUFBQSxjQUFVTCxJQUFJLEVBQUU7SUFDMUIsSUFBSU0sSUFBSSxHQUFHLElBQUk7SUFDZixLQUFLLElBQUlYLENBQUMsR0FBRyxJQUFJLENBQUNiLE9BQU8sQ0FBQ2MsTUFBTSxHQUFHLENBQUMsRUFBRUQsQ0FBQyxJQUFJLENBQUMsRUFBRUEsQ0FBQyxFQUFFLEVBQUU7TUFDL0MsSUFBR0ssSUFBSSxJQUFJLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ2EsQ0FBQyxDQUFDLENBQUNLLElBQUksRUFDL0I7UUFDSU0sSUFBSSxHQUFHLElBQUksQ0FBQ3hCLE9BQU8sQ0FBQ2EsQ0FBQyxDQUFDO1FBQ3RCO01BQ0o7SUFDSjtJQUNBLE9BQU9XLElBQUk7RUFDZixDQUFDO0VBRUQ7RUFDQUMsZUFBZSxFQUFDLFNBQUFBLGdCQUFTQyxNQUFNLEVBQUM7SUFDNUIsSUFBSUYsSUFBSSxHQUFHLElBQUk7SUFDZixLQUFLLElBQUlYLENBQUMsR0FBRyxJQUFJLENBQUNiLE9BQU8sQ0FBQ2MsTUFBTSxHQUFHLENBQUMsRUFBRUQsQ0FBQyxJQUFJLENBQUMsRUFBRUEsQ0FBQyxFQUFFLEVBQUU7TUFDL0MsSUFBR2EsTUFBTSxJQUFJLElBQUksQ0FBQzFCLE9BQU8sQ0FBQ2EsQ0FBQyxDQUFDLENBQUNHLEVBQUUsRUFDL0I7UUFDSVEsSUFBSSxHQUFHLElBQUksQ0FBQ3hCLE9BQU8sQ0FBQ2EsQ0FBQyxDQUFDO1FBQ3RCO01BQ0o7SUFDSjtJQUNBLE9BQU9XLElBQUk7RUFDZixDQUFDO0VBRURHLGFBQWEsRUFBQyxTQUFBQSxjQUFBLEVBQVU7SUFDcEIsT0FBTyxJQUFJLENBQUMzQixPQUFPLENBQUNjLE1BQU07RUFDOUIsQ0FBQztFQUVEYyxXQUFXLEVBQUMsU0FBQUEsWUFBQSxFQUFVO0lBQ2xCLE9BQU8sSUFBSSxDQUFDNUIsT0FBTztFQUN2QjtBQUNKLENBQUMsQ0FBQztBQUNGNkIsTUFBTSxDQUFDQyxPQUFPLEdBQUdwQyxhQUFhIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ2FyRGF0YSA9IHJlcXVpcmUoXCJDYXJEYXRhXCIpO1xyXG52YXIgQ2FyTWFwRGVjb2RlciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAganNvbk5hbWU6XCJjYXJcIixcclxuICAgICAgICBjYXJMaXN0OntcclxuICAgICAgICAgICAgZGVmYXVsdDpbXSxcclxuICAgICAgICAgICAgdHlwZTpbQ2FyRGF0YV0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgLy/op6PmnpDmlbDmja5cclxuICAgIERlY29kZUpzb246ZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgLy9jYy5sb2coXCI9PT3op6PmnpDmsb3ovabmlbDmja49PT1cIik7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYucmVDYiA9IGV2ZW50O1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKFwianNvbi9cIitzZWxmLmpzb25OYW1lLCBmdW5jdGlvbiAoZXJyb3IsIG9iaikge1xyXG4gICAgICAgICAgICBpZihlcnJvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCIrKyvop6PmnpDlh7rplJnvvIzmn6XkuItqc29uKysrXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlQ2IoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIganNvblJvb3QgPSBvYmouanNvbi5jYXI7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwiPT095pWw5o2u6ZW/5bqmPT09XCIgKyBqc29uUm9vdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25Sb290Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FyRCA9IG5ldyBDYXJEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBjYXJELklkID0ganNvblJvb3RbaV0uSWQ7XHJcbiAgICAgICAgICAgICAgICBjYXJELmljb24gPSBqc29uUm9vdFtpXS5pY29uO1xyXG4gICAgICAgICAgICAgICAgY2FyRC5uYW1lID0ganNvblJvb3RbaV0ubmFtZTtcclxuICAgICAgICAgICAgICAgIGNhckQucHJpY2UgPSBqc29uUm9vdFtpXS5wcmljZTtcclxuICAgICAgICAgICAgICAgIGNhckQuYWRkQm9udXMgPSBqc29uUm9vdFtpXS5hZGRCb251cztcclxuICAgICAgICAgICAgICAgIGNhckQuYWRkSHAgPSBqc29uUm9vdFtpXS5hZGRIcDtcclxuICAgICAgICAgICAgICAgIGNhckQuYWRkRGF0ZSA9IGpzb25Sb290W2ldLmFkZERhdGU7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNhckxpc3RbaV0gPSBjYXJEOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnJlQ2IodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6YCa6L+H5ZCN5a2X5ou/5Yiw5b2T5YmN55qE5pWw5o2uIOS4jeW7uuiurueUqO+8jOS9oOimgeeUqOaIkeS5n+ayoeWKnuazlVxyXG4gICAgZ2V0RGF0YUJ5TmFtZTpmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jYXJMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gdGhpcy5jYXJMaXN0W2ldLm5hbWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmNhckxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgJrov4dpdGVtaWTojrflj5bmlbDmja5cclxuICAgIGdldERhdGFCeUl0ZW1JZDpmdW5jdGlvbihpdGVtSWQpe1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jYXJMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKGl0ZW1JZCA9PSB0aGlzLmNhckxpc3RbaV0uSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmNhckxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SnNvbkxlbmd0aDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhckxpc3QubGVuZ3RoXHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGFMaXN0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FyTGlzdDtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENhck1hcERlY29kZXI7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Company/CompanyData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9e61cjcHeVApKXn3yzx/j6m', 'CompanyData');
// Scripts/DataMap/Company/CompanyData.js

"use strict";

var ProData = require("ProData");
var CompanyData = cc.Class({
  name: "CompanyData",
  properties: {
    Id: cc.Integer,
    icon: "",
    name: "",
    inPrice: 15.20,
    // 价格
    outPrice: 15.20,
    //破产点
    LimitYear: cc.Integer,
    //限制交易年限
    bonusRatio: 0.02,
    proList: [ProData],
    //盈亏
    unList: [ProData] //没有买到时候的盈亏刷新比例
  }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQ29tcGFueVxcQ29tcGFueURhdGEuanMiXSwibmFtZXMiOlsiUHJvRGF0YSIsInJlcXVpcmUiLCJDb21wYW55RGF0YSIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsIklkIiwiSW50ZWdlciIsImljb24iLCJpblByaWNlIiwib3V0UHJpY2UiLCJMaW1pdFllYXIiLCJib251c1JhdGlvIiwicHJvTGlzdCIsInVuTGlzdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxPQUFPLEdBQUdDLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFDaEMsSUFBSUMsV0FBVyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN2QkMsSUFBSSxFQUFDLGFBQWE7RUFDbEJDLFVBQVUsRUFBRTtJQUNSQyxFQUFFLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUNiQyxJQUFJLEVBQUMsRUFBRTtJQUNQSixJQUFJLEVBQUMsRUFBRTtJQUNQSyxPQUFPLEVBQUMsS0FBSztJQUFDO0lBQ2RDLFFBQVEsRUFBQyxLQUFLO0lBQUM7SUFDZkMsU0FBUyxFQUFDVCxFQUFFLENBQUNLLE9BQU87SUFBRTtJQUN0QkssVUFBVSxFQUFDLElBQUk7SUFDZkMsT0FBTyxFQUFDLENBQUNkLE9BQU8sQ0FBQztJQUFFO0lBQ25CZSxNQUFNLEVBQUMsQ0FBQ2YsT0FBTyxDQUFDLENBQUM7RUFDckI7QUFDSixDQUFDLENBQUMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBQcm9EYXRhID0gcmVxdWlyZShcIlByb0RhdGFcIik7XHJcbnZhciBDb21wYW55RGF0YSA9IGNjLkNsYXNzKHtcclxuICAgIG5hbWU6XCJDb21wYW55RGF0YVwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIElkOmNjLkludGVnZXIsXHJcbiAgICAgICAgaWNvbjpcIlwiLFxyXG4gICAgICAgIG5hbWU6XCJcIixcclxuICAgICAgICBpblByaWNlOjE1LjIwLC8vIOS7t+agvFxyXG4gICAgICAgIG91dFByaWNlOjE1LjIwLC8v56C05Lqn54K5XHJcbiAgICAgICAgTGltaXRZZWFyOmNjLkludGVnZXIsIC8v6ZmQ5Yi25Lqk5piT5bm06ZmQXHJcbiAgICAgICAgYm9udXNSYXRpbzowLjAyLFxyXG4gICAgICAgIHByb0xpc3Q6W1Byb0RhdGFdLCAvL+ebiOS6j1xyXG4gICAgICAgIHVuTGlzdDpbUHJvRGF0YV0sLy/msqHmnInkubDliLDml7blgJnnmoTnm4jkuo/liLfmlrDmr5TkvotcclxuICAgIH0sXHJcbn0pO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/EventData/EventMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '49f31Sx7i1Jg51B22IXJ8Fr', 'EventMapDecoder');
// Scripts/DataMap/EventData/EventMapDecoder.js

"use strict";

var EventData = require("EventTipData");
var EventCost = require("EventCost");
var EventResult = require("EventResult");
var EventMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "events",
    eventList: {
      "default": [],
      type: [EventData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析事件数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.events;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var eventData = new EventData();
        eventData.Id = jsonRoot[i].Id;
        //eventData.icon = jsonRoot[i].icon;
        eventData.name = jsonRoot[i].name;
        eventData.desId = jsonRoot[i].desId;

        //消耗
        for (var j = 0; j < jsonRoot[i].cost.length; j++) {
          var cData = new EventCost();
          var dt = jsonRoot[i].cost[j];
          cData.costType = dt[0];
          cData.costNum = dt[1];
          cData.desId = dt[2];
          eventData.cost[j] = cData;
        }
        //正向两种结果
        for (var j = 0; j < jsonRoot[i].Yresult.length; j++) {
          var cData = new EventResult();
          var data = jsonRoot[i].Yresult[j];
          cData.rewardType = data[0];
          cData.rewardNum = data[1];
          cData.rewardId = data[2]; //如果奖励的是金钱等  则id 为0
          cData.desId = data[3];
          eventData.YResults[j] = cData;
        }
        //负向两种结果
        for (var j = 0; j < jsonRoot[i].Nresult.length; j++) {
          var cData = new EventResult();
          var data = jsonRoot[i].Nresult[j];
          cData.rewardType = data[0];
          cData.rewardNum = data[1];
          cData.rewardId = data[2]; //如果奖励的是金钱等  则id 为0
          cData.desId = data[3];
          eventData.NResults[j] = cData;
        }
        self.eventList[i] = eventData;
      }
      self.reCb(true);
    });
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.eventList.length - 1; i >= 0; i--) {
      if (itemId == this.eventList[i].Id) {
        data = this.eventList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.eventList.length;
  },
  getDataList: function getDataList() {
    return this.eventList;
  }
});
module.exports = EventMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcRXZlbnREYXRhXFxFdmVudE1hcERlY29kZXIuanMiXSwibmFtZXMiOlsiRXZlbnREYXRhIiwicmVxdWlyZSIsIkV2ZW50Q29zdCIsIkV2ZW50UmVzdWx0IiwiRXZlbnRNYXBEZWNvZGVyIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJqc29uTmFtZSIsImV2ZW50TGlzdCIsInR5cGUiLCJEZWNvZGVKc29uIiwiZXZlbnQiLCJzZWxmIiwicmVDYiIsImxvYWRlciIsImxvYWRSZXMiLCJlcnJvciIsIm9iaiIsImpzb25Sb290IiwianNvbiIsImV2ZW50cyIsImkiLCJsZW5ndGgiLCJldmVudERhdGEiLCJJZCIsIm5hbWUiLCJkZXNJZCIsImoiLCJjb3N0IiwiY0RhdGEiLCJkdCIsImNvc3RUeXBlIiwiY29zdE51bSIsIllyZXN1bHQiLCJkYXRhIiwicmV3YXJkVHlwZSIsInJld2FyZE51bSIsInJld2FyZElkIiwiWVJlc3VsdHMiLCJOcmVzdWx0IiwiTlJlc3VsdHMiLCJnZXREYXRhQnlJdGVtSWQiLCJpdGVtSWQiLCJnZXRKc29uTGVuZ3RoIiwiZ2V0RGF0YUxpc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFNBQVMsR0FBR0MsT0FBTyxDQUFDLGNBQWMsQ0FBQztBQUN2QyxJQUFJQyxTQUFTLEdBQUdELE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDcEMsSUFBSUUsV0FBVyxHQUFHRixPQUFPLENBQUMsYUFBYSxDQUFDO0FBQ3hDLElBQUlHLGVBQWUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDM0IsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDLFFBQVE7SUFDakJDLFNBQVMsRUFBQztNQUNULFdBQVEsRUFBRTtNQUNWQyxJQUFJLEVBQUMsQ0FBQ1gsU0FBUztJ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QyxDQUFDO0FBQ0ZxQyxNQUFNLENBQUNDLE9BQU8sR0FBRzVDLGVBQWUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFdmVudERhdGEgPSByZXF1aXJlKFwiRXZlbnRUaXBEYXRhXCIpO1xyXG52YXIgRXZlbnRDb3N0ID0gcmVxdWlyZShcIkV2ZW50Q29zdFwiKTtcclxudmFyIEV2ZW50UmVzdWx0ID0gcmVxdWlyZShcIkV2ZW50UmVzdWx0XCIpO1xyXG52YXIgRXZlbnRNYXBEZWNvZGVyID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBqc29uTmFtZTpcImV2ZW50c1wiLFxyXG4gICAgICAgIGV2ZW50TGlzdDp7XHJcbiAgICAgICAgXHRkZWZhdWx0OltdLFxyXG4gICAgICAgIFx0dHlwZTpbRXZlbnREYXRhXSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuXHJcbiAgICAvL+ino+aekOaVsOaNrlxyXG4gICAgRGVjb2RlSnNvbjpmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAvL2NjLmxvZyhcIj09Peino+aekOS6i+S7tuaVsOaNrj09PVwiKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5yZUNiID0gZXZlbnQ7XHJcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoXCJqc29uL1wiK3NlbGYuanNvbk5hbWUsIGZ1bmN0aW9uIChlcnJvciwgb2JqKSB7XHJcbiAgICAgICAgICAgIGlmKGVycm9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIisrK+ino+aekOWHuumUme+8jOafpeS4i2pzb24rKytcIiArIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHNlbGYucmVDYihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBqc29uUm9vdCA9IG9iai5qc29uLmV2ZW50cztcclxuICAgICAgICAgICAgLy9jYy5sb2coXCI9PT3mlbDmja7plb/luqY9PT1cIiArIGpzb25Sb290Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvblJvb3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSBuZXcgRXZlbnREYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBldmVudERhdGEuSWQgPSBqc29uUm9vdFtpXS5JZDtcclxuICAgICAgICAgICAgICAgIC8vZXZlbnREYXRhLmljb24gPSBqc29uUm9vdFtpXS5pY29uO1xyXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLm5hbWUgPSBqc29uUm9vdFtpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLmRlc0lkID0ganNvblJvb3RbaV0uZGVzSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy/mtojogJdcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwganNvblJvb3RbaV0uY29zdC5sZW5ndGggOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIFx0dmFyIGNEYXRhID0gbmV3IEV2ZW50Q29zdCgpO1xyXG4gICAgICAgICAgICAgICAgXHR2YXIgZHQgPSBqc29uUm9vdFtpXS5jb3N0W2pdO1xyXG4gICAgICAgICAgICAgICAgXHRjRGF0YS5jb3N0VHlwZSA9IGR0WzBdO1xyXG4gICAgICAgICAgICAgICAgXHRjRGF0YS5jb3N0TnVtID0gZHRbMV07XHJcbiAgICAgICAgICAgICAgICBcdGNEYXRhLmRlc0lkID0gZHRbMl07XHJcbiAgICAgICAgICAgICAgICBcdGV2ZW50RGF0YS5jb3N0W2pdID0gY0RhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL+ato+WQkeS4pOenjee7k+aenFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBqc29uUm9vdFtpXS5ZcmVzdWx0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNEYXRhID0gbmV3IEV2ZW50UmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uUm9vdFtpXS5ZcmVzdWx0W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEYXRhLnJld2FyZFR5cGUgPSBkYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEYXRhLnJld2FyZE51bSA9IGRhdGFbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY0RhdGEucmV3YXJkSWQgPSBkYXRhWzJdOyAvL+WmguaenOWlluWKseeahOaYr+mHkemSseetiSAg5YiZaWQg5Li6MFxyXG4gICAgICAgICAgICAgICAgICAgIGNEYXRhLmRlc0lkID0gZGF0YVszXTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERhdGEuWVJlc3VsdHNbal0gPSAgY0RhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL+i0n+WQkeS4pOenjee7k+aenFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBqc29uUm9vdFtpXS5OcmVzdWx0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNEYXRhID0gbmV3IEV2ZW50UmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uUm9vdFtpXS5OcmVzdWx0W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEYXRhLnJld2FyZFR5cGUgPSBkYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEYXRhLnJld2FyZE51bSA9IGRhdGFbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY0RhdGEucmV3YXJkSWQgPSBkYXRhWzJdOyAvL+WmguaenOWlluWKseeahOaYr+mHkemSseetiSAg5YiZaWQg5Li6MFxyXG4gICAgICAgICAgICAgICAgICAgIGNEYXRhLmRlc0lkID0gZGF0YVszXTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERhdGEuTlJlc3VsdHNbal0gPSAgY0RhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLmV2ZW50TGlzdFtpXSA9IGV2ZW50RGF0YTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5yZUNiKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+mAmui/h2l0ZW1pZOiOt+WPluaVsOaNrlxyXG4gICAgZ2V0RGF0YUJ5SXRlbUlkOmZ1bmN0aW9uKGl0ZW1JZCl7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmV2ZW50TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZihpdGVtSWQgPT0gdGhpcy5ldmVudExpc3RbaV0uSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmV2ZW50TGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICAgZ2V0SnNvbkxlbmd0aDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TGlzdC5sZW5ndGhcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGF0YUxpc3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudExpc3Q7XHJcbiAgICB9LFxyXG4gICBcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRNYXBEZWNvZGVyO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/House/HouseMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '71682ynATpAf4XlApYBy/p8', 'HouseMapDecoder');
// Scripts/DataMap/House/HouseMapDecoder.js

"use strict";

var HouseData = require("HouseData");
var HouseMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "house",
    houseList: {
      "default": [],
      type: [HouseData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析房屋数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.house;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var houseD = new HouseData();
        houseD.Id = jsonRoot[i].Id;
        houseD.icon = jsonRoot[i].icon;
        houseD.name = jsonRoot[i].name;
        houseD.price = jsonRoot[i].price;
        houseD.addBonus = jsonRoot[i].addBonus;
        houseD.addHp = jsonRoot[i].addHp;
        self.houseList[i] = houseD;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.houseList.length - 1; i >= 0; i--) {
      if (name == this.houseList[i].name) {
        data = this.houseList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.houseList.length - 1; i >= 0; i--) {
      if (itemId == this.houseList[i].Id) {
        data = this.houseList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.houseList.length;
  },
  getDataList: function getDataList() {
    return this.houseList;
  }
});
module.exports = HouseMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcSG91c2VcXEhvdXNlTWFwRGVjb2Rlci5qcyJdLCJuYW1lcyI6WyJIb3VzZURhdGEiLCJyZXF1aXJlIiwiSG91c2VNYXBEZWNvZGVyIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJqc29uTmFtZSIsImhvdXNlTGlzdCIsInR5cGUiLCJEZWNvZGVKc29uIiwiZXZlbnQiLCJzZWxmIiwicmVDYiIsImxvYWRlciIsImxvYWRSZXMiLCJlcnJvciIsIm9iaiIsImpzb25Sb290IiwianNvbiIsImhvdXNlIiwiaSIsImxlbmd0aCIsImhvdXNlRCIsIklkIiwiaWNvbiIsIm5hbWUiLCJwcmljZSIsImFkZEJvbnVzIiwiYWRkSHAiLCJnZXREYXRhQnlOYW1lIiwiZGF0YSIsImdldERhdGFCeUl0ZW1JZCIsIml0ZW1JZCIsImdldEpzb25MZW5ndGgiLCJnZXREYXRhTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxHQUFHQyxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlDLGVBQWUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDM0IsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDLE9BQU87SUFDaEJDLFNBQVMsRUFBQztNQUNOLFdBQVEsRUFBRTtNQUNWQyxJQUFJLEVBQUMsQ0FBQ1QsU0FBUztJQUNuQjtFQUNKLENBQUM7RUFFRDtFQUNBVSxVQUFVLEVBQUMsU0FBQUEsV0FBVUMsS0FBSyxFQUFFO0lBQ3hCO0lBQ0EsSUFBSUMsSUFBSSxHQUFHLElBQUk7SUFDZkEsSUFBSSxDQUFDQyxJQUFJLEdBQUdGLEtBQUs7SUFDakJSLEVBQUUsQ0FBQ1csTUFBTSxDQUFDQyxPQUFPLENBQUMsT0FBTyxHQUFDSCxJQUFJLENBQUNMLFFBQVEsRUFBRSxVQUFVUyxLQUFLLEVBQUVDLEdBQUcsRUFBRTtNQUMzRCxJQUFHRCxLQUFLLEVBQ1I7UUFDSTtRQUNBSixJQUFJLENBQUNDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDaEI7TUFDSjtNQUVBLElBQUlLLFFBQVEsR0FBR0QsR0FBRyxDQUFDRSxJQUFJLENBQUNDLEtBQUs7TUFDN0I7TUFDQSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0gsUUFBUSxDQUFDSSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUlFLE1BQU0sR0FBRyxJQUFJdkIsU0FBUyxFQUFFO1FBQzVCdUIsTUFBTSxDQUFDQyxFQUFFLEdBQUdOLFFBQVEsQ0FBQ0csQ0FBQyxDQUFDLENBQUNHLEVBQUU7UUFDMUJELE1BQU0sQ0FBQ0UsSUFBSSxHQUFHUCxRQUFRLENBQUNHLENBQUMsQ0FBQyxDQUFDSSxJQUFJO1FBQzlCRixNQUFNLENBQUNHLElBQUksR0FBR1IsUUFBUSxDQUFDRyxDQUFDLENBQUMsQ0FBQ0ssSUFBSTtRQUM5QkgsTUFBTSxDQUFDSSxLQUFLLEdBQUdULFFBQVEsQ0FBQ0csQ0FBQyxDQUFDLENBQUNNLEtBQUs7UUFDaENKLE1BQU0sQ0FBQ0ssUUFBUSxHQUFHVixRQUFRLENBQUNHLENBQUMsQ0FBQyxDQUFDTyxRQUFRO1FBQ3RDTCxNQUFNLENBQUNNLEtBQUssR0FBR1gsUUFBUSxDQUFDRyxDQUFDLENBQUMsQ0FBQ1EsS0FBSztRQUVoQ2pCLElBQUksQ0FBQ0osU0FBUyxDQUFDYSxDQUFDLENBQUMsR0FBR0UsTUFBTTtNQUM5QjtNQUNBWCxJQUFJLENBQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkIsQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUVEO0VBQ0FpQixhQUFhLEVBQUMsU0FBQUEsY0FBVUosSUFBSSxFQUFFO0lBQzFCLElBQUlLLElBQUksR0FBRyxJQUFJO0lBQ2YsS0FBSyxJQUFJVixDQUFDLEdBQUcsSUFBSSxDQUFDYixTQUFTLENBQUNjLE1BQU0sR0FBRyxDQUFDLEVBQUVELENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO01BQ2pELElBQUdLLElBQUksSUFBSSxJQUFJLENBQUNsQixTQUFTLENBQUNhLENBQUMsQ0FBQyxDQUFDSyxJQUFJLEVBQ2pDO1FBQ0lLLElBQUksR0FBRyxJQUFJLENBQUN2QixTQUFTLENBQUNhLENBQUMsQ0FBQztRQUN4QjtNQUNKO0lBQ0o7SUFDQSxPQUFPVSxJQUFJO0VBQ2YsQ0FBQztFQUVEO0VBQ0FDLGVBQWUsRUFBQyxTQUFBQSxnQkFBU0MsTUFBTSxFQUFDO0lBQzVCLElBQUlGLElBQUksR0FBRyxJQUFJO0lBQ2YsS0FBSyxJQUFJVixDQUFDLEdBQUcsSUFBSSxDQUFDYixTQUFTLENBQUNjLE1BQU0sR0FBRyxDQUFDLEVBQUVELENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO01BQ2pELElBQUdZLE1BQU0sSUFBSSxJQUFJLENBQUN6QixTQUFTLENBQUNhLENBQUMsQ0FBQyxDQUFDRyxFQUFFLEVBQ2pDO1FBQ0lPLElBQUksR0FBRyxJQUFJLENBQUN2QixTQUFTLENBQUNhLENBQUMsQ0FBQztRQUN4QjtNQUNKO0lBQ0o7SUFDQSxPQUFPVSxJQUFJO0VBQ2YsQ0FBQztFQUVERyxhQUFhLEVBQUMsU0FBQUEsY0FBQSxFQUFVO0lBQ3BCLE9BQU8sSUFBSSxDQUFDMUIsU0FBUyxDQUFDYyxNQUFNO0VBQ2hDLENBQUM7RUFFRGEsV0FBVyxFQUFDLFNBQUFBLFlBQUEsRUFBVTtJQUNsQixPQUFPLElBQUksQ0FBQzNCLFNBQVM7RUFDekI7QUFFSixDQUFDLENBQUM7QUFDRjRCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHbkMsZUFBZSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvdXNlRGF0YSA9IHJlcXVpcmUoXCJIb3VzZURhdGFcIik7XHJcbnZhciBIb3VzZU1hcERlY29kZXIgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGpzb25OYW1lOlwiaG91c2VcIixcclxuICAgICAgICBob3VzZUxpc3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltIb3VzZURhdGFdLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG5cclxuICAgIC8v6Kej5p6Q5pWw5o2uXHJcbiAgICBEZWNvZGVKc29uOmZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5oi/5bGL5pWw5o2uPT09XCIpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLnJlQ2IgPSBldmVudDtcclxuICAgICAgICBjYy5sb2FkZXIubG9hZFJlcyhcImpzb24vXCIrc2VsZi5qc29uTmFtZSwgZnVuY3Rpb24gKGVycm9yLCBvYmopIHtcclxuICAgICAgICAgICAgaWYoZXJyb3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiKysr6Kej5p6Q5Ye66ZSZ77yM5p+l5LiLanNvbisrK1wiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZUNiKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGpzb25Sb290ID0gb2JqLmpzb24uaG91c2U7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwiPT095pWw5o2u6ZW/5bqmPT09XCIgKyBqc29uUm9vdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25Sb290Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG91c2VEID0gbmV3IEhvdXNlRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgaG91c2VELklkID0ganNvblJvb3RbaV0uSWQ7XHJcbiAgICAgICAgICAgICAgICBob3VzZUQuaWNvbiA9IGpzb25Sb290W2ldLmljb247XHJcbiAgICAgICAgICAgICAgICBob3VzZUQubmFtZSA9IGpzb25Sb290W2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBob3VzZUQucHJpY2UgPSBqc29uUm9vdFtpXS5wcmljZTtcclxuICAgICAgICAgICAgICAgIGhvdXNlRC5hZGRCb251cyA9IGpzb25Sb290W2ldLmFkZEJvbnVzO1xyXG4gICAgICAgICAgICAgICAgaG91c2VELmFkZEhwID0ganNvblJvb3RbaV0uYWRkSHA7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHNlbGYuaG91c2VMaXN0W2ldID0gaG91c2VEOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnJlQ2IodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6YCa6L+H5ZCN5a2X5ou/5Yiw5b2T5YmN55qE5pWw5o2uIOS4jeW7uuiurueUqO+8jOS9oOimgeeUqOaIkeS5n+ayoeWKnuazlVxyXG4gICAgZ2V0RGF0YUJ5TmFtZTpmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5ob3VzZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYobmFtZSA9PSB0aGlzLmhvdXNlTGlzdFtpXS5uYW1lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5ob3VzZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgJrov4dpdGVtaWTojrflj5bmlbDmja5cclxuICAgIGdldERhdGFCeUl0ZW1JZDpmdW5jdGlvbihpdGVtSWQpe1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5ob3VzZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYoaXRlbUlkID09IHRoaXMuaG91c2VMaXN0W2ldLklkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5ob3VzZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SnNvbkxlbmd0aDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhvdXNlTGlzdC5sZW5ndGhcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGF0YUxpc3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VzZUxpc3Q7XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gSG91c2VNYXBEZWNvZGVyOyJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Goods/GoodsData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '6a7505TW61P9ZfY7U548dnv', 'GoodsData');
// Scripts/DataMap/Goods/GoodsData.js

"use strict";

var PriceData = require("PriceData");
var GoodsData = cc.Class({
  name: "GoodsData",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    priceList: [PriceData]
  }
});
module.exports = GoodsData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcR29vZHNcXEdvb2RzRGF0YS5qcyJdLCJuYW1lcyI6WyJQcmljZURhdGEiLCJyZXF1aXJlIiwiR29vZHNEYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiaWNvbiIsIklkIiwiSW50ZWdlciIsInByaWNlTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxHQUFHQyxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlDLFNBQVMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDeEJDLElBQUksRUFBQyxXQUFXO0VBQ2JDLFVBQVUsRUFBRTtJQUNYQyxJQUFJLEVBQUMsRUFBRTtJQUNQRixJQUFJLEVBQUMsRUFBRTtJQUNQRyxFQUFFLEVBQUNMLEVBQUUsQ0FBQ00sT0FBTztJQUNWQyxTQUFTLEVBQUMsQ0FBQ1YsU0FBUztFQUN4QjtBQUNKLENBQUMsQ0FBQztBQUNGVyxNQUFNLENBQUNDLE9BQU8sR0FBR1YsU0FBUyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFByaWNlRGF0YSA9IHJlcXVpcmUoXCJQcmljZURhdGFcIik7XHJcbnZhciBHb29kc0RhdGEgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIkdvb2RzRGF0YVwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgXHRpY29uOlwiXCIsXHJcbiAgICBcdG5hbWU6XCJcIixcclxuICAgIFx0SWQ6Y2MuSW50ZWdlcixcclxuICAgICAgICBwcmljZUxpc3Q6W1ByaWNlRGF0YV0sXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBHb29kc0RhdGE7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/InitCash/CashMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '7b512H+PV9ParK39iqtZBZ1', 'CashMapDecoder');
// Scripts/DataMap/InitCash/CashMapDecoder.js

"use strict";

var CashData = require("CashData");
var CashMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "cash",
    cashList: {
      "default": [],
      type: [CashData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析现金数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.cash;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var cashD = new CashData();
        cashD.Id = jsonRoot[i].Id;
        cashD.cash = jsonRoot[i].cash;
        cashD.weight = jsonRoot[i].weight;
        self.cashList[i] = cashD;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.cashList.length - 1; i >= 0; i--) {
      if (name == this.cashList[i].name) {
        data = this.cashList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.cashList.length - 1; i >= 0; i--) {
      if (itemId == this.cashList[i].Id) {
        data = this.cashList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.cashList.length;
  }
});
module.exports = CashMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcSW5pdENhc2hcXENhc2hNYXBEZWNvZGVyLmpzIl0sIm5hbWVzIjpbIkNhc2hEYXRhIiwicmVxdWlyZSIsIkNhc2hNYXBEZWNvZGVyIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJqc29uTmFtZSIsImNhc2hMaXN0IiwidHlwZSIsIkRlY29kZUpzb24iLCJldmVudCIsInNlbGYiLCJyZUNiIiwibG9hZGVyIiwibG9hZFJlcyIsImVycm9yIiwib2JqIiwianNvblJvb3QiLCJqc29uIiwiY2FzaCIsImkiLCJsZW5ndGgiLCJjYXNoRCIsIklkIiwid2VpZ2h0IiwiZ2V0RGF0YUJ5TmFtZSIsIm5hbWUiLCJkYXRhIiwiZ2V0RGF0YUJ5SXRlbUlkIiwiaXRlbUlkIiwiZ2V0SnNvbkxlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLGNBQWMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDMUIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDLE1BQU07SUFDZkMsUUFBUSxFQUFDO01BQ0wsV0FBUSxFQUFFO01BQ1ZDLElBQUksRUFBQyxDQUFDVCxRQUFRO0lBQ2xCO0VBQ0osQ0FBQztFQUVEO0VBQ0FVLFVBQVUsRUFBQyxTQUFBQSxXQUFVQyxLQUFLLEVBQUU7SUFDeEI7SUFDQSxJQUFJQyxJQUFJLEdBQUcsSUFBSTtJQUNmQSxJQUFJLENBQUNDLElBQUksR0FBR0YsS0FBSztJQUNqQlIsRUFBRSxDQUFDVyxNQUFNLENBQUNDLE9BQU8sQ0FBQyxPQUFPLEdBQUNILElBQUksQ0FBQ0wsUUFBUSxFQUFFLFVBQVVTLEtBQUssRUFBRUMsR0FBRyxFQUFFO01BQzNELElBQUdELEtBQUssRUFDUjtRQUNJO1FBQ0FKLElBQUksQ0FBQ0MsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNoQjtNQUNKO01BRUEsSUFBSUssUUFBUSxHQUFHRCxHQUFHLENBQUNFLElBQUksQ0FBQ0MsSUFBSTtNQUM1QjtNQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHSCxRQUFRLENBQUNJLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsSUFBSUUsS0FBSyxHQUFHLElBQUl2QixRQUFRLEVBQUU7UUFDMUJ1QixLQUFLLENBQUNDLEVBQUUsR0FBR04sUUFBUSxDQUFDRyxDQUFDLENBQUMsQ0FBQ0csRUFBRTtRQUN6QkQsS0FBSyxDQUFDSCxJQUFJLEdBQUdGLFFBQVEsQ0FBQ0csQ0FBQyxDQUFDLENBQUNELElBQUk7UUFDN0JHLEtBQUssQ0FBQ0UsTUFBTSxHQUFHUCxRQUFRLENBQUNHLENBQUMsQ0FBQyxDQUFDSSxNQUFNO1FBRWpDYixJQUFJLENBQUNKLFFBQVEsQ0FBQ2EsQ0FBQyxDQUFDLEdBQUdFLEtBQUs7TUFDNUI7TUFDQVgsSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUMsQ0FBQztFQUNOLENBQUM7RUFFRDtFQUNBYSxhQUFhLEVBQUMsU0FBQUEsY0FBVUMsSUFBSSxFQUFFO0lBQzFCLElBQUlDLElBQUksR0FBRyxJQUFJO0lBQ2YsS0FBSyxJQUFJUCxDQUFDLEdBQUcsSUFBSSxDQUFDYixRQUFRLENBQUNjLE1BQU0sR0FBRyxDQUFDLEVBQUVELENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO01BQ2hELElBQUdNLElBQUksSUFBSSxJQUFJLENBQUNuQixRQUFRLENBQUNhLENBQUMsQ0FBQyxDQUFDTSxJQUFJLEVBQ2hDO1FBQ0lDLElBQUksR0FBRyxJQUFJLENBQUNwQixRQUFRLENBQUNhLENBQUMsQ0FBQztRQUN2QjtNQUNKO0lBQ0o7SUFDQSxPQUFPTyxJQUFJO0VBQ2YsQ0FBQztFQUVEO0VBQ0FDLGVBQWUsRUFBQyxTQUFBQSxnQkFBU0MsTUFBTSxFQUFDO0lBQzVCLElBQUlGLElBQUksR0FBRyxJQUFJO0lBQ2YsS0FBSyxJQUFJUCxDQUFDLEdBQUcsSUFBSSxDQUFDYixRQUFRLENBQUNjLE1BQU0sR0FBRyxDQUFDLEVBQUVELENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO01BQ2hELElBQUdTLE1BQU0sSUFBSSxJQUFJLENBQUN0QixRQUFRLENBQUNhLENBQUMsQ0FBQyxDQUFDRyxFQUFFLEVBQ2hDO1FBQ0lJLElBQUksR0FBRyxJQUFJLENBQUNwQixRQUFRLENBQUNhLENBQUMsQ0FBQztRQUN2QjtNQUNKO0lBQ0o7SUFDQSxPQUFPTyxJQUFJO0VBQ2YsQ0FBQztFQUVERyxhQUFhLEVBQUMsU0FBQUEsY0FBQSxFQUFVO0lBQ3BCLE9BQU8sSUFBSSxDQUFDdkIsUUFBUSxDQUFDYyxNQUFNO0VBQy9CO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZVLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHL0IsY0FBYyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIENhc2hEYXRhID0gcmVxdWlyZShcIkNhc2hEYXRhXCIpO1xyXG52YXIgQ2FzaE1hcERlY29kZXIgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGpzb25OYW1lOlwiY2FzaFwiLFxyXG4gICAgICAgIGNhc2hMaXN0OntcclxuICAgICAgICAgICAgZGVmYXVsdDpbXSxcclxuICAgICAgICAgICAgdHlwZTpbQ2FzaERhdGFdLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG5cclxuICAgIC8v6Kej5p6Q5pWw5o2uXHJcbiAgICBEZWNvZGVKc29uOmZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q546w6YeR5pWw5o2uPT09XCIpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLnJlQ2IgPSBldmVudDtcclxuICAgICAgICBjYy5sb2FkZXIubG9hZFJlcyhcImpzb24vXCIrc2VsZi5qc29uTmFtZSwgZnVuY3Rpb24gKGVycm9yLCBvYmopIHtcclxuICAgICAgICAgICAgaWYoZXJyb3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiKysr6Kej5p6Q5Ye66ZSZ77yM5p+l5LiLanNvbisrK1wiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZUNiKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGpzb25Sb290ID0gb2JqLmpzb24uY2FzaDtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCI9PT3mlbDmja7plb/luqY9PT1cIiArIGpzb25Sb290Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvblJvb3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYXNoRCA9IG5ldyBDYXNoRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgY2FzaEQuSWQgPSBqc29uUm9vdFtpXS5JZDtcclxuICAgICAgICAgICAgICAgIGNhc2hELmNhc2ggPSBqc29uUm9vdFtpXS5jYXNoO1xyXG4gICAgICAgICAgICAgICAgY2FzaEQud2VpZ2h0ID0ganNvblJvb3RbaV0ud2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzZWxmLmNhc2hMaXN0W2ldID0gY2FzaEQ7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYucmVDYih0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgJrov4flkI3lrZfmi7/liLDlvZPliY3nmoTmlbDmja4g5LiN5bu66K6u55So77yM5L2g6KaB55So5oiR5Lmf5rKh5Yqe5rOVXHJcbiAgICBnZXREYXRhQnlOYW1lOmZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNhc2hMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gdGhpcy5jYXNoTGlzdFtpXS5uYW1lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5jYXNoTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+mAmui/h2l0ZW1pZOiOt+WPluaVsOaNrlxyXG4gICAgZ2V0RGF0YUJ5SXRlbUlkOmZ1bmN0aW9uKGl0ZW1JZCl7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNhc2hMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKGl0ZW1JZCA9PSB0aGlzLmNhc2hMaXN0W2ldLklkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5jYXNoTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRKc29uTGVuZ3RoOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FzaExpc3QubGVuZ3RoXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBDYXNoTWFwRGVjb2RlcjtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Mate/MateGetCond.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0f2b0jLVP9Ji4nyrFL2vCZS', 'MateGetCond');
// Scripts/DataMap/Mate/MateGetCond.js

"use strict";

var MateGetCond = cc.Class({
  name: "MateGetCond",
  properties: {
    unlockType: cc.Integer,
    value: cc.Integer
  }
});
module.exports = MateGetCond;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcTWF0ZVxcTWF0ZUdldENvbmQuanMiXSwibmFtZXMiOlsiTWF0ZUdldENvbmQiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJ1bmxvY2tUeXBlIiwiSW50ZWdlciIsInZhbHVlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxXQUFXLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3ZCQyxJQUFJLEVBQUMsYUFBYTtFQUNsQkMsVUFBVSxFQUFFO0lBQ1JDLFVBQVUsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ3JCQyxLQUFLLEVBQUNOLEVBQUUsQ0FBQ0s7RUFDYjtBQUNKLENBQUMsQ0FBQztBQUNGRSxNQUFNLENBQUNDLE9BQU8sR0FBR1QsV0FBVyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBNYXRlR2V0Q29uZCA9IGNjLkNsYXNzKHtcclxuICAgIG5hbWU6XCJNYXRlR2V0Q29uZFwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHVubG9ja1R5cGU6Y2MuSW50ZWdlcixcclxuICAgICAgICB2YWx1ZTpjYy5JbnRlZ2VyLFxyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTWF0ZUdldENvbmQ7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Skill/SkillMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'dfb4cSI2vdF4KaViCbkpfOj', 'SkillMapDecoder');
// Scripts/DataMap/Skill/SkillMapDecoder.js

"use strict";

var SkillData = require("SkillData");
var CostData = require("CostData");
var SkillMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "skill",
    skillList: {
      "default": [],
      type: [SkillData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析技能数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.skill;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var skillData = new SkillData();
        skillData.Id = jsonRoot[i].Id;
        skillData.subId = jsonRoot[i].subId;
        skillData.icon = jsonRoot[i].icon;
        skillData.desId = jsonRoot[i].desId;
        skillData.name = jsonRoot[i].name;
        skillData.skillType = jsonRoot[i].skillType;
        skillData.upLevel = jsonRoot[i].upCostList.length; //jsonRoot[i].upLevel;
        for (var j = 0; j < jsonRoot[i].upCostList.length; j++) {
          var costD = new CostData();
          costD.cost = jsonRoot[i].upCostList[j][2];
          costD.toLevel = jsonRoot[i].upCostList[j][0];
          costD.addBonus = jsonRoot[i].upCostList[j][1];
          skillData.upCostList[j] = costD;
        }
        self.skillList[i] = skillData;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.skillList.length - 1; i >= 0; i--) {
      if (name == this.skillList[i].name) {
        data = this.skillList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.skillList.length - 1; i >= 0; i--) {
      if (itemId == this.skillList[i].Id) {
        data = this.skillList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.skillList.length;
  },
  getDataList: function getDataList() {
    return this.skillList;
  },
  //获取升级技能消费数据 需要提供两个 Id
  getUpgradeCostByTwoId: function getUpgradeCostByTwoId(Id, subId, tolv) {
    var Cost = 20;
    for (var i = this.skillList.length - 1; i >= 0; i--) {
      var data = this.skillList[i];
      if (data.Id == Id && data.subId == subId) {
        for (var i = data.upCostList.length - 1; i >= 0; i--) {
          var dt = data.upCostList[i];
          if (dt.toLevel == tolv) {
            //cc.log("Id subId toLv 花费技能点===================" + dt.cost + " " + tolv);
            Cost = dt.cost;
            return dt.cost;
          }
        }
      }
    }
    return Cost;
  },
  getSkillAddBonusByTwoIdAndLv: function getSkillAddBonusByTwoIdAndLv(Id, subId, lv) {
    var bonus = 0;
    for (var i = this.skillList.length - 1; i >= 0; i--) {
      var data = this.skillList[i];
      if (data.Id == Id && data.subId == subId) {
        for (var i = data.upCostList.length - 1; i >= 0; i--) {
          var dt = data.upCostList[i];
          if (dt.toLevel == lv) {
            bonus = dt.addBonus;
            return dt.addBonus;
          }
        }
      }
    }
    return bonus;
  },
  getSkillDataByTwoId: function getSkillDataByTwoId(Id, subId) {
    var dt = null;
    for (var i = this.skillList.length - 1; i >= 0; i--) {
      var data = this.skillList[i];
      if (data.Id == Id && data.subId == subId) {
        dt = data;
        return data;
      }
    }
    return dt;
  },
  getSkillListById: function getSkillListById(Id) {
    var param = [];
    for (var i = this.skillList.length - 1; i >= 0; i--) {
      var data = this.skillList[i];
      if (data.Id == Id) {
        param.push(data);
      }
    }
    return param;
  }
});
module.exports = SkillMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcU2tpbGxcXFNraWxsTWFwRGVjb2Rlci5qcyJdLCJuYW1lcyI6WyJTa2lsbERhdGEiLCJyZXF1aXJlIiwiQ29zdERhdGEiLCJTa2lsbE1hcERlY29kZXIiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImpzb25OYW1lIiwic2tpbGxMaXN0IiwidHlwZSIsIkRlY29kZUpzb24iLCJldmVudCIsInNlbGYiLCJyZUNiIiwibG9hZGVyIiwibG9hZFJlcyIsImVycm9yIiwib2JqIiwianNvblJvb3QiLCJqc29uIiwic2tpbGwiLCJpIiwibGVuZ3RoIiwic2tpbGxEYXRhIiwiSWQiLCJzdWJJZCIsImljb24iLCJkZXNJZCIsIm5hbWUiLCJza2lsbFR5cGUiLCJ1cExldmVsIiwidXBDb3N0TGlzdCIsImoiLCJjb3N0RCIsImNvc3QiLCJ0b0xldmVsIiwiYWRkQm9udXMiLCJnZXREYXRhQnlOYW1lIiwiZGF0YSIsImdldERhdGFCeUl0ZW1JZCIsIml0ZW1JZCIsImdldEpzb25MZW5ndGgiLCJnZXREYXRhTGlzdCIsImdldFVwZ3JhZGVDb3N0QnlUd29JZCIsInRvbHYiLCJDb3N0IiwiZHQiLCJnZXRTa2lsbEFkZEJvbnVzQnlUd29JZEFuZEx2IiwibHYiLCJib251cyIsImdldFNraWxsRGF0YUJ5VHdvSWQiLCJnZXRTa2lsbExpc3RCeUlkIiwicGFyYW0iLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDcEMsSUFBSUMsUUFBUSxHQUFHRCxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlFLGVBQWUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDM0IsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDLE9B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QUNGRSxNQUFNLENBQUNDLE9BQU8sR0FBR3JELGVBQWUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBTa2lsbERhdGEgPSByZXF1aXJlKFwiU2tpbGxEYXRhXCIpO1xyXG52YXIgQ29zdERhdGEgPSByZXF1aXJlKFwiQ29zdERhdGFcIik7XHJcbnZhciBTa2lsbE1hcERlY29kZXIgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGpzb25OYW1lOlwic2tpbGxcIixcclxuICAgICAgICBza2lsbExpc3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltTa2lsbERhdGFdLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG5cclxuICAgIC8v6Kej5p6Q5pWw5o2uXHJcbiAgICBEZWNvZGVKc29uOmZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5oqA6IO95pWw5o2uPT09XCIpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLnJlQ2IgPSBldmVudDtcclxuICAgICAgICBjYy5sb2FkZXIubG9hZFJlcyhcImpzb24vXCIrc2VsZi5qc29uTmFtZSwgZnVuY3Rpb24gKGVycm9yLCBvYmopIHtcclxuICAgICAgICAgICAgaWYoZXJyb3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiKysr6Kej5p6Q5Ye66ZSZ77yM5p+l5LiLanNvbisrK1wiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZUNiKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGpzb25Sb290ID0gb2JqLmpzb24uc2tpbGw7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwiPT095pWw5o2u6ZW/5bqmPT09XCIgKyBqc29uUm9vdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25Sb290Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tpbGxEYXRhID0gbmV3IFNraWxsRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgc2tpbGxEYXRhLklkID0ganNvblJvb3RbaV0uSWQ7XHJcbiAgICAgICAgICAgICAgICBza2lsbERhdGEuc3ViSWQgPSBqc29uUm9vdFtpXS5zdWJJZDtcclxuICAgICAgICAgICAgICAgIHNraWxsRGF0YS5pY29uID0ganNvblJvb3RbaV0uaWNvbjtcclxuICAgICAgICAgICAgICAgIHNraWxsRGF0YS5kZXNJZCA9IGpzb25Sb290W2ldLmRlc0lkO1xyXG4gICAgICAgICAgICAgICAgc2tpbGxEYXRhLm5hbWUgPSBqc29uUm9vdFtpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgc2tpbGxEYXRhLnNraWxsVHlwZSA9IGpzb25Sb290W2ldLnNraWxsVHlwZTtcclxuICAgICAgICAgICAgICAgIHNraWxsRGF0YS51cExldmVsID0ganNvblJvb3RbaV0udXBDb3N0TGlzdC5sZW5ndGg7Ly9qc29uUm9vdFtpXS51cExldmVsO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBqc29uUm9vdFtpXS51cENvc3RMaXN0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvc3REID0gbmV3IENvc3REYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdEQuY29zdCA9IGpzb25Sb290W2ldLnVwQ29zdExpc3Rbal1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdEQudG9MZXZlbCA9IGpzb25Sb290W2ldLnVwQ29zdExpc3Rbal1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdEQuYWRkQm9udXMgPSBqc29uUm9vdFtpXS51cENvc3RMaXN0W2pdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNraWxsRGF0YS51cENvc3RMaXN0W2pdID0gY29zdEQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNraWxsTGlzdFtpXSA9IHNraWxsRGF0YTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5yZUNiKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+mAmui/h+WQjeWtl+aLv+WIsOW9k+WJjeeahOaVsOaNriDkuI3lu7rorq7nlKjvvIzkvaDopoHnlKjmiJHkuZ/msqHlip7ms5VcclxuICAgIGdldERhdGFCeU5hbWU6ZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2tpbGxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gdGhpcy5za2lsbExpc3RbaV0ubmFtZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuc2tpbGxMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6YCa6L+HaXRlbWlk6I635Y+W5pWw5o2uXHJcbiAgICBnZXREYXRhQnlJdGVtSWQ6ZnVuY3Rpb24oaXRlbUlkKXtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2tpbGxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKGl0ZW1JZCA9PSB0aGlzLnNraWxsTGlzdFtpXS5JZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuc2tpbGxMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEpzb25MZW5ndGg6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5za2lsbExpc3QubGVuZ3RoXHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGFMaXN0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpbGxMaXN0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+iOt+WPluWNh+e6p+aKgOiDvea2iOi0ueaVsOaNriDpnIDopoHmj5DkvpvkuKTkuKogSWRcclxuICAgIGdldFVwZ3JhZGVDb3N0QnlUd29JZDpmdW5jdGlvbihJZCxzdWJJZCx0b2x2KXtcclxuICAgICAgICB2YXIgQ29zdCA9IDIwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNraWxsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2tpbGxMaXN0W2ldO1xyXG4gICAgICAgICAgICBpZihkYXRhLklkID09IElkICYmIGRhdGEuc3ViSWQgPT0gc3ViSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLnVwQ29zdExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHQgPSBkYXRhLnVwQ29zdExpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZHQudG9MZXZlbCA9PSB0b2x2KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYy5sb2coXCJJZCBzdWJJZCB0b0x2IOiKsei0ueaKgOiDveeCuT09PT09PT09PT09PT09PT09PT1cIiArIGR0LmNvc3QgKyBcIiBcIiArIHRvbHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb3N0ID0gZHQuY29zdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0LmNvc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb3N0O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTa2lsbEFkZEJvbnVzQnlUd29JZEFuZEx2OmZ1bmN0aW9uKElkLHN1YklkLGx2KXtcclxuICAgICAgICB2YXIgYm9udXMgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNraWxsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2tpbGxMaXN0W2ldO1xyXG4gICAgICAgICAgICBpZihkYXRhLklkID09IElkICYmIGRhdGEuc3ViSWQgPT0gc3ViSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLnVwQ29zdExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHQgPSBkYXRhLnVwQ29zdExpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZHQudG9MZXZlbCA9PSBsdilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbnVzID0gZHQuYWRkQm9udXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkdC5hZGRCb251cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJvbnVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTa2lsbERhdGFCeVR3b0lkOmZ1bmN0aW9uKElkLCBzdWJJZCl7XHJcbiAgICAgICAgdmFyIGR0ID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5za2lsbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNraWxsTGlzdFtpXTtcclxuICAgICAgICAgICAgaWYoZGF0YS5JZCA9PSBJZCAmJiBkYXRhLnN1YklkID09IHN1YklkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkdCA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNraWxsTGlzdEJ5SWQ6ZnVuY3Rpb24oSWQpe1xyXG4gICAgICAgIHZhciBwYXJhbSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNraWxsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2tpbGxMaXN0W2ldO1xyXG4gICAgICAgICAgICBpZihkYXRhLklkID09IElkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBTa2lsbE1hcERlY29kZXI7Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/CarStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '90b744v50RCgbdX1aSxHkRW', 'CarStruct');
// Scripts/OwnData/CarStruct.js

"use strict";

//需要更多源码联系Q:3038745955
//拥有的车
var CarStruct = cc.Class({
  name: "CarStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    ownNum: cc.Integer,
    //拥有数量
    price: cc.Integer,
    addBonus: cc.Integer,
    //增加名声
    addHp: cc.Integer,
    //增加健康值
    addDate: 0 //增加约会成功率
  },

  RefreshData: function RefreshData(addNum) {
    //为负值表示卖出去
    this.ownNum += addNum;
  }
});
module.exports = CarStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcQ2FyU3RydWN0LmpzIl0sIm5hbWVzIjpbIkNhclN0cnVjdCIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsImljb24iLCJJZCIsIkludGVnZXIiLCJvd25OdW0iLCJwcmljZSIsImFkZEJvbnVzIiwiYWRkSHAiLCJhZGREYXRlIiwiUmVmcmVzaERhdGEiLCJhZGROdW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxJQUFJQSxTQUFTLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCQyxJQUFJLEVBQUMsV0FBVztFQUNoQkMsVUFBVSxFQUFDO0lBQ1ZDLElBQUksRUFBQyxFQUFFO0lBQ1BGLElBQUksRUFBQyxFQUFFO0lBQ1BHLEVBQUUsRUFBQ0wsRUFBRSxDQUFDTSxPQUFPO0lBQ2JDLE1BQU0sRUFBQ1AsRUFBRSxDQUFDTSxPQUFPO0lBQUM7SUFDbEJFLEtBQUssRUFBQ1IsRUFBRSxDQUFDTSxPQUFPO0lBQ2hCRyxRQUFRLEVBQUNULEVBQUUsQ0FBQ00sT0FBTztJQUFFO0lBQ3JCSSxLQUFLLEVBQUNWLEVBQUUsQ0FBQ00sT0FBTztJQUFDO0lBQ2pCSyxPQUFPLEVBQUMsQ0FBQyxDQUFDO0VBQ1gsQ0FBQzs7RUFFREMsV0FBVyxFQUFDLFNBQUFBLFlBQVNDLE1BQU0sRUFBRTtJQUFFO0lBQzlCLElBQUksQ0FBQ04sTUFBTSxJQUFJTSxNQUFNO0VBQ3RCO0FBQ0QsQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHaEIsU0FBUyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLy/pnIDopoHmm7TlpJrmupDnoIHogZTns7tROjMwMzg3NDU5NTVcclxuLy/mi6XmnInnmoTovaZcclxudmFyIENhclN0cnVjdCA9IGNjLkNsYXNzKHtcclxuXHRuYW1lOlwiQ2FyU3RydWN0XCIsXHJcblx0cHJvcGVydGllczp7XHJcblx0XHRpY29uOlwiXCIsXHJcblx0XHRuYW1lOlwiXCIsXHJcblx0XHRJZDpjYy5JbnRlZ2VyLFxyXG5cdFx0b3duTnVtOmNjLkludGVnZXIsLy/mi6XmnInmlbDph49cclxuXHRcdHByaWNlOmNjLkludGVnZXIsXHJcblx0XHRhZGRCb251czpjYy5JbnRlZ2VyLCAvL+WinuWKoOWQjeWjsFxyXG5cdFx0YWRkSHA6Y2MuSW50ZWdlciwvL+WinuWKoOWBpeW6t+WAvFxyXG5cdFx0YWRkRGF0ZTowLC8v5aKe5Yqg57qm5Lya5oiQ5Yqf546HXHJcblx0fSxcclxuXHJcblx0UmVmcmVzaERhdGE6ZnVuY3Rpb24oYWRkTnVtKSB7IC8v5Li66LSf5YC86KGo56S65Y2W5Ye65Y67XHJcblx0XHR0aGlzLm93bk51bSArPSBhZGROdW07XHJcblx0fSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ2FyU3RydWN0O1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/AdsRetirePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '5eb7cNKMpxNWIREVbU5YEO4', 'AdsRetirePanel');
// Scripts/UI/AdsRetirePanel.js

"use strict";

var AdsParam = require("AdsParam");
var AdsRetirePanel = cc.Class({
  "extends": cc.Component,
  properties: {},
  ShowPanel: function ShowPanel() {},
  showRewardVideo: function showRewardVideo() {
    this.js2android('show_reward_video', '1');
  },
  ///激励视频播放完成回调方法 continue_game
  /// Native.android2js("continue_game", ()=>{
  ///     //激励视频播放完成，原生端回调
  /// });
  js2android: function js2android(name, data) {
    console.log("name:" + name + "-data:" + data);
    if (window.injectedObject && window.injectedObject.setJsContent) {
      window.injectedObject.setJsContent(name, data);
    }
  },
  ConfirmUseAds: function ConfirmUseAds() {
    cc.Mgr.AudioMgr.playSFX("click");
    var self = this;
    self.showRewardVideo();
    cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointD, function (out) {
      if (out == 0) {
        cc.Mgr.UserDataMgr.retireAge += cc.Mgr.global.tmpRetireAgeBonues;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.RefreshAllUIShow, {});
        cc.Mgr.global.useRetireAds = true;
        self.node.active = false;
      }
    });
  },
  ShareToFriend: function ShareToFriend() {
    cc.Mgr.PlatformController.ShareToFriend(2);
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
    cc.director.GlobalEvent.emit(cc.Mgr.Event.Retire, {});
  }
});
module.exports = AdsRetirePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEFkc1JldGlyZVBhbmVsLmpzIl0sIm5hbWVzIjpbIkFkc1BhcmFtIiwicmVxdWlyZSIsIkFkc1JldGlyZVBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJTaG93UGFuZWwiLCJzaG93UmV3YXJkVmlkZW8iLCJqczJhbmRyb2lkIiwibmFtZSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwid2luZG93IiwiaW5qZWN0ZWRPYmplY3QiLCJzZXRKc0NvbnRlbnQiLCJDb25maXJtVXNlQWRzIiwiTWdyIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwic2VsZiIsIkFkc01nciIsIlNob3dWaWRlb0FkcyIsIlBvaW50RCIsIm91dCIsIlVzZXJEYXRhTWdyIiwicmV0aXJlQWdlIiwiZ2xvYmFsIiwidG1wUmV0aXJlQWdlQm9udWVzIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIlJlZnJlc2hBbGxVSVNob3ciLCJ1c2VSZXRpcmVBZHMiLCJub2RlIiwiYWN0aXZlIiwiU2hhcmVUb0ZyaWVuZCIsIlBsYXRmb3JtQ29udHJvbGxlciIsIkNsb3NlUGFuZWwiLCJSZXRpcmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxjQUFjLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzFCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFLENBRVosQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFVLENBRXBCLENBQUM7RUFDREMsZUFBZSxXQUFBQSxnQkFBQSxFQUFHO0lBQ2QsSUFBSSxDQUFDQyxVQUFVLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxDQUFDO0VBQzdDLENBQUM7RUFFRDtFQUNBO0VBQ0E7RUFDQTtFQUNBQSxVQUFVLFdBQUFBLFdBQUNDLElBQUksRUFBRUMsSUFBSSxFQUFDO0lBQ2xCQyxPQUFPLENBQUNDLEdBQUcsV0FBU0gsSUFBSSxjQUFTQyxJQUFJLENBQUc7SUFDeEMsSUFBR0csTUFBTSxDQUFDQyxjQUFjLElBQUlELE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxZQUFZLEVBQUM7TUFDM0RGLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxZQUFZLENBQUNOLElBQUksRUFBRUMsSUFBSSxDQUFDO0lBQ2xEO0VBQ0osQ0FBQztFQUNETSxhQUFhLEVBQUMsU0FBQUEsY0FBQSxFQUFZO0lBQ3RCZCxFQUFFLENBQUNlLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUlDLElBQUksR0FBRyxJQUFJO0lBQ2ZBLElBQUksQ0FBQ2IsZUFBZSxFQUFFO0lBQ3RCTCxFQUFFLENBQUNlLEdBQUcsQ0FBQ0ksTUFBTSxDQUFDQyxZQUFZLENBQUN2QixRQUFRLENBQUN3QixNQUFNLEVBQUUsVUFBU0MsR0FBRyxFQUFDO01BQ3JELElBQUdBLEdBQUcsSUFBSSxDQUFDLEVBQ1g7UUFDSXRCLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDUSxXQUFXLENBQUNDLFNBQVMsSUFBSXhCLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDVSxNQUFNLENBQUNDLGtCQUFrQjtRQUNoRTFCLEVBQUUsQ0FBQzJCLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUM3QixFQUFFLENBQUNlLEdBQUcsQ0FBQ2UsS0FBSyxDQUFDQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUUvRC9CLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDVSxNQUFNLENBQUNPLFlBQVksR0FBRyxJQUFJO1FBQ2pDZCxJQUFJLENBQUNlLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7TUFDNUI7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDO0VBRURDLGFBQWEsRUFBQyxTQUFBQSxjQUFBLEVBQVU7SUFDcEJuQyxFQUFFLENBQUNlLEdBQUcsQ0FBQ3FCLGtCQUFrQixDQUFDRCxhQUFhLENBQUMsQ0FBQyxDQUFDO0VBQzlDLENBQUM7RUFFREUsVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBVTtJQUNqQnJDLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDZ0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztJQUN4QmxDLEVBQUUsQ0FBQzJCLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUM3QixFQUFFLENBQUNlLEdBQUcsQ0FBQ2UsS0FBSyxDQUFDUSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDekQ7QUFDSixDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUd6QyxjQUFjIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQWRzUGFyYW0gPSByZXF1aXJlKFwiQWRzUGFyYW1cIik7XHJcbnZhciBBZHNSZXRpcmVQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbigpe1xyXG5cclxuICAgIH0sXHJcbiAgICBzaG93UmV3YXJkVmlkZW8oKSB7XHJcbiAgICAgICAgdGhpcy5qczJhbmRyb2lkKCdzaG93X3Jld2FyZF92aWRlbycsICcxJylcclxuICAgIH0sXHJcblxyXG4gICAgLy8v5r+A5Yqx6KeG6aKR5pKt5pS+5a6M5oiQ5Zue6LCD5pa55rOVIGNvbnRpbnVlX2dhbWVcclxuICAgIC8vLyBOYXRpdmUuYW5kcm9pZDJqcyhcImNvbnRpbnVlX2dhbWVcIiwgKCk9PntcclxuICAgIC8vLyAgICAgLy/mv4DlirHop4bpopHmkq3mlL7lrozmiJDvvIzljp/nlJ/nq6/lm57osINcclxuICAgIC8vLyB9KTtcclxuICAgIGpzMmFuZHJvaWQobmFtZSwgZGF0YSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coYG5hbWU6JHtuYW1lfS1kYXRhOiR7ZGF0YX1gKTtcclxuICAgICAgICBpZih3aW5kb3cuaW5qZWN0ZWRPYmplY3QgJiYgd2luZG93LmluamVjdGVkT2JqZWN0LnNldEpzQ29udGVudCl7XHJcbiAgICAgICAgICAgIHdpbmRvdy5pbmplY3RlZE9iamVjdC5zZXRKc0NvbnRlbnQobmFtZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIENvbmZpcm1Vc2VBZHM6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYuc2hvd1Jld2FyZFZpZGVvKCk7XHJcbiAgICAgICAgY2MuTWdyLkFkc01nci5TaG93VmlkZW9BZHMoQWRzUGFyYW0uUG9pbnRELCBmdW5jdGlvbihvdXQpe1xyXG4gICAgICAgICAgICBpZihvdXQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnJldGlyZUFnZSArPSBjYy5NZ3IuZ2xvYmFsLnRtcFJldGlyZUFnZUJvbnVlcztcclxuICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlJlZnJlc2hBbGxVSVNob3csIHt9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC51c2VSZXRpcmVBZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNoYXJlVG9GcmllbmQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLlNoYXJlVG9GcmllbmQoMik7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5SZXRpcmUsIHt9KTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFkc1JldGlyZVBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/AudioMgr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '80f4ec1zbdNFZ7s9jPxp+Rh', 'AudioMgr');
// Scripts/Core/AudioMgr.js

"use strict";

/*
*****Created By Alex 2018 08 24
*/
var AudioMgr = cc.Class({
  "extends": cc.Component,
  properties: {
    bgmVolume: 0.5,
    sfxVolume: 1.0,
    bgmAudioID: -1,
    musicState: 1 //1 表示开启 0 表示关闭
  },

  // use this for initialization
  init: function init() {
    cc.Mgr.loadSound = false;
    var t = cc.sys.localStorage.getItem("bgmVolume");
    if (t != null) {
      this.bgmVolume = parseFloat(t);
    }
    var t = cc.sys.localStorage.getItem("sfxVolume");
    if (t != null) {
      this.sfxVolume = parseFloat(t);
    }
    cc.game.on(cc.game.EVENT_HIDE, function () {
      console.log("cc.audioEngine.pauseAll");
      cc.audioEngine.pauseAll();
    });
    cc.game.on(cc.game.EVENT_SHOW, function () {
      console.log("cc.audioEngine.resumeAll");
      cc.audioEngine.resumeAll();
    });
    this.node = new cc.Node('audioNode');
  },
  //获取需要播放某个音效用  根据名字来
  getUrl: function getUrl(url) {
    return cc.url.raw("resources/sound/" + url + ".mp3");
  },
  //播放背景音乐
  playBGM: function playBGM(url) {
    var _this = this;
    if (this.bgmAudioID >= 0) {
      cc.audioEngine.stop(this.bgmAudioID);
    }
    cc.resources.load('sound/' + url, cc.AudioClip, function (err, audioClip) {
      var audioSource = _this.node.addComponent(cc.AudioSource);
      audioSource.clip = audioClip;
      audioSource.volumn = _this.bgmVolume;
      audioSource.loop = true;
      audioSource.play();
    });
  },
  //播放音效
  playSFX: function playSFX(url) {
    var _this2 = this;
    cc.resources.load('sound/' + url, cc.AudioClip, function (err, audioClip) {
      var audioSource = _this2.node.addComponent(cc.AudioSource);
      audioSource.clip = audioClip;
      audioSource.volumn = _this2.sfxVolume;
      audioSource.loop = false;
      audioSource.play();
    });
  },
  //设置音效大小
  setSFXVolume: function setSFXVolume(v) {
    if (this.sfxVolume != v) {
      cc.sys.localStorage.setItem("sfxVolume", v);
      this.sfxVolume = v;
    }
  },
  //设置背景音大小
  setBGMVolume: function setBGMVolume(v, force) {
    if (this.bgmAudioID >= 0) {
      if (v > 0) {
        cc.audioEngine.resume(this.bgmAudioID);
      } else {
        cc.audioEngine.pause(this.bgmAudioID);
      }
    }
    if (this.bgmVolume != v || force) {
      cc.sys.localStorage.setItem("bgmVolume", v);
      this.bgmVolume = v;
      cc.audioEngine.setVolume(this.bgmAudioID, v);
    }
  },
  //暂停
  pauseAll: function pauseAll() {
    this.musicState = 0;
    this.bgmVolume = 0.0;
    this.sfxVolume = 0.0;
    cc.audioEngine.pauseAll();
  },
  //恢复
  resumeAll: function resumeAll() {
    this.musicState = 1;
    this.bgmVolume = 0.5;
    this.sfxVolume = 1.0;
    cc.audioEngine.resumeAll();
  },
  getVoiceState: function getVoiceState() {
    return this.musicState;
  }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcQXVkaW9NZ3IuanMiXSwibmFtZXMiOlsiQXVkaW9NZ3IiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImJnbVZvbHVtZSIsInNmeFZvbHVtZSIsImJnbUF1ZGlvSUQiLCJtdXNpY1N0YXRlIiwiaW5pdCIsIk1nciIsImxvYWRTb3VuZCIsInQiLCJzeXMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VGbG9hdCIsImdhbWUiLCJvbiIsIkVWRU5UX0hJREUiLCJjb25zb2xlIiwibG9nIiwiYXVkaW9FbmdpbmUiLCJwYXVzZUFsbCIsIkVWRU5UX1NIT1ciLCJyZXN1bWVBbGwiLCJub2RlIiwiTm9kZSIsImdldFVybCIsInVybCIsInJhdyIsInBsYXlCR00iLCJfdGhpcyIsInN0b3AiLCJyZXNvdXJjZXMiLCJsb2FkIiwiQXVkaW9DbGlwIiwiZXJyIiwiYXVkaW9DbGlwIiwiYXVkaW9Tb3VyY2UiLCJhZGRDb21wb25lbnQiLCJBdWRpb1NvdXJjZSIsImNsaXAiLCJ2b2x1bW4iLCJsb29wIiwicGxheSIsInBsYXlTRlgiLCJfdGhpczIiLCJzZXRTRlhWb2x1bWUiLCJ2Iiwic2V0SXRlbSIsInNldEJHTVZvbHVtZSIsImZvcmNlIiwicmVzdW1lIiwicGF1c2UiLCJzZXRWb2x1bWUiLCJnZXRWb2ljZVN0YXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLElBQUlBLFFBQVEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDcEIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsU0FBUyxFQUFDLEdBQUc7SUFDYkMsU0FBUyxFQUFDLEdBQUc7SUFDYkMsVUFBVSxFQUFDLENBQUMsQ0FBQztJQUNiQyxVQUFVLEVBQUMsQ0FBQyxDQUFFO0VBQ2xCLENBQUM7O0VBRUQ7RUFDQUMsSUFBSSxFQUFFLFNBQUFBLEtBQUEsRUFBWTtJQUNkUixFQUFFLENBQUNTLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLEtBQUs7SUFFeEIsSUFBSUMsQ0FBQyxHQUFHWCxFQUFFLENBQUNZLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDQyxPQUFPLENBQUMsV0FBVyxDQUFDO0lBQ2hELElBQUdILENBQUMsSUFBSSxJQUFJLEVBQUM7TUFDVCxJQUFJLENBQUNQLFNBQVMsR0FBR1csVUFBVSxDQUFDSixDQUFDLENBQUM7SUFDbEM7SUFFQSxJQUFJQSxDQUFDLEdBQUdYLEVBQUUsQ0FBQ1ksR0FBRyxDQUFDQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxXQUFXLENBQUM7SUFDaEQsSUFBR0gsQ0FBQyxJQUFJLElBQUksRUFBQztNQUNULElBQUksQ0FBQ04sU0FBUyxHQUFHVSxVQUFVLENBQUNKLENBQUMsQ0FBQztJQUNsQztJQUVBWCxFQUFFLENBQUNnQixJQUFJLENBQUNDLEVBQUUsQ0FBQ2pCLEVBQUUsQ0FBQ2dCLElBQUksQ0FBQ0UsVUFBVSxFQUFFLFlBQVk7TUFDdkNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHlCQUF5QixDQUFDO01BQ3RDcEIsRUFBRSxDQUFDcUIsV0FBVyxDQUFDQyxRQUFRLEVBQUU7SUFDN0IsQ0FBQyxDQUFDO0lBQ0Z0QixFQUFFLENBQUNnQixJQUFJLENBQUNDLEVBQUUsQ0FBQ2pCLEVBQUUsQ0FBQ2dCLElBQUksQ0FBQ08sVUFBVSxFQUFFLFlBQVk7TUFDdkNKLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDBCQUEwQixDQUFDO01BQ3ZDcEIsRUFBRSxDQUFDcUIsV0FBVyxDQUFDRyxTQUFTLEVBQUU7SUFDOUIsQ0FBQyxDQUFDO0lBQ0YsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSXpCLEVBQUUsQ0FBQzBCLElBQUksQ0FBQyxXQUFXLENBQUM7RUFDeEMsQ0FBQztFQUVEO0VBQ0FDLE1BQU0sRUFBQyxTQUFBQSxPQUFTQyxHQUFHLEVBQUM7SUFDaEIsT0FBTzVCLEVBQUUsQ0FBQzRCLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQixHQUFHRCxHQUFHLEdBQUcsTUFBTSxDQUFDO0VBQ3hELENBQUM7RUFFRDtFQUNBRSxPQUFPLEVBQUMsU0FBQUEsUUFBU0YsR0FBRyxFQUFDO0lBQUEsSUFBQUcsS0FBQTtJQUNqQixJQUFHLElBQUksQ0FBQ3pCLFVBQVUsSUFBSSxDQUFDLEVBQUM7TUFDcEJOLEVBQUUsQ0FBQ3FCLFdBQVcsQ0FBQ1csSUFBSSxDQUFDLElBQUksQ0FBQzFCLFVBQVUsQ0FBQztJQUN4QztJQUNBTixFQUFFLENBQUNpQyxTQUFTLENBQUNDLElBQUksQ0FBQyxRQUFRLEdBQUdOLEdBQUcsRUFBRTVCLEVBQUUsQ0FBQ21DLFNBQVMsRUFBRSxVQUFDQyxHQUFHLEVBQUVDLFNBQVMsRUFBSztNQUNoRSxJQUFJQyxXQUFXLEdBQUdQLEtBQUksQ0FBQ04sSUFBSSxDQUFDYyxZQUFZLENBQUN2QyxFQUFFLENBQUN3QyxXQUFXLENBQUM7TUFDeERGLFdBQVcsQ0FBQ0csSUFBSSxHQUFHSixTQUFTO01BQzVCQyxXQUFXLENBQUNJLE1BQU0sR0FBR1gsS0FBSSxDQUFDM0IsU0FBUztNQUNuQ2tDLFdBQVcsQ0FBQ0ssSUFBSSxHQUFHLElBQUk7TUFDdkJMLFdBQVcsQ0FBQ00sSUFBSSxFQUFFO0lBQ3RCLENBQUMsQ0FBQztFQUNOLENBQUM7RUFDRDtFQUNBQyxPQUFPLEVBQUMsU0FBQUEsUUFBU2pCLEdBQUcsRUFBQztJQUFBLElBQUFrQixNQUFBO0lBQ2pCOUMsRUFBRSxDQUFDaUMsU0FBUyxDQUFDQyxJQUFJLENBQUMsUUFBUSxHQUFHTixHQUFHLEVBQUU1QixFQUFFLENBQUNtQyxTQUFTLEVBQUUsVUFBQ0MsR0FBRyxFQUFFQyxTQUFTLEVBQUs7TUFDaEUsSUFBSUMsV0FBVyxHQUFHUSxNQUFJLENBQUNyQixJQUFJLENBQUNjLFlBQVksQ0FBQ3ZDLEVBQUUsQ0FBQ3dDLFdBQVcsQ0FBQztNQUN4REYsV0FBVyxDQUFDRyxJQUFJLEdBQUdKLFNBQVM7TUFDNUJDLFdBQVcsQ0FBQ0ksTUFBTSxHQUFHSSxNQUFJLENBQUN6QyxTQUFTO01BQ25DaUMsV0FBVyxDQUFDSyxJQUFJLEdBQUcsS0FBSztNQUN4QkwsV0FBVyxDQUFDTSxJQUFJLEVBQUU7SUFDdEIsQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUNEO0VBQ0FHLFlBQVksRUFBQyxTQUFBQSxhQUFTQyxDQUFDLEVBQUM7SUFDcEIsSUFBRyxJQUFJLENBQUMzQyxTQUFTLElBQUkyQyxDQUFDLEVBQUM7TUFDbkJoRCxFQUFFLENBQUNZLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDb0MsT0FBTyxDQUFDLFdBQVcsRUFBQ0QsQ0FBQyxDQUFDO01BQzFDLElBQUksQ0FBQzNDLFNBQVMsR0FBRzJDLENBQUM7SUFDdEI7RUFDSixDQUFDO0VBQ0Q7RUFDQUUsWUFBWSxFQUFDLFNBQUFBLGFBQVNGLENBQUMsRUFBQ0csS0FBSyxFQUFDO0lBQzFCLElBQUcsSUFBSSxDQUFDN0MsVUFBVSxJQUFJLENBQUMsRUFBQztNQUNwQixJQUFHMEMsQ0FBQyxHQUFHLENBQUMsRUFBQztRQUNMaEQsRUFBRSxDQUFDcUIsV0FBVyxDQUFDK0IsTUFBTSxDQUFDLElBQUksQ0FBQzlDLFVBQVUsQ0FBQztNQUMxQyxDQUFDLE1BQ0c7UUFDQU4sRUFBRSxDQUFDcUIsV0FBVyxDQUFDZ0MsS0FBSyxDQUFDLElBQUksQ0FBQy9DLFVBQVUsQ0FBQztNQUN6QztJQUNKO0lBQ0EsSUFBRyxJQUFJLENBQUNGLFNBQVMsSUFBSTRDLENBQUMsSUFBSUcsS0FBSyxFQUFDO01BQzVCbkQsRUFBRSxDQUFDWSxHQUFHLENBQUNDLFlBQVksQ0FBQ29DLE9BQU8sQ0FBQyxXQUFXLEVBQUNELENBQUMsQ0FBQztNQUMxQyxJQUFJLENBQUM1QyxTQUFTLEdBQUc0QyxDQUFDO01BQ2xCaEQsRUFBRSxDQUFDcUIsV0FBVyxDQUFDaUMsU0FBUyxDQUFDLElBQUksQ0FBQ2hELFVBQVUsRUFBQzBDLENBQUMsQ0FBQztJQUMvQztFQUNKLENBQUM7RUFDRDtFQUNBMUIsUUFBUSxFQUFDLFNBQUFBLFNBQUEsRUFBVTtJQUNmLElBQUksQ0FBQ2YsVUFBVSxHQUFHLENBQUM7SUFDbkIsSUFBSSxDQUFDSCxTQUFTLEdBQUcsR0FBRztJQUNwQixJQUFJLENBQUNDLFNBQVMsR0FBRyxHQUFHO0lBQ3BCTCxFQUFFLENBQUNxQixXQUFXLENBQUNDLFFBQVEsRUFBRTtFQUU3QixDQUFDO0VBQ0Q7RUFDQUUsU0FBUyxFQUFDLFNBQUFBLFVBQUEsRUFBVTtJQUNoQixJQUFJLENBQUNqQixVQUFVLEdBQUcsQ0FBQztJQUNuQixJQUFJLENBQUNILFNBQVMsR0FBRyxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEdBQUc7SUFDcEJMLEVBQUUsQ0FBQ3FCLFdBQVcsQ0FBQ0csU0FBUyxFQUFFO0VBQzlCLENBQUM7RUFFRCtCLGFBQWEsRUFBQyxTQUFBQSxjQUFBLEVBQVU7SUFDcEIsT0FBTyxJQUFJLENBQUNoRCxVQUFVO0VBQzFCO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4qKioqKkNyZWF0ZWQgQnkgQWxleCAyMDE4IDA4IDI0XHJcbiovXHJcbnZhciBBdWRpb01nciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYmdtVm9sdW1lOjAuNSxcclxuICAgICAgICBzZnhWb2x1bWU6MS4wLFxyXG4gICAgICAgIGJnbUF1ZGlvSUQ6LTEsXHJcbiAgICAgICAgbXVzaWNTdGF0ZToxLCAvLzEg6KGo56S65byA5ZCvIDAg6KGo56S65YWz6ZetXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNjLk1nci5sb2FkU291bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJiZ21Wb2x1bWVcIik7XHJcbiAgICAgICAgaWYodCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5iZ21Wb2x1bWUgPSBwYXJzZUZsb2F0KHQpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzZnhWb2x1bWVcIik7XHJcbiAgICAgICAgaWYodCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zZnhWb2x1bWUgPSBwYXJzZUZsb2F0KHQpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MuZ2FtZS5vbihjYy5nYW1lLkVWRU5UX0hJREUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5hdWRpb0VuZ2luZS5wYXVzZUFsbFwiKTtcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfU0hPVywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLmF1ZGlvRW5naW5lLnJlc3VtZUFsbFwiKTtcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lQWxsKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbmV3IGNjLk5vZGUoJ2F1ZGlvTm9kZScpXHJcbiAgICB9LFxyXG5cclxuICAgIC8v6I635Y+W6ZyA6KaB5pKt5pS+5p+Q5Liq6Z+z5pWI55SoICDmoLnmja7lkI3lrZfmnaVcclxuICAgIGdldFVybDpmdW5jdGlvbih1cmwpe1xyXG4gICAgICAgIHJldHVybiBjYy51cmwucmF3KFwicmVzb3VyY2VzL3NvdW5kL1wiICsgdXJsICsgXCIubXAzXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+aSreaUvuiDjOaZr+mfs+S5kFxyXG4gICAgcGxheUJHTTpmdW5jdGlvbih1cmwpe1xyXG4gICAgICAgIGlmKHRoaXMuYmdtQXVkaW9JRCA+PSAwKXtcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUuc3RvcCh0aGlzLmJnbUF1ZGlvSUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5yZXNvdXJjZXMubG9hZCgnc291bmQvJyArIHVybCwgY2MuQXVkaW9DbGlwLCAoZXJyLCBhdWRpb0NsaXApID0+IHtcclxuICAgICAgICAgICAgbGV0IGF1ZGlvU291cmNlID0gdGhpcy5ub2RlLmFkZENvbXBvbmVudChjYy5BdWRpb1NvdXJjZSk7XHJcbiAgICAgICAgICAgIGF1ZGlvU291cmNlLmNsaXAgPSBhdWRpb0NsaXA7XHJcbiAgICAgICAgICAgIGF1ZGlvU291cmNlLnZvbHVtbiA9IHRoaXMuYmdtVm9sdW1lXHJcbiAgICAgICAgICAgIGF1ZGlvU291cmNlLmxvb3AgPSB0cnVlXHJcbiAgICAgICAgICAgIGF1ZGlvU291cmNlLnBsYXkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvL+aSreaUvumfs+aViFxyXG4gICAgcGxheVNGWDpmdW5jdGlvbih1cmwpe1xyXG4gICAgICAgIGNjLnJlc291cmNlcy5sb2FkKCdzb3VuZC8nICsgdXJsLCBjYy5BdWRpb0NsaXAsIChlcnIsIGF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYXVkaW9Tb3VyY2UgPSB0aGlzLm5vZGUuYWRkQ29tcG9uZW50KGNjLkF1ZGlvU291cmNlKTtcclxuICAgICAgICAgICAgYXVkaW9Tb3VyY2UuY2xpcCA9IGF1ZGlvQ2xpcDtcclxuICAgICAgICAgICAgYXVkaW9Tb3VyY2Uudm9sdW1uID0gdGhpcy5zZnhWb2x1bWVcclxuICAgICAgICAgICAgYXVkaW9Tb3VyY2UubG9vcCA9IGZhbHNlXHJcbiAgICAgICAgICAgIGF1ZGlvU291cmNlLnBsYXkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvL+iuvue9rumfs+aViOWkp+Wwj1xyXG4gICAgc2V0U0ZYVm9sdW1lOmZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIGlmKHRoaXMuc2Z4Vm9sdW1lICE9IHYpe1xyXG4gICAgICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzZnhWb2x1bWVcIix2KTtcclxuICAgICAgICAgICAgdGhpcy5zZnhWb2x1bWUgPSB2O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvL+iuvue9ruiDjOaZr+mfs+Wkp+Wwj1xyXG4gICAgc2V0QkdNVm9sdW1lOmZ1bmN0aW9uKHYsZm9yY2Upe1xyXG4gICAgICAgIGlmKHRoaXMuYmdtQXVkaW9JRCA+PSAwKXtcclxuICAgICAgICAgICAgaWYodiA+IDApe1xyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lKHRoaXMuYmdtQXVkaW9JRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnBhdXNlKHRoaXMuYmdtQXVkaW9JRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5iZ21Wb2x1bWUgIT0gdiB8fCBmb3JjZSl7XHJcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImJnbVZvbHVtZVwiLHYpO1xyXG4gICAgICAgICAgICB0aGlzLmJnbVZvbHVtZSA9IHY7XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnNldFZvbHVtZSh0aGlzLmJnbUF1ZGlvSUQsdik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8v5pqC5YGcXHJcbiAgICBwYXVzZUFsbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubXVzaWNTdGF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5iZ21Wb2x1bWUgPSAwLjA7XHJcbiAgICAgICAgdGhpcy5zZnhWb2x1bWUgPSAwLjA7XHJcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcclxuXHJcbiAgICB9LFxyXG4gICAgLy/mgaLlpI1cclxuICAgIHJlc3VtZUFsbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubXVzaWNTdGF0ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5iZ21Wb2x1bWUgPSAwLjU7XHJcbiAgICAgICAgdGhpcy5zZnhWb2x1bWUgPSAxLjA7XHJcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lQWxsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZvaWNlU3RhdGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXNpY1N0YXRlO1xyXG4gICAgfSxcclxufSk7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/sdk/EyouClientTiktok.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2e60dS3yGVHcbUkRe5ateNh', 'EyouClientTiktok');
// Scripts/sdk/EyouClientTiktok.js

"use strict";

exports.__esModule = true;
exports["default"] = void 0;
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var BASE_URL = 'https://games.hndibei.com';
var EyouClientTiktok = /*#__PURE__*/function () {
  function EyouClientTiktok() {
    var x = null,
      y = 0x2,
      F = null,
      I = null,
      X = '-1',
      w = '-1',
      U = '4',
      j = null,
      K = null,
      z = null,
      A = null,
      t = null,
      P = null;
    var Q = new Map();
    var h = null;
    var E = function E(H, f) {
        H['gameId'] = x, (H['platformId'] = y, H['sys'] = U), J(H)['then'](function (W) {
          if (W['payType'] == 0x4) tt['previewImage']({
            'urls': [W['payUrl']],
            'showmenu': !![]
          });else {
            if (W['payType'] == 0x8) W['balance'] > 0x0 ? G('充值提示', '账户余额:' + W['balance'] + '元,\x20还需充值:' + W['needPay'] + '元', function () {
              return Z(W, f);
            }) : Z(W, f);else throw new Error('非法支付类型');
          }
        });
      },
      Z = function Z(H, f) {
        if (H['needPay'] == 0x0) {
          T(H, f);
          return;
        }
        tt['requestGamePayment']({
          'mode': 'game',
          'env': 0x0,
          'currencyType': 'CNY',
          'platform': 'android',
          'buyQuantity': H['needPay'] * H['rate'],
          'zoneId': H['zoneId'],
          'customId': H['orderId'],
          'extraInfo': H['orderId'],
          'success': function success(W) {
            T(H, f);
          }
        });
      },
      V = BASE_URL + '/market-multi-game-server/tiktokClient/deduct',
      T = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(H, f) {
          var W, a;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                W = {
                  'orderId': H['orderId'],
                  'gameId': x,
                  'platformId': y,
                  'userId': H['userId']
                };
                _context.next = 4;
                return q(V, W);
              case 4:
                a = _context.sent;
                a['code'] === CodeStatus['SUCCESS'] && f(a);
                _context.next = 11;
                break;
              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);
                console['error']('[扣款失败]异常:>', _context.t0);
              case 11:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[0, 8]]);
        }));
        return function T(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }(),
      d = BASE_URL + '/market-multi-game-server/tiktokClient/pullPay',
      J = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(H) {
          var f, W, a, S, g;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                f = 0x3;
                W = 0x0, a = ![], S = ![];
              case 2:
                if (!(W < f && !a)) {
                  _context2.next = 20;
                  break;
                }
                _context2.prev = 3;
                _context2.next = 6;
                return q(d, H);
              case 6:
                g = _context2.sent;
                if (!(g['code'] === CodeStatus['SUCCESS'])) {
                  _context2.next = 11;
                  break;
                }
                return _context2.abrupt("return", g['data']);
              case 11:
                !S && (G('支付拉起失败', g['message']), S = !![]);
              case 12:
                _context2.next = 17;
                break;
              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](3);
                !S && (G('支付拉起失败', '网络超时'), S = !![]);
              case 17:
                W++;
                _context2.next = 2;
                break;
              case 20:
                throw new Error('支付拉起失败');
              case 21:
              case "end":
                return _context2.stop();
            }
          }, _callee2, null, [[3, 14]]);
        }));
        return function J(_x3) {
          return _ref2.apply(this, arguments);
        };
      }(),
      k = function k() {
        return new Promise(function (H, f) {
          tt['login']({
            'force': !![],
            'success': function success(_ref3) {
              var W = _ref3.code;
              W ? (console['log']('code:>', W), H(W)) : f(new Error('获取code失败'));
            },
            'fail': f
          });
        });
      },
      B = function B(H) {
        x = H;
        var f = tt['getSystemInfoSync']();
        U = f['platform'] === 'android' ? '4' : f['platform'] === 'ios' ? '5' : '6';
        var W = tt['getLaunchOptionsSync']()['query'];
        F = W['channel'], I = W['sub_channel'];
        var a = {
          '10919': ['promotionid', 'clickid']
        };
        if (a['hasOwnProperty'](F)) {
          var _a$F = a[F],
            S = _a$F[0],
            g = _a$F[1];
          X = W[S], w = W[g];
        } else F = '10906', I = '' + x + y + F + U + '0';
      },
      p = BASE_URL + '/market-multi-game-server/tiktokClient/adAction',
      o = function o(H, f, W) {
        var a = {
          'gameId': x,
          'platformId': y,
          'channelId': F,
          'subChannelId': I,
          'aid': X,
          'traceId': w,
          'sys': U,
          'userId': K,
          'adType': H,
          'adUnitId': f,
          'adActionType': W
        };
        q(p, a)['catch'](function (S) {
          console['log']('发送广告行为失败:>', S);
        });
      },
      L = function L(H) {
        var f = Q['get'](H);
        if (!f) throw new Error('未创建编号为' + H + '的客服按钮');
        return f;
      },
      C = function C() {
        if (!h) throw new Error('未创建录屏管理器');
      },
      G = function G(H, f, W, a) {
        tt['showModal']({
          'title': H,
          'content': f,
          'success': function success(S) {
            if (S['confirm'] && W) W();else S['cancel'] && a && a();
          }
        });
      },
      q = function q(H, f) {
        return new Promise(function (W, a) {
          tt['request']({
            'url': H,
            'method': 'POST',
            'header': {
              'Content-Type': 'application/json;charset=UTF-8'
            },
            'data': JSON['stringify'](f),
            'fail': a,
            'success': function success(S) {
              W(S['data']);
            },
            'complete': function complete(S) {
              console['log']('---------------------------------请求\x20BEGIN--------------------------------'), console['log']('Url:>', H), console['log']('请求参数:>', f), console['log']('响应:>', S['data'] || S['errMsg']), console['log']('---------------------------------请求\x20END--------------------------------');
            }
          });
        });
      },
      i = BASE_URL + '/market-multi-game-server/tiktokClient/initGame';
    this['init'] = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(H, f) {
        var W, a;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              tt['onShareAppMessage'](function (S) {
                return {
                  'templateId': A,
                  'query': '',
                  'success': function success() {
                    console['log']('分享成功');
                  },
                  'fail': function fail(g) {
                    console['log']('分享失败', g);
                  }
                };
              });
              _context3.next = 4;
              return k();
            case 4:
              j = _context3.sent;
              B(H);
              W = {
                'code': j,
                'gameId': x,
                'platformId': y,
                'channelId': F,
                'subChannelId': I,
                'aid': X,
                'traceId': w,
                'sys': U
              };
              _context3.next = 9;
              return q(i, W);
            case 9:
              a = _context3.sent;
              a['code'] === CodeStatus['SUCCESS'] && (K = a['data']['userId'], z = a['data']['unionId'], A = a['data']['shareTemplateId'], a['data'] = null), f(a);
              _context3.next = 16;
              break;
            case 13:
              _context3.prev = 13;
              _context3.t0 = _context3["catch"](0);
              console['error']('[初始化游戏]异常:>', _context3.t0);
            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, null, [[0, 13]]);
      }));
      return function (_x4, _x5) {
        return _ref4.apply(this, arguments);
      };
    }(), this['login'] = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(H) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              H({
                'code': CodeStatus['SUCCESS'],
                'message': '操作成功',
                'data': {
                  'code': j
                }
              });
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return function (_x6) {
        return _ref5.apply(this, arguments);
      };
    }(), this['pay'] = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(H, f) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              tt['checkSession']({
                'success': function success(W) {
                  try {
                    E(H, f);
                  } catch (a) {
                    console['error']('[支付拉起]异常:>', a);
                  }
                },
                'fail': function fail(W) {
                  tt['login']({
                    'success': function success(a) {
                      try {
                        E(H, f);
                      } catch (S) {
                        console['error']('[支付拉起]异常:>', S);
                      }
                    }
                  });
                }
              });
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      return function (_x7, _x8) {
        return _ref6.apply(this, arguments);
      };
    }();
    var c = BASE_URL + '/market-multi-game-server/tiktokClient/uploadRoleInfo';
    this['uploadRoleInfo'] = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(H, f) {
        var W;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              H['gameId'] = x, H['platformId'] = y;
              _context6.next = 4;
              return q(c, H);
            case 4:
              W = _context6.sent;
              f(W);
              _context6.next = 11;
              break;
            case 8:
              _context6.prev = 8;
              _context6.t0 = _context6["catch"](0);
              console['error']('上报角色数据异常:>', _context6.t0);
            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, null, [[0, 8]]);
      }));
      return function (_x9, _x10) {
        return _ref7.apply(this, arguments);
      };
    }();
    var M = BASE_URL + '/market-multi-game-server/tiktokClient/antidirt';
    this['antidirt'] = /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(H, f) {
        var W, a;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              W = {
                'gameId': x,
                'platformId': y,
                'contents': H
              };
              _context7.next = 4;
              return q(M, W);
            case 4:
              a = _context7.sent;
              f(a);
              _context7.next = 11;
              break;
            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](0);
              console['error']('[内容安全检测]异常:>', _context7.t0);
            case 11:
            case "end":
              return _context7.stop();
          }
        }, _callee7, null, [[0, 8]]);
      }));
      return function (_x11, _x12) {
        return _ref8.apply(this, arguments);
      };
    }(), this['createRewardedVideoAd'] = function (H, f) {
      var W = {
        'adUnitId': H['adUnitId']
      };
      H['multiton'] && (W['multiton'] = H['multiton'], W['multitonRewardMsg'] = H['multitonRewardMsg'], W['multitonRewardTimes'] = H['multitonRewardTimes']), H['progressTip'] && (W['progressTip'] = H['progressTip']), P = tt['createRewardedVideoAd'](W), P['onClose'](function (a) {
        o(AdType['REWARDED_VIDEO_AD'], t, AdActionType['FINISHED']), H['onClose'] && H['onClose'](a), P['destroy']();
      }), H['onError'] && P['onError'](function (a) {
        H['onError'] && H['onError'](a), P['destroy']();
      }), t = H['adUnitId'], f({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': null
      });
    }, this['showRewardedVideoAd'] = function () {
      P && (P['load'](), P['show']()['then'](function () {
        return o(AdType['REWARDED_VIDEO_AD'], t, AdActionType['SHOW']);
      })['catch'](function (H) {
        P['load']()['then'](function () {
          P['show']()['then'](function () {
            return o(AdType['REWARDED_VIDEO_AD'], t, AdActionType['SHOW']);
          });
        })['catch'](function (f) {
          return console['log']('激励视频\x20广告显示失败');
        });
      }));
    }, this['createContactButton'] = function (H, f) {
      var W = tt['createContactButton'](H);
      Q['set'](Q['size'], W), f({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': {
          'contactBtnNo': Q['size'] - 0x1
        }
      });
    }, this['contactBtnDestory'] = function (H) {
      var f = L(H);
      f['destory'](), Q['set'](H, null);
    }, this['contactBtnShow'] = function (H) {
      var f = L(H);
      f['show']();
    }, this['contactBtnHide'] = function (H) {
      var f = L(H);
      f['hide']();
    }, this['createGameRecorder'] = function (H, f) {
      h = tt['getGameRecorderManager'](), H['onStart'] && h['onStart'](H['onStart']), H['onResume'] && h['onResume'](H['onResume']), H['onPause'] && h['onPause'](H['onPause']), H['onStop'] && h['onStop'](H['onStop']), H['onError'] && h['onError'](H['onError']), H['onInterruptionBegin'] && h['onInterruptionBegin'](H['onInterruptionBegin']), H['onInterruptionEnd'] && h['onInterruptionEnd'](H['onInterruptionEnd']), f({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': null
      });
    }, this['gameRecorderStart'] = function (H) {
      C(), h['start'](H);
    }, this['gameRecorderPause'] = function () {
      C(), h['pause']();
    }, this['gameRecorderResume'] = function () {
      C(), h['resume']();
    }, this['gameRecorderStop'] = function () {
      C(), h['stop']();
    }, this['shareAppMessage'] = function (H, f) {
      tt['shareAppMessage'](_extends({}, H, {
        'templateId': A,
        'success': function success() {
          f({
            'code': CodeStatus['SUCCESS'],
            'message': '操作成功',
            'data': null
          });
        },
        'fail': function fail(W) {
          console['log']('[分享失败]:>', W), f({
            'code': CodeStatus['FAIL'],
            'message': '操作失败',
            'data': null
          });
        }
      }));
    }, this['addShortcut'] = function (H) {
      tt['addShortcut']({
        'complete': H
      });
    };
  }
  EyouClientTiktok['getIns'] = function getIns() {
    return !this['ins'] && (this['ins'] = new EyouClientTiktok()), this['ins'];
  };
  return EyouClientTiktok;
}();
exports["default"] = EyouClientTiktok;
var CodeStatus = function CodeStatus() {};
CodeStatus['SUCCESS'] = 0x0;
CodeStatus['FAIL'] = -0x1;
var AdType = function AdType() {};
AdType['REWARDED_VIDEO_AD'] = 0x1;
AdType['BANNER_AD'] = 0x2;
var AdActionType = function AdActionType() {};
AdActionType['SHOW'] = 0x1;
AdActionType['FINISHED'] = 0x2;
module.exports = exports["default"];

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcc2RrXFxFeW91Q2xpZW50VGlrdG9rLmpzIl0sIm5hbWVzIjpbIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJleHBvcnRzIiwiT3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwiZGVzYyIsInZhbHVlIiwiJFN5bWJvbCIsIlN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsImNvbnRleHQiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJ0eXBlIiwiY2FsbCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJfaW52b2tlIiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInJlc3VsdCIsIl9fYXdhaXQiLCJ0aGVuIiwidW53cmFwcGVkIiwiZXJyb3IiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsImRvbmUiLCJtZXRob2ROYW1lIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaW5mbyIsInJlc3VsdE5hbWUiLCJuZXh0IiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmFibGUiLCJpdGVyYXRvck1ldGhvZCIsImlzTmFOIiwibGVuZ3RoIiwiaSIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJtYXJrIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJhd3JhcCIsImFzeW5jIiwiUHJvbWlzZSIsIml0ZXIiLCJrZXlzIiwidmFsIiwib2JqZWN0IiwicmV2ZXJzZSIsInBvcCIsInNraXBUZW1wUmVzZXQiLCJwcmV2IiwiY2hhckF0Iiwic2xpY2UiLCJzdG9wIiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJfbmV4dCIsIl90aHJvdyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiQkFTRV9VUkwiLCJFeW91Q2xpZW50VGlrdG9rIiwieCIsInkiLCJGIiwiSSIsIlgiLCJ3IiwiVSIsImoiLCJLIiwieiIsIkEiLCJ0IiwiUCIsIlEiLCJNYXAiLCJoIiwiRSIsIkgiLCJmIiwiSiIsIlciLCJ0dCIsIkciLCJaIiwiVCIsInN1Y2Nlc3MiLCJWIiwiX3JlZiIsIl9jYWxsZWUiLCJhIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInEiLCJDb2RlU3RhdHVzIiwidDAiLCJjb25zb2xlIiwiX3giLCJfeDIiLCJkIiwiX3JlZjIiLCJfY2FsbGVlMiIsIlMiLCJnIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwiX3gzIiwiayIsIl9yZWYzIiwiY29kZSIsIkIiLCJfYSRGIiwicCIsIm8iLCJMIiwiQyIsIkpTT04iLCJfcmVmNCIsIl9jYWxsZWUzIiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiZmFpbCIsIl94NCIsIl94NSIsIl9yZWY1IiwiX2NhbGxlZTQiLCJfY2FsbGVlNCQiLCJfY29udGV4dDQiLCJfeDYiLCJfcmVmNiIsIl9jYWxsZWU1IiwiX2NhbGxlZTUkIiwiX2NvbnRleHQ1IiwiX3g3IiwiX3g4IiwiYyIsIl9yZWY3IiwiX2NhbGxlZTYiLCJfY2FsbGVlNiQiLCJfY29udGV4dDYiLCJfeDkiLCJfeDEwIiwiTSIsIl9yZWY4IiwiX2NhbGxlZTciLCJfY2FsbGVlNyQiLCJfY29udGV4dDciLCJfeDExIiwiX3gxMiIsIkFkVHlwZSIsIkFkQWN0aW9uVHlwZSIsIl9leHRlbmRzIiwiZ2V0SW5zIiwibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0FDQSxxSkFBQUEsbUJBQUEsWUFBQUEsb0JBQUEsV0FBQUMsT0FBQSxTQUFBQSxPQUFBLE9BQUFDLEVBQUEsR0FBQUMsTUFBQSxDQUFBQyxTQUFBLEVBQUFDLE1BQUEsR0FBQUgsRUFBQSxDQUFBSSxjQUFBLEVBQUFDLGNBQUEsR0FBQUosTUFBQSxDQUFBSSxjQUFBLGNBQUFDLEdBQUEsRUFBQUMsR0FBQSxFQUFBQyxJQUFBLElBQUFGLEdBQUEsQ0FBQUMsR0FBQSxJ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QUFBLEVBQWtCO0lBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUMsSUFBSTVGLGdCQUFnQixFQUFFLENBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0VBQUMsQ0FBQztFQUFBLE9BQUFBLGdCQUFBO0FBQUE7QUFBQXBKLE9BQUEsY0FBQW9KLGdCQUFBO0FBQUEsSUFBT2tDLFVBQVUsWUFBQUEsV0FBQTtBQUFWQSxVQUFVLENBQVMsU0FBUyxJQUFFLEdBQUc7QUFBakNBLFVBQVUsQ0FBZ0MsTUFBTSxJQUFFLENBQUMsR0FBRztBQUFBLElBQVF1RCxNQUFNLFlBQUFBLE9BQUE7QUFBTkEsTUFBTSxDQUFTLG1CQUFtQixJQUFFLEdBQUc7QUFBdkNBLE1BQU0sQ0FBMEMsV0FBVyxJQUFFLEdBQUc7QUFBQSxJQUFRQyxZQUFZLFlBQUFBLGFBQUE7QUFBWkEsWUFBWSxDQUFTLE1BQU0sSUFBRSxHQUFHO0FBQWhDQSxZQUFZLENBQTZCLFVBQVUsSUFBRSxHQUFHO0FBQUFHLE1BQUEsQ0FBQWpQLE9BQUEsR0FBQUEsT0FBQSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQkFTRV9VUkw9J2h0dHBzOi8vZ2FtZXMuaG5kaWJlaS5jb20nO2V4cG9ydCBkZWZhdWx0IGNsYXNzIEV5b3VDbGllbnRUaWt0b2t7Y29uc3RydWN0b3IoKXtsZXQgeD1udWxsLHk9MHgyLEY9bnVsbCxJPW51bGwsWD0nLTEnLHc9Jy0xJyxVPSc0JyxqPW51bGwsSz1udWxsLHo9bnVsbCxBPW51bGwsdD1udWxsLFA9bnVsbDtjb25zdCBRPW5ldyBNYXAoKTtsZXQgaD1udWxsO2NvbnN0IEU9KEgsZik9PntIWydnYW1lSWQnXT14LChIWydwbGF0Zm9ybUlkJ109eSxIWydzeXMnXT1VKSxKKEgpWyd0aGVuJ10oVz0+e2lmKFdbJ3BheVR5cGUnXT09MHg0KXR0WydwcmV2aWV3SW1hZ2UnXSh7J3VybHMnOltXWydwYXlVcmwnXV0sJ3Nob3dtZW51JzohIVtdfSk7ZWxzZXtpZihXWydwYXlUeXBlJ109PTB4OClXWydiYWxhbmNlJ10+MHgwP0coJ+WFheWAvOaPkOekuicsJ+i0puaIt+S9meminTonK1dbJ2JhbGFuY2UnXSsn5YWDLFxceDIw6L+Y6ZyA5YWF5YC8OicrV1snbmVlZFBheSddKyflhYMnLCgpPT5aKFcsZikpOlooVyxmKTtlbHNlIHRocm93IG5ldyBFcnJvcign6Z2e5rOV5pSv5LuY57G75Z6LJyk7fX0pO30sWj0oSCxmKT0+e2lmKEhbJ25lZWRQYXknXT09MHgwKXtUKEgsZik7cmV0dXJuO310dFsncmVxdWVzdEdhbWVQYXltZW50J10oeydtb2RlJzonZ2FtZScsJ2Vudic6MHgwLCdjdXJyZW5jeVR5cGUnOidDTlknLCdwbGF0Zm9ybSc6J2FuZHJvaWQnLCdidXlRdWFudGl0eSc6SFsnbmVlZFBheSddKkhbJ3JhdGUnXSwnem9uZUlkJzpIWyd6b25lSWQnXSwnY3VzdG9tSWQnOkhbJ29yZGVySWQnXSwnZXh0cmFJbmZvJzpIWydvcmRlcklkJ10sJ3N1Y2Nlc3MnOlc9PntUKEgsZik7fX0pO30sVj1CQVNFX1VSTCsnL21hcmtldC1tdWx0aS1nYW1lLXNlcnZlci90aWt0b2tDbGllbnQvZGVkdWN0JyxUPWFzeW5jKEgsZik9Pnt0cnl7Y29uc3QgVz17J29yZGVySWQnOkhbJ29yZGVySWQnXSwnZ2FtZUlkJzp4LCdwbGF0Zm9ybUlkJzp5LCd1c2VySWQnOkhbJ3VzZXJJZCddfTtsZXQgYT1hd2FpdCBxKFYsVyk7YVsnY29kZSddPT09Q29kZVN0YXR1c1snU1VDQ0VTUyddJiZmKGEpO31jYXRjaChTKXtjb25zb2xlWydlcnJvciddKCdb5omj5qy+5aSx6LSlXeW8guW4uDo+JyxTKTt9fSxkPUJBU0VfVVJMKycvbWFya2V0LW11bHRpLWdhbWUtc2VydmVyL3Rpa3Rva0NsaWVudC9wdWxsUGF5JyxKPWFzeW5jIEg9Pntjb25zdCBmPTB4MztsZXQgVz0weDAsYT0hW10sUz0hW107d2hpbGUoVzxmJiYhYSl7dHJ5e2NvbnN0IGc9YXdhaXQgcShkLEgpO2lmKGdbJ2NvZGUnXT09PUNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSlyZXR1cm4gZ1snZGF0YSddO2Vsc2UhUyYmKEcoJ+aUr+S7mOaLiei1t+Wksei0pScsZ1snbWVzc2FnZSddKSxTPSEhW10pO31jYXRjaChZKXshUyYmKEcoJ+aUr+S7mOaLiei1t+Wksei0pScsJ+e9kee7nOi2heaXticpLFM9ISFbXSk7fVcrKzt9dGhyb3cgbmV3IEVycm9yKCfmlK/ku5jmi4notbflpLHotKUnKTt9LGs9KCk9PntyZXR1cm4gbmV3IFByb21pc2UoKEgsZik9Pnt0dFsnbG9naW4nXSh7J2ZvcmNlJzohIVtdLCdzdWNjZXNzJzooe2NvZGU6V30pPT57Vz8oY29uc29sZVsnbG9nJ10oJ2NvZGU6PicsVyksSChXKSk6ZihuZXcgRXJyb3IoJ+iOt+WPlmNvZGXlpLHotKUnKSk7fSwnZmFpbCc6Zn0pO30pO30sQj1IPT57eD1IO2NvbnN0IGY9dHRbJ2dldFN5c3RlbUluZm9TeW5jJ10oKTtVPWZbJ3BsYXRmb3JtJ109PT0nYW5kcm9pZCc/JzQnOmZbJ3BsYXRmb3JtJ109PT0naW9zJz8nNSc6JzYnO2NvbnN0IFc9dHRbJ2dldExhdW5jaE9wdGlvbnNTeW5jJ10oKVsncXVlcnknXTtGPVdbJ2NoYW5uZWwnXSxJPVdbJ3N1Yl9jaGFubmVsJ107Y29uc3QgYT17JzEwOTE5JzpbJ3Byb21vdGlvbmlkJywnY2xpY2tpZCddfTtpZihhWydoYXNPd25Qcm9wZXJ0eSddKEYpKXtjb25zdCBbUyxnXT1hW0ZdO1g9V1tTXSx3PVdbZ107fWVsc2UgRj0nMTA5MDYnLEk9JycreCt5K0YrVSsnMCc7fSxwPUJBU0VfVVJMKycvbWFya2V0LW11bHRpLWdhbWUtc2VydmVyL3Rpa3Rva0NsaWVudC9hZEFjdGlvbicsbz0oSCxmLFcpPT57bGV0IGE9eydnYW1lSWQnOngsJ3BsYXRmb3JtSWQnOnksJ2NoYW5uZWxJZCc6Riwnc3ViQ2hhbm5lbElkJzpJLCdhaWQnOlgsJ3RyYWNlSWQnOncsJ3N5cyc6VSwndXNlcklkJzpLLCdhZFR5cGUnOkgsJ2FkVW5pdElkJzpmLCdhZEFjdGlvblR5cGUnOld9O3EocCxhKVsnY2F0Y2gnXShTPT57Y29uc29sZVsnbG9nJ10oJ+WPkemAgeW5v+WRiuihjOS4uuWksei0pTo+JyxTKTt9KTt9LEw9SD0+e2xldCBmPVFbJ2dldCddKEgpO2lmKCFmKXRocm93IG5ldyBFcnJvcign5pyq5Yib5bu657yW5Y+35Li6JytIKyfnmoTlrqLmnI3mjInpkq4nKTtyZXR1cm4gZjt9LEM9KCk9PntpZighaCl0aHJvdyBuZXcgRXJyb3IoJ+acquWIm+W7uuW9leWxj+euoeeQhuWZqCcpO30sRz0oSCxmLFcsYSk9Pnt0dFsnc2hvd01vZGFsJ10oeyd0aXRsZSc6SCwnY29udGVudCc6Ziwnc3VjY2Vzcyc6ZnVuY3Rpb24oUyl7aWYoU1snY29uZmlybSddJiZXKVcoKTtlbHNlIFNbJ2NhbmNlbCddJiZhJiZhKCk7fX0pO30scT0oSCxmKT0+e3JldHVybiBuZXcgUHJvbWlzZSgoVyxhKT0+e3R0WydyZXF1ZXN0J10oeyd1cmwnOkgsJ21ldGhvZCc6J1BPU1QnLCdoZWFkZXInOnsnQ29udGVudC1UeXBlJzonYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J30sJ2RhdGEnOkpTT05bJ3N0cmluZ2lmeSddKGYpLCdmYWlsJzphLCdzdWNjZXNzJzpmdW5jdGlvbihTKXtXKFNbJ2RhdGEnXSk7fSwnY29tcGxldGUnOmZ1bmN0aW9uKFMpe2NvbnNvbGVbJ2xvZyddKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS3or7fmsYJcXHgyMEJFR0lOLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKSxjb25zb2xlWydsb2cnXSgnVXJsOj4nLEgpLGNvbnNvbGVbJ2xvZyddKCfor7fmsYLlj4LmlbA6PicsZiksY29uc29sZVsnbG9nJ10oJ+WTjeW6lDo+JyxTWydkYXRhJ118fFNbJ2Vyck1zZyddKSxjb25zb2xlWydsb2cnXSgnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t6K+35rGCXFx4MjBFTkQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO319KTt9KTt9LGk9QkFTRV9VUkwrJy9tYXJrZXQtbXVsdGktZ2FtZS1zZXJ2ZXIvdGlrdG9rQ2xpZW50L2luaXRHYW1lJzt0aGlzWydpbml0J109YXN5bmMoSCxmKT0+e3RyeXt0dFsnb25TaGFyZUFwcE1lc3NhZ2UnXShTPT57cmV0dXJueyd0ZW1wbGF0ZUlkJzpBLCdxdWVyeSc6JycsJ3N1Y2Nlc3MnOigpPT57Y29uc29sZVsnbG9nJ10oJ+WIhuS6q+aIkOWKnycpO30sJ2ZhaWwnOmc9Pntjb25zb2xlWydsb2cnXSgn5YiG5Lqr5aSx6LSlJyxnKTt9fTt9KSxqPWF3YWl0IGsoKSxCKEgpO2NvbnN0IFc9eydjb2RlJzpqLCdnYW1lSWQnOngsJ3BsYXRmb3JtSWQnOnksJ2NoYW5uZWxJZCc6Riwnc3ViQ2hhbm5lbElkJzpJLCdhaWQnOlgsJ3RyYWNlSWQnOncsJ3N5cyc6VX0sYT1hd2FpdCBxKGksVyk7YVsnY29kZSddPT09Q29kZVN0YXR1c1snU1VDQ0VTUyddJiYoSz1hWydkYXRhJ11bJ3VzZXJJZCddLHo9YVsnZGF0YSddWyd1bmlvbklkJ10sQT1hWydkYXRhJ11bJ3NoYXJlVGVtcGxhdGVJZCddLGFbJ2RhdGEnXT1udWxsKSxmKGEpO31jYXRjaChTKXtjb25zb2xlWydlcnJvciddKCdb5Yid5aeL5YyW5ri45oiPXeW8guW4uDo+JyxTKTt9fSx0aGlzWydsb2dpbiddPWFzeW5jIEg9PntIKHsnY29kZSc6Q29kZVN0YXR1c1snU1VDQ0VTUyddLCdtZXNzYWdlJzon5pON5L2c5oiQ5YqfJywnZGF0YSc6eydjb2RlJzpqfX0pO30sdGhpc1sncGF5J109YXN5bmMoSCxmKT0+e3R0WydjaGVja1Nlc3Npb24nXSh7J3N1Y2Nlc3MnOlc9Pnt0cnl7RShILGYpO31jYXRjaChhKXtjb25zb2xlWydlcnJvciddKCdb5pSv5LuY5ouJ6LW3XeW8guW4uDo+JyxhKTt9fSwnZmFpbCc6Vz0+e3R0Wydsb2dpbiddKHsnc3VjY2Vzcyc6YT0+e3RyeXtFKEgsZik7fWNhdGNoKFMpe2NvbnNvbGVbJ2Vycm9yJ10oJ1vmlK/ku5jmi4notbdd5byC5bi4Oj4nLFMpO319fSk7fX0pO307Y29uc3QgYz1CQVNFX1VSTCsnL21hcmtldC1tdWx0aS1nYW1lLXNlcnZlci90aWt0b2tDbGllbnQvdXBsb2FkUm9sZUluZm8nO3RoaXNbJ3VwbG9hZFJvbGVJbmZvJ109YXN5bmMoSCxmKT0+e3RyeXtIWydnYW1lSWQnXT14LEhbJ3BsYXRmb3JtSWQnXT15O2NvbnN0IFc9YXdhaXQgcShjLEgpO2YoVyk7fWNhdGNoKGEpe2NvbnNvbGVbJ2Vycm9yJ10oJ+S4iuaKpeinkuiJsuaVsOaNruW8guW4uDo+JyxhKTt9fTtjb25zdCBNPUJBU0VfVVJMKycvbWFya2V0LW11bHRpLWdhbWUtc2VydmVyL3Rpa3Rva0NsaWVudC9hbnRpZGlydCc7dGhpc1snYW50aWRpcnQnXT1hc3luYyhILGYpPT57dHJ5e2xldCBXPXsnZ2FtZUlkJzp4LCdwbGF0Zm9ybUlkJzp5LCdjb250ZW50cyc6SH07Y29uc3QgYT1hd2FpdCBxKE0sVyk7ZihhKTt9Y2F0Y2goUyl7Y29uc29sZVsnZXJyb3InXSgnW+WGheWuueWuieWFqOajgOa1i13lvILluLg6PicsUyk7fX0sdGhpc1snY3JlYXRlUmV3YXJkZWRWaWRlb0FkJ109KEgsZik9PntsZXQgVz17J2FkVW5pdElkJzpIWydhZFVuaXRJZCddfTtIWydtdWx0aXRvbiddJiYoV1snbXVsdGl0b24nXT1IWydtdWx0aXRvbiddLFdbJ211bHRpdG9uUmV3YXJkTXNnJ109SFsnbXVsdGl0b25SZXdhcmRNc2cnXSxXWydtdWx0aXRvblJld2FyZFRpbWVzJ109SFsnbXVsdGl0b25SZXdhcmRUaW1lcyddKSxIWydwcm9ncmVzc1RpcCddJiYoV1sncHJvZ3Jlc3NUaXAnXT1IWydwcm9ncmVzc1RpcCddKSxQPXR0WydjcmVhdGVSZXdhcmRlZFZpZGVvQWQnXShXKSxQWydvbkNsb3NlJ10oYT0+e28oQWRUeXBlWydSRVdBUkRFRF9WSURFT19BRCddLHQsQWRBY3Rpb25UeXBlWydGSU5JU0hFRCddKSxIWydvbkNsb3NlJ10mJkhbJ29uQ2xvc2UnXShhKSxQWydkZXN0cm95J10oKTt9KSxIWydvbkVycm9yJ10mJlBbJ29uRXJyb3InXShhPT57SFsnb25FcnJvciddJiZIWydvbkVycm9yJ10oYSksUFsnZGVzdHJveSddKCk7fSksdD1IWydhZFVuaXRJZCddLGYoeydjb2RlJzpDb2RlU3RhdHVzWydTVUNDRVNTJ10sJ21lc3NhZ2UnOifmk43kvZzmiJDlip8nLCdkYXRhJzpudWxsfSk7fSx0aGlzWydzaG93UmV3YXJkZWRWaWRlb0FkJ109KCk9PntQJiYoUFsnbG9hZCddKCksUFsnc2hvdyddKClbJ3RoZW4nXSgoKT0+byhBZFR5cGVbJ1JFV0FSREVEX1ZJREVPX0FEJ10sdCxBZEFjdGlvblR5cGVbJ1NIT1cnXSkpWydjYXRjaCddKEg9PntQWydsb2FkJ10oKVsndGhlbiddKCgpPT57UFsnc2hvdyddKClbJ3RoZW4nXSgoKT0+byhBZFR5cGVbJ1JFV0FSREVEX1ZJREVPX0FEJ10sdCxBZEFjdGlvblR5cGVbJ1NIT1cnXSkpO30pWydjYXRjaCddKGY9PmNvbnNvbGVbJ2xvZyddKCfmv4DlirHop4bpopFcXHgyMOW5v+WRiuaYvuekuuWksei0pScpKTt9KSk7fSx0aGlzWydjcmVhdGVDb250YWN0QnV0dG9uJ109KEgsZik9Pntjb25zdCBXPXR0WydjcmVhdGVDb250YWN0QnV0dG9uJ10oSCk7UVsnc2V0J10oUVsnc2l6ZSddLFcpLGYoeydjb2RlJzpDb2RlU3RhdHVzWydTVUNDRVNTJ10sJ21lc3NhZ2UnOifmk43kvZzmiJDlip8nLCdkYXRhJzp7J2NvbnRhY3RCdG5Obyc6UVsnc2l6ZSddLTB4MX19KTt9LHRoaXNbJ2NvbnRhY3RCdG5EZXN0b3J5J109SD0+e2xldCBmPUwoSCk7ZlsnZGVzdG9yeSddKCksUVsnc2V0J10oSCxudWxsKTt9LHRoaXNbJ2NvbnRhY3RCdG5TaG93J109SD0+e2xldCBmPUwoSCk7Zlsnc2hvdyddKCk7fSx0aGlzWydjb250YWN0QnRuSGlkZSddPUg9PntsZXQgZj1MKEgpO2ZbJ2hpZGUnXSgpO30sdGhpc1snY3JlYXRlR2FtZVJlY29yZGVyJ109KEgsZik9PntoPXR0WydnZXRHYW1lUmVjb3JkZXJNYW5hZ2VyJ10oKSxIWydvblN0YXJ0J10mJmhbJ29uU3RhcnQnXShIWydvblN0YXJ0J10pLEhbJ29uUmVzdW1lJ10mJmhbJ29uUmVzdW1lJ10oSFsnb25SZXN1bWUnXSksSFsnb25QYXVzZSddJiZoWydvblBhdXNlJ10oSFsnb25QYXVzZSddKSxIWydvblN0b3AnXSYmaFsnb25TdG9wJ10oSFsnb25TdG9wJ10pLEhbJ29uRXJyb3InXSYmaFsnb25FcnJvciddKEhbJ29uRXJyb3InXSksSFsnb25JbnRlcnJ1cHRpb25CZWdpbiddJiZoWydvbkludGVycnVwdGlvbkJlZ2luJ10oSFsnb25JbnRlcnJ1cHRpb25CZWdpbiddKSxIWydvbkludGVycnVwdGlvbkVuZCddJiZoWydvbkludGVycnVwdGlvbkVuZCddKEhbJ29uSW50ZXJydXB0aW9uRW5kJ10pLGYoeydjb2RlJzpDb2RlU3RhdHVzWydTVUNDRVNTJ10sJ21lc3NhZ2UnOifmk43kvZzmiJDlip8nLCdkYXRhJzpudWxsfSk7fSx0aGlzWydnYW1lUmVjb3JkZXJTdGFydCddPUg9PntDKCksaFsnc3RhcnQnXShIKTt9LHRoaXNbJ2dhbWVSZWNvcmRlclBhdXNlJ109KCk9PntDKCksaFsncGF1c2UnXSgpO30sdGhpc1snZ2FtZVJlY29yZGVyUmVzdW1lJ109KCk9PntDKCksaFsncmVzdW1lJ10oKTt9LHRoaXNbJ2dhbWVSZWNvcmRlclN0b3AnXT0oKT0+e0MoKSxoWydzdG9wJ10oKTt9LHRoaXNbJ3NoYXJlQXBwTWVzc2FnZSddPShILGYpPT57dHRbJ3NoYXJlQXBwTWVzc2FnZSddKHsuLi5ILCd0ZW1wbGF0ZUlkJzpBLCdzdWNjZXNzJzooKT0+e2Yoeydjb2RlJzpDb2RlU3RhdHVzWydTVUNDRVNTJ10sJ21lc3NhZ2UnOifmk43kvZzmiJDlip8nLCdkYXRhJzpudWxsfSk7fSwnZmFpbCc6Vz0+e2NvbnNvbGVbJ2xvZyddKCdb5YiG5Lqr5aSx6LSlXTo+JyxXKSxmKHsnY29kZSc6Q29kZVN0YXR1c1snRkFJTCddLCdtZXNzYWdlJzon5pON5L2c5aSx6LSlJywnZGF0YSc6bnVsbH0pO319KTt9LHRoaXNbJ2FkZFNob3J0Y3V0J109SD0+e3R0WydhZGRTaG9ydGN1dCddKHsnY29tcGxldGUnOkh9KTt9O31zdGF0aWNbJ2dldElucyddKCl7cmV0dXJuIXRoaXNbJ2lucyddJiYodGhpc1snaW5zJ109bmV3IEV5b3VDbGllbnRUaWt0b2soKSksdGhpc1snaW5zJ107fX1jbGFzcyBDb2RlU3RhdHVze3N0YXRpYyBbJ1NVQ0NFU1MnXT0weDA7c3RhdGljIFsnRkFJTCddPS0weDE7fWNsYXNzIEFkVHlwZXtzdGF0aWMgWydSRVdBUkRFRF9WSURFT19BRCddPTB4MTtzdGF0aWMgWydCQU5ORVJfQUQnXT0weDI7fWNsYXNzIEFkQWN0aW9uVHlwZXtzdGF0aWMgWydTSE9XJ109MHgxO3N0YXRpYyBbJ0ZJTklTSEVEJ109MHgyO30iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/AdsParam.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'fa2e6IZkMdDF7UwWjGhoHrq', 'AdsParam');
// Scripts/Core/AdsParam.js

"use strict";

//广告点位 名称
var AdsParam = cc.Enum({
  PointA: 1,
  PointB: 2,
  PointC: 3,
  PointD: 4,
  PointE: 5,
  PointF: 6,
  PointG: 7,
  PointH: 8,
  PointI: 9,
  PointJ: 10
});
module.exports = AdsParam;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcQWRzUGFyYW0uanMiXSwibmFtZXMiOlsiQWRzUGFyYW0iLCJjYyIsIkVudW0iLCJQb2ludEEiLCJQb2ludEIiLCJQb2ludEMiLCJQb2ludEQiLCJQb2ludEUiLCJQb2ludEYiLCJQb2ludEciLCJQb2ludEgiLCJQb2ludEkiLCJQb2ludEoiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsSUFBSUEsUUFBUSxHQUFHQyxFQUFFLENBQUNDLElBQUksQ0FBQztFQUNuQkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDLENBQUM7RUFDUkMsTUFBTSxFQUFDO0FBQ1gsQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHZCxRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyIvL+W5v+WRiueCueS9jSDlkI3np7BcclxudmFyIEFkc1BhcmFtID0gY2MuRW51bSh7XHJcbiAgICBQb2ludEE6MSwgXHJcbiAgICBQb2ludEI6MiwgXHJcbiAgICBQb2ludEM6MyxcclxuICAgIFBvaW50RDo0LFxyXG4gICAgUG9pbnRFOjUsXHJcbiAgICBQb2ludEY6NiwgXHJcbiAgICBQb2ludEc6NyxcclxuICAgIFBvaW50SDo4LFxyXG4gICAgUG9pbnRJOjksXHJcbiAgICBQb2ludEo6MTAsXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFkc1BhcmFtOyJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/GlobalEvent.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1a01avjH0lMCbDFtWsW9kZh', 'GlobalEvent');
// Scripts/Core/GlobalEvent.js

"use strict";

//全局事件处理  分发和监听   相当于一个全局观察者
//这个事件分发处理机制 没有针对每个绑定个体的
cc.director.GlobalEvent = {
  handles_: {},
  //发送事件 事件分发
  emit: function emit(eventName, data) {
    var returns = []; //返回值
    //console.log('事件分发', eventName);
    data.eventName = eventName; //保存一下事件名字

    for (var findEvenName in this.handles_) {
      if (findEvenName == eventName) {
        for (var i = 0; i < this.handles_[findEvenName].length; i++) {
          if (this.handles_[findEvenName][i]) {
            var returnValue = this.handles_[findEvenName][i](data);
            returns.push(returnValue);
          }
        }
      }
    }
    return returns;
  },
  //添加普通事件  监听
  on: function on(eventName, callback, target) {
    //console.log('完成事件注册监听', eventName);
    this.handles_[eventName] = this.handles_[eventName] || [];
    this.handles_[eventName].push(callback.bind(target));
  },
  //通过事件名和target移除一种事件监听
  off: function off(eventName) {
    if (!this.handles_[eventName]) return;
    for (var i = 0; i < this.handles_[eventName].length; i++) {
      this.handles_[eventName][i] = null;
    }
  },
  //一次性清空所有数据
  clear: function clear() {
    for (var findEvenName in this.handles_) {
      for (var i = 0; i < this.handles_[findEvenName].length; i++) {
        this.handles_[findEvenName][i] = null;
      }
    }
  }
};

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcR2xvYmFsRXZlbnQuanMiXSwibmFtZXMiOlsiY2MiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiaGFuZGxlc18iLCJlbWl0IiwiZXZlbnROYW1lIiwiZGF0YSIsInJldHVybnMiLCJmaW5kRXZlbk5hbWUiLCJpIiwibGVuZ3RoIiwicmV0dXJuVmFsdWUiLCJwdXNoIiwib24iLCJjYWxsYmFjayIsInRhcmdldCIsImJpbmQiLCJvZmYiLCJjbGVhciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0FBLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDQyxXQUFXLEdBQUc7RUFDdEJDLFFBQVEsRUFBRSxDQUFDLENBQUM7RUFDWjtFQUNBQyxJQUFJLEVBQUUsU0FBQUEsS0FBVUMsU0FBUyxFQUFFQyxJQUFJLEVBQUU7SUFDN0IsSUFBSUMsT0FBTyxHQUFHLEVBQUUsRUFBQztJQUNqQjtJQUNBRCxJQUFJLENBQUNELFNBQVMsR0FBR0EsU0FBUzs7SUFFMUIsS0FBTSxJQUFJRyxZQUFZLElBQUksSUFBSSxDQUFDTCxRQUFRLEVBQUU7TUFDckMsSUFBSUssWUFBWSxJQUFJSCxTQUFTLEVBQUU7UUFDM0IsS0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcsSUFBSSxDQUFDTixRQUFRLENBQUNLLFlBQVksQ0FBQyxDQUFDRSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO1VBQ3pELElBQUksSUFBSSxDQUFDTixRQUFRLENBQUNLLFlBQVksQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFDbEM7WUFDSSxJQUFJRSxXQUFXLEdBQUcsSUFBSSxDQUFDUixRQUFRLENBQUNLLFlBQVksQ0FBQyxDQUFDQyxDQUFDLENBQUMsQ0FBQ0gsSUFBSSxDQUFDO1lBQ3REQyxPQUFPLENBQUNLLElBQUksQ0FBQ0QsV0FBVyxDQUFDO1VBQzdCO1FBQ0o7TUFDSjtJQUNKO0lBQ0EsT0FBT0osT0FBTztFQUNsQixDQUFDO0VBQ0Q7RUFDQU0sRUFBRSxFQUFFLFNBQUFBLEdBQVVSLFNBQVMsRUFBRVMsUUFBUSxFQUFFQyxNQUFNLEVBQUU7SUFDdkM7SUFDQSxJQUFJLENBQUNaLFFBQVEsQ0FBQ0UsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDRixRQUFRLENBQUNFLFNBQVMsQ0FBQyxJQUFJLEVBQUU7SUFFekQsSUFBSSxDQUFDRixRQUFRLENBQUNFLFNBQVMsQ0FBQyxDQUFDTyxJQUFJLENBQUNFLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDRCxNQUFNLENBQUMsQ0FBQztFQUN4RCxDQUFDO0VBQ0Q7RUFDQUUsR0FBRyxFQUFFLFNBQUFBLElBQVVaLFNBQVMsRUFBRTtJQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDRixRQUFRLENBQUNFLFNBQVMsQ0FBQyxFQUN6QjtJQUVKLEtBQUssSUFBSUksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHLElBQUksQ0FBQ04sUUFBUSxDQUFDRSxTQUFTLENBQUMsQ0FBQ0ssTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUN0RCxJQUFJLENBQUNOLFFBQVEsQ0FBQ0UsU0FBUyxDQUFDLENBQUNJLENBQUMsQ0FBQyxHQUFHLElBQUk7SUFDdEM7RUFDSixDQUFDO0VBRUQ7RUFDQVMsS0FBSyxFQUFFLFNBQUFBLE1BQUEsRUFBVTtJQUNiLEtBQU0sSUFBSVYsWUFBWSxJQUFJLElBQUksQ0FBQ0wsUUFBUSxFQUFFO01BQ3JDLEtBQUssSUFBSU0sQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHLElBQUksQ0FBQ04sUUFBUSxDQUFDSyxZQUFZLENBQUMsQ0FBQ0UsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtRQUN6RCxJQUFJLENBQUNOLFFBQVEsQ0FBQ0ssWUFBWSxDQUFDLENBQUNDLENBQUMsQ0FBQyxHQUFHLElBQUk7TUFDekM7SUFDSjtFQUNKO0FBQ0osQ0FBQyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLy/lhajlsYDkuovku7blpITnkIYgIOWIhuWPkeWSjOebkeWQrCAgIOebuOW9k+S6juS4gOS4quWFqOWxgOinguWvn+iAhVxyXG4vL+i/meS4quS6i+S7tuWIhuWPkeWkhOeQhuacuuWItiDmsqHmnInpkojlr7nmr4/kuKrnu5HlrprkuKrkvZPnmoRcclxuY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQgPSB7XHJcbiAgICBoYW5kbGVzXzoge30sXHJcbiAgICAvL+WPkemAgeS6i+S7tiDkuovku7bliIblj5FcclxuICAgIGVtaXQ6IGZ1bmN0aW9uIChldmVudE5hbWUsIGRhdGEpIHtcclxuICAgICAgICB2YXIgcmV0dXJucyA9IFtdIC8v6L+U5Zue5YC8XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygn5LqL5Lu25YiG5Y+RJywgZXZlbnROYW1lKTtcclxuICAgICAgICBkYXRhLmV2ZW50TmFtZSA9IGV2ZW50TmFtZS8v5L+d5a2Y5LiA5LiL5LqL5Lu25ZCN5a2XXHJcblxyXG4gICAgICAgIGZvciAoIHZhciBmaW5kRXZlbk5hbWUgaW4gdGhpcy5oYW5kbGVzXyApe1xyXG4gICAgICAgICAgICBpZiAoZmluZEV2ZW5OYW1lID09IGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXNfW2ZpbmRFdmVuTmFtZV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVzX1tmaW5kRXZlbk5hbWVdW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gdGhpcy5oYW5kbGVzX1tmaW5kRXZlbk5hbWVdW2ldKGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMucHVzaChyZXR1cm5WYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldHVybnNcclxuICAgIH0sXHJcbiAgICAvL+a3u+WKoOaZrumAmuS6i+S7tiAg55uR5ZCsXHJcbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRhcmdldCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ+WujOaIkOS6i+S7tuazqOWGjOebkeWQrCcsIGV2ZW50TmFtZSk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzX1tldmVudE5hbWVdID0gdGhpcy5oYW5kbGVzX1tldmVudE5hbWVdIHx8IFtdXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5oYW5kbGVzX1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2suYmluZCh0YXJnZXQpKVxyXG4gICAgfSxcclxuICAgIC8v6YCa6L+H5LqL5Lu25ZCN5ZKMdGFyZ2V056e76Zmk5LiA56eN5LqL5Lu255uR5ZCsXHJcbiAgICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlc19bZXZlbnROYW1lXSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlc19bZXZlbnROYW1lXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXNfW2V2ZW50TmFtZV1baV0gPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+S4gOasoeaAp+a4heepuuaJgOacieaVsOaNrlxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgZm9yICggdmFyIGZpbmRFdmVuTmFtZSBpbiB0aGlzLmhhbmRsZXNfICl7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oYW5kbGVzX1tmaW5kRXZlbk5hbWVdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXNfW2ZpbmRFdmVuTmFtZV1baV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufVxyXG5cclxuXHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/utils/httpUtil.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'fe15dE7wbtD3KspKLh/Cq0R', 'httpUtil');
// Scripts/utils/httpUtil.js

"use strict";

var HttpUtil = /*#__PURE__*/function () {
  function HttpUtil() {}
  /**
   * GET请求
   *
   * @static
   * @param {string} url
   * @param {object} [params={}]
   * @param {Function} callback
   * @memberof HttpUtil
   */
  HttpUtil.get = function get(url, params, callback) {
    if (params === void 0) {
      params = {};
    }
    var dataStr = '';
    Object.keys(params).forEach(function (key) {
      dataStr += key + '=' + encodeURIComponent(params[key]) + '&';
    });
    if (dataStr !== '') {
      dataStr = dataStr.substr(0, dataStr.lastIndexOf('&'));
      url = url + '?' + dataStr;
    }
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        var _response = xhr.responseText;
        if (xhr.status >= 200 && xhr.status < 300) {
          var httpStatus = xhr.statusText;
          callback(true, _response);
        } else {
          callback(false, _response);
        }
      }
    };
    xhr.timeout = HttpUtil.TimeOut;
    xhr.send();
  }

  /**
   * POST请求
   *
   * @static
   * @param {string} url
   * @param {object} [param={}]
   * @param {Function} callback
   * @memberof HttpUtil
   */;
  HttpUtil.post = function post(url, param, callback) {
    if (param === void 0) {
      param = {};
    }
    var xhr = new XMLHttpRequest();
    var dataStr = '';
    Object.keys(param).forEach(function (key) {
      return dataStr += key + '=' + encodeURIComponent(param[key]) + '&';
    });
    if (dataStr !== '') {
      dataStr = dataStr.substr(0, dataStr.lastIndexOf('&'));
    }
    xhr.open("POST", url, true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        var _response2 = xhr.responseText;
        if (xhr.status >= 200 && xhr.status < 300) {
          var httpStatus = xhr.statusText;
          callback(true, JSON.parse(_response2));
        } else {
          callback(false, _response2);
        }
      }
    };
    xhr.send(dataStr);
  };
  HttpUtil.postJson = function postJson(url, param, callback) {
    if (param === void 0) {
      param = {};
    }
    var xhr = new XMLHttpRequest();
    xhr.open('POST', url, true);
    xhr.setRequestHeader("Content-type", "application/json");
    xhr.send(JSON.stringify(param));
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        var json = xhr.responseText; //获取到服务端返回的数据
        if (xhr.status >= 200 && xhr.status < 300) {
          var _response3 = xhr.responseText;
          callback(true, JSON.parse(_response3));
        } else {
          callback(false, response);
        }
      }
    };
  };
  return HttpUtil;
}(); // 导出工具类
/**
 * 延迟多久没回复就返回False
 *
 * @type {number}
 * @memberof HttpUtil
 */
HttpUtil.TimeOut = 200;
module.exports = HttpUtil;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcdXRpbHNcXGh0dHBVdGlsLmpzIl0sIm5hbWVzIjpbIkh0dHBVdGlsIiwiZ2V0IiwidXJsIiwicGFyYW1zIiwiY2FsbGJhY2siLCJkYXRhU3RyIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJzdGF0dXMiLCJodHRwU3RhdHVzIiwic3RhdHVzVGV4dCIsInRpbWVvdXQiLCJUaW1lT3V0Iiwic2VuZCIsInBvc3QiLCJwYXJhbSIsIkpTT04iLCJwYXJzZSIsInBvc3RKc29uIiwic3RyaW5naWZ5IiwianNvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQU1BLFFBQVE7RUFBQSxTQUFBQSxTQUFBO0VBU1Y7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUklBLFFBQUEsQ0FTT0MsR0FBRyxHQUFWLFNBQUFBLElBQVdDLEdBQUcsRUFBRUMsTUFBTSxFQUFPQyxRQUFRLEVBQUU7SUFBQSxJQUF2QkQsTUFBTTtNQUFOQSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQUE7SUFDdkIsSUFBSUUsT0FBTyxHQUFHLEVBQUU7SUFDaEJDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDSixNQUFNLENBQUMsQ0FBQ0ssT0FBTyxDQUFDLFVBQUFDLEdBQUcsRUFBSTtNQUMvQkosT0FBTyxJQUFJSSxHQUFHLEdBQUcsR0FBRyxHQUFHQyxrQkFBa0IsQ0FBQ1AsTUFBTSxDQUFDTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUc7SUFDaEUsQ0FBQyxDQUFDO0lBQ0YsSUFBSUosT0FBTyxLQUFLLEVBQUUs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XHJcbiAgICAgKiDlu7bov5/lpJrkuYXmsqHlm57lpI3lsLHov5Tlm55GYWxzZVxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgSHR0cFV0aWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFRpbWVPdXQgPSAyMDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHRVTor7fmsYJcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcz17fV1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiBAbWVtYmVyb2YgSHR0cFV0aWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCh1cmwsIHBhcmFtcyA9IHt9LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBkYXRhU3RyID0gJyc7XHJcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGRhdGFTdHIgKz0ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSArICcmJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIGlmIChkYXRhU3RyICE9PSAnJykge1xyXG4gICAgICAgICAgICBkYXRhU3RyID0gZGF0YVN0ci5zdWJzdHIoMCwgZGF0YVN0ci5sYXN0SW5kZXhPZignJicpKTtcclxuICAgICAgICAgICAgdXJsID0gdXJsICsgJz8nICsgZGF0YVN0cjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIpO1xyXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGh0dHBTdGF0dXMgPSB4aHIuc3RhdHVzVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci50aW1lb3V0ID0gSHR0cFV0aWwuVGltZU91dDtcclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUE9TVOivt+axglxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW09e31dXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICogQG1lbWJlcm9mIEh0dHBVdGlsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwb3N0KHVybCwgcGFyYW0gPSB7fSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgbGV0IGRhdGFTdHIgPSAnJztcclxuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbSkuZm9yRWFjaChrZXkgPT4gZGF0YVN0ciArPSBrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1ba2V5XSkgKyAnJicpXHJcbiAgICAgICAgaWYgKGRhdGFTdHIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGRhdGFTdHIgPSBkYXRhU3RyLnN1YnN0cigwLCBkYXRhU3RyLmxhc3RJbmRleE9mKCcmJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgdXJsLCB0cnVlKTtcclxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcclxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBodHRwU3RhdHVzID0geGhyLnN0YXR1c1RleHRcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCBKU09OLnBhcnNlKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5zZW5kKGRhdGFTdHIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwb3N0SnNvbih1cmwsIHBhcmFtID0ge30sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcclxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLFwiYXBwbGljYXRpb24vanNvblwiKTtcclxuICAgICAgICB4aHIuc2VuZChKU09OLnN0cmluZ2lmeShwYXJhbSkpO1xyXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHhoci5yZXNwb25zZVRleHQ7Ly/ojrflj5bliLDmnI3liqHnq6/ov5Tlm57nmoTmlbDmja5cclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCBKU09OLnBhcnNlKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyDlr7zlh7rlt6XlhbfnsbtcclxubW9kdWxlLmV4cG9ydHMgPSBIdHRwVXRpbDsiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/Global.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3605deiEu1OKaROIrlGmbqV', 'Global');
// Scripts/Core/Global.js

"use strict";

var Global = cc.Class({
  "extends": cc.Component,
  statics: {
    InitGetMoneyId: 1,
    //初始获得金钱 是第几个等级

    CompanyCreateCost: 1000,
    //创办公司消耗1000手 1手= 100
    InitWareHouseCapcity: 100,
    //仓库初始容量
    AssetExplorRate: 5,
    //资产暴涨定位 5倍
    AssetExplorDownRate: 0.6,
    //资产暴涨定位 5倍
    AssetBurden: 30,
    //财富暴涨造成健康指数下降
    YearRecover: 1,
    //需要两年恢复健康
    DateSuccescRatio: 0.3,
    //约会到人的概率是 0.2
    LastEventAge: 27,
    //上一次事件发生的年龄
    AddCapacityCost: 10000,
    //扩充一个仓储容量 消耗的金钱
    BetWinRatio: 0.3,
    //赌博赢钱比例 先设定为 15%
    RetireInitAge: 70,
    //退休基础年龄
    HealthLine: 50,
    //健康值红线

    showStockProfit: false,
    //显示股票收益

    HasCompanyReputationAdd: 4,
    //拥有公司时候 会增加的名声 每年

    GoodsForeId: -1,
    //市场前瞻用的保留数据 Id
    //以下是可变动数据

    TempAdsBonus: 0,
    //临时广告加成
    TempAdsBetBonus: 0,
    TempAdsAssetBonus: 0,
    TempAdsStockBonus: 0,
    BetInitCost: 1000,
    //赌博初始花费
    DateInitCost: 1000,
    //约会的最低起价 今后每次递增 2 倍

    tmpRetireAgeBonues: 5,
    //临时广告退休年龄加成
    useRetireAds: false,
    //成就完成所需数据记录
    goToHospital: 0,
    //进入医院次数
    BankruptTimes: 0,
    //破产次数
    CreateCompanyTimes: 0,
    //创业次数

    tutorialGoodsId: -1,
    tutorialStep: -1,
    // -1 表示不在引导序列  采用 11 表示第一个大步骤 第一小步
    tutorialInDate: false,
    tutorialInBus: false,
    HealthSubAge: 40,
    //多少岁开始健康随年龄下降
    //健康状态
    HpStateA: 80,
    HpStateB: 55,
    HpStateC: 54,
    //赌博赢钱的概率 累加形式
    BetWinNullRatio: 0.69,
    BetWinThreeRatio: 0.85,
    BetWinFourRatio: 0.95,
    BetWinFiveRatio: 1.0,
    //是否激活了什么
    hasActiveGuShen: false,
    hasActiveCaiShen: false,
    hasActiveDuShen: false,
    hasActiveAiShen: false,
    InitChangeData: function InitChangeData() {
      this.GoodsForeId = -1;
      this.tutorialGoodsId = -1;
      this.tutorialInBus = false;
      this.tutorialInDate = false;
      this.tutorialStep = -1;
      this.BetInitCost = 1000; //赌博初始花费
      this.DateInitCost = 1000; //约会的最低起价 今后每次递增 2 倍

      this.showStockProfit = false;
      this.useRetireAds = false, this.tmpRetireAgeBonues = 5;
      this.BetWinRatio = 0.25;
      this.TempAdsBonus = 0;
      this.TempAdsStockBonus = 0;
      this.TempAdsAssetBonus = 0;
      this.TempAdsBetBonus = 0;

      //成就完成所需数据记录
      this.goToHospital = 0; //进入医院次数
      this.BankruptTimes = 0; //破产次数
      this.CreateCompanyTimes = 0; //创业次数

      //之前激活
      this.hasActiveAiShen = false;
      this.hasActiveDuShen = false;
      this.hasActiveCaiShen = false;
      this.hasActiveGuShen = false;
    },
    InitEventHappenAge: function InitEventHappenAge() {
      this.LastEventAge = 25 + Math.floor(Math.random() * 6);
    },
    //生成一个随机整数  在 index1 - index2之间
    SpawnSeedBetweenTwoNum: function SpawnSeedBetweenTwoNum(index1, index2) {
      var seed = index1 + Math.floor(Math.random() * (index2 - index1 + 1));
      return seed;
    },
    getTranslation: function getTranslation(desId) {
      for (var prop in cc.director.NoticeText) {
        if (prop.toString() == desId) {
          return cc.director.NoticeText[prop];
        }
      }
      var des = "翻译字段null";
      return des;
    },
    FormatNum: function FormatNum(num) {
      num = num + '';
      var str = "";
      for (var i = num.length - 1, j = 1; i >= 0; i--, j++) {
        if (j % 3 == 0 && i != 0) {
          //每隔三位加逗号，过滤正好在第一个数字的情况  
          str += num[i] + ","; //加千分位逗号  
          continue;
        }
        str += num[i]; //倒着累加数字
      }

      var out = str.split('').reverse().join(""); //字符串=>数组=>反转=>字符串
      if (out[0] == ',') return out.splice(0, 1);
      return out;
    }
  }
});
module.exports = Global;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcR2xvYmFsLmpzIl0sIm5hbWVzIjpbIkdsb2JhbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJzdGF0aWNzIiwiSW5pdEdldE1vbmV5SWQiLCJDb21wYW55Q3JlYXRlQ29zdCIsIkluaXRXYXJlSG91c2VDYXBjaXR5IiwiQXNzZXRFeHBsb3JSYXRlIiwiQXNzZXRFeHBsb3JEb3duUmF0ZSIsIkFzc2V0QnVyZGVuIiwiWWVhclJlY292ZXIiLCJEYXRlU3VjY2VzY1JhdGlvIiwiTGFzdEV2ZW50QWdlIiwiQWRkQ2FwYWNpdHlDb3N0IiwiQmV0V2luUmF0aW8iLCJSZXRpcmVJbml0QWdlIiwiSGVhbHRoTGluZSIsInNob3dTdG9ja1Byb2ZpdCIsIkhhc0NvbXBhbnlSZXB1dGF0aW9uQWRkIiwiR29vZHNGb3JlSWQiLCJUZW1wQWRzQm9udXMiLCJUZW1wQWRzQmV0Qm9udXMiLCJUZW1wQWRzQXNzZXRCb251cyIsIlRlbXBBZHNTdG9ja0JvbnVzIiwiQmV0SW5pdENvc3QiLCJEYXRlSW5pdENvc3QiLCJ0bXBSZXRpcmVBZ2VCb251ZXMiLCJ1c2VSZXRpcmVBZHMiLCJnb1RvSG9zcGl0YWwiLCJCYW5rcnVwdFRpbWVzIiwiQ3JlYXRlQ29tcGFueVRpbWVzIiwidHV0b3JpYWxHb29kc0lkIiwidHV0b3JpYWxTdGVwIiwidHV0b3JpYWxJbkRhdGUiLCJ0dXRvcmlhbEluQnVzIiwiSGVhbHRoU3ViQWdlIiwiSHBTdGF0ZUEiLCJIcFN0YXRlQiIsIkhwU3RhdGVDIiwiQmV0V2luTnVsbFJhdGlvIiwiQmV0V2luVGhyZWVSYXRpbyIsIkJldFdpbkZvdXJSYXRpbyIsIkJldFdpbkZpdmVSYXRpbyIsImhhc0FjdGl2ZUd1U2hlbiIsImhhc0FjdGl2ZUNhaVNoZW4iLCJoYXNBY3RpdmVEdVNoZW4iLCJoYXNBY3RpdmVBaVNoZW4iLCJJbml0Q2hhbmdlRGF0YSIsIkluaXRFdmVudEhhcHBlbkFnZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIlNwYXduU2VlZEJldHdlZW5Ud29OdW0iLCJpbmRleDEiLCJpbmRleDIiLCJzZWVkIiwiZ2V0VHJhbnNsYXRpb24iLCJkZXNJZCIsInByb3AiLCJkaXJlY3RvciIsIk5vdGljZVRleHQiLCJ0b1N0cmluZyIsImRlcyIsIkZvcm1hdE51bSIsIm51bSIsInN0ciIsImkiLCJsZW5ndGgiLCJqIiwib3V0Iiwic3BsaXQiLCJyZXZlcnNlIiwiam9pbiIsInNwbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsTUFBTSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNsQixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLE9BQU8sRUFBRTtJQUNMQyxjQUFjLEVBQUMsQ0FBQztJQUFDOztJQUVwQkMsaUJBQWlCLEVBQUMsSUFBSTtJQUFDO0lBQ3ZCQyxvQkFBb0IsRUFBQyxHQUFHO0lBQUM7SUFDekJDLGVBQWUsRUFBQyxDQUFDO0lBQUM7SUFDZkMsbUJBQW1CLEVBQUMsR0FBRztJQUFDO0lBQzNCQyxXQUFXLEVBQUMsRUFBRTtJQUFFO0lBQ2hCQyxXQUFXLEVBQUMsQ0FBQztJQUFFO0lBQ2ZDLGdCQUFnQixFQUFDLEdBQUc7SUFBRTtJQUNuQkMsWUFBWSxFQUFDLEVBQUU7SUFBQztJQUNoQkMsZUFBZSxFQUFDLEtBQUs7SUFBQztJQUN6QkMsV0FBVyxFQUFDLEdBQUc7SUFBQztJQUNiQyxhQUFhLEVBQUMsRUFBRTtJQUFDO0lBQ2pCQyxVQUFVLEVBQUMsRUFBRTtJQUFDOztJQUVkQyxlQUFlLEVBQUMsS0FBSztJQUFDOztJQUV0QkMsdUJBQXVCLEVBQUMsQ0FBQztJQUFFOztJQUUzQkMsV0FBVyxFQUFDLENBQUMsQ0FBQztJQUFFO0lBQ2hCOztJQUVBQyxZQUFZLEVBQUMsQ0FBQztJQUFFO0lBQ2hCQyxlQUFlLEVBQUMsQ0FBQztJQUNqQkMsaUJBQWlCLEVBQUMsQ0FBQztJQUNuQkMsaUJBQWlCLEVBQUMsQ0FBQztJQUVu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TUFBTSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBHbG9iYWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgc3RhdGljczoge1xyXG4gICAgICAgIEluaXRHZXRNb25leUlkOjEsLy/liJ3lp4vojrflvpfph5HpkrEg5piv56ys5Yeg5Liq562J57qnXHJcblxyXG4gICAgXHRDb21wYW55Q3JlYXRlQ29zdDoxMDAwLC8v5Yib5Yqe5YWs5Y+45raI6ICXMTAwMOaJiyAx5omLPSAxMDBcclxuICAgIFx0SW5pdFdhcmVIb3VzZUNhcGNpdHk6MTAwLC8v5LuT5bqT5Yid5aeL5a656YePXHJcbiAgICBcdEFzc2V0RXhwbG9yUmF0ZTo1LC8v6LWE5Lqn5pq05rao5a6a5L2NIDXlgI1cclxuICAgICAgICBBc3NldEV4cGxvckRvd25SYXRlOjAuNiwvL+i1hOS6p+aatOa2qOWumuS9jSA15YCNXHJcbiAgICBcdEFzc2V0QnVyZGVuOjMwLCAvL+i0ouWvjOaatOa2qOmAoOaIkOWBpeW6t+aMh+aVsOS4i+mZjVxyXG4gICAgXHRZZWFyUmVjb3ZlcjoxLCAvL+mcgOimgeS4pOW5tOaBouWkjeWBpeW6t1xyXG4gICAgXHREYXRlU3VjY2VzY1JhdGlvOjAuMywgLy/nuqbkvJrliLDkurrnmoTmpoLnjofmmK8gMC4yXHJcbiAgICAgICAgTGFzdEV2ZW50QWdlOjI3LC8v5LiK5LiA5qyh5LqL5Lu25Y+R55Sf55qE5bm06b6EXHJcbiAgICAgICAgQWRkQ2FwYWNpdHlDb3N0OjEwMDAwLC8v5omp5YWF5LiA5Liq5LuT5YKo5a656YePIOa2iOiAl+eahOmHkemSsVxyXG4gICAgXHRCZXRXaW5SYXRpbzowLjMsLy/otYzljZrotaLpkrHmr5Tkvosg5YWI6K6+5a6a5Li6IDE1JVxyXG4gICAgICAgIFJldGlyZUluaXRBZ2U6NzAsLy/pgIDkvJHln7rnoYDlubTpvoRcclxuICAgICAgICBIZWFsdGhMaW5lOjUwLC8v5YGl5bq35YC857qi57q/XHJcblxyXG4gICAgICAgIHNob3dTdG9ja1Byb2ZpdDpmYWxzZSwvL+aYvuekuuiCoeelqOaUtuebilxyXG5cclxuICAgICAgICBIYXNDb21wYW55UmVwdXRhdGlvbkFkZDo0LCAvL+aLpeacieWFrOWPuOaXtuWAmSDkvJrlop7liqDnmoTlkI3lo7Ag5q+P5bm0XHJcblxyXG4gICAgICAgIEdvb2RzRm9yZUlkOi0xLCAvL+W4guWcuuWJjeeeu+eUqOeahOS/neeVmeaVsOaNriBJZFxyXG4gICAgICAgIC8v5Lul5LiL5piv5Y+v5Y+Y5Yqo5pWw5o2uXHJcblxyXG4gICAgICAgIFRlbXBBZHNCb251czowLCAvL+S4tOaXtuW5v+WRiuWKoOaIkFxyXG4gICAgICAgIFRlbXBBZHNCZXRCb251czowLFxyXG4gICAgICAgIFRlbXBBZHNBc3NldEJvbnVzOjAsXHJcbiAgICAgICAgVGVtcEFkc1N0b2NrQm9udXM6MCxcclxuXHJcbiAgICAgICAgQmV0SW5pdENvc3Q6MTAwMCwvL+i1jOWNmuWIneWni+iKsei0uVxyXG4gICAgICAgIERhdGVJbml0Q29zdDoxMDAwLCAvL+e6puS8mueahOacgOS9jui1t+S7tyDku4rlkI7mr4/mrKHpgJLlop4gMiDlgI1cclxuXHJcbiAgICAgICAgdG1wUmV0aXJlQWdlQm9udWVzOjUsLy/kuLTml7blub/lkYrpgIDkvJHlubTpvoTliqDmiJBcclxuICAgICAgICB1c2VSZXRpcmVBZHM6ZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/miJDlsLHlrozmiJDmiYDpnIDmlbDmja7orrDlvZVcclxuICAgICAgICBnb1RvSG9zcGl0YWw6MCwgLy/ov5vlhaXljLvpmaLmrKHmlbBcclxuICAgICAgICBCYW5rcnVwdFRpbWVzOjAsIC8v56C05Lqn5qyh5pWwXHJcbiAgICAgICAgQ3JlYXRlQ29tcGFueVRpbWVzOjAsLy/liJvkuJrmrKHmlbBcclxuXHJcbiAgICAgICAgdHV0b3JpYWxHb29kc0lkOi0xLFxyXG4gICAgICAgIHR1dG9yaWFsU3RlcDotMSwvLyAtMSDooajnpLrkuI3lnKjlvJXlr7zluo/liJcgIOmHh+eUqCAxMSDooajnpLrnrKzkuIDkuKrlpKfmraXpqqQg56ys5LiA5bCP5q2lXHJcbiAgICAgICAgdHV0b3JpYWxJbkRhdGU6ZmFsc2UsXHJcbiAgICAgICAgdHV0b3JpYWxJbkJ1czpmYWxzZSxcclxuXHJcbiAgICAgICAgSGVhbHRoU3ViQWdlOjQwLCAvL+WkmuWwkeWygeW8gOWni+WBpeW6t+maj+W5tOm+hOS4i+mZjVxyXG4gICAgICAgIC8v5YGl5bq354q25oCBXHJcbiAgICAgICAgSHBTdGF0ZUE6ODAsXHJcbiAgICAgICAgSHBTdGF0ZUI6NTUsXHJcbiAgICAgICAgSHBTdGF0ZUM6NTQsXHJcblxyXG4gICAgICAgIC8v6LWM5Y2a6LWi6ZKx55qE5qaC546HIOe0r+WKoOW9ouW8j1xyXG4gICAgICAgIEJldFdpbk51bGxSYXRpbzowLjY5LFxyXG4gICAgICAgIEJldFdpblRocmVlUmF0aW86MC44NSxcclxuICAgICAgICBCZXRXaW5Gb3VyUmF0aW86MC45NSxcclxuICAgICAgICBCZXRXaW5GaXZlUmF0aW86MS4wLFxyXG5cclxuXHJcbiAgICAgICAgLy/mmK/lkKbmv4DmtLvkuobku4DkuYhcclxuICAgICAgICBoYXNBY3RpdmVHdVNoZW46ZmFsc2UsXHJcbiAgICAgICAgaGFzQWN0aXZlQ2FpU2hlbjpmYWxzZSxcclxuICAgICAgICBoYXNBY3RpdmVEdVNoZW46ZmFsc2UsXHJcbiAgICAgICAgaGFzQWN0aXZlQWlTaGVuOmZhbHNlLFxyXG5cclxuICAgICAgICBJbml0Q2hhbmdlRGF0YTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLkdvb2RzRm9yZUlkID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxHb29kc0lkID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxJbkJ1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnR1dG9yaWFsSW5EYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxTdGVwID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuQmV0SW5pdENvc3QgPSAxMDAwOy8v6LWM5Y2a5Yid5aeL6Iqx6LS5XHJcbiAgICAgICAgICAgIHRoaXMuRGF0ZUluaXRDb3N0ID0gMTAwMDsgLy/nuqbkvJrnmoTmnIDkvY7otbfku7cg5LuK5ZCO5q+P5qyh6YCS5aKeIDIg5YCNXHJcblxyXG4gICAgICAgICAgICB0aGlzLnNob3dTdG9ja1Byb2ZpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnVzZVJldGlyZUFkcyA9IGZhbHNlLFxyXG4gICAgICAgICAgICB0aGlzLnRtcFJldGlyZUFnZUJvbnVlcyA9IDU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLkJldFdpblJhdGlvID0gMC4yNTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuVGVtcEFkc0JvbnVzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5UZW1wQWRzU3RvY2tCb251cyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuVGVtcEFkc0Fzc2V0Qm9udXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLlRlbXBBZHNCZXRCb251cyA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL+aIkOWwseWujOaIkOaJgOmcgOaVsOaNruiusOW9lVxyXG4gICAgICAgICAgICB0aGlzLmdvVG9Ib3NwaXRhbCA9IDA7IC8v6L+b5YWl5Yy76Zmi5qyh5pWwXHJcbiAgICAgICAgICAgIHRoaXMuQmFua3J1cHRUaW1lcyA9IDA7IC8v56C05Lqn5qyh5pWwXHJcbiAgICAgICAgICAgIHRoaXMuQ3JlYXRlQ29tcGFueVRpbWVzID0gMDsvL+WIm+S4muasoeaVsFxyXG5cclxuICAgICAgICAgICAgLy/kuYvliY3mv4DmtLtcclxuICAgICAgICAgICAgdGhpcy5oYXNBY3RpdmVBaVNoZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYXNBY3RpdmVEdVNoZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYXNBY3RpdmVDYWlTaGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzQWN0aXZlR3VTaGVuID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgSW5pdEV2ZW50SGFwcGVuQWdlOmZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuTGFzdEV2ZW50QWdlID0gMjUgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL+eUn+aIkOS4gOS4qumaj+acuuaVtOaVsCAg5ZyoIGluZGV4MSAtIGluZGV4MuS5i+mXtFxyXG4gICAgICAgIFNwYXduU2VlZEJldHdlZW5Ud29OdW06ZnVuY3Rpb24oaW5kZXgxLCBpbmRleDIpe1xyXG4gICAgICAgICAgICB2YXIgc2VlZCA9IGluZGV4MSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpbmRleDIgLSBpbmRleDEgKyAxKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWVkO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBnZXRUcmFuc2xhdGlvbjpmdW5jdGlvbihkZXNJZCl7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY2MuZGlyZWN0b3IuTm90aWNlVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYocHJvcC50b1N0cmluZygpID09IGRlc0lkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYy5kaXJlY3Rvci5Ob3RpY2VUZXh0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkZXMgPSBcIue/u+ivkeWtl+autW51bGxcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGRlcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBGb3JtYXROdW06ZnVuY3Rpb24obnVtKXtcclxuICAgICAgICAgICAgbnVtID0gbnVtICsnJztcclxuICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT1udW0ubGVuZ3RoLSAxLGo9MTtpPj0wO2ktLSxqKyspeyAgXHJcbiAgICAgICAgICAgICAgICBpZihqJTM9PTAgJiYgaSE9MCl7Ly/mr4/pmpTkuInkvY3liqDpgJflj7fvvIzov4fmu6TmraPlpb3lnKjnrKzkuIDkuKrmlbDlrZfnmoTmg4XlhrUgIFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cis9bnVtW2ldK1wiLFwiOy8v5Yqg5Y2D5YiG5L2N6YCX5Y+3ICBcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgIFxyXG4gICAgICAgICAgICAgICAgfSAgXHJcbiAgICAgICAgICAgICAgICBzdHIrPW51bVtpXTsvL+WAkuedgOe0r+WKoOaVsOWtl1xyXG4gICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgdmFyIG91dCA9IHN0ci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oXCJcIik7Ly/lrZfnrKbkuLI9PuaVsOe7hD0+5Y+N6L2sPT7lrZfnrKbkuLJcclxuICAgICAgICAgICAgaWYob3V0WzBdID09ICcsJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuc3BsaWNlKDAsMSlcclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gR2xvYmFsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/ItemType.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1d410+N2SFPRoQ3E06qQDFC', 'ItemType');
// Scripts/Core/ItemType.js

"use strict";

var ItemType = cc.Enum({
  //现金100  货物101 技能102 公司103 房子104 汽车105 伴侣106
  Cash: 100,
  Goods: 101,
  Skill: 102,
  Company: 103,
  House: 104,
  Car: 105,
  Mate: 106,
  Achieve: 107,
  //成就类型
  EventData: 108 //事件类型
});

module.exports = ItemType;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcSXRlbVR5cGUuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJjYyIsIkVudW0iLCJDYXNoIiwiR29vZHMiLCJTa2lsbCIsIkNvbXBhbnkiLCJIb3VzZSIsIkNhciIsIk1hdGUiLCJBY2hpZXZlIiwiRXZlbnREYXRhIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxRQUFRLEdBQUdDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDO0VBQ3RCO0VBQ0dDLElBQUksRUFBQyxHQUFHO0VBQ1JDLEtBQUssRUFBQyxHQUFHO0VBQ1RDLEtBQUssRUFBQyxHQUFHO0VBQ1RDLE9BQU8sRUFBQyxHQUFHO0VBQ1hDLEtBQUssRUFBQyxHQUFHO0VBQ1RDLEdBQUcsRUFBQyxHQUFHO0VBQ1BDLElBQUksRUFBQyxHQUFHO0VBQ1JDLE9BQU8sRUFBQyxHQUFHO0VBQUM7RUFDWkMsU0FBUyxFQUFDLEdBQUcsQ0FBQztBQUVsQixDQUFDLENBQUM7O0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHYixRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIEl0ZW1UeXBlID0gY2MuRW51bSh7XHJcblx0Ly/njrDph5ExMDAgIOi0p+eJqTEwMSDmioDog70xMDIg5YWs5Y+4MTAzIOaIv+WtkDEwNCDmsb3ovaYxMDUg5Ly05L6jMTA2XHJcbiAgICBDYXNoOjEwMCxcclxuICAgIEdvb2RzOjEwMSxcclxuICAgIFNraWxsOjEwMixcclxuICAgIENvbXBhbnk6MTAzLFxyXG4gICAgSG91c2U6MTA0LFxyXG4gICAgQ2FyOjEwNSxcclxuICAgIE1hdGU6MTA2LFxyXG4gICAgQWNoaWV2ZToxMDcsLy/miJDlsLHnsbvlnotcclxuICAgIEV2ZW50RGF0YToxMDgsLy/kuovku7bnsbvlnotcclxuICAgIFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBJdGVtVHlwZTsiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/MateUnLockType.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3aeadbC8Q9Ke6gBVyyYRv+I', 'MateUnLockType');
// Scripts/Core/MateUnLockType.js

"use strict";

//伴侣解锁方式
var MateUnLockType = cc.Enum({
  NULL: 0,
  //直接初始解锁
  InHospital: 1,
  //住院了
  ToDate: 2 //去约会
});

module.exports = MateUnLockType;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcTWF0ZVVuTG9ja1R5cGUuanMiXSwibmFtZXMiOlsiTWF0ZVVuTG9ja1R5cGUiLCJjYyIsIkVudW0iLCJOVUxMIiwiSW5Ib3NwaXRhbCIsIlRvRGF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFJQSxjQUFjLEdBQUdDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDO0VBQ3pCQyxJQUFJLEVBQUMsQ0FBQztFQUFFO0VBQ1JDLFVBQVUsRUFBQyxDQUFDO0VBQUU7RUFDZEMsTUFBTSxFQUFDLENBQUMsQ0FBRTtBQUNkLENBQUMsQ0FBQzs7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUdQLGNBQWMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8v5Ly05L6j6Kej6ZSB5pa55byPXHJcbnZhciBNYXRlVW5Mb2NrVHlwZSA9IGNjLkVudW0oe1xyXG4gICAgTlVMTDowLCAvL+ebtOaOpeWIneWni+ino+mUgVxyXG4gICAgSW5Ib3NwaXRhbDoxLCAvL+S9j+mZouS6hlxyXG4gICAgVG9EYXRlOjIsIC8v5Y6757qm5LyaXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVVbkxvY2tUeXBlO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/MateBonusType.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'cd6d8Yz/BNElpLWLto0yi8D', 'MateBonusType');
// Scripts/Core/MateBonusType.js

"use strict";

var MateBonusType = cc.Enum({
  NULL: 0,
  HP: 1,
  Reputation: 2,
  Money: 3,
  WareHouseCapcity: 4,
  Treat: 5
});
module.exports = MateBonusType;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcTWF0ZUJvbnVzVHlwZS5qcyJdLCJuYW1lcyI6WyJNYXRlQm9udXNUeXBlIiwiY2MiLCJFbnVtIiwiTlVMTCIsIkhQIiwiUmVwdXRhdGlvbiIsIk1vbmV5IiwiV2FyZUhvdXNlQ2FwY2l0eSIsIlRyZWF0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxhQUFhLEdBQUdDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDO0VBQ3hCQyxJQUFJLEVBQUMsQ0FBQztFQUNOQyxFQUFFLEVBQUMsQ0FBQztFQUNKQyxVQUFVLEVBQUMsQ0FBQztFQUNaQyxLQUFLLEVBQUMsQ0FBQztFQUNQQyxnQkFBZ0IsRUFBQyxDQUFDO0VBQ2xCQyxLQUFLLEVBQUM7QUFDVixDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUdWLGFBQWEiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBNYXRlQm9udXNUeXBlID0gY2MuRW51bSh7XHJcbiAgICBOVUxMOjAsXHJcbiAgICBIUDoxLFxyXG4gICAgUmVwdXRhdGlvbjoyLFxyXG4gICAgTW9uZXk6MyxcclxuICAgIFdhcmVIb3VzZUNhcGNpdHk6NCxcclxuICAgIFRyZWF0OjUsXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVCb251c1R5cGU7Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/MateGetType.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c875fqeMHlNkZoUD58hrwl0', 'MateGetType');
// Scripts/Core/MateGetType.js

"use strict";

//伴侣解锁条件
var MateGetType = cc.Enum({
  Money: 1,
  //花钱                  1111
  House: 2,
  //有房
  Car: 3,
  //有车
  Asset: 4,
  //资产要求  会对应一定数额   1111
  Reputation: 5,
  //名声达到数值 对应数值
  HP: 6,
  //健康值达到多少
  Company: 7 //是否有一家公司
});

module.exports = MateGetType;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcTWF0ZUdldFR5cGUuanMiXSwibmFtZXMiOlsiTWF0ZUdldFR5cGUiLCJjYyIsIkVudW0iLCJNb25leSIsIkhvdXNlIiwiQ2FyIiwiQXNzZXQiLCJSZXB1dGF0aW9uIiwiSFAiLCJDb21wYW55IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLElBQUlBLFdBQVcsR0FBR0MsRUFBRSxDQUFDQyxJQUFJLENBQUM7RUFDdEJDLEtBQUssRUFBQyxDQUFDO0VBQUU7RUFDVEMsS0FBSyxFQUFDLENBQUM7RUFBRTtFQUNUQyxHQUFHLEVBQUMsQ0FBQztFQUFDO0VBQ05DLEtBQUssRUFBQyxDQUFDO0VBQUM7RUFDUkMsVUFBVSxFQUFDLENBQUM7RUFBQztFQUNiQyxFQUFFLEVBQUMsQ0FBQztFQUFFO0VBQ05DLE9BQU8sRUFBQyxDQUFDLENBQUU7QUFDZixDQUFDLENBQUM7O0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWCxXQUFXIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyIvL+S8tOS+o+ino+mUgeadoeS7tlxyXG52YXIgTWF0ZUdldFR5cGUgPSBjYy5FbnVtKHtcclxuICAgIE1vbmV5OjEsIC8v6Iqx6ZKxICAgICAgICAgICAgICAgICAgMTExMVxyXG4gICAgSG91c2U6MiwgLy/mnInmiL9cclxuICAgIENhcjozLC8v5pyJ6L2mXHJcbiAgICBBc3NldDo0LC8v6LWE5Lqn6KaB5rGCICDkvJrlr7nlupTkuIDlrprmlbDpop0gICAxMTExXHJcbiAgICBSZXB1dGF0aW9uOjUsLy/lkI3lo7Dovr7liLDmlbDlgLwg5a+55bqU5pWw5YC8XHJcbiAgICBIUDo2LCAvL+WBpeW6t+WAvOi+vuWIsOWkmuWwkVxyXG4gICAgQ29tcGFueTo3LCAvL+aYr+WQpuacieS4gOWutuWFrOWPuFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlR2V0VHlwZTsiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/RewardType.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '25306VAhAxP447Ff2c0eJ0v', 'RewardType');
// Scripts/Core/RewardType.js

"use strict";

//事件奖励类型  消耗类型
//无1000 金钱  1001  健康1002  名声1003 
//货物1004 车子1005 房子1006 股票1007数量
//1008 股票价格
var RewardType = cc.Enum({
  NULL: 1000,
  Cash: 1001,
  HP: 1002,
  Reputation: 1003,
  Goods: 1004,
  Car: 1005,
  House: 1006,
  Stock: 1007,
  StockPrice: 1008
});
module.exports = RewardType;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcUmV3YXJkVHlwZS5qcyJdLCJuYW1lcyI6WyJSZXdhcmRUeXBlIiwiY2MiLCJFbnVtIiwiTlVMTCIsIkNhc2giLCJIUCIsIlJlcHV0YXRpb24iLCJHb29kcyIsIkNhciIsIkhvdXNlIiwiU3RvY2siLCJTdG9ja1ByaWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlBLFVBQVUsR0FBR0MsRUFBRSxDQUFDQyxJQUFJLENBQUM7RUFDckJDLElBQUksRUFBQyxJQUFJO0VBQ1RDLElBQUksRUFBQyxJQUFJO0VBQ1RDLEVBQUUsRUFBQyxJQUFJO0VBQ1BDLFVBQVUsRUFBQyxJQUFJO0VBQ2ZDLEtBQUssRUFBQyxJQUFJO0VBQ1ZDLEdBQUcsRUFBQyxJQUFJO0VBQ1JDLEtBQUssRUFBQyxJQUFJO0VBQ1ZDLEtBQUssRUFBQyxJQUFJO0VBQ1ZDLFVBQVUsRUFBQztBQUNmLENBQUMsQ0FBQztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR2IsVUFBVSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLy/kuovku7blpZblirHnsbvlnosgIOa2iOiAl+exu+Wei1xyXG4vL+aXoDEwMDAg6YeR6ZKxICAxMDAxICDlgaXlurcxMDAyICDlkI3lo7AxMDAzIFxyXG4vL+i0p+eJqTEwMDQg6L2m5a2QMTAwNSDmiL/lrZAxMDA2IOiCoeelqDEwMDfmlbDph49cclxuLy8xMDA4IOiCoeelqOS7t+agvFxyXG52YXIgUmV3YXJkVHlwZSA9IGNjLkVudW0oe1xyXG4gICAgTlVMTDoxMDAwLFxyXG4gICAgQ2FzaDoxMDAxLFxyXG4gICAgSFA6MTAwMixcclxuICAgIFJlcHV0YXRpb246MTAwMyxcclxuICAgIEdvb2RzOjEwMDQsXHJcbiAgICBDYXI6MTAwNSxcclxuICAgIEhvdXNlOjEwMDYsXHJcbiAgICBTdG9jazoxMDA3LFxyXG4gICAgU3RvY2tQcmljZToxMDA4LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBSZXdhcmRUeXBlO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/SkillType.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '78ab2zMYnZOvIXB1cO+StpL', 'SkillType');
// Scripts/Core/SkillType.js

"use strict";

var SkillType = cc.Enum({
  WLNS: 1,
  //仓储                  1111
  THY: 2,
  //约会成功概率
  XSJY: 3,
  //每年获得一定数额金钱
  FGZJ: 4,
  //初始进入社会金钱增加   1111
  GSGL: 5,
  //增加公司收益率
  TPGS: 6,
  //公司股价上涨概率增加
  JZCC: 7,
  //结算时技能点获得增加
  MLSZ: 8,
  //约会花费降低
  DS: 9,
  //赌场赢钱概率怎加
  LDYZ: 10,
  //退休年限增加          1111
  NSCM: 11,
  //增加初始名声          1111
  QCDR: 12,
  //购买汽车价格降低
  HYLL: 13,
  //好运连连
  DCZJ: 14 //购 房价格降低
});

module.exports = SkillType;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcU2tpbGxUeXBlLmpzIl0sIm5hbWVzIjpbIlNraWxsVHlwZSIsImNjIiwiRW51bSIsIldMTlMiLCJUSFkiLCJYU0pZIiwiRkdaSiIsIkdTR0wiLCJUUEdTIiwiSlpDQyIsIk1MU1oiLCJEUyIsIkxEWVoiLCJOU0NNIiwiUUNEUiIsIkhZTEwiLCJEQ1pKIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxTQUFTLEdBQUdDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDO0VBQ3BCQyxJQUFJLEVBQUMsQ0FBQztFQUFFO0VBQ1JDLEdBQUcsRUFBQyxDQUFDO0VBQUU7RUFDUEMsSUFBSSxFQUFDLENBQUM7RUFBQztFQUNQQyxJQUFJLEVBQUMsQ0FBQztFQUFDO0VBQ1BDLElBQUksRUFBQyxDQUFDO0VBQUM7RUFDUEMsSUFBSSxFQUFDLENBQUM7RUFBQztFQUNQQyxJQUFJLEVBQUMsQ0FBQztFQUFDO0VBQ1BDLElBQUksRUFBQyxDQUFDO0VBQUM7RUFDUEMsRUFBRSxFQUFDLENBQUM7RUFBQztFQUNMQyxJQUFJLEVBQUMsRUFBRTtFQUFDO0VBQ1JDLElBQUksRUFBQyxFQUFFO0VBQUM7RUFDUkMsSUFBSSxFQUFDLEVBQUU7RUFBQztFQUNSQyxJQUFJLEVBQUMsRUFBRTtFQUFDO0VBQ1JDLElBQUksRUFBQyxFQUFFLENBQUM7QUFDWixDQUFDLENBQUM7O0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHbEIsU0FBUyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBTa2lsbFR5cGUgPSBjYy5FbnVtKHtcclxuICAgIFdMTlM6MSwgLy/ku5PlgqggICAgICAgICAgICAgICAgICAxMTExXHJcbiAgICBUSFk6MiwgLy/nuqbkvJrmiJDlip/mpoLnjodcclxuICAgIFhTSlk6MywvL+avj+W5tOiOt+W+l+S4gOWumuaVsOminemHkemSsVxyXG4gICAgRkdaSjo0LC8v5Yid5aeL6L+b5YWl56S+5Lya6YeR6ZKx5aKe5YqgICAgMTExMVxyXG4gICAgR1NHTDo1LC8v5aKe5Yqg5YWs5Y+45pS255uK546HXHJcbiAgICBUUEdTOjYsLy/lhazlj7jogqHku7fkuIrmtqjmpoLnjoflop7liqBcclxuICAgIEpaQ0M6NywvL+e7k+eul+aXtuaKgOiDveeCueiOt+W+l+WinuWKoFxyXG4gICAgTUxTWjo4LC8v57qm5Lya6Iqx6LS56ZmN5L2OXHJcbiAgICBEUzo5LC8v6LWM5Zy66LWi6ZKx5qaC546H5oCO5YqgXHJcbiAgICBMRFlaOjEwLC8v6YCA5LyR5bm06ZmQ5aKe5YqgICAgICAgICAgIDExMTFcclxuICAgIE5TQ006MTEsLy/lop7liqDliJ3lp4vlkI3lo7AgICAgICAgICAgMTExMVxyXG4gICAgUUNEUjoxMiwvL+i0reS5sOaxvei9puS7t+agvOmZjeS9jlxyXG4gICAgSFlMTDoxMywvL+Wlvei/kOi/nui/nlxyXG4gICAgRENaSjoxNCwvL+i0rSDmiL/ku7fmoLzpmY3kvY5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gU2tpbGxUeXBlO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/NoticeText.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '944dc7LVZhDmJbOmJPAPdho', 'NoticeText');
// Scripts/Core/NoticeText.js

"use strict";

var _cc$director$NoticeTe;
cc.director.NoticeText = (_cc$director$NoticeTe = {
  "date_1": "你怎么现在才来？我耗尽了整个青春一直在这里等你。",
  "date_2": "我还是你心里的沈佳宜吗？",
  "date_3": "最好的感觉就是,当我望向你时,你也正好注视着我。",
  "date_4": "身高:168cm 体重:49kg 胸围:36E，我想找男朋友。",
  "date_5": "白衣天使是我，制服女郎也是我，约吗？",
  "date_6": "T台上再多的光鲜亮丽，都抵不上你眼里的皓月明空。",
  "date_7": "面包我有，你给我爱情就好。",
  "date_8": "从小伴你长大，我是你永远可以依靠的港湾。",
  "date_9": "只想默默喜欢你，守护你…",
  "date_10": "多年以后，我还在你身旁，酒是烈的，风是暖的。",
  "date_11": "我就是你可爱的小奶狗，每天摇着尾巴对你说擦浪嘿呦~",
  "date_12": "我能为你的每个过错都做出完美的辩护。",
  "date_13": "你若向前，我就是你的前锋，为你踢走一切阻碍。",
  "date_14": "我要让全世界知道，这个鱼塘被你承包了。",
  //进入社会时金钱的
  "Cash_1": "出身寒门,进入社会只怀揣着打工的<color=#e77122>20000</c>元闯荡江湖",
  "Cash_2": "中产家庭,父母有担当,给你<color=#e77122>50000</c>元作为创业启动基金",
  "Cash_3": "富裕家庭，家族为了你能早日闯出一片天地，出资<color=#e77122>100000</c>元",
  "MateHas_1": "朝朝暮暮，柴米油盐，才是婚姻",
  "MateHas_2": "亲爱的, 平平淡淡也是真啊",
  "MarryTxt_1": "祈愿执子之手，与子偕老。",
  "MarryTxt_2": "你就是我的小心心,挂在那天上放光明",
  "Disvorce_1": "婚姻不易,且行且珍惜，我愿意再给你一次机会重新考虑。",
  "Disvorce_2": "强扭的瓜也不甜，要离就离吧。以后我们各自安好。",
  "Disvorce_3": "我爱你不后悔，也尊重故事结尾。",
  "Disvorce_4": "分手应该体面，谁都不要说抱歉。",
  "Disvorce_5": "离开也要体面，才不辜负这些年。",
  "Disvorce_6": "你不必亏欠，我敢给就敢心碎 。",
  "Disvorce_7": "此后一别两宽，各生欢喜。",
  "Disvorce_8": "婚姻法没有规定一个人必须爱一个人一辈子，你没有错。",
  "Disvorce_9": "你真的要为你一时的冲动，做出离婚这么愚蠢的决定吗？",
  "Disvorce_10": "结婚时你许的诺言都喂了狗吗？祝你和你的狗过得幸福。",
  "RecoverHealth": "由于日夜劳作，您的健康状况堪忧，两年后出院",
  "RecoverHealthD": "由于资产波动过大,小心脏承受不起,健康受损严重,请及时接受治疗",
  //退休时的盖棺定论
  "Retire_0": "劳碌半生，跌宕起伏，也没有人生伴侣，可谓晚景凄凉，凄凄惨惨戚戚。",
  "Retire_1": "这一辈子虽不算大富大贵，但总归事业有成，家庭美满，可安享晚年。",
  "Retire_2": "人生的意义,不在于得到什么或是失去什么。丰富的阅历、百万的家产已让人羡慕了。",
  "Retire_3": "小有成就，但壮志未酬。“挣它一个亿”的家族目标只能交给后人来奋斗了。",
  "Retire_4": "身价千万，有车有房，人生赢家。晚年安逸，你请人为自己写了一本人生回忆录。",
  "Retire_5": "几经沉浮，你终于实现了自己的小目标——亿万富翁，感觉人生已经达到了巅峰。",
  "Retire_6": "经过努力，你终于开上了法拉瑞，住上了古堡，实现了财富自由，每天都很开心。",
  "DateOut_0": "久久不能忘记的，是与你相视那一眼的怦然心动",
  "DateOut_1": "平生不会相思，才会相思，便害相思。",
  "DateOut_2": "你的酒窝没有酒，我却醉的像条狗。",
  "DateOut_3": "现在才明白什么叫“一日不见，如隔三秋。”",
  "DateOut_4": "只愿你我不负时光不负倾城。",
  "DateOut_5": "你的过去我来不及参与，你的未来我奉陪到底。"
}, _cc$director$NoticeTe["RecoverHealth"] = "由于日夜劳作，你的健康状况堪忧，需疗养两年后出院", _cc$director$NoticeTe["UnLockMateByInHos"] = "住院期间,你结识了护士姐姐。", _cc$director$NoticeTe["UnLockMate_3"] = "公司的联谊会上，你结识了颇有气质的艺术老师。", _cc$director$NoticeTe["UnLockMate_4"] = "前去马尔代夫的航班上，遇到了一见倾心的美丽空姐。", _cc$director$NoticeTe["UnLockMate_5"] = "你结识了温柔护士，可约会发展。", _cc$director$NoticeTe["UnLockMate_6"] = "朋友的周末轰趴上，你结识了人气超模。", _cc$director$NoticeTe["UnLockMate_7"] = "一次驴友旅游中，你结识了白富美。", _cc$director$NoticeTe["UnLockMate_10"] = "同学聚会，你结识了大学校草", _cc$director$NoticeTe["UnLockMate_11"] = "新去的私人健身房，你结识了小鲜肉。", _cc$director$NoticeTe["UnLockMate_12"] = "在夜跑群，你结识了帅气的精英律师，", _cc$director$NoticeTe["UnLockMate_13"] = "老套的场景，你被球砸中结识了足球队长。", _cc$director$NoticeTe["UnLockMate_14"] = "国际项目交流会上，你结识了霸道总裁。", _cc$director$NoticeTe["ToDate_1"] = "我熬过了白雪皑皑，只为换一个与君（卿）同在。", _cc$director$NoticeTe["ToDate_2"] = "遇见你,花光了我所有的运气。", _cc$director$NoticeTe["ToDate_3"] = "佛说:前世的五百次回眸才换来今生的擦肩而过。", _cc$director$NoticeTe["ToDate_4"] = "我从没想过要单身,只是一直未能与你相遇。", _cc$director$NoticeTe["ToDate_5"] = "世界这么大，过客这么多，好不容易才遇见一个你。", _cc$director$NoticeTe["InHealDownLine"] = "您还处在恢复阶段，目前不能交易", _cc$director$NoticeTe["MateMarryCond_1"] = "我还是希望拥有一个属于我们的房子，哪怕是最便宜的廉价房", _cc$director$NoticeTe["MateMarryCond_2"] = "我希望开着梨田车，一起行驶在幸福的大道上", _cc$director$NoticeTe["MateMarryCond_3"] = "我梦想在一所漂亮的公寓里，和你演奏爱的乐章", _cc$director$NoticeTe["MateMarryCond_4"] = "从小我就喜欢成熟稳重企业家，你先创办一个公司吧", _cc$director$NoticeTe["MateMarryCond_5"] = "我的伴侣必须和我一样身体健康", _cc$director$NoticeTe["MateMarryCond_6"] = "我想要大大的洋房，放上我所有喜欢的衣服和包包", _cc$director$NoticeTe["MateMarryCond_7"] = "我的家族需要你通过考验才允许我们在一起，加油吧亲爱的", _cc$director$NoticeTe["MateMarryCond_8"] = "让我开着车，带你去兜风", _cc$director$NoticeTe["MateMarryCond_9"] = "我希望开着梨田车，一起行驶在幸福的大道上", _cc$director$NoticeTe["MateMarryCond_10"] = "从你从宝马下来的那一刻，我就被你吸引", _cc$director$NoticeTe["MateMarryCond_11"] = "我们的爱情，价值百万", _cc$director$NoticeTe["MateMarryCond_12"] = "我和企业家的结合，将会是强强联合的代表", _cc$director$NoticeTe["MateMarryCond_13"] = "运动就是我的生命，我的伴侣必须和我一样健康", _cc$director$NoticeTe["MateMarryCond_14"] = "我的家族需要你通过考验才允许我们在一起，加油吧亲爱的", _cc$director$NoticeTe["event_1001"] = "参加公司的吃鸡比赛，遇到美女小姐姐的战队", _cc$director$NoticeTe["event_10010"] = "毫不留情虐菜", _cc$director$NoticeTe["event_10011"] = "假装失误放水", _cc$director$NoticeTe["event_10012"] = "你获得了本次比赛的MVP", _cc$director$NoticeTe["event_10013"] = "你的行为遭到了女性同事的鄙视", _cc$director$NoticeTe["event_10014"] = "你的行为遭到了男性同事的鄙视", _cc$director$NoticeTe["event_10015"] = "小姐姐很开心，并对你比了个小心心", _cc$director$NoticeTe["event_1002"] = "你在咖啡馆发现好基友正在相亲，你选择", _cc$director$NoticeTe["event_10020"] = "偷笑观察", _cc$director$NoticeTe["event_10021"] = "假装巧遇", _cc$director$NoticeTe["event_10022"] = "看了一阵感觉双方进展不错便离开了", _cc$director$NoticeTe["event_10023"] = "好友发现了你的存在，并暗示你离开", _cc$director$NoticeTe["event_10024"] = "场面一度十分尴尬，好友有点生气", _cc$director$NoticeTe["event_10025"] = "双方都是你的朋友，你积极撮合", _cc$director$NoticeTe["event_1003"] = "圣诞节快到了，你准备送一个礼物给对象", _cc$director$NoticeTe["event_10030"] = "路边摘一朵玫瑰", _cc$director$NoticeTe["event_10031"] = "买一部最新爱疯", _cc$director$NoticeTe["event_10032"] = "对象夸赞你是个浪漫的人", _cc$director$NoticeTe["event_10033"] = "你被花圃的主人追了半条街", _cc$director$NoticeTe["event_10034"] = "手机信号太差，对象明显开始冷落你", _cc$director$NoticeTe["event_10035"] = "开心到爆，并送你一个法式热吻", _cc$director$NoticeTe["event_1004"] = "朋友推荐你参加一个总裁学习班，学费昂贵", _cc$director$NoticeTe["event_10040"] = "赶紧报名", _cc$director$NoticeTe["event_10041"] = "放弃参加", _cc$director$NoticeTe["event_10042"] = "讲课的老师都是大佬，同学人脉也很宽广", _cc$director$NoticeTe["event_10043"] = "上课第一天就发现被忽悠", _cc$director$NoticeTe["event_10044"] = "讲课的老师都是大佬，错失机会", _cc$director$NoticeTe["event_10045"] = "听说都是忽悠，庆幸不已", _cc$director$NoticeTe["event_1005"] = "台风来袭，大暴雨让仓库开始浸水", _cc$director$NoticeTe["event_10050"] = "组织员工排水", _cc$director$NoticeTe["event_10051"] = "请专业人士排水", _cc$director$NoticeTe["event_10052"] = "大家团结一致，最终解决了问题", _cc$director$NoticeTe["event_10053"] = "雨势太大，虽然拯救了货品，但员工集体感冒生病了", _cc$director$NoticeTe["event_10054"] = "专业人士通过专用设备，迅速解决了问题", _cc$director$NoticeTe["event_10055"] = "专业人士通过专用设备，迅速解决了问题", _cc$director$NoticeTe["event_1006"] = "又是一年的尾声，公司年会方案也提上日程。场地选在哪呢", _cc$director$NoticeTe["event_10060"] = "五星酒店", _cc$director$NoticeTe["event_10061"] = "农家乐", _cc$director$NoticeTe["event_10062"] = "年会场面很大气，大家都很自豪，干劲十足", _cc$director$NoticeTe["event_10063"] = "大家海吃海喝，支出不小", _cc$director$NoticeTe["event_10064"] = "气氛很随意，大家开开心心总结了一年的收益", _cc$director$NoticeTe["event_10065"] = "气氛很随意，大家开开心心总结了一年的收益", _cc$director$NoticeTe["event_1007"] = "开年利是，行政小姐姐问要准备多少个红包发给大家", _cc$director$NoticeTe["event_10070"] = "部分员工才有", _cc$director$NoticeTe["event_10071"] = "所有员工都有", _cc$director$NoticeTe["event_10072"] = "领到的小伙伴纷纷赞扬你", _cc$director$NoticeTe["event_10073"] = "没领到的小伙伴表示不满", _cc$director$NoticeTe["event_10074"] = "大家都很开心，工作效率提升", _cc$director$NoticeTe["event_10075"] = "大家都很开心，工作效率提升", _cc$director$NoticeTe["event_1008"] = "员工在厂房搬砖时，发现一个地窖", _cc$director$NoticeTe["event_10080"] = "一探究竟", _cc$director$NoticeTe["event_10081"] = "上报国家", _cc$director$NoticeTe["event_10082"] = "里面黑咕隆咚，一不小心摔了一跤", _cc$director$NoticeTe["event_10083"] = "一番探索，发现一些字画", _cc$director$NoticeTe["event_10084"] = "获得大力表扬外加一面锦旗", _cc$director$NoticeTe["event_10085"] = "获得大力表扬外加一面锦旗", _cc$director$NoticeTe["event_1009"] = "股市跌穿股灾低点，刚好你手上有一笔资金。你选择", _cc$director$NoticeTe["event_10090"] = "全部买入", _cc$director$NoticeTe["event_10091"] = "继续观察", _cc$director$NoticeTe["event_10092"] = "股市剧烈震荡，你心脏有点受不了", _cc$director$NoticeTe["event_10093"] = "强力反弹，连续涨停", _cc$director$NoticeTe["event_10094"] = "观望来观望去，你最终还是选择放弃", _cc$director$NoticeTe["event_10095"] = "发现一个机会，低位买入小赚一笔", _cc$director$NoticeTe["event_1010"] = "最近公司事务繁忙，身心感到有些疲惫。", _cc$director$NoticeTe["event_10100"] = "使用全健火疗", _cc$director$NoticeTe["event_10101"] = "找个海岛度假", _cc$director$NoticeTe["event_10102"] = "感觉好像有那么点效果，也许是心里作用", _cc$director$NoticeTe["event_10103"] = "体验之后还被人忽悠办了个会员卡", _cc$director$NoticeTe["event_10104"] = "火山喷发导致在岛上滞留了几天影响了工作计划", _cc$director$NoticeTe["event_10105"] = "度假之后满血复活，重新投入工作", _cc$director$NoticeTe["event_1011"] = "你收到举报，公司的财务报表存在偷税漏税的情况", _cc$director$NoticeTe["event_10110"] = "找公司调查", _cc$director$NoticeTe["event_10111"] = "信任财务主管", _cc$director$NoticeTe["event_10112"] = "及时发现了问题并妥善处理", _cc$director$NoticeTe["event_10113"] = "没有发现问题，公司正常运营", _cc$director$NoticeTe["event_10114"] = "被有关部门发现并罚款", _cc$director$NoticeTe["event_10115"] = "公司正常运营", _cc$director$NoticeTe["event_1012"] = "因管理不善，部分货品超出了保质期", _cc$director$NoticeTe["event_10120"] = "打折处理", _cc$director$NoticeTe["event_10121"] = "全部销毁", _cc$director$NoticeTe["event_10122"] = "消费者发现并爆料给新闻", _cc$director$NoticeTe["event_10123"] = "消费者发现并投诉赔偿", _cc$director$NoticeTe["event_10124"] = "众人非常认可你的担当和责任，集体荣誉感上升", _cc$director$NoticeTe["event_10125"] = "众人非常认可你的担当和责任，集体荣誉感上升", _cc$director$NoticeTe["event_1013"] = "网络直播兴起，你尝试和主播合作进行运营活动。", _cc$director$NoticeTe["event_10130"] = "漂亮优先", _cc$director$NoticeTe["event_10131"] = "人气优先", _cc$director$NoticeTe["event_10132"] = "活动效果反应平平", _cc$director$NoticeTe["event_10133"] = "活动效果反应平平", _cc$director$NoticeTe["event_10134"] = "活动反响不错，打开了新的销路", _cc$director$NoticeTe["event_10135"] = "活动反响不错，打开了新的销路", _cc$director$NoticeTe["event_1014"] = "共享单车进入人们生活，你想在车身投放广告。", _cc$director$NoticeTe["event_10140"] = "小黄车", _cc$director$NoticeTe["event_10141"] = "小红车", _cc$director$NoticeTe["event_10142"] = "小黄车陷入押金风波,广告失败", _cc$director$NoticeTe["event_10143"] = "小黄车陷入押金风波,广告失败", _cc$director$NoticeTe["event_10144"] = "小红车被收购，广告效果一般", _cc$director$NoticeTe["event_10145"] = "小红车被收购，广告效果一般", _cc$director$NoticeTe["event_1015"] = "国际贸易关系紧张，刚好你想换一部新手机", _cc$director$NoticeTe["event_10150"] = "国货优先", _cc$director$NoticeTe["event_10151"] = "进口优先", _cc$director$NoticeTe["event_10152"] = "排队抢购的人太多，你不得不加价购买", _cc$director$NoticeTe["event_10153"] = "各方面效果刚刚的，你把它推荐给身边的朋友", _cc$director$NoticeTe["event_10154"] = "手机信号不太稳定，导致有些生意电话没接到", _cc$director$NoticeTe["event_10155"] = "系统体验确实丝滑柔顺，你推荐给身边的朋友", _cc$director$NoticeTe["event_1016"] = "合同交付时间将至，需要员工加班加快进度，你如何激励", _cc$director$NoticeTe["event_10160"] = "双倍工资", _cc$director$NoticeTe["event_10161"] = "画个大饼", _cc$director$NoticeTe["event_10162"] = "进度终于赶上，你终于松了一口气", _cc$director$NoticeTe["event_10163"] = "部分员工加班太猛，差点让你破产", _cc$director$NoticeTe["event_10164"] = "进度终于赶上，但你却累倒了", _cc$director$NoticeTe["event_10165"] = "效果不佳，合同最终没有完成", _cc$director$NoticeTe["event_1017"] = "你今天需要面见两个创业团队，决定对哪个进行天使投资", _cc$director$NoticeTe["event_10170"] = "想改变世界的青年团队", _cc$director$NoticeTe["event_10171"] = "大厂背景的资深团队", _cc$director$NoticeTe["event_10172"] = "凭借着活力和激情，他们最终在市场站稳了。", _cc$director$NoticeTe["event_10173"] = "最终还是没有实现，但你还是看好他们", _cc$director$NoticeTe["event_10174"] = "他们的产品在你的帮助下迅速的占领了市场", _cc$director$NoticeTe["event_10175"] = "脱离了大厂平台，他们离成功还是差了一点", _cc$director$NoticeTe["event_1018"] = "开车路过某老城区街道，眼看前方一老人倒地不起", _cc$director$NoticeTe["event_10180"] = "直接路过", _cc$director$NoticeTe["event_10181"] = "下车查看", _cc$director$NoticeTe["event_10182"] = "事后内心一直觉得愧疚", _cc$director$NoticeTe["event_10183"] = "事后内心一直觉得愧疚", _cc$director$NoticeTe["event_10184"] = "即时送往医院处理，家人感激不尽", _cc$director$NoticeTe["event_10185"] = "原来是碰瓷，幸好我有行车记录仪", _cc$director$NoticeTe["event_1019"] = "企业家慈善拍卖会，有两个拍卖品你都有兴趣", _cc$director$NoticeTe["event_10190"] = "一掷千金全部买下", _cc$director$NoticeTe["event_10191"] = "买入价格低的", _cc$director$NoticeTe["event_10192"] = "你在拍卖会上为自己赢得了美名", _cc$director$NoticeTe["event_10193"] = "你在拍卖会上为自己赢得了美名", _cc$director$NoticeTe["event_10194"] = "你将它放在办公桌上，时刻鞭策你", _cc$director$NoticeTe["event_10195"] = "你将它放在办公桌上，时刻鞭策你", _cc$director$NoticeTe["event_1020"] = " 政府鼓励消费，小额贷款需求活跃", _cc$director$NoticeTe["event_10200"] = "加大宣传", _cc$director$NoticeTe["event_10201"] = "照常经营", _cc$director$NoticeTe["event_10202"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10203"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10204"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_10205"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_1021"] = "越来越多的群众习惯网购，电商物流需求攀升", _cc$director$NoticeTe["event_10210"] = "扩大建设", _cc$director$NoticeTe["event_10211"] = "照常经营", _cc$director$NoticeTe["event_10212"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10213"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10214"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_10215"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_1022"] = "外卖市场越来越大，连锁餐饮是否加入外卖平台", _cc$director$NoticeTe["event_10220"] = "积极加入", _cc$director$NoticeTe["event_10221"] = "照常经营", _cc$director$NoticeTe["event_10222"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10223"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10224"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_10225"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_1023"] = "新生代中产阶级崛起，金融保险需求越来越高", _cc$director$NoticeTe["event_10230"] = "加强销售", _cc$director$NoticeTe["event_10231"] = "照常经营", _cc$director$NoticeTe["event_10232"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10233"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10234"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_10235"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_1024"] = "亚健康现象越来越普遍，保健食品市场有望爆发", _cc$director$NoticeTe["event_10240"] = "抢夺市场", _cc$director$NoticeTe["event_10241"] = "照常经营", _cc$director$NoticeTe["event_10242"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10243"] = "抓住机会，再创新高", _cc$director$NoticeTe["event_10244"] = "错失机会，后悔不已", _cc$director$NoticeTe["event_10245"] = "错失机会，后悔不已", _cc$director$NoticeTe["Market_2"] = "区块链概念大火，金币价格持续高涨", _cc$director$NoticeTe["Market_1"] = "虚拟币的发行被管控，金币价格一落千丈", _cc$director$NoticeTe["Market_4"] = "水果手机全新外观上市，粉丝排成长队疯狂抢购", _cc$director$NoticeTe["Market_3"] = "定价过高，小问题不断。水果手机价格跌入低谷", _cc$director$NoticeTe["Market_6"] = "市场热钱涌动，大师字画在拍卖行价格一飞冲天", _cc$director$NoticeTe["Market_5"] = "经济形势悲观，艺术投资减少，大师字画无人问津", _cc$director$NoticeTe["Market_8"] = "区域局势紧张，冲突一触即发。黄金价格顺势暴涨", _cc$director$NoticeTe["Market_7"] = "国外投机势力大肆做空黄金，价格一路下滑", _cc$director$NoticeTe["Market_10"] = "飞人球鞋联合最火运动明星，打造大受好评的限量珍藏版。", _cc$director$NoticeTe["Market_9"] = "对手爆款上市，飞人球鞋无人问津低价出售", _cc$director$NoticeTe["Market_12"] = "网传大蒜能有效预防流感，市场一扫而空。", _cc$director$NoticeTe["Market_11"] = "去年大蒜大丰收，市场需求不足滞销严重。", _cc$director$NoticeTe["Market_14"] = "游戏战队获得世界冠军，吸引大量用户购买游戏账号", _cc$director$NoticeTe["Market_13"] = "服务器出现严重问题，游戏账号遭到玩家放弃", _cc$director$NoticeTe["Market_16"] = "无人机续航和拍照获得重大突破，供不应求", _cc$director$NoticeTe["Market_15"] = "无人机安全事故频发，无人机市场暂时熄火", _cc$director$NoticeTe["Market_18"] = "一线明星代言奢侈包包，受到时尚达人们的追捧", _cc$director$NoticeTe["Market_17"] = "动物保护协会控诉奢侈品包包伤害动物，引起公民关注。", _cc$director$NoticeTe["Market_20"] = "今年寒流加剧，美观又保暖的皮草大衣深受市场好评", _cc$director$NoticeTe["Market_19"] = "暖冬现象导致穿一件外套足以，皮草大衣束之高阁", _cc$director$NoticeTe["Market_22"] = "香水商家联合最火美女明星发布新品广告，销量猛增", _cc$director$NoticeTe["Market_21"] = "网络歌曲《香水有毒》唱响各大晚会，大家竟信以为真。", _cc$director$NoticeTe["Market_24"] = "海淘平台普及。各种进口零食进入千家万户的家中", _cc$director$NoticeTe["Market_23"] = "运输时间久和价格偏贵，进口零食销量打折出售", _cc$director$NoticeTe["Market_25"] = "今年市场行情平稳", _cc$director$NoticeTe["Tf_1"] = "增加初始仓库", _cc$director$NoticeTe["Tf_2"] = "约会成功概率提升", _cc$director$NoticeTe["Tf_3"] = "每年额外获得金钱", _cc$director$NoticeTe["Tf_4"] = "增加初始金钱", _cc$director$NoticeTe["Tf_5"] = "增加公司收益率", _cc$director$NoticeTe["Tf_6"] = "公司股价上涨概率提升", _cc$director$NoticeTe["Tf_7"] = "家族天赋点结算提升", _cc$director$NoticeTe["Tf_8"] = "约会花费降低", _cc$director$NoticeTe["Tf_9"] = "娱乐获奖概率提升", _cc$director$NoticeTe["Tf_10"] = "退休年限延长", _cc$director$NoticeTe["Tf_11"] = "增加初始名声", _cc$director$NoticeTe["Tf_12"] = "购买汽车价格降低", _cc$director$NoticeTe["Tf_13"] = "事件金钱消耗降低", _cc$director$NoticeTe["Tf_14"] = "购买住宅价格降低", _cc$director$NoticeTe["Cj_1"] = "总资产达到1亿", _cc$director$NoticeTe["Cj_2"] = "一生中进过3次医院", _cc$director$NoticeTe["Cj_3"] = "一生中公司连续倒闭5次", _cc$director$NoticeTe["Cj_4"] = "一生中连续创业3次", _cc$director$NoticeTe["Cj_5"] = "30岁前资产达到1000万", _cc$director$NoticeTe["Cj_6"] = "达到一亿时 年龄超过60岁", _cc$director$NoticeTe["Cj_7"] = "一生未有伴侣且资产低于100万", _cc$director$NoticeTe["Cj_8"] = "一生未有伴侣且资产大于2000万", _cc$director$NoticeTe["Cj_9"] = "有伴侣且有四个以上好感度达到99的异性", _cc$director$NoticeTe["goods_1"] = "金币", _cc$director$NoticeTe["goods_2"] = "水果手机", _cc$director$NoticeTe["goods_3"] = "大师字画", _cc$director$NoticeTe["goods_4"] = "黄金", _cc$director$NoticeTe["goods_5"] = "飞人球鞋", _cc$director$NoticeTe["goods_6"] = "大蒜", _cc$director$NoticeTe["goods_7"] = "游戏帐号", _cc$director$NoticeTe["goods_8"] = "航拍无人机", _cc$director$NoticeTe["goods_9"] = "奢侈包包", _cc$director$NoticeTe["goods_10"] = "羊毛大衣", _cc$director$NoticeTe["goods_11"] = "香水", _cc$director$NoticeTe["goods_12"] = "零食", _cc$director$NoticeTe["role_1"] = "初中师妹", _cc$director$NoticeTe["role_2"] = "高中班花", _cc$director$NoticeTe["role_3"] = "艺术老师", _cc$director$NoticeTe["role_4"] = "空姐", _cc$director$NoticeTe["role_5"] = "温柔护士", _cc$director$NoticeTe["role_6"] = "超模", _cc$director$NoticeTe["role_7"] = "白富美", _cc$director$NoticeTe["role_8"] = "邻家大哥", _cc$director$NoticeTe["role_9"] = "暖男师兄", _cc$director$NoticeTe["role_10"] = "大学校草", _cc$director$NoticeTe["role_11"] = "小鲜肉", _cc$director$NoticeTe["role_12"] = "精英律师", _cc$director$NoticeTe["role_13"] = "足球队长", _cc$director$NoticeTe["role_14"] = "霸道总裁", _cc$director$NoticeTe["company_1"] = "保健食品公司", _cc$director$NoticeTe["company_2"] = "金融保险公司", _cc$director$NoticeTe["company_3"] = "连锁餐饮公司", _cc$director$NoticeTe["company_4"] = "电商物流公司", _cc$director$NoticeTe["company_5"] = "小额贷款公司", _cc$director$NoticeTe["tutorial_11"] = "为了实现目标，先从低买高卖累积资本", _cc$director$NoticeTe["tutorial_12"] = "点击买入", _cc$director$NoticeTe["tutorial_13"] = "看看明年的市场行情如何", _cc$director$NoticeTe["tutorial_14"] = "商品涨价了，果断卖出赚取差价", _cc$director$NoticeTe["tutorial_15"] = "点击卖出", _cc$director$NoticeTe["tutorial_21"] = "好的伴侣是事业坚实的基础，实在不行还可以求包养", _cc$director$NoticeTe["tutorial_22"] = "这么多款，总有一个适合你", _cc$director$NoticeTe["tutorial_31"] = "到而立之年，应该考虑创业来享受资产升值和分红了", _cc$director$NoticeTe["tutorial_32"] = "有足够的钱的话，这些公司你可以随意投资。", _cc$director$NoticeTe["tutorial_41"] = "创办企业后，享受股价提升的收益，每年收到分红。", _cc$director$NoticeTe["tutorial_51"] = "每一次约会都会增加亲密度，亲密度达到99可发起求婚哦", _cc$director$NoticeTe["MateUnlockTip"] = "你们尚未相遇,前往约会圣地碰碰运气", _cc$director$NoticeTe["HasMarray_0"] = "你是要婚姻还是要真爱？若要真爱,你先离婚吧", _cc$director$NoticeTe["HasMarray_1"] = "你都有家室了，我们是不可能的，除非你先恢复单身。", _cc$director$NoticeTe["HasMarray_2"] = "你若真的爱我，就给我名分吧。", _cc$director$NoticeTe["HasMarray_3"] = "你说 是我们相见恨晚；我说 为爱你应该勇敢，", _cc$director$NoticeTe["NoMoneyDate_0"] = "等你有钱了,再去追求约会那个奢侈玩意儿吧", _cc$director$NoticeTe["NoMoneyDate_1"] = "没钱时,约会是你一种得不到的奢侈", _cc$director$NoticeTe["BetWin"] = "哈哈，发财了。赚了钱，我要买车买房约美女", _cc$director$NoticeTe["BetLose"] = "我不信，这都没中。丫的，再来一把肯定中", _cc$director$NoticeTe["CashInit_1"] = "出身寒门,进入社会只怀揣着打工的20000元闯荡江湖", _cc$director$NoticeTe["CashInit_2"] = "中产家庭,父母有担当,给你50000元作为创业启动基金", _cc$director$NoticeTe["CashInit_3"] = "富裕家庭，家族为了你能早日闯出一片天地，出资100000元", _cc$director$NoticeTe["MoneyNotEnough"] = "现金不足，无法参与", _cc$director$NoticeTe["DateFail_0"] = "未来有一个人在等待，爱要拐几个弯才到来", _cc$director$NoticeTe["DateFail_1"] = "我们曾在过去的梦境里相遇，也将会在未来的现实中重逢", _cc$director$NoticeTe["Name1"] = "校长王", _cc$director$NoticeTe["Name2"] = "巴菲莱", _cc$director$NoticeTe["Name3"] = "麻花藤", _cc$director$NoticeTe["Name4"] = "马爸爸", _cc$director$NoticeTe["Name5"] = "社会主义接班人", _cc$director$NoticeTe["Name6"] = "比尔.盖特", _cc$director$NoticeTe["Name7"] = "我是首富", _cc$director$NoticeTe["Name8"] = "柳传承", _cc$director$NoticeTe["Name9"] = "雷布斯", _cc$director$NoticeTe["Name10"] = "王达林", _cc$director$NoticeTe["Name11"] = "史铁柱", _cc$director$NoticeTe["Name12"] = "董珍珠", _cc$director$NoticeTe["Name13"] = "丁三石", _cc$director$NoticeTe["Name14"] = "恒家印", _cc$director$NoticeTe["Name15"] = "李佳晨", _cc$director$NoticeTe["Name16"] = "天生钞能力", _cc$director$NoticeTe["Name17"] = "老夫炒股一把梭", _cc$director$NoticeTe["Name18"] = "睡醒就数钱", _cc$director$NoticeTe["Name19"] = "数钱手抽筋", _cc$director$NoticeTe["Name20"] = "人生赢家", _cc$director$NoticeTe["Name21"] = "单手开车我最强", _cc$director$NoticeTe["Name22"] = "菜虚鲲", _cc$director$NoticeTe["Name23"] = "辣鸡大司马", _cc$director$NoticeTe["Name24"] = "东子大兄弟", _cc$director$NoticeTe);

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcTm90aWNlVGV4dC5qcyJdLCJuYW1lcyI6WyJjYyIsImRpcmVjdG9yIiwiTm90aWNlVGV4dCIsIl9jYyRkaXJlY3RvciROb3RpY2VUZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUFBLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDQyxVQUFVLElBQUFDLHFCQUFBO0VBRWxCLFFBQVEsRUFBQywwQkFBMEI7RUFDbkMsUUFBUSxFQUFDLGNBQWM7RUFDdkIsUUFBUSxFQUFDLDBCQUEwQjtFQUNuQyxRQUFRLEVBQUMsaUNBQWlDO0VBQzFDLFFBQVEsRUFBQyxvQkFBb0I7RUFDN0IsUUFBUSxFQUFDLDBCQUEwQjtFQUNuQyxRQUFRLEVBQUMsZUFBZTtFQUN4QixRQUFRLEVBQUMsc0JBQXNCO0VBQy9CLFFBQVEsRUFBQyxjQUFjO0VBQ3ZCLFNBQVMsRUFBQyx3QkFBd0I7RUFDbEMsU0FBUyxFQUFDLDJCQUEyQjtFQUNyQyxTQUFTLEVBQUMsb0JBQW9CO0VBQzlCLFNBQVMsRUFBQyx3QkFBd0I7RUFDbEMsU0FBUyxFQUFDLHFCQUFxQjtFQUcvQjtFQUNBLFFBQVEsRUFBQywrQ0FBK0M7RUFDeEQsUUFBUSxFQUFDLGdEQUFnRDtFQUN6RCxRQUFRLEVBQUMsa0RBQWtEO0VBRTNELFdBQVcsRUFBQyxnQkFBZ0I7RUFDNUIsV0FBVyxFQUFDLGVBQWU7RUFFM0IsWUFBWSxFQUFDLGNBQWM7RUFDM0IsWUFBWSxFQUFDLG1CQUFtQjtFQUVoQyxZQUFZLEVBQUMsNEJBQTRCO0VBQ3pDLFlBQVksRUFBQyx5QkFBeUI7RUFDdEMsWUFBWSxFQUFDLGlCQUFpQjtFQUM5QixZQUFZLEVBQUMsaUJBQWlCO0VBQzlCLFlBQVksRUFBQyxpQkFBaUI7RUFDOUIsWUFBWSxFQUFDLGlCQUFpQjtFQUM5QixZQUFZLEVBQUMsY0FBYztFQUMzQixZQUFZLEVBQUMsMkJBQTJCO0VBQ3hDLFlBQVksRUFBQywyQkFBMkI7RUFDeEMsYUFBYSxFQUFD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SUFBQyxJQUFJLEVBQUFBLHFCQUFBLENBQ2QsU0FBUyxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDaEIsU0FBUyxJQUFDLE9BQU8sRUFBQUEscUJBQUEsQ0FDakIsU0FBUyxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDaEIsVUFBVSxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDakIsVUFBVSxJQUFDLElBQUksRUFBQUEscUJBQUEsQ0FDZixVQUFVLElBQUMsSUFBSSxFQUFBQSxxQkFBQSxDQUVmLFFBQVEsSUFBQyxNQUFNLEVBQUFBLHFCQUFBLENBQ2YsUUFBUSxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDZixRQUFRLElBQUMsTUFBTSxFQUFBQSxxQkFBQSxDQUNmLFFBQVEsSUFBQyxJQUFJLEVBQUFBLHFCQUFBLENBQ2IsUUFBUSxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDZixRQUFRLElBQUMsSUFBSSxFQUFBQSxxQkFBQSxDQUNiLFFBQVEsSUFBQyxLQUFLLEVBQUFBLHFCQUFBLENBQ2QsUUFBUSxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDZixRQUFRLElBQUMsTUFBTSxFQUFBQSxxQkFBQSxDQUNmLFNBQVMsSUFBQyxNQUFNLEVBQUFBLHFCQUFBLENBQ2hCLFNBQVMsSUFBQyxLQUFLLEVBQUFBLHFCQUFBLENBQ2YsU0FBUyxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDaEIsU0FBUyxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDaEIsU0FBUyxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FFaEIsV0FBVyxJQUFDLFFBQVEsRUFBQUEscUJBQUEsQ0FDcEIsV0FBVyxJQUFDLFFBQVEsRUFBQUEscUJBQUEsQ0FDcEIsV0FBVyxJQUFDLFFBQVEsRUFBQUEscUJBQUEsQ0FDcEIsV0FBVyxJQUFDLFFBQVEsRUFBQUEscUJBQUEsQ0FDcEIsV0FBVyxJQUFDLFFBQVEsRUFBQUEscUJBQUEsQ0FHcEIsYUFBYSxJQUFDLG1CQUFtQixFQUFBQSxxQkFBQSxDQUNqQyxhQUFhLElBQUMsTUFBTSxFQUFBQSxxQkFBQSxDQUNwQixhQUFhLElBQUMsYUFBYSxFQUFBQSxxQkFBQSxDQUMzQixhQUFhLElBQUMsZ0JBQWdCLEVBQUFBLHFCQUFBLENBQzlCLGFBQWEsSUFBQyxNQUFNLEVBQUFBLHFCQUFBLENBQ3BCLGFBQWEsSUFBQyx5QkFBeUIsRUFBQUEscUJBQUEsQ0FDdkMsYUFBYSxJQUFDLGNBQWMsRUFBQUEscUJBQUEsQ0FDNUIsYUFBYSxJQUFDLHlCQUF5QixFQUFBQSxxQkFBQSxDQUN2QyxhQUFhLElBQUMsc0JBQXNCLEVBQUFBLHFCQUFBLENBQ3BDLGFBQWEsSUFBQyx5QkFBeUIsRUFBQUEscUJBQUEsQ0FDdkMsYUFBYSxJQUFDLDRCQUE0QixFQUFBQSxxQkFBQSxDQUUxQyxlQUFlLElBQUMsbUJBQW1CLEVBQUFBLHFCQUFBLENBRW5DLGFBQWEsSUFBQyx1QkFBdUIsRUFBQUEscUJBQUEsQ0FDckMsYUFBYSxJQUFDLDBCQUEwQixFQUFBQSxxQkFBQSxDQUN4QyxhQUFhLElBQUMsZ0JBQWdCLEVBQUFBLHFCQUFBLENBQzlCLGFBQWEsSUFBQyx3QkFBd0IsRUFBQUEscUJBQUEsQ0FFdEMsZUFBZSxJQUFDLHNCQUFzQixFQUFBQSxxQkFBQSxDQUN0QyxlQUFlLElBQUMsa0JBQWtCLEVBQUFBLHFCQUFBLENBRWxDLFFBQVEsSUFBQyxzQkFBc0IsRUFBQUEscUJBQUEsQ0FDL0IsU0FBUyxJQUFDLHFCQUFxQixFQUFBQSxxQkFBQSxDQUUvQixZQUFZLElBQUMsNEJBQTRCLEVBQUFBLHFCQUFBLENBQ3pDLFlBQVksSUFBQyw2QkFBNkIsRUFBQUEscUJBQUEsQ0FDMUMsWUFBWSxJQUFDLCtCQUErQixFQUFBQSxxQkFBQSxDQUU1QyxnQkFBZ0IsSUFBQyxXQUFXLEVBQUFBLHFCQUFBLENBRTVCLFlBQVksSUFBQyxxQkFBcUIsRUFBQUEscUJBQUEsQ0FDbEMsWUFBWSxJQUFDLDJCQUEyQixFQUFBQSxxQkFBQSxDQUV4QyxPQUFPLElBQUMsS0FBSyxFQUFBQSxxQkFBQSxDQUNiLE9BQU8sSUFBQyxLQUFLLEVBQUFBLHFCQUFBLENBQ2IsT0FBTyxJQUFDLEtBQUssRUFBQUEscUJBQUEsQ0FDYixPQUFPLElBQUMsS0FBSyxFQUFBQSxxQkFBQSxDQUNiLE9BQU8sSUFBQyxTQUFTLEVBQUFBLHFCQUFBLENBQ2pCLE9BQU8sSUFBQyxPQUFPLEVBQUFBLHFCQUFBLENBQ2YsT0FBTyxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDZCxPQUFPLElBQUMsS0FBSyxFQUFBQSxxQkFBQSxDQUNiLE9BQU8sSUFBQyxLQUFLLEVBQUFBLHFCQUFBLENBQ2IsUUFBUSxJQUFDLEtBQUssRUFBQUEscUJBQUEsQ0FDZCxRQUFRLElBQUMsS0FBSyxFQUFBQSxxQkFBQSxDQUNkLFFBQVEsSUFBQyxLQUFLLEVBQUFBLHFCQUFBLENBQ2QsUUFBUSxJQUFDLEtBQUssRUFBQUEscUJBQUEsQ0FDZCxRQUFRLElBQUMsS0FBSyxFQUFBQSxxQkFBQSxDQUNkLFFBQVEsSUFBQyxLQUFLLEVBQUFBLHFCQUFBLENBQ2QsUUFBUSxJQUFDLE9BQU8sRUFBQUEscUJBQUEsQ0FDaEIsUUFBUSxJQUFDLFNBQVMsRUFBQUEscUJBQUEsQ0FDbEIsUUFBUSxJQUFDLE9BQU8sRUFBQUEscUJBQUEsQ0FDaEIsUUFBUSxJQUFDLE9BQU8sRUFBQUEscUJBQUEsQ0FDaEIsUUFBUSxJQUFDLE1BQU0sRUFBQUEscUJBQUEsQ0FDZixRQUFRLElBQUMsU0FBUyxFQUFBQSxxQkFBQSxDQUNsQixRQUFRLElBQUMsS0FBSyxFQUFBQSxxQkFBQSxDQUNkLFFBQVEsSUFBQyxPQUFPLEVBQUFBLHFCQUFBLENBQ2hCLFFBQVEsSUFBQyxPQUFPLEVBQUFBLHFCQUFBLENBRW5CIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJjYy5kaXJlY3Rvci5Ob3RpY2VUZXh0ID0ge1xuXG4gICAgXCJkYXRlXzFcIjpcIuS9oOaAjuS5iOeOsOWcqOaJjeadpe+8n+aIkeiAl+WwveS6huaVtOS4qumdkuaYpeS4gOebtOWcqOi/memHjOetieS9oOOAglwiLFxuICAgIFwiZGF0ZV8yXCI6XCLmiJHov5jmmK/kvaDlv4Pph4znmoTmsojkvbPlrpzlkJfvvJ9cIixcbiAgICBcImRhdGVfM1wiOlwi5pyA5aW955qE5oSf6KeJ5bCx5pivLOW9k+aIkeacm+WQkeS9oOaXtizkvaDkuZ/mraPlpb3ms6jop4bnnYDmiJHjgIJcIixcbiAgICBcImRhdGVfNFwiOlwi6Lqr6auYOjE2OGNtIOS9k+mHjTo0OWtnIOiDuOWbtDozNkXvvIzmiJHmg7Pmib7nlLfmnIvlj4vjgIJcIixcbiAgICBcImRhdGVfNVwiOlwi55m96KGj5aSp5L2/5piv5oiR77yM5Yi25pyN5aWz6YOO5Lmf5piv5oiR77yM57qm5ZCX77yfXCIsXG4gICAgXCJkYXRlXzZcIjpcIlTlj7DkuIrlho3lpJrnmoTlhYnpspzkuq7kuL3vvIzpg73mirXkuI3kuIrkvaDnnLzph4znmoTnmpPmnIjmmI7nqbrjgIJcIixcbiAgICBcImRhdGVfN1wiOlwi6Z2i5YyF5oiR5pyJ77yM5L2g57uZ5oiR54ix5oOF5bCx5aW944CCXCIsXG4gICAgXCJkYXRlXzhcIjpcIuS7juWwj+S8tOS9oOmVv+Wkp++8jOaIkeaYr+S9oOawuOi/nOWPr+S7peS+nemdoOeahOa4r+a5vuOAglwiLFxuICAgIFwiZGF0ZV85XCI6XCLlj6rmg7Ppu5jpu5jllpzmrKLkvaDvvIzlrojmiqTkvaDigKZcIixcbiAgICBcImRhdGVfMTBcIjpcIuWkmuW5tOS7peWQju+8jOaIkei/mOWcqOS9oOi6q+aXge+8jOmFkuaYr+eDiOeahO+8jOmjjuaYr+aalueahOOAglwiLFxuICAgIFwiZGF0ZV8xMVwiOlwi5oiR5bCx5piv5L2g5Y+v54ix55qE5bCP5aW254uX77yM5q+P5aSp5pGH552A5bC+5be05a+55L2g6K+05pOm5rWq5Zi/5ZGmflwiLFxuICAgIFwiZGF0ZV8xMlwiOlwi5oiR6IO95Li65L2g55qE5q+P5Liq6L+H6ZSZ6YO95YGa5Ye65a6M576O55qE6L6p5oqk44CCXCIsXG4gICAgXCJkYXRlXzEzXCI6XCLkvaDoi6XlkJHliY3vvIzmiJHlsLHmmK/kvaDnmoTliY3plIvvvIzkuLrkvaDouKLotbDkuIDliIfpmLvnoo3jgIJcIixcbiAgICBcImRhdGVfMTRcIjpcIuaIkeimgeiuqeWFqOS4lueVjOefpemBk++8jOi/meS4qumxvOWhmOiiq+S9oOaJv+WMheS6huOAglwiLFxuXG5cbiAgICAvL+i/m+WFpeekvuS8muaXtumHkemSseeahFxuICAgIFwiQ2FzaF8xXCI6XCLlh7rouqvlr5Lpl6gs6L+b5YWl56S+5Lya5Y+q5oCA5o+j552A5omT5bel55qEPGNvbG9yPSNlNzcxMjI+MjAwMDA8L2M+5YWD6Zev6I2h5rGf5rmWXCIsXG4gICAgXCJDYXNoXzJcIjpcIuS4reS6p+WutuW6rSzniLbmr43mnInmi4XlvZMs57uZ5L2gPGNvbG9yPSNlNzcxMjI+NTAwMDA8L2M+5YWD5L2c5Li65Yib5Lia5ZCv5Yqo5Z+66YeRXCIsXG4gICAgXCJDYXNoXzNcIjpcIuWvjOijleWutuW6re+8jOWutuaXj+S4uuS6huS9oOiDveaXqeaXpemXr+WHuuS4gOeJh+WkqeWcsO+8jOWHuui1hDxjb2xvcj0jZTc3MTIyPjEwMDAwMDwvYz7lhYNcIixcblxuICAgIFwiTWF0ZUhhc18xXCI6XCLmnJ3mnJ3mmq7mmq7vvIzmn7TnsbPmsrnnm5DvvIzmiY3mmK/lqZrlp7tcIixcbiAgICBcIk1hdGVIYXNfMlwiOlwi5Lqy54ix55qELCDlubPlubPmt6Hmt6HkuZ/mmK/nnJ/llYpcIixcblxuICAgIFwiTWFycnlUeHRfMVwiOlwi56WI5oS/5omn5a2Q5LmL5omL77yM5LiO5a2Q5YGV6ICB44CCXCIsXG4gICAgXCJNYXJyeVR4dF8yXCI6XCLkvaDlsLHmmK/miJHnmoTlsI/lv4Plv4Ms5oyC5Zyo6YKj5aSp5LiK5pS+5YWJ5piOXCIsXG5cbiAgICBcIkRpc3ZvcmNlXzFcIjpcIuWpmuWnu+S4jeaYkyzkuJTooYzkuJTnj43mg5zvvIzmiJHmhL/mhI/lho3nu5nkvaDkuIDmrKHmnLrkvJrph43mlrDogIPomZHjgIJcIixcbiAgICBcIkRpc3ZvcmNlXzJcIjpcIuW8uuaJreeahOeTnOS5n+S4jeeUnO+8jOimgeemu+Wwseemu+WQp+OAguS7peWQjuaIkeS7rOWQhOiHquWuieWlveOAglwiLFxuICAgIFwiRGlzdm9yY2VfM1wiOlwi5oiR54ix5L2g5LiN5ZCO5oKU77yM5Lmf5bCK6YeN5pWF5LqL57uT5bC+44CCXCIsXG4gICAgXCJEaXN2b3JjZV80XCI6XCLliIbmiYvlupTor6XkvZPpnaLvvIzosIHpg73kuI3opoHor7TmirHmrYnjgIJcIixcbiAgICBcIkRpc3ZvcmNlXzVcIjpcIuemu+W8gOS5n+imgeS9k+mdou+8jOaJjeS4jei+nOi0n+i/meS6m+W5tOOAglwiLFxuICAgIFwiRGlzdm9yY2VfNlwiOlwi5L2g5LiN5b+F5LqP5qyg77yM5oiR5pWi57uZ5bCx5pWi5b+D56KOIOOAglwiLFxuICAgIFwiRGlzdm9yY2VfN1wiOlwi5q2k5ZCO5LiA5Yir5Lik5a6977yM5ZCE55Sf5qyi5Zac44CCXCIsXG4gICAgXCJEaXN2b3JjZV84XCI6XCLlqZrlp7vms5XmsqHmnInop4TlrprkuIDkuKrkurrlv4XpobvniLHkuIDkuKrkurrkuIDovojlrZDvvIzkvaDmsqHmnInplJnjgIJcIixcbiAgICBcIkRpc3ZvcmNlXzlcIjpcIuS9oOecn+eahOimgeS4uuS9oOS4gOaXtueahOWGsuWKqO+8jOWBmuWHuuemu+Wpmui/meS5iOaEmuigoueahOWGs+WumuWQl++8n1wiLFxuICAgIFwiRGlzdm9yY2VfMTBcIjpcIue7k+WpmuaXtuS9oOiuuOeahOivuuiogOmDveWWguS6hueLl+WQl++8n+elneS9oOWSjOS9oOeahOeLl+i/h+W+l+W5uOemj+OAglwiLFxuXG5cbiAgICBcIlJlY292ZXJIZWFsdGhcIjpcIueUseS6juaXpeWknOWKs+S9nO+8jOaCqOeahOWBpeW6t+eKtuWGteWgquW/p++8jOS4pOW5tOWQjuWHuumZolwiLFxuICAgIFwiUmVjb3ZlckhlYWx0aERcIjpcIueUseS6jui1hOS6p+azouWKqOi/h+WkpyzlsI/lv4PohI/mib/lj5fkuI3otbcs5YGl5bq35Y+X5o2f5Lil6YeNLOivt+WPiuaXtuaOpeWPl+ayu+eWl1wiLFxuXG4gICAgLy/pgIDkvJHml7bnmoTnm5bmo7rlrprorrpcbiAgICBcIlJldGlyZV8wXCI6XCLlirPnoozljYrnlJ/vvIzot4zlrpXotbfkvI/vvIzkuZ/msqHmnInkurrnlJ/kvLTkvqPvvIzlj6/osJPmmZrmma/lh4Tlh4nvvIzlh4Tlh4Tmg6jmg6jmiJrmiJrjgIJcIixcbiAgICBcIlJldGlyZV8xXCI6XCLov5nkuIDovojlrZDomb3kuI3nrpflpKflr4zlpKfotLXvvIzkvYbmgLvlvZLkuovkuJrmnInmiJDvvIzlrrbluq3nvo7mu6HvvIzlj6/lronkuqvmmZrlubTjgIJcIixcbiAgICBcIlJldGlyZV8yXCI6XCLkurrnlJ/nmoTmhI/kuYks5LiN5Zyo5LqO5b6X5Yiw5LuA5LmI5oiW5piv5aSx5Y675LuA5LmI44CC5Liw5a+M55qE6ZiF5Y6G44CB55m+5LiH55qE5a625Lqn5bey6K6p5Lq6576h5oWV5LqG44CCXCIsXG4gICAgXCJSZXRpcmVfM1wiOlwi5bCP5pyJ5oiQ5bCx77yM5L2G5aOu5b+X5pyq6YWs44CC4oCc5oyj5a6D5LiA5Liq5Lq/4oCd55qE5a625peP55uu5qCH5Y+q6IO95Lqk57uZ5ZCO5Lq65p2l5aWL5paX5LqG44CCXCIsXG4gICAgXCJSZXRpcmVfNFwiOlwi6Lqr5Lu35Y2D5LiH77yM5pyJ6L2m5pyJ5oi/77yM5Lq655Sf6LWi5a6244CC5pma5bm05a6J6YC477yM5L2g6K+35Lq65Li66Ieq5bex5YaZ5LqG5LiA5pys5Lq655Sf5Zue5b+G5b2V44CCXCIsXG4gICAgXCJSZXRpcmVfNVwiOlwi5Yeg57uP5rKJ5rWu77yM5L2g57uI5LqO5a6e546w5LqG6Ieq5bex55qE5bCP55uu5qCH4oCU4oCU5Lq/5LiH5a+M57+B77yM5oSf6KeJ5Lq655Sf5bey57uP6L6+5Yiw5LqG5beF5bOw44CCXCIsXG4gICAgXCJSZXRpcmVfNlwiOlwi57uP6L+H5Yqq5Yqb77yM5L2g57uI5LqO5byA5LiK5LqG5rOV5ouJ55Ge77yM5L2P5LiK5LqG5Y+k5aCh77yM5a6e546w5LqG6LSi5a+M6Ieq55Sx77yM5q+P5aSp6YO95b6I5byA5b+D44CCXCIsXG5cbiAgICBcbiAgICBcIkRhdGVPdXRfMFwiOlwi5LmF5LmF5LiN6IO95b+Y6K6w55qE77yM5piv5LiO5L2g55u46KeG6YKj5LiA55y855qE5oCm54S25b+D5YqoXCIsXG4gICAgXCJEYXRlT3V0XzFcIjpcIuW5s+eUn+S4jeS8muebuOaAne+8jOaJjeS8muebuOaAne+8jOS+v+Wus+ebuOaAneOAglwiLFxuICAgIFwiRGF0ZU91dF8yXCI6XCLkvaDnmoTphZLnqp3msqHmnInphZLvvIzmiJHljbTphonnmoTlg4/mnaHni5fjgIJcIixcbiAgICBcIkRhdGVPdXRfM1wiOlwi546w5Zyo5omN5piO55m95LuA5LmI5Y+r4oCc5LiA5pel5LiN6KeB77yM5aaC6ZqU5LiJ56eL44CC4oCdXCIsXG4gICAgXCJEYXRlT3V0XzRcIjpcIuWPquaEv+S9oOaIkeS4jei0n+aXtuWFieS4jei0n+WAvuWfjuOAglwiLFxuICAgIFwiRGF0ZU91dF81XCI6XCLkvaDnmoTov4fljrvmiJHmnaXkuI3lj4rlj4LkuI7vvIzkvaDnmoTmnKrmnaXmiJHlpYnpmarliLDlupXjgIJcIixcblxuICAgIFwiUmVjb3ZlckhlYWx0aFwiOlwi55Sx5LqO5pel5aSc5Yqz5L2c77yM5L2g55qE5YGl5bq354q25Ya15aCq5b+n77yM6ZyA55aX5YW75Lik5bm05ZCO5Ye66ZmiXCIsXG5cblxuICAgIC8v5byA5pS+5Y+v57qm5Lya5a+56LGhXG4gICAgXCJVbkxvY2tNYXRlQnlJbkhvc1wiOlwi5L2P6Zmi5pyf6Ze0LOS9oOe7k+ivhuS6huaKpOWjq+WnkOWnkOOAglwiLFxuICAgIFwiVW5Mb2NrTWF0ZV8zXCI6XCLlhazlj7jnmoTogZTosIrkvJrkuIrvvIzkvaDnu5Por4bkuobpoofmnInmsJTotKjnmoToibrmnK/ogIHluIjjgIJcIixcbiAgICBcIlVuTG9ja01hdGVfNFwiOlwi5YmN5Y676ams5bCU5Luj5aSr55qE6Iiq54+t5LiK77yM6YGH5Yiw5LqG5LiA6KeB5YC+5b+D55qE576O5Li956m65aeQ44CCXCIsXG4gICAgXCJVbkxvY2tNYXRlXzVcIjpcIuS9oOe7k+ivhuS6hua4qeaflOaKpOWjq++8jOWPr+e6puS8muWPkeWxleOAglwiLFxuICAgIFwiVW5Mb2NrTWF0ZV82XCI6XCLmnIvlj4vnmoTlkajmnKvovbDotrTkuIrvvIzkvaDnu5Por4bkuobkurrmsJTotoXmqKHjgIJcIixcbiAgICBcIlVuTG9ja01hdGVfN1wiOlwi5LiA5qyh6am05Y+L5peF5ri45Lit77yM5L2g57uT6K+G5LqG55m95a+M576O44CCXCIsXG4gICAgXCJVbkxvY2tNYXRlXzEwXCI6XCLlkIzlrabogZrkvJrvvIzkvaDnu5Por4bkuoblpKflrabmoKHojYlcIixcbiAgICBcIlVuTG9ja01hdGVfMTFcIjpcIuaWsOWOu+eahOengeS6uuWBpei6q+aIv++8jOS9oOe7k+ivhuS6huWwj+mynOiCieOAglwiLFxuICAgIFwiVW5Mb2NrTWF0ZV8xMlwiOlwi5Zyo5aSc6LeR576k77yM5L2g57uT6K+G5LqG5biF5rCU55qE57K+6Iux5b6L5biI77yMXCIsXG4gICAgXCJVbkxvY2tNYXRlXzEzXCI6XCLogIHlpZfnmoTlnLrmma/vvIzkvaDooqvnkIPnoLjkuK3nu5Por4bkuobotrPnkIPpmJ/plb/jgIJcIixcbiAgICBcIlVuTG9ja01hdGVfMTRcIjpcIuWbvemZhemhueebruS6pOa1geS8muS4iu+8jOS9oOe7k+ivhuS6humcuOmBk+aAu+ijgeOAglwiLFxuXG4gICAgXCJUb0RhdGVfMVwiOlwi5oiR54as6L+H5LqG55m96Zuq55qR55qR77yM5Y+q5Li65o2i5LiA5Liq5LiO5ZCb77yI5Y2/77yJ5ZCM5Zyo44CCXCIsXG4gICAgXCJUb0RhdGVfMlwiOlwi6YGH6KeB5L2gLOiKseWFieS6huaIkeaJgOacieeahOi/kOawlOOAglwiLFxuICAgIFwiVG9EYXRlXzNcIjpcIuS9m+ivtDrliY3kuJbnmoTkupTnmb7mrKHlm57nnLjmiY3mjaLmnaXku4rnlJ/nmoTmk6bogqnogIzov4fjgIJcIixcbiAgICBcIlRvRGF0ZV80XCI6XCLmiJHku47msqHmg7Pov4fopoHljZXouqss5Y+q5piv5LiA55u05pyq6IO95LiO5L2g55u46YGH44CCXCIsXG4gICAgXCJUb0RhdGVfNVwiOlwi5LiW55WM6L+Z5LmI5aSn77yM6L+H5a6i6L+Z5LmI5aSa77yM5aW95LiN5a655piT5omN6YGH6KeB5LiA5Liq5L2g44CCXCIsXG5cblxuICAgIFwiSW5IZWFsRG93bkxpbmVcIjpcIuaCqOi/mOWkhOWcqOaBouWkjemYtuaute+8jOebruWJjeS4jeiDveS6pOaYk1wiLFxuICAgIC8vXG4gICAgXCJNYXRlTWFycnlDb25kXzFcIjpcIuaIkei/mOaYr+W4jOacm+aLpeacieS4gOS4quWxnuS6juaIkeS7rOeahOaIv+WtkO+8jOWTquaAleaYr+acgOS+v+WunOeahOW7ieS7t+aIv1wiLFxuICAgIFwiTWF0ZU1hcnJ5Q29uZF8yXCI6XCLmiJHluIzmnJvlvIDnnYDmoqjnlLDovabvvIzkuIDotbfooYzpqbblnKjlubjnpo/nmoTlpKfpgZPkuIpcIixcbiAgICBcIk1hdGVNYXJyeUNvbmRfM1wiOlwi5oiR5qKm5oOz5Zyo5LiA5omA5ryC5Lqu55qE5YWs5a+T6YeM77yM5ZKM5L2g5ryU5aWP54ix55qE5LmQ56ugXCIsXG4gICAgXCJNYXRlTWFycnlDb25kXzRcIjpcIuS7juWwj+aIkeWwseWWnOasouaIkOeGn+eos+mHjeS8geS4muWutu+8jOS9oOWFiOWIm+WKnuS4gOS4quWFrOWPuOWQp1wiLFxuICAgIFwiTWF0ZU1hcnJ5Q29uZF81XCI6XCLmiJHnmoTkvLTkvqPlv4XpobvlkozmiJHkuIDmoLfouqvkvZPlgaXlurdcIixcbiAgICBcIk1hdGVNYXJyeUNvbmRfNlwiOlwi5oiR5oOz6KaB5aSn5aSn55qE5rSL5oi/77yM5pS+5LiK5oiR5omA5pyJ5Zac5qyi55qE6KGj5pyN5ZKM5YyF5YyFXCIsXG4gICAgXCJNYXRlTWFycnlDb25kXzdcIjpcIuaIkeeahOWutuaXj+mcgOimgeS9oOmAmui/h+iAg+mqjOaJjeWFgeiuuOaIkeS7rOWcqOS4gOi1t++8jOWKoOayueWQp+S6sueIseeahFwiLFxuICAgIFwiTWF0ZU1hcnJ5Q29uZF84XCI6XCLorqnmiJHlvIDnnYDovabvvIzluKbkvaDljrvlhZzpo45cIixcbiAgICBcIk1hdGVNYXJyeUNvbmRfOVwiOlwi5oiR5biM5pyb5byA552A5qKo55Sw6L2m77yM5LiA6LW36KGM6am25Zyo5bm456aP55qE5aSn6YGT5LiKXCIsXG4gICAgXCJNYXRlTWFycnlDb25kXzEwXCI6XCLku47kvaDku47lrp3pqazkuIvmnaXnmoTpgqPkuIDliLvvvIzmiJHlsLHooqvkvaDlkLjlvJVcIixcbiAgICBcIk1hdGVNYXJyeUNvbmRfMTFcIjpcIuaIkeS7rOeahOeIseaDhe+8jOS7t+WAvOeZvuS4h1wiLFxuICAgIFwiTWF0ZU1hcnJ5Q29uZF8xMlwiOlwi5oiR5ZKM5LyB5Lia5a6255qE57uT5ZCI77yM5bCG5Lya5piv5by65by66IGU5ZCI55qE5Luj6KGoXCIsXG4gICAgXCJNYXRlTWFycnlDb25kXzEzXCI6XCLov5DliqjlsLHmmK/miJHnmoTnlJ/lkb3vvIzmiJHnmoTkvLTkvqPlv4XpobvlkozmiJHkuIDmoLflgaXlurdcIixcbiAgICBcIk1hdGVNYXJyeUNvbmRfMTRcIjpcIuaIkeeahOWutuaXj+mcgOimgeS9oOmAmui/h+iAg+mqjOaJjeWFgeiuuOaIkeS7rOWcqOS4gOi1t++8jOWKoOayueWQp+S6sueIseeahFwiLFxuXG5cbiAgICAvL+S6i+S7tuaPj+i/sFxuICAgICBcImV2ZW50XzEwMDFcIjpcIuWPguWKoOWFrOWPuOeahOWQg+m4oeavlOi1m++8jOmBh+WIsOe+juWls+Wwj+WnkOWnkOeahOaImOmYn1wiLFxuICAgIFwiZXZlbnRfMTAwMTBcIjpcIuavq+S4jeeVmeaDheiZkOiPnFwiLFxuICAgIFwiZXZlbnRfMTAwMTFcIjpcIuWBh+ijheWkseivr+aUvuawtFwiLFxuICAgIFwiZXZlbnRfMTAwMTJcIjpcIuS9oOiOt+W+l+S6huacrOasoeavlOi1m+eahE1WUFwiLFxuICAgIFwiZXZlbnRfMTAwMTNcIjpcIuS9oOeahOihjOS4uumBreWIsOS6huWls+aAp+WQjOS6i+eahOmEmeinhlwiLFxuICAgIFwiZXZlbnRfMTAwMTRcIjpcIuS9oOeahOihjOS4uumBreWIsOS6hueUt+aAp+WQjOS6i+eahOmEmeinhlwiLFxuICAgIFwiZXZlbnRfMTAwMTVcIjpcIuWwj+WnkOWnkOW+iOW8gOW/g++8jOW5tuWvueS9oOavlOS6huS4quWwj+W/g+W/g1wiLCAgICAgXG5cbiAgICBcImV2ZW50XzEwMDJcIjpcIuS9oOWcqOWSluWVoemmhuWPkeeOsOWlveWfuuWPi+ato+WcqOebuOS6su+8jOS9oOmAieaLqVwiLFxuICAgIFwiZXZlbnRfMTAwMjBcIjpcIuWBt+eskeinguWvn1wiLFxuICAgIFwiZXZlbnRfMTAwMjFcIjpcIuWBh+ijheW3p+mBh1wiLFxuICAgIFwiZXZlbnRfMTAwMjJcIjpcIueci+S6huS4gOmYteaEn+inieWPjOaWuei/m+WxleS4jemUmeS+v+emu+W8gOS6hlwiLFxuICAgIFwiZXZlbnRfMTAwMjNcIjpcIuWlveWPi+WPkeeOsOS6huS9oOeahOWtmOWcqO+8jOW5tuaal+ekuuS9oOemu+W8gFwiLFxuICAgIFwiZXZlbnRfMTAwMjRcIjpcIuWcuumdouS4gOW6puWNgeWIhuWwtOWwrO+8jOWlveWPi+acieeCueeUn+awlFwiLFxuICAgIFwiZXZlbnRfMTAwMjVcIjpcIuWPjOaWuemDveaYr+S9oOeahOaci+WPi++8jOS9oOenr+aegeaSruWQiFwiLCAgIFxuXG4gICAgXCJldmVudF8xMDAzXCI6XCLlnKPor57oioLlv6vliLDkuobvvIzkvaDlh4blpIfpgIHkuIDkuKrnpLzniannu5nlr7nosaFcIixcbiAgICBcImV2ZW50XzEwMDMwXCI6XCLot6/ovrnmkZjkuIDmnLXnjqvnkbBcIixcbiAgICBcImV2ZW50XzEwMDMxXCI6XCLkubDkuIDpg6jmnIDmlrDniLHnlq9cIixcbiAgICBcImV2ZW50XzEwMDMyXCI6XCLlr7nosaHlpLjotZ7kvaDmmK/kuKrmtarmvKvnmoTkurpcIixcbiAgICBcImV2ZW50XzEwMDMzXCI6XCLkvaDooqvoirHlnIPnmoTkuLvkurrov73kuobljYrmnaHooZdcIixcbiAgICBcImV2ZW50XzEwMDM0XCI6XCLmiYvmnLrkv6Hlj7flpKrlt67vvIzlr7nosaHmmI7mmL7lvIDlp4vlhrfokL3kvaBcIixcbiAgICBcImV2ZW50XzEwMDM1XCI6XCLlvIDlv4PliLDniIbvvIzlubbpgIHkvaDkuIDkuKrms5XlvI/ng63lkLtcIiwgICAgXG5cbiAgICBcImV2ZW50XzEwMDRcIjpcIuaci+WPi+aOqOiNkOS9oOWPguWKoOS4gOS4quaAu+ijgeWtpuS5oOePre+8jOWtpui0ueaYgui0tVwiLFxuICAgIFwiZXZlbnRfMTAwNDBcIjpcIui1tue0p+aKpeWQjVwiLFxuICAgIFwiZXZlbnRfMTAwNDFcIjpcIuaUvuW8g+WPguWKoFwiLFxuICAgIFwiZXZlbnRfMTAwNDJcIjpcIuiusuivvueahOiAgeW4iOmDveaYr+Wkp+S9rO+8jOWQjOWtpuS6uuiEieS5n+W+iOWuveW5v1wiLFxuICAgIFwiZXZlbnRfMTAwNDNcIjpcIuS4iuivvuesrOS4gOWkqeWwseWPkeeOsOiiq+W/veaCoFwiLFxuICAgIFwiZXZlbnRfMTAwNDRcIjpcIuiusuivvueahOiAgeW4iOmDveaYr+Wkp+S9rO+8jOmUmeWkseacuuS8mlwiLFxuICAgIFwiZXZlbnRfMTAwNDVcIjpcIuWQrOivtOmDveaYr+W/veaCoO+8jOW6huW5uOS4jeW3slwiLCAgICBcblxuICAgIFwiZXZlbnRfMTAwNVwiOlwi5Y+w6aOO5p2l6KKt77yM5aSn5pq06Zuo6K6p5LuT5bqT5byA5aeL5rW45rC0XCIsXG4gICAgXCJldmVudF8xMDA1MFwiOlwi57uE57uH5ZGY5bel5o6S5rC0XCIsXG4gICAgXCJldmVudF8xMDA1MVwiOlwi6K+35LiT5Lia5Lq65aOr5o6S5rC0XCIsXG4gICAgXCJldmVudF8xMDA1MlwiOlwi5aSn5a625Zui57uT5LiA6Ie077yM5pyA57uI6Kej5Yaz5LqG6Zeu6aKYXCIsXG4gICAgXCJldmVudF8xMDA1M1wiOlwi6Zuo5Yq/5aSq5aSn77yM6Jm954S25ouv5pWR5LqG6LSn5ZOB77yM5L2G5ZGY5bel6ZuG5L2T5oSf5YaS55Sf55eF5LqGXCIsXG4gICAgXCJldmVudF8xMDA1NFwiOlwi5LiT5Lia5Lq65aOr6YCa6L+H5LiT55So6K6+5aSH77yM6L+F6YCf6Kej5Yaz5LqG6Zeu6aKYXCIsXG4gICAgXCJldmVudF8xMDA1NVwiOlwi5LiT5Lia5Lq65aOr6YCa6L+H5LiT55So6K6+5aSH77yM6L+F6YCf6Kej5Yaz5LqG6Zeu6aKYXCIsXG4gXG5cbiAgICBcImV2ZW50XzEwMDZcIjpcIuWPiOaYr+S4gOW5tOeahOWwvuWjsO+8jOWFrOWPuOW5tOS8muaWueahiOS5n+aPkOS4iuaXpeeoi+OAguWcuuWcsOmAieWcqOWTquWRolwiLFxuICAgIFwiZXZlbnRfMTAwNjBcIjpcIuS6lOaYn+mFkuW6l1wiLFxuICAgIFwiZXZlbnRfMTAwNjFcIjpcIuWGnOWutuS5kFwiLFxuICAgIFwiZXZlbnRfMTAwNjJcIjpcIuW5tOS8muWcuumdouW+iOWkp+awlO+8jOWkp+WutumDveW+iOiHquixqu+8jOW5suWKsuWNgei2s1wiLFxuICAgIFwiZXZlbnRfMTAwNjNcIjpcIuWkp+Wutua1t+WQg+a1t+WWne+8jOaUr+WHuuS4jeWwj1wiLFxuICAgIFwiZXZlbnRfMTAwNjRcIjpcIuawlOawm+W+iOmaj+aEj++8jOWkp+WutuW8gOW8gOW/g+W/g+aAu+e7k+S6huS4gOW5tOeahOaUtuebilwiLFxuICAgIFwiZXZlbnRfMTAwNjVcIjpcIuawlOawm+W+iOmaj+aEj++8jOWkp+WutuW8gOW8gOW/g+W/g+aAu+e7k+S6huS4gOW5tOeahOaUtuebilwiLCAgXG5cbiAgICBcImV2ZW50XzEwMDdcIjpcIuW8gOW5tOWIqeaYr++8jOihjOaUv+Wwj+WnkOWnkOmXruimgeWHhuWkh+WkmuWwkeS4que6ouWMheWPkee7meWkp+WutlwiLFxuICAgIFwiZXZlbnRfMTAwNzBcIjpcIumDqOWIhuWRmOW3peaJjeaciVwiLFxuICAgIFwiZXZlbnRfMTAwNzFcIjpcIuaJgOacieWRmOW3pemDveaciVwiLFxuICAgIFwiZXZlbnRfMTAwNzJcIjpcIumihuWIsOeahOWwj+S8meS8tOe6t+e6t+i1nuaJrOS9oFwiLFxuICAgIFwiZXZlbnRfMTAwNzNcIjpcIuayoemihuWIsOeahOWwj+S8meS8tOihqOekuuS4jea7oVwiLFxuICAgIFwiZXZlbnRfMTAwNzRcIjpcIuWkp+WutumDveW+iOW8gOW/g++8jOW3peS9nOaViOeOh+aPkOWNh1wiLFxuICAgIFwiZXZlbnRfMTAwNzVcIjpcIuWkp+WutumDveW+iOW8gOW/g++8jOW3peS9nOaViOeOh+aPkOWNh1wiLFxuXG4gICAgXCJldmVudF8xMDA4XCI6XCLlkZjlt6XlnKjljoLmiL/mkKznoJbml7bvvIzlj5HnjrDkuIDkuKrlnLDnqpZcIixcbiAgICBcImV2ZW50XzEwMDgwXCI6XCLkuIDmjqLnqbbnq59cIixcbiAgICBcImV2ZW50XzEwMDgxXCI6XCLkuIrmiqXlm73lrrZcIixcbiAgICBcImV2ZW50XzEwMDgyXCI6XCLph4zpnaLpu5HlkpXpmoblkprvvIzkuIDkuI3lsI/lv4PmkZTkuobkuIDot6RcIixcbiAgICBcImV2ZW50XzEwMDgzXCI6XCLkuIDnlarmjqLntKLvvIzlj5HnjrDkuIDkupvlrZfnlLtcIixcbiAgICBcImV2ZW50XzEwMDg0XCI6XCLojrflvpflpKflipvooajmiazlpJbliqDkuIDpnaLplKbml5dcIixcbiAgICBcImV2ZW50XzEwMDg1XCI6XCLojrflvpflpKflipvooajmiazlpJbliqDkuIDpnaLplKbml5dcIiwgIFxuXG4gICAgXCJldmVudF8xMDA5XCI6XCLogqHluILot4znqb/ogqHngb7kvY7ngrnvvIzliJrlpb3kvaDmiYvkuIrmnInkuIDnrJTotYTph5HjgILkvaDpgInmi6lcIixcbiAgICBcImV2ZW50XzEwMDkwXCI6XCLlhajpg6jkubDlhaVcIixcbiAgICBcImV2ZW50XzEwMDkxXCI6XCLnu6fnu63op4Llr59cIixcbiAgICBcImV2ZW50XzEwMDkyXCI6XCLogqHluILliafng4jpnIfojaHvvIzkvaDlv4PohI/mnInngrnlj5fkuI3kuoZcIixcbiAgICBcImV2ZW50XzEwMDkzXCI6XCLlvLrlipvlj43lvLnvvIzov57nu63mtqjlgZxcIixcbiAgICBcImV2ZW50XzEwMDk0XCI6XCLop4LmnJvmnaXop4LmnJvljrvvvIzkvaDmnIDnu4jov5jmmK/pgInmi6nmlL7lvINcIixcbiAgICBcImV2ZW50XzEwMDk1XCI6XCLlj5HnjrDkuIDkuKrmnLrkvJrvvIzkvY7kvY3kubDlhaXlsI/otZrkuIDnrJRcIiwgICAgICBcblxuICAgIFwiZXZlbnRfMTAxMFwiOlwi5pyA6L+R5YWs5Y+45LqL5Yqh57mB5b+Z77yM6Lqr5b+D5oSf5Yiw5pyJ5Lqb55ay5oOr44CCXCIsXG4gICAgXCJldmVudF8xMDEwMFwiOlwi5L2/55So5YWo5YGl54Gr55aXXCIsXG4gICAgXCJldmVudF8xMDEwMVwiOlwi5om+5Liq5rW35bKb5bqm5YGHXCIsXG4gICAgXCJldmVudF8xMDEwMlwiOlwi5oSf6KeJ5aW95YOP5pyJ6YKj5LmI54K55pWI5p6c77yM5Lmf6K645piv5b+D6YeM5L2c55SoXCIsXG4gICAgXCJldmVudF8xMDEwM1wiOlwi5L2T6aqM5LmL5ZCO6L+Y6KKr5Lq65b+95oKg5Yqe5LqG5Liq5Lya5ZGY5Y2hXCIsXG4gICAgXCJldmVudF8xMDEwNFwiOlwi54Gr5bGx5Za35Y+R5a+86Ie05Zyo5bKb5LiK5rue55WZ5LqG5Yeg5aSp5b2x5ZON5LqG5bel5L2c6K6h5YiSXCIsXG4gICAgXCJldmVudF8xMDEwNVwiOlwi5bqm5YGH5LmL5ZCO5ruh6KGA5aSN5rS777yM6YeN5paw5oqV5YWl5bel5L2cXCIsICAgIFxuXG4gICAgXCJldmVudF8xMDExXCI6XCLkvaDmlLbliLDkuL7miqXvvIzlhazlj7jnmoTotKLliqHmiqXooajlrZjlnKjlgbfnqI7mvI/nqI7nmoTmg4XlhrVcIixcbiAgICBcImV2ZW50XzEwMTEwXCI6XCLmib7lhazlj7josIPmn6VcIixcbiAgICBcImV2ZW50XzEwMTExXCI6XCLkv6Hku7votKLliqHkuLvnrqFcIixcbiAgICBcImV2ZW50XzEwMTEyXCI6XCLlj4rml7blj5HnjrDkuobpl67popjlubblpqXlloTlpITnkIZcIixcbiAgICBcImV2ZW50XzEwMTEzXCI6XCLmsqHmnInlj5HnjrDpl67popjvvIzlhazlj7jmraPluLjov5DokKVcIixcbiAgICBcImV2ZW50XzEwMTE0XCI6XCLooqvmnInlhbPpg6jpl6jlj5HnjrDlubbnvZrmrL5cIixcbiAgICBcImV2ZW50XzEwMTE1XCI6XCLlhazlj7jmraPluLjov5DokKVcIiwgICBcblxuICAgIFwiZXZlbnRfMTAxMlwiOlwi5Zug566h55CG5LiN5ZaE77yM6YOo5YiG6LSn5ZOB6LaF5Ye65LqG5L+d6LSo5pyfXCIsXG4gICAgXCJldmVudF8xMDEyMFwiOlwi5omT5oqY5aSE55CGXCIsXG4gICAgXCJldmVudF8xMDEyMVwiOlwi5YWo6YOo6ZSA5q+BXCIsXG4gICAgXCJldmVudF8xMDEyMlwiOlwi5raI6LS56ICF5Y+R546w5bm254iG5paZ57uZ5paw6Ze7XCIsXG4gICAgXCJldmVudF8xMDEyM1wiOlwi5raI6LS56ICF5Y+R546w5bm25oqV6K+J6LWU5YG/XCIsXG4gICAgXCJldmVudF8xMDEyNFwiOlwi5LyX5Lq66Z2e5bi46K6k5Y+v5L2g55qE5ouF5b2T5ZKM6LSj5Lu777yM6ZuG5L2T6I2j6KqJ5oSf5LiK5Y2HXCIsXG4gICAgXCJldmVudF8xMDEyNVwiOlwi5LyX5Lq66Z2e5bi46K6k5Y+v5L2g55qE5ouF5b2T5ZKM6LSj5Lu777yM6ZuG5L2T6I2j6KqJ5oSf5LiK5Y2HXCIsICAgIFxuXG4gICAgXCJldmVudF8xMDEzXCI6XCLnvZHnu5znm7Tmkq3lhbTotbfvvIzkvaDlsJ3or5XlkozkuLvmkq3lkIjkvZzov5vooYzov5DokKXmtLvliqjjgIJcIixcbiAgICBcImV2ZW50XzEwMTMwXCI6XCLmvILkuq7kvJjlhYhcIixcbiAgICBcImV2ZW50XzEwMTMxXCI6XCLkurrmsJTkvJjlhYhcIixcbiAgICBcImV2ZW50XzEwMTMyXCI6XCLmtLvliqjmlYjmnpzlj43lupTlubPlubNcIixcbiAgICBcImV2ZW50XzEwMTMzXCI6XCLmtLvliqjmlYjmnpzlj43lupTlubPlubNcIixcbiAgICBcImV2ZW50XzEwMTM0XCI6XCLmtLvliqjlj43lk43kuI3plJnvvIzmiZPlvIDkuobmlrDnmoTplIDot69cIixcbiAgICBcImV2ZW50XzEwMTM1XCI6XCLmtLvliqjlj43lk43kuI3plJnvvIzmiZPlvIDkuobmlrDnmoTplIDot69cIiwgIFxuXG4gICAgXCJldmVudF8xMDE0XCI6XCLlhbHkuqvljZXovabov5vlhaXkurrku6znlJ/mtLvvvIzkvaDmg7PlnKjovabouqvmipXmlL7lub/lkYrjgIJcIixcbiAgICBcImV2ZW50XzEwMTQwXCI6XCLlsI/pu4TovaZcIixcbiAgICBcImV2ZW50XzEwMTQxXCI6XCLlsI/nuqLovaZcIixcbiAgICBcImV2ZW50XzEwMTQyXCI6XCLlsI/pu4TovabpmbflhaXmirzph5Hpo47ms6Is5bm/5ZGK5aSx6LSlXCIsXG4gICAgXCJldmVudF8xMDE0M1wiOlwi5bCP6buE6L2m6Zm35YWl5oq86YeR6aOO5rOiLOW5v+WRiuWksei0pVwiLFxuICAgIFwiZXZlbnRfMTAxNDRcIjpcIuWwj+e6oui9puiiq+aUtui0re+8jOW5v+WRiuaViOaenOS4gOiIrFwiLFxuICAgIFwiZXZlbnRfMTAxNDVcIjpcIuWwj+e6oui9puiiq+aUtui0re+8jOW5v+WRiuaViOaenOS4gOiIrFwiLCAgXG5cbiAgICBcImV2ZW50XzEwMTVcIjpcIuWbvemZhei0uOaYk+WFs+ezu+e0p+W8oO+8jOWImuWlveS9oOaDs+aNouS4gOmDqOaWsOaJi+aculwiLFxuICAgIFwiZXZlbnRfMTAxNTBcIjpcIuWbvei0p+S8mOWFiFwiLFxuICAgIFwiZXZlbnRfMTAxNTFcIjpcIui/m+WPo+S8mOWFiFwiLFxuICAgIFwiZXZlbnRfMTAxNTJcIjpcIuaOkumYn+aKoui0reeahOS6uuWkquWkmu+8jOS9oOS4jeW+l+S4jeWKoOS7t+i0reS5sFwiLFxuICAgIFwiZXZlbnRfMTAxNTNcIjpcIuWQhOaWuemdouaViOaenOWImuWImueahO+8jOS9oOaKiuWug+aOqOiNkOe7mei6q+i+ueeahOaci+WPi1wiLFxuICAgIFwiZXZlbnRfMTAxNTRcIjpcIuaJi+acuuS/oeWPt+S4jeWkqueos+Wumu+8jOWvvOiHtOacieS6m+eUn+aEj+eUteivneayoeaOpeWIsFwiLFxuICAgIFwiZXZlbnRfMTAxNTVcIjpcIuezu+e7n+S9k+mqjOehruWunuS4nea7keaflOmhuu+8jOS9oOaOqOiNkOe7mei6q+i+ueeahOaci+WPi1wiLCAgICAgXG5cbiAgICBcImV2ZW50XzEwMTZcIjpcIuWQiOWQjOS6pOS7mOaXtumXtOWwhuiHs++8jOmcgOimgeWRmOW3peWKoOePreWKoOW/q+i/m+W6pu+8jOS9oOWmguS9lea/gOWKsVwiLFxuICAgIFwiZXZlbnRfMTAxNjBcIjpcIuWPjOWAjeW3pei1hFwiLFxuICAgIFwiZXZlbnRfMTAxNjFcIjpcIueUu+S4quWkp+mlvFwiLFxuICAgIFwiZXZlbnRfMTAxNjJcIjpcIui/m+W6pue7iOS6jui1tuS4iu+8jOS9oOe7iOS6juadvuS6huS4gOWPo+awlFwiLFxuICAgIFwiZXZlbnRfMTAxNjNcIjpcIumDqOWIhuWRmOW3peWKoOePreWkqueMm++8jOW3rueCueiuqeS9oOegtOS6p1wiLFxuICAgIFwiZXZlbnRfMTAxNjRcIjpcIui/m+W6pue7iOS6jui1tuS4iu+8jOS9huS9oOWNtOe0r+WAkuS6hlwiLFxuICAgIFwiZXZlbnRfMTAxNjVcIjpcIuaViOaenOS4jeS9s++8jOWQiOWQjOacgOe7iOayoeacieWujOaIkFwiLCAgXG5cbiAgICBcImV2ZW50XzEwMTdcIjpcIuS9oOS7iuWkqemcgOimgemdouingeS4pOS4quWIm+S4muWboumYn++8jOWGs+WumuWvueWTquS4qui/m+ihjOWkqeS9v+aKlei1hFwiLFxuICAgIFwiZXZlbnRfMTAxNzBcIjpcIuaDs+aUueWPmOS4lueVjOeahOmdkuW5tOWboumYn1wiLFxuICAgIFwiZXZlbnRfMTAxNzFcIjpcIuWkp+WOguiDjOaZr+eahOi1hOa3seWboumYn1wiLFxuICAgIFwiZXZlbnRfMTAxNzJcIjpcIuWHreWAn+edgOa0u+WKm+WSjOa/gOaDhe+8jOS7luS7rOacgOe7iOWcqOW4guWcuuermeeos+S6huOAglwiLFxuICAgIFwiZXZlbnRfMTAxNzNcIjpcIuacgOe7iOi/mOaYr+ayoeacieWunueOsO+8jOS9huS9oOi/mOaYr+eci+WlveS7luS7rFwiLFxuICAgIFwiZXZlbnRfMTAxNzRcIjpcIuS7luS7rOeahOS6p+WTgeWcqOS9oOeahOW4ruWKqeS4i+i/hemAn+eahOWNoOmihuS6huW4guWculwiLFxuICAgIFwiZXZlbnRfMTAxNzVcIjpcIuiEseemu+S6huWkp+WOguW5s+WPsO+8jOS7luS7rOemu+aIkOWKn+i/mOaYr+W3ruS6huS4gOeCuVwiLCAgICBcblxuICAgIFwiZXZlbnRfMTAxOFwiOlwi5byA6L2m6Lev6L+H5p+Q6ICB5Z+O5Yy66KGX6YGT77yM55y855yL5YmN5pa55LiA6ICB5Lq65YCS5Zyw5LiN6LW3XCIsXG4gICAgXCJldmVudF8xMDE4MFwiOlwi55u05o6l6Lev6L+HXCIsXG4gICAgXCJldmVudF8xMDE4MVwiOlwi5LiL6L2m5p+l55yLXCIsXG4gICAgXCJldmVudF8xMDE4MlwiOlwi5LqL5ZCO5YaF5b+D5LiA55u06KeJ5b6X5oSn55aaXCIsXG4gICAgXCJldmVudF8xMDE4M1wiOlwi5LqL5ZCO5YaF5b+D5LiA55u06KeJ5b6X5oSn55aaXCIsXG4gICAgXCJldmVudF8xMDE4NFwiOlwi5Y2z5pe26YCB5b6A5Yy76Zmi5aSE55CG77yM5a625Lq65oSf5r+A5LiN5bC9XCIsXG4gICAgXCJldmVudF8xMDE4NVwiOlwi5Y6f5p2l5piv56Kw55O377yM5bm45aW95oiR5pyJ6KGM6L2m6K6w5b2V5LuqXCIsICBcblxuICAgIFwiZXZlbnRfMTAxOVwiOlwi5LyB5Lia5a625oWI5ZaE5ouN5Y2W5Lya77yM5pyJ5Lik5Liq5ouN5Y2W5ZOB5L2g6YO95pyJ5YW06LajXCIsXG4gICAgXCJldmVudF8xMDE5MFwiOlwi5LiA5o635Y2D6YeR5YWo6YOo5Lmw5LiLXCIsXG4gICAgXCJldmVudF8xMDE5MVwiOlwi5Lmw5YWl5Lu35qC85L2O55qEXCIsXG4gICAgXCJldmVudF8xMDE5MlwiOlwi5L2g5Zyo5ouN5Y2W5Lya5LiK5Li66Ieq5bex6LWi5b6X5LqG576O5ZCNXCIsXG4gICAgXCJldmVudF8xMDE5M1wiOlwi5L2g5Zyo5ouN5Y2W5Lya5LiK5Li66Ieq5bex6LWi5b6X5LqG576O5ZCNXCIsXG4gICAgXCJldmVudF8xMDE5NFwiOlwi5L2g5bCG5a6D5pS+5Zyo5Yqe5YWs5qGM5LiK77yM5pe25Yi76Z6t562W5L2gXCIsXG4gICAgXCJldmVudF8xMDE5NVwiOlwi5L2g5bCG5a6D5pS+5Zyo5Yqe5YWs5qGM5LiK77yM5pe25Yi76Z6t562W5L2gXCIsICAgICAgICBcblxuICAgIFwiZXZlbnRfMTAyMFwiOlwiIOaUv+W6nOm8k+WKsea2iOi0ue+8jOWwj+minei0t+asvumcgOaxgua0u+i3g1wiLFxuICAgIFwiZXZlbnRfMTAyMDBcIjpcIuWKoOWkp+Wuo+S8oFwiLFxuICAgIFwiZXZlbnRfMTAyMDFcIjpcIueFp+W4uOe7j+iQpVwiLFxuICAgIFwiZXZlbnRfMTAyMDJcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMDNcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMDRcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLFxuICAgIFwiZXZlbnRfMTAyMDVcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLCAgICAgICAgXG5cbiAgICBcImV2ZW50XzEwMjFcIjpcIui2iuadpei2iuWkmueahOe+pOS8l+S5oOaDr+e9kei0re+8jOeUteWVhueJqea1gemcgOaxguaUgOWNh1wiLFxuICAgIFwiZXZlbnRfMTAyMTBcIjpcIuaJqeWkp+W7uuiuvlwiLFxuICAgIFwiZXZlbnRfMTAyMTFcIjpcIueFp+W4uOe7j+iQpVwiLFxuICAgIFwiZXZlbnRfMTAyMTJcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMTNcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMTRcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLFxuICAgIFwiZXZlbnRfMTAyMTVcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLCBcblxuICAgICBcImV2ZW50XzEwMjJcIjpcIuWkluWNluW4guWcuui2iuadpei2iuWkp++8jOi/numUgemkkOmlruaYr+WQpuWKoOWFpeWkluWNluW5s+WPsFwiLFxuICAgIFwiZXZlbnRfMTAyMjBcIjpcIuenr+aegeWKoOWFpVwiLFxuICAgIFwiZXZlbnRfMTAyMjFcIjpcIueFp+W4uOe7j+iQpVwiLFxuICAgIFwiZXZlbnRfMTAyMjJcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMjNcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMjRcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLFxuICAgIFwiZXZlbnRfMTAyMjVcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLCAgICAgICAgXG5cbiAgICBcImV2ZW50XzEwMjNcIjpcIuaWsOeUn+S7o+S4reS6p+mYtue6p+W0m+i1t++8jOmHkeiejeS/nemZqemcgOaxgui2iuadpei2iumrmFwiLFxuICAgIFwiZXZlbnRfMTAyMzBcIjpcIuWKoOW8uumUgOWUrlwiLFxuICAgIFwiZXZlbnRfMTAyMzFcIjpcIueFp+W4uOe7j+iQpVwiLFxuICAgIFwiZXZlbnRfMTAyMzJcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMzNcIjpcIuaKk+S9j+acuuS8mu+8jOWGjeWIm+aWsOmrmFwiLFxuICAgIFwiZXZlbnRfMTAyMzRcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLFxuICAgIFwiZXZlbnRfMTAyMzVcIjpcIumUmeWkseacuuS8mu+8jOWQjuaClOS4jeW3slwiLCBcblxuXG4gICAgXCJldmVudF8xMDI0XCI6XCLkuprlgaXlurfnjrDosaHotormnaXotormma7pgY3vvIzkv53lgaXpo5/lk4HluILlnLrmnInmnJvniIblj5FcIixcbiAgICBcImV2ZW50XzEwMjQwXCI6XCLmiqLlpLrluILlnLpcIixcbiAgICBcImV2ZW50XzEwMjQxXCI6XCLnhafluLjnu4/okKVcIixcbiAgICBcImV2ZW50XzEwMjQyXCI6XCLmipPkvY/mnLrkvJrvvIzlho3liJvmlrDpq5hcIixcbiAgICBcImV2ZW50XzEwMjQzXCI6XCLmipPkvY/mnLrkvJrvvIzlho3liJvmlrDpq5hcIixcbiAgICBcImV2ZW50XzEwMjQ0XCI6XCLplJnlpLHmnLrkvJrvvIzlkI7mgpTkuI3lt7JcIixcbiAgICBcImV2ZW50XzEwMjQ1XCI6XCLplJnlpLHmnLrkvJrvvIzlkI7mgpTkuI3lt7JcIiwgIFxuXG4gICAgLy/nianlk4Hmj4/ov7BcblxuICAgIC8v5biC5Zy66KGM5oOFICBcblx0XCJNYXJrZXRfMlwiOlwi5Yy65Z2X6ZO+5qaC5b+15aSn54Gr77yM6YeR5biB5Lu35qC85oyB57ut6auY5raoXCIsXG4gICAgXCJNYXJrZXRfMVwiOlwi6Jma5ouf5biB55qE5Y+R6KGM6KKr566h5o6n77yM6YeR5biB5Lu35qC85LiA6JC95Y2D5LiIXCIsXG4gICAgXCJNYXJrZXRfNFwiOlwi5rC05p6c5omL5py65YWo5paw5aSW6KeC5LiK5biC77yM57KJ5Lid5o6S5oiQ6ZW/6Zif55av54uC5oqi6LStXCIsXG5cdFwiTWFya2V0XzNcIjpcIuWumuS7t+i/h+mrmO+8jOWwj+mXrumimOS4jeaWreOAguawtOaenOaJi+acuuS7t+agvOi3jOWFpeS9juiwt1wiLFxuICAgIFwiTWFya2V0XzZcIjpcIuW4guWcuueDremSsea2jOWKqO+8jOWkp+W4iOWtl+eUu+WcqOaLjeWNluihjOS7t+agvOS4gOmjnuWGsuWkqVwiLFxuICAgIFwiTWFya2V0XzVcIjpcIue7j+a1juW9ouWKv+aCsuingu+8jOiJuuacr+aKlei1hOWHj+Wwke+8jOWkp+W4iOWtl+eUu+aXoOS6uumXrua0pVwiLFxuXHRcIk1hcmtldF84XCI6XCLljLrln5/lsYDlir/ntKflvKDvvIzlhrLnqoHkuIDop6bljbPlj5HjgILpu4Tph5Hku7fmoLzpobrlir/mmrTmtqhcIixcbiAgICBcIk1hcmtldF83XCI6XCLlm73lpJbmipXmnLrlir/lipvlpKfogoblgZrnqbrpu4Tph5HvvIzku7fmoLzkuIDot6/kuIvmu5FcIixcbiAgICBcIk1hcmtldF8xMFwiOlwi6aOe5Lq655CD6Z6L6IGU5ZCI5pyA54Gr6L+Q5Yqo5piO5pif77yM5omT6YCg5aSn5Y+X5aW96K+E55qE6ZmQ6YeP54+N6JeP54mI44CCXCIsXG5cdFwiTWFya2V0XzlcIjpcIuWvueaJi+eIhuasvuS4iuW4gu+8jOmjnuS6uueQg+mei+aXoOS6uumXrua0peS9juS7t+WHuuWUrlwiLFxuICAgIFwiTWFya2V0XzEyXCI6XCLnvZHkvKDlpKfokpzog73mnInmlYjpooTpmLLmtYHmhJ/vvIzluILlnLrkuIDmiavogIznqbrjgIJcIixcbiAgICBcIk1hcmtldF8xMVwiOlwi5Y675bm05aSn6JKc5aSn5Liw5pS277yM5biC5Zy66ZyA5rGC5LiN6Laz5rue6ZSA5Lil6YeN44CCXCIsXG5cdFwiTWFya2V0XzE0XCI6XCLmuLjmiI/miJjpmJ/ojrflvpfkuJbnlYzlhqDlhpvvvIzlkLjlvJXlpKfph4/nlKjmiLfotK3kubDmuLjmiI/otKblj7dcIixcbiAgICBcIk1hcmtldF8xM1wiOlwi5pyN5Yqh5Zmo5Ye6546w5Lil6YeN6Zeu6aKY77yM5ri45oiP6LSm5Y+36YGt5Yiw546p5a625pS+5byDXCIsXG4gICAgXCJNYXJrZXRfMTZcIjpcIuaXoOS6uuacuue7reiIquWSjOaLjeeFp+iOt+W+l+mHjeWkp+eqgeegtO+8jOS+m+S4jeW6lOaxglwiLFxuXHRcIk1hcmtldF8xNVwiOlwi5peg5Lq65py65a6J5YWo5LqL5pWF6aKR5Y+R77yM5peg5Lq65py65biC5Zy65pqC5pe254aE54GrXCIsXG4gICAgXCJNYXJrZXRfMThcIjpcIuS4gOe6v+aYjuaYn+S7o+iogOWlouS+iOWMheWMhe+8jOWPl+WIsOaXtuWwmui+vuS6uuS7rOeahOi/veaNp1wiLFxuICAgIFwiTWFya2V0XzE3XCI6XCLliqjniankv53miqTljY/kvJrmjqfor4nlpaLkvojlk4HljIXljIXkvKTlrrPliqjnianvvIzlvJXotbflhazmsJHlhbPms6jjgIJcIixcblx0XCJNYXJrZXRfMjBcIjpcIuS7iuW5tOWvkua1geWKoOWJp++8jOe+juinguWPiOS/neaalueahOearuiNieWkp+iho+a3seWPl+W4guWcuuWlveivhFwiLFxuICAgIFwiTWFya2V0XzE5XCI6XCLmmpblhqznjrDosaHlr7zoh7Tnqb/kuIDku7blpJblpZfotrPku6XvvIznmq7ojYnlpKfooaPmnZ/kuYvpq5jpmIFcIixcbiAgICBcIk1hcmtldF8yMlwiOlwi6aaZ5rC05ZWG5a626IGU5ZCI5pyA54Gr576O5aWz5piO5pif5Y+R5biD5paw5ZOB5bm/5ZGK77yM6ZSA6YeP54yb5aKeXCIsXG5cdFwiTWFya2V0XzIxXCI6XCLnvZHnu5zmrYzmm7LjgIrpppnmsLTmnInmr5LjgIvllLHlk43lkITlpKfmmZrkvJrvvIzlpKflrrbnq5/kv6Hku6XkuLrnnJ/jgIJcIixcbiAgICBcIk1hcmtldF8yNFwiOlwi5rW35reY5bmz5Y+w5pmu5Y+K44CC5ZCE56eN6L+b5Y+j6Zu26aOf6L+b5YWl5Y2D5a625LiH5oi355qE5a625LitXCIsXG4gICAgXCJNYXJrZXRfMjNcIjpcIui/kOi+k+aXtumXtOS5heWSjOS7t+agvOWBj+i0te+8jOi/m+WPo+mbtumjn+mUgOmHj+aJk+aKmOWHuuWUrlwiLFxuXHRcIk1hcmtldF8yNVwiOlwi5LuK5bm05biC5Zy66KGM5oOF5bmz56izXCIsXG5cblx0Ly/lpKnotYvmioDog71cblx0XCJUZl8xXCI6XCLlop7liqDliJ3lp4vku5PlupNcIixcblx0XCJUZl8yXCI6XCLnuqbkvJrmiJDlip/mpoLnjofmj5DljYdcIixcbiAgICBcIlRmXzNcIjpcIuavj+W5tOmineWkluiOt+W+l+mHkemSsVwiLFxuXHRcIlRmXzRcIjpcIuWinuWKoOWIneWni+mHkemSsVwiLFxuXHRcIlRmXzVcIjpcIuWinuWKoOWFrOWPuOaUtuebiueOh1wiLFxuXHRcIlRmXzZcIjpcIuWFrOWPuOiCoeS7t+S4iua2qOamgueOh+aPkOWNh1wiLFxuXHRcIlRmXzdcIjpcIuWutuaXj+Wkqei1i+eCuee7k+eul+aPkOWNh1wiLFxuXHRcIlRmXzhcIjpcIue6puS8muiKsei0uemZjeS9jlwiLFxuXHRcIlRmXzlcIjpcIuWoseS5kOiOt+WlluamgueOh+aPkOWNh1wiLFxuXHRcIlRmXzEwXCI6XCLpgIDkvJHlubTpmZDlu7bplb9cIixcblx0XCJUZl8xMVwiOlwi5aKe5Yqg5Yid5aeL5ZCN5aOwXCIsXG5cdFwiVGZfMTJcIjpcIui0reS5sOaxvei9puS7t+agvOmZjeS9jlwiLFxuXHRcIlRmXzEzXCI6XCLkuovku7bph5HpkrHmtojogJfpmY3kvY5cIixcblx0XCJUZl8xNFwiOlwi6LSt5Lmw5L2P5a6F5Lu35qC86ZmN5L2OXCIsXG5cblx0Ly/miJDlsLHkuIDnlJ/kuK3lhazlj7jov57nu63lgJLpl6015qyhXG4gICAgXCJDal8xXCI6XCLmgLvotYTkuqfovr7liLAx5Lq/XCIsXG5cdFwiQ2pfMlwiOlwi5LiA55Sf5Lit6L+b6L+HM+asoeWMu+mZolwiLFxuICAgIFwiQ2pfM1wiOlwi5LiA55Sf5Lit5YWs5Y+46L+e57ut5YCS6ZetNeasoVwiLFxuICAgIFwiQ2pfNFwiOlwi5LiA55Sf5Lit6L+e57ut5Yib5LiaM+asoVwiLFxuXHRcIkNqXzVcIjpcIjMw5bKB5YmN6LWE5Lqn6L6+5YiwMTAwMOS4h1wiLFxuICAgIFwiQ2pfNlwiOlwi6L6+5Yiw5LiA5Lq/5pe2IOW5tOm+hOi2hei/hzYw5bKBXCIsXG5cdFwiQ2pfN1wiOlwi5LiA55Sf5pyq5pyJ5Ly05L6j5LiU6LWE5Lqn5L2O5LqOMTAw5LiHXCIsXG5cdFwiQ2pfOFwiOlwi5LiA55Sf5pyq5pyJ5Ly05L6j5LiU6LWE5Lqn5aSn5LqOMjAwMOS4h1wiLFxuICAgIFwiQ2pfOVwiOlwi5pyJ5Ly05L6j5LiU5pyJ5Zub5Liq5Lul5LiK5aW95oSf5bqm6L6+5YiwOTnnmoTlvILmgKdcIixcblxuICAgIFwiZ29vZHNfMVwiOlwi6YeR5biBXCIsXG4gICAgXCJnb29kc18yXCI6XCLmsLTmnpzmiYvmnLpcIixcbiAgICBcImdvb2RzXzNcIjpcIuWkp+W4iOWtl+eUu1wiLFxuICAgIFwiZ29vZHNfNFwiOlwi6buE6YeRXCIsXG4gICAgXCJnb29kc181XCI6XCLpo57kurrnkIPpnotcIixcbiAgICBcImdvb2RzXzZcIjpcIuWkp+iSnFwiLFxuICAgIFwiZ29vZHNfN1wiOlwi5ri45oiP5biQ5Y+3XCIsXG4gICAgXCJnb29kc184XCI6XCLoiKrmi43ml6DkurrmnLpcIixcbiAgICBcImdvb2RzXzlcIjpcIuWlouS+iOWMheWMhVwiLFxuICAgIFwiZ29vZHNfMTBcIjpcIue+iuavm+Wkp+iho1wiLFxuICAgIFwiZ29vZHNfMTFcIjpcIummmeawtFwiLFxuICAgIFwiZ29vZHNfMTJcIjpcIumbtumjn1wiLFxuXG4gICAgXCJyb2xlXzFcIjpcIuWIneS4reW4iOWmuVwiLFxuICAgIFwicm9sZV8yXCI6XCLpq5jkuK3nj63oirFcIixcbiAgICBcInJvbGVfM1wiOlwi6Im65pyv6ICB5biIXCIsXG4gICAgXCJyb2xlXzRcIjpcIuepuuWnkFwiLFxuICAgIFwicm9sZV81XCI6XCLmuKnmn5TmiqTlo6tcIixcbiAgICBcInJvbGVfNlwiOlwi6LaF5qihXCIsXG4gICAgXCJyb2xlXzdcIjpcIueZveWvjOe+jlwiLFxuICAgIFwicm9sZV84XCI6XCLpgrvlrrblpKflk6VcIixcbiAgICBcInJvbGVfOVwiOlwi5pqW55S35biI5YWEXCIsXG4gICAgXCJyb2xlXzEwXCI6XCLlpKflrabmoKHojYlcIixcbiAgICBcInJvbGVfMTFcIjpcIuWwj+mynOiCiVwiLFxuICAgIFwicm9sZV8xMlwiOlwi57K+6Iux5b6L5biIXCIsXG4gICAgXCJyb2xlXzEzXCI6XCLotrPnkIPpmJ/plb9cIixcbiAgICBcInJvbGVfMTRcIjpcIumcuOmBk+aAu+ijgVwiLFxuXG4gICAgXCJjb21wYW55XzFcIjpcIuS/neWBpemjn+WTgeWFrOWPuFwiLFxuICAgIFwiY29tcGFueV8yXCI6XCLph5Hono3kv53pmanlhazlj7hcIixcbiAgICBcImNvbXBhbnlfM1wiOlwi6L+e6ZSB6aSQ6aWu5YWs5Y+4XCIsXG4gICAgXCJjb21wYW55XzRcIjpcIueUteWVhueJqea1geWFrOWPuFwiLFxuICAgIFwiY29tcGFueV81XCI6XCLlsI/pop3otLfmrL7lhazlj7hcIixcblxuXG4gICAgXCJ0dXRvcmlhbF8xMVwiOlwi5Li65LqG5a6e546w55uu5qCH77yM5YWI5LuO5L2O5Lmw6auY5Y2W57Sv56ev6LWE5pysXCIsXG4gICAgXCJ0dXRvcmlhbF8xMlwiOlwi54K55Ye75Lmw5YWlXCIsXG4gICAgXCJ0dXRvcmlhbF8xM1wiOlwi55yL55yL5piO5bm055qE5biC5Zy66KGM5oOF5aaC5L2VXCIsXG4gICAgXCJ0dXRvcmlhbF8xNFwiOlwi5ZWG5ZOB5rao5Lu35LqG77yM5p6c5pat5Y2W5Ye66LWa5Y+W5beu5Lu3XCIsXG4gICAgXCJ0dXRvcmlhbF8xNVwiOlwi54K55Ye75Y2W5Ye6XCIsXG4gICAgXCJ0dXRvcmlhbF8yMVwiOlwi5aW955qE5Ly05L6j5piv5LqL5Lia5Z2a5a6e55qE5Z+656GA77yM5a6e5Zyo5LiN6KGM6L+Y5Y+v5Lul5rGC5YyF5YW7XCIsXG4gICAgXCJ0dXRvcmlhbF8yMlwiOlwi6L+Z5LmI5aSa5qy+77yM5oC75pyJ5LiA5Liq6YCC5ZCI5L2gXCIsXG4gICAgXCJ0dXRvcmlhbF8zMVwiOlwi5Yiw6ICM56uL5LmL5bm077yM5bqU6K+l6ICD6JmR5Yib5Lia5p2l5Lqr5Y+X6LWE5Lqn5Y2H5YC85ZKM5YiG57qi5LqGXCIsXG4gICAgXCJ0dXRvcmlhbF8zMlwiOlwi5pyJ6Laz5aSf55qE6ZKx55qE6K+d77yM6L+Z5Lqb5YWs5Y+45L2g5Y+v5Lul6ZqP5oSP5oqV6LWE44CCXCIsXG4gICAgXCJ0dXRvcmlhbF80MVwiOlwi5Yib5Yqe5LyB5Lia5ZCO77yM5Lqr5Y+X6IKh5Lu35o+Q5Y2H55qE5pS255uK77yM5q+P5bm05pS25Yiw5YiG57qi44CCXCIsXG4gICAgXCJ0dXRvcmlhbF81MVwiOlwi5q+P5LiA5qyh57qm5Lya6YO95Lya5aKe5Yqg5Lqy5a+G5bqm77yM5Lqy5a+G5bqm6L6+5YiwOTnlj6/lj5HotbfmsYLlqZrlk6ZcIixcblxuICAgIFwiTWF0ZVVubG9ja1RpcFwiOlwi5L2g5Lus5bCa5pyq55u46YGHLOWJjeW+gOe6puS8muWco+WcsOeisOeisOi/kOawlFwiLFxuXG4gICAgXCJIYXNNYXJyYXlfMFwiOlwi5L2g5piv6KaB5ama5ae76L+Y5piv6KaB55yf54ix77yf6Iul6KaB55yf54ixLOS9oOWFiOemu+WpmuWQp1wiLFxuICAgIFwiSGFzTWFycmF5XzFcIjpcIuS9oOmDveacieWutuWupOS6hu+8jOaIkeS7rOaYr+S4jeWPr+iDveeahO+8jOmZpOmdnuS9oOWFiOaBouWkjeWNlei6q+OAglwiLFxuICAgIFwiSGFzTWFycmF5XzJcIjpcIuS9oOiLpeecn+eahOeIseaIke+8jOWwsee7meaIkeWQjeWIhuWQp+OAglwiLFxuICAgIFwiSGFzTWFycmF5XzNcIjpcIuS9oOivtCDmmK/miJHku6znm7jop4HmgajmmZrvvJvmiJHor7Qg5Li654ix5L2g5bqU6K+l5YuH5pWi77yMXCIsXG5cbiAgICBcIk5vTW9uZXlEYXRlXzBcIjpcIuetieS9oOaciemSseS6hizlho3ljrvov73msYLnuqbkvJrpgqPkuKrlpaLkvojnjqnmhI/lhL/lkKdcIixcbiAgICBcIk5vTW9uZXlEYXRlXzFcIjpcIuayoemSseaXtiznuqbkvJrmmK/kvaDkuIDnp43lvpfkuI3liLDnmoTlpaLkvohcIixcblxuICAgIFwiQmV0V2luXCI6XCLlk4jlk4jvvIzlj5HotKLkuobjgILotZrkuobpkrHvvIzmiJHopoHkubDovabkubDmiL/nuqbnvo7lpbNcIixcbiAgICBcIkJldExvc2VcIjpcIuaIkeS4jeS/oe+8jOi/memDveayoeS4reOAguS4q+eahO+8jOWGjeadpeS4gOaKiuiCr+WumuS4rVwiLFxuXG4gICAgXCJDYXNoSW5pdF8xXCI6XCLlh7rouqvlr5Lpl6gs6L+b5YWl56S+5Lya5Y+q5oCA5o+j552A5omT5bel55qEMjAwMDDlhYPpl6/ojaHmsZ/muZZcIixcbiAgICBcIkNhc2hJbml0XzJcIjpcIuS4reS6p+WutuW6rSzniLbmr43mnInmi4XlvZMs57uZ5L2gNTAwMDDlhYPkvZzkuLrliJvkuJrlkK/liqjln7rph5FcIixcbiAgICBcIkNhc2hJbml0XzNcIjpcIuWvjOijleWutuW6re+8jOWutuaXj+S4uuS6huS9oOiDveaXqeaXpemXr+WHuuS4gOeJh+WkqeWcsO+8jOWHuui1hDEwMDAwMOWFg1wiLFxuXG4gICAgXCJNb25leU5vdEVub3VnaFwiOlwi546w6YeR5LiN6Laz77yM5peg5rOV5Y+C5LiOXCIsXG5cbiAgICBcIkRhdGVGYWlsXzBcIjpcIuacquadpeacieS4gOS4quS6uuWcqOetieW+he+8jOeIseimgeaLkOWHoOS4quW8r+aJjeWIsOadpVwiLFxuICAgIFwiRGF0ZUZhaWxfMVwiOlwi5oiR5Lus5pu+5Zyo6L+H5Y6755qE5qKm5aKD6YeM55u46YGH77yM5Lmf5bCG5Lya5Zyo5pyq5p2l55qE546w5a6e5Lit6YeN6YCiXCIsXG5cbiAgICBcIk5hbWUxXCI6XCLmoKHplb/njotcIixcbiAgICBcIk5hbWUyXCI6XCLlt7Toj7LojrFcIixcbiAgICBcIk5hbWUzXCI6XCLpurvoirHol6RcIixcbiAgICBcIk5hbWU0XCI6XCLpqazniLjniLhcIixcbiAgICBcIk5hbWU1XCI6XCLnpL7kvJrkuLvkuYnmjqXnj63kurpcIixcbiAgICBcIk5hbWU2XCI6XCLmr5TlsJQu55uW54m5XCIsXG4gICAgXCJOYW1lN1wiOlwi5oiR5piv6aaW5a+MXCIsXG4gICAgXCJOYW1lOFwiOlwi5p+z5Lyg5om/XCIsXG4gICAgXCJOYW1lOVwiOlwi6Zu35biD5pavXCIsXG4gICAgXCJOYW1lMTBcIjpcIueOi+i+vuael1wiLFxuICAgIFwiTmFtZTExXCI6XCLlj7Lpk4Hmn7FcIixcbiAgICBcIk5hbWUxMlwiOlwi6JGj54+N54+gXCIsXG4gICAgXCJOYW1lMTNcIjpcIuS4geS4ieefs1wiLFxuICAgIFwiTmFtZTE0XCI6XCLmgZLlrrbljbBcIixcbiAgICBcIk5hbWUxNVwiOlwi5p2O5L2z5pmoXCIsXG4gICAgXCJOYW1lMTZcIjpcIuWkqeeUn+mSnuiDveWKm1wiLFxuICAgIFwiTmFtZTE3XCI6XCLogIHlpKvngpLogqHkuIDmiormoq1cIixcbiAgICBcIk5hbWUxOFwiOlwi552h6YaS5bCx5pWw6ZKxXCIsXG4gICAgXCJOYW1lMTlcIjpcIuaVsOmSseaJi+aKveeti1wiLFxuICAgIFwiTmFtZTIwXCI6XCLkurrnlJ/otaLlrrZcIixcbiAgICBcIk5hbWUyMVwiOlwi5Y2V5omL5byA6L2m5oiR5pyA5by6XCIsXG4gICAgXCJOYW1lMjJcIjpcIuiPnOiZmumyslwiLFxuICAgIFwiTmFtZTIzXCI6XCLovqPpuKHlpKflj7jpqaxcIixcbiAgICBcIk5hbWUyNFwiOlwi5Lic5a2Q5aSn5YWE5byfXCIsXG4gICAgXG59XG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/PlatformController.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'df981lfZ3ZDuI2YfqwwH8kx', 'PlatformController');
// Scripts/Core/PlatformController.js

"use strict";

var PlatformController = cc.Class({
  statics: {
    wxSubContextViewLock: 0,
    //微信 wx
    //头条 tt
    //百度 baidu
    nickName: "校长王",
    Init: function Init() {
      this.InitRandNickName();

      // this.CreateGameClub();
    },

    //百度 头条等先判定是否登陆了
    IsLoginSync: function IsLoginSync() {
      if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        var result = swan.isLoginSync();
        if (result.isLogin) {
          console.log("已经有登陆了");
          return true;
        }
        return false;
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {}
      return true;
    },
    Login: function Login() {
      var self = this;
      if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        swan.login({
          success: function success() {
            self.setUserCloudStorage(cc.Mgr.UserDataMgr.HistoryHighAssets);
          },
          fail: function fail() {
            swan.showModal({
              title: "登录失败",
              content: "是否重新登录？",
              cancelText: "退出游戏",
              success: function success(res) {
                if (res.confirm) {
                  console.log("点击了确定");
                  self.Login();
                } else if (res.cancel) {
                  console.log("点击了取消");
                  swan.exit();
                }
              }
            });
          }
        });
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {}
      return true;
    },
    //游戏圈按钮
    CreateGameClub: function CreateGameClub() {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        var winSize = cc.view.getVisibleSize();
        var leftRatio = 68 / winSize.width;
        var topRatio = 275 / winSize.height;
        var sysInfo = wx.getSystemInfoSync();
        this.leftPos = sysInfo.windowWidth * leftRatio;
        this.topPos = sysInfo.windowHeight * topRatio;
        console.log(this.topPos + "  ================创建游戏圈按钮===============" + this.leftPos);
        var self = this;
        this.gameClubBtn = wx.createGameClubButton({
          icon: 'green',
          text: "游戏圈",
          style: {
            left: self.leftPos - 20,
            top: self.topPos - 20,
            width: 45,
            height: 45
          }
        });
      }
    },
    ShowClubButton: function ShowClubButton(flag) {
      if (flag === void 0) {
        flag = false;
      }
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && this.gameClubBtn != null && !isKuaiShou) {
        if (flag == true) this.gameClubBtn.show();else this.gameClubBtn.hide();
      }
    },
    //随机一个名字
    InitRandNickName: function InitRandNickName() {
      var seed = Math.floor(Math.random() * 24) + 1;
      this.nickName = cc.Mgr.global.getTranslation("Name" + seed);
      cc.log("================================ " + this.nickName);
    },
    //右上角的转发按钮
    ShareTopNav: function ShareTopNav() {
      var index = Math.floor(Math.random() * 6);
      var info = cc.Mgr.ShareInfos.getShareInfos(index);
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        wx.showShareMenu({
          withShareTicket: true
        });
        wx.onShareAppMessage(function () {
          // 用户点击了“转发”按钮
          return {
            title: "【有人@你】我在这个游戏里面挣了一个亿",
            imageUrlId: 'dwMg-qBPS8S7MIWk4VRHxw',
            imageUrl: "https://paopao.talkyun.com.cn/yiyi/1.jpg"
          };
        });
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        tt.showShareMenu(false);
        tt.onShareAppMessage(function () {
          // 用户点击了“转发”按钮
          return {
            title: info.text,
            //imageUrlId: 'Ik14RZj7SV2BtigrtE3d1g',
            imageUrl: info.url
          };
        });
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        swan.showShareMenu(false);
        swan.onShareAppMessage(function () {
          // 用户点击了“转发”按钮
          return {
            title: info.text,
            imageUrl: info.url
          };
        });
      }
    },
    //转发一段文本
    ShareToFriendTxt: function ShareToFriendTxt(str) {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        console.log("点击了分享啊");
        wx.shareAppMessage({
          title: str
        });
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        tt.shareAppMessage({
          title: str
        });
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        console.log("点击了分享啊");
        swan.shareAppMessage({
          title: str
        });
      } else if (isKuaiShou) {
        ks.shareAppMessage({});
      }
    },
    //自定义转发
    ShareToFriend: function ShareToFriend(index) {
      var info = cc.Mgr.ShareInfos.getShareInfos(index);
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        console.log("点击了分享啊");
        wx.shareAppMessage({
          title: info.text,
          imageUrl: info.url
        });
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        tt.shareAppMessage({
          title: info.text,
          imageUrl: info.url
        });
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        console.log("点击了分享啊");
        swan.shareAppMessage({
          title: info.text,
          imageUrl: info.url
        });
      } else if (isKuaiShou) {
        ks.shareAppMessage({});
      }
    },
    //显示平台的小弹窗 回调用
    showToast: function showToast(text) {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      cc.log(text);
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        wx.showToast({
          title: text,
          icon: 'success',
          duration: 2000
        });
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        tt.showToast({
          title: text,
          icon: 'success',
          duration: 2000
        });
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        swan.showToast({
          title: text,
          icon: 'success',
          duration: 2000
        });
      } else if (isKuaiShou) {
        ks.showToast({
          title: text,
          icon: 'success',
          duration: 2000
        });
      }
    },
    //微信开放数据存储 score 代表当前要保存的东西
    setUserCloudStorage: function setUserCloudStorage(socre) {
      if (!this.IsLoginSync()) {
        return;
      }
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      cc.log("setUserCloudStorage socre = " + socre);
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        var kvData = {};
        kvData.wxgame = {};
        kvData.wxgame.score = socre;
        kvData.wxgame.update_time = new Date().getTime();
        console.log(JSON.stringify(kvData));
        var kvDataList = new Array();
        kvDataList.push({
          key: "xmbScore",
          value: JSON.stringify(kvData)
        });
        wx.setUserCloudStorage({
          KVDataList: kvDataList,
          success: function success(res) {
            console.log("success:" + JSON.stringify(res));
          },
          fail: function fail(res) {
            console.log("fail : " + res);
          }
        });
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        var kvData = {};
        kvData.wxgame = {};
        kvData.wxgame.score = socre;
        kvData.wxgame.update_time = new Date().getTime();
        console.log(JSON.stringify(kvData));
        var kvDataList = new Array();
        kvDataList.push({
          key: "xmbScore",
          value: JSON.stringify(kvData)
        });
        swan.setUserCloudStorage({
          KVDataList: kvDataList,
          success: function success(res) {
            return console.log("success " + res);
          },
          fail: function fail(res) {
            return console.log("fail " + res);
          },
          complete: function complete(res) {
            return console.log("complete " + res);
          }
        });
      }
    },
    //是否支持排行功能
    IsSupportRank: function IsSupportRank() {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou || cc.sys.platform === cc.sys.BAIDU_GAME) return true;
      return false;
    },
    //显示子域
    showSubContentView: function showSubContentView() {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou || cc.sys.platform === cc.sys.BAIDU_GAME) {
        var param = {};
        param.flag = true;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.ShowRank, param);
      }
    },
    hideSubContentView: function hideSubContentView() {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou || cc.sys.platform === cc.sys.BAIDU_GAME) {
        var param = {};
        param.flag = false;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.ShowRank, param);
      }
    },
    SendMessageToSubView: function SendMessageToSubView(code, curScore) {
      if (curScore === void 0) {
        curScore = 0;
      }
      var msg = {};
      msg.code = code;
      msg.curScore = curScore;
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        wx.getOpenDataContext().postMessage({
          message: msg
        });
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        swan.getOpenDataContext().postMessage({
          message: msg
        });
      }
    },
    //整理数据
    CollateData: function CollateData(data) {
      this.userInfo = [];
      var j = 0;
      for (var _i = 0; _i < data.length; ++_i) {
        if (data[_i].KVDataList.length == 0) {
          console.log("combData 没有此项数据");
          continue;
        }
        //{"openid":"o0OhZ5Kn2xO9b5FVR8TE0YXOl3Wc","nickname":"杨彬","avatarUrl":"https://wx.qlogo.cn/mmopen/vi_32/FcRibGPkicSKhn6LA1OWfL7ictiaKiajzibzW8zwQibkGKdCJmmiasvibcRasI2KytcVtW8ClH5IQTsOs3CB8vyMSUAOarA/132","KVDataList":[{"key":"\belsfkScore","value":"{\"wxgame\":{\"score\":1889,\"update_time\":1553824369920}}"}]}
        this.userInfo[j] = {};
        this.userInfo[j].openid = data[_i].openid;
        this.userInfo[j].nickname = data[_i].nickname;
        this.userInfo[j].avatarUrl = data[_i].avatarUrl;
        var kVDataListValuestr = data[_i].KVDataList[0].value;
        kVDataListValuestr = kVDataListValuestr.substr(1); //删除第一个字符
        kVDataListValuestr = kVDataListValuestr.substr(0, kVDataListValuestr.length - 1);
        kVDataListValuestr = "{" + kVDataListValuestr + "}";
        var gameScore = JSON.parse(kVDataListValuestr).wxgame;
        this.userInfo[j].score = gameScore.score;
        j++;
      }
      //给用户数据进行排序
      this.userInfo.sort(function (a, b) {
        if (a.score < b.score) return 1;else if (a.score > b.score) return -1;else return 0;
      });
      console.log("CollateData--- " + JSON.stringify(this.userInfo));
      for (var i = 0; i < this.userInfo.length; i++) {
        //挑出自己的排名
        if (this.userInfo[i].avatarUrl == this.avatarUrl) {
          this.mySordId = i;
        }
      }
    }
  }
});
module.exports = PlatformController;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcUGxhdGZvcm1Db250cm9sbGVyLmpzIl0sIm5hbWVzIjpbIlBsYXRmb3JtQ29udHJvbGxlciIsImNjIiwiQ2xhc3MiLCJzdGF0aWNzIiwid3hTdWJDb250ZXh0Vmlld0xvY2siLCJuaWNrTmFtZSIsIkluaXQiLCJJbml0UmFuZE5pY2tOYW1lIiwiSXNMb2dpblN5bmMiLCJzeXMiLCJwbGF0Zm9ybSIsIkJBSURVX0dBTUUiLCJyZXN1bHQiLCJzd2FuIiwiaXNMb2dpblN5bmMiLCJpc0xvZ2luIiwiY29uc29sZSIsImxvZyIsIkJZVEVEQU5DRV9HQU1FIiwiTG9naW4iLCJzZWxmIiwibG9naW4iLCJzdWNjZXNzIiwic2V0VXNlckNsb3VkU3RvcmFnZSIsIk1nciIsIlVzZXJEYXRhTWdyIiwiSGlzdG9yeUhpZ2hBc3NldHMiLCJmYWlsIiwic2hvd01vZGFsIiwidGl0bGUiLCJjb250ZW50IiwiY2FuY2VsVGV4dCIsInJlcyIsImNvbmZpcm0iLCJjYW5jZWwiLCJleGl0IiwiQ3JlYXRlR2FtZUNsdWIiLCJpc0t1YWlTaG91Iiwia3MiLCJXRUNIQVRfR0FNRSIsIndpblNpemUiLCJ2aWV3IiwiZ2V0VmlzaWJsZVNpemUiLCJsZWZ0UmF0aW8iLCJ3aWR0aCIsInRvcFJhdGlvIiwiaGVpZ2h0Iiwic3lzSW5mbyIsInd4IiwiZ2V0U3lzdGVtSW5mb1N5bmMiLCJsZWZ0UG9zIiwid2luZG93V2lkdGgiLCJ0b3BQb3MiLCJ3aW5kb3dIZWlnaHQiLCJnYW1lQ2x1YkJ0biIsImNyZWF0ZUdhbWVDbHViQnV0dG9uIiwiaWNvbiIsInRleHQiLCJzdHlsZSIsImxlZnQiLCJ0b3AiLCJTaG93Q2x1YkJ1dHRvbiIsImZsYWciLCJzaG93IiwiaGlkZSIsInNlZWQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsIlNoYXJlVG9wTmF2IiwiaW5kZXgiLCJpbmZvIiwiU2hhcmVJbmZvcyIsImdldFNoYXJlSW5mb3MiLCJzaG93U2hhcmVNZW51Iiwid2l0aFNoYXJlVGlja2V0Iiwib25TaGFyZUFwcE1lc3NhZ2UiLCJpbWFnZVVybElkIiwiaW1hZ2VVcmwiLCJ0dCIsInVybCIsIlNoYXJlVG9GcmllbmRUeHQiLCJzdHIiLCJzaGFyZUFwcE1lc3NhZ2UiLCJTaGFyZVRvRnJpZW5kIiwic2hvd1RvYXN0IiwiZHVyYXRpb24iLCJzb2NyZSIsImt2RGF0YSIsInd4Z2FtZSIsInNjb3JlIiwidXBkYXRlX3RpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJrdkRhdGFMaXN0IiwiQXJyYXkiLCJwdXNoIiwia2V5IiwidmFsdWUiLCJLVkRhdGFMaXN0IiwiY29tcGxldGUiLCJJc1N1cHBvcnRSYW5rIiwic2hvd1N1YkNvbnRlbnRWaWV3IiwicGFyYW0iLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiU2hvd1JhbmsiLCJoaWRlU3ViQ29udGVudFZpZXciLCJTZW5kTWVzc2FnZVRvU3ViVmlldyIsImNvZGUiLCJjdXJTY29yZSIsIm1zZyIsImdldE9wZW5EYXRhQ29udGV4dCIsInBvc3RNZXNzYWdlIiwibWVzc2FnZSIsIkNvbGxhdGVEYXRhIiwiZGF0YSIsInVzZXJJbmZvIiwiaiIsImkiLCJsZW5ndGgiLCJvcGVuaWQiLCJuaWNrbmFtZSIsImF2YXRhclVybCIsImtWRGF0YUxpc3RWYWx1ZXN0ciIsInN1YnN0ciIsImdhbWVTY29yZSIsInBhcnNlIiwic29ydCIsImEiLCJiIiwibXlTb3JkSWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLGtCQUFrQixHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUM5QkMsT0FBTyxFQUFDO0lBQ0pDLG9CQUFvQixFQUFDLENBQUM7SUFDdEI7SUFDQTtJQUNBO0lBQ0FDLFFBQVEsRUFBQyxLQUFLO0lBRWRDLElBQUksRUFBQyxTQUFBQSxLQUFBLEVBQVk7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LElBQUksQ0FBQ0QsUUFBUSxDQUFDVyxJQUFJLENBQUMsVUFBQ0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUc7UUFDbEIsSUFBR0QsQ0FBQyxDQUFDM0MsS0FBSyxHQUFDNEMsQ0FBQyxDQUFDNUMsS0FBSyxFQUNkLE9BQU8sQ0FBQyxDQUFDLEtBQ1IsSUFBRzJDLENBQUMsQ0FBQzNDLEtBQUssR0FBQzRDLENBQUMsQ0FBQzVDLEtBQUssRUFDbkIsT0FBTyxDQUFDLENBQUMsTUFFVCxPQUFPLENBQUM7TUFDaEIsQ0FBQyxDQUNKO01BQ0Q1RSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBRytFLElBQUksQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQzBCLFFBQVEsQ0FBQyxDQUFDO01BQzlELEtBQUksSUFBSUUsQ0FBQyxHQUFDLENBQUMsRUFBRUEsQ0FBQyxHQUFDLElBQUksQ0FBQ0YsUUFBUSxDQUFDRyxNQUFNLEVBQUNELENBQUMsRUFBRSxFQUN2QztRQUFFO1FBQ0UsSUFBRyxJQUFJLENBQUNGLFFBQVEsQ0FBQ0UsQ0FBQyxDQUFDLENBQUNJLFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsRUFDL0M7VUFDSSxJQUFJLENBQUNRLFFBQVEsR0FBR1osQ0FBQztRQUNyQjtNQUNKO0lBQ0o7RUFDRDtBQUNKLENBQUMsQ0FBQztBQUNGYSxNQUFNLENBQUNDLE9BQU8sR0FBRzNJLGtCQUFrQiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBQbGF0Zm9ybUNvbnRyb2xsZXIgPSBjYy5DbGFzcyh7XHJcbiAgICBzdGF0aWNzOntcclxuICAgICAgICB3eFN1YkNvbnRleHRWaWV3TG9jazowLFxyXG4gICAgICAgIC8v5b6u5L+hIHd4XHJcbiAgICAgICAgLy/lpLTmnaEgdHRcclxuICAgICAgICAvL+eZvuW6piBiYWlkdVxyXG4gICAgICAgIG5pY2tOYW1lOlwi5qCh6ZW/546LXCIsXHJcblxyXG4gICAgICAgIEluaXQ6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLkluaXRSYW5kTmlja05hbWUoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIHRoaXMuQ3JlYXRlR2FtZUNsdWIoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL+eZvuW6piDlpLTmnaHnrYnlhYjliKTlrprmmK/lkKbnmbvpmYbkuoZcclxuICAgICAgICBJc0xvZ2luU3luYzpmdW5jdGlvbigpe1xyXG4gICAgICAgIFx0aWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSkge1xyXG4gICAgICAgIFx0XHR2YXIgcmVzdWx0ID0gc3dhbi5pc0xvZ2luU3luYygpO1xyXG4gICAgXHRcdFx0aWYocmVzdWx0LmlzTG9naW4pXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdGNvbnNvbGUubG9nKFwi5bey57uP5pyJ55m76ZmG5LqGXCIpO1xyXG4gICAgXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuICAgIFx0XHRcdH1cclxuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICAgICAgICBcdH0gZWxzZSBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CWVRFREFOQ0VfR0FNRSkge1xyXG5cclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRyZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBMb2dpbjpmdW5jdGlvbigpe1xyXG4gICAgICAgIFx0dmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIFx0aWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuICAgICAgICBcdHtcclxuICAgICAgICBcdFx0c3dhbi5sb2dpbih7XHJcblx0XHRcdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQgICAgICAgICAgICBzZWxmLnNldFVzZXJDbG91ZFN0b3JhZ2UoY2MuTWdyLlVzZXJEYXRhTWdyLkhpc3RvcnlIaWdoQXNzZXRzKTtcclxuXHRcdFx0ICAgICAgICB9LFxyXG5cdFx0XHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0ICAgICAgICAgICAgc3dhbi5zaG93TW9kYWwoe1xyXG5cdFx0XHQgICAgICAgICAgICAgICAgdGl0bGU6IFwi55m75b2V5aSx6LSlXCIsXHJcblx0XHRcdCAgICAgICAgICAgICAgICBjb250ZW50OiBcIuaYr+WQpumHjeaWsOeZu+W9le+8n1wiLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgY2FuY2VsVGV4dDogXCLpgIDlh7rmuLjmiI9cIixcclxuXHRcdFx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXMpIHtcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmNvbmZpcm0pIHtcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLngrnlh7vkuobnoa7lrppcIik7XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuTG9naW4oKTtcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzLmNhbmNlbCkge1xyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIueCueWHu+S6huWPlua2iFwiKTtcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dhbi5leGl0KCk7XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdFx0XHQgICAgICAgICAgICAgICAgfVxyXG5cdFx0XHQgICAgICAgICAgICB9KVxyXG5cdFx0XHQgICAgICAgIH1cclxuXHRcdFx0ICAgIH0pXHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRlbHNlIGlmKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJZVEVEQU5DRV9HQU1FKVxyXG4gICAgICAgIFx0e1xyXG5cclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRyZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL+a4uOaIj+WciOaMiemSrlxyXG4gICAgICAgIENyZWF0ZUdhbWVDbHViOmZ1bmN0aW9uKCl7XHJcblx0XHRcdGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcblx0XHRcdGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuXHRcdFx0XHRpc0t1YWlTaG91ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG4gICAgICAgIFx0aWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuV0VDSEFUX0dBTUUgJiYgIWlzS3VhaVNob3UpXHJcbiAgICAgICAgXHR7XHJcbiAgICAgICAgXHRcdHZhciB3aW5TaXplID0gY2Mudmlldy5nZXRWaXNpYmxlU2l6ZSgpO1xyXG4gICAgICAgIFx0XHR2YXIgbGVmdFJhdGlvID0gNjggLyB3aW5TaXplLndpZHRoO1xyXG4gICAgICAgIFx0XHR2YXIgdG9wUmF0aW8gPSAyNzUgLyB3aW5TaXplLmhlaWdodDtcclxuXHJcbiAgICAgICAgXHRcdHZhciBzeXNJbmZvID0gd3guZ2V0U3lzdGVtSW5mb1N5bmMoKTtcclxuXHJcbiAgICAgICAgXHRcdHRoaXMubGVmdFBvcyA9IHN5c0luZm8ud2luZG93V2lkdGggKiBsZWZ0UmF0aW87XHJcbiAgICAgICAgXHRcdHRoaXMudG9wUG9zID0gc3lzSW5mby53aW5kb3dIZWlnaHQgKiB0b3BSYXRpbztcclxuXHJcbiAgICAgICAgXHRcdGNvbnNvbGUubG9nKHRoaXMudG9wUG9zICsgXCIgID09PT09PT09PT09PT09PT3liJvlu7rmuLjmiI/lnIjmjInpkq49PT09PT09PT09PT09PT1cIiArIHRoaXMubGVmdFBvcyk7XHJcblxyXG4gICAgICAgIFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHRcdHRoaXMuZ2FtZUNsdWJCdG4gPSB3eC5jcmVhdGVHYW1lQ2x1YkJ1dHRvbih7XHJcbiAgICAgICAgXHRcdFx0aWNvbjonZ3JlZW4nLFxyXG4gICAgICAgIFx0XHRcdHRleHQ6XCLmuLjmiI/lnIhcIixcclxuICAgICAgICBcdFx0XHRzdHlsZTp7XHJcbiAgICAgICAgXHRcdFx0XHRsZWZ0OnNlbGYubGVmdFBvcyAtIDIwLFxyXG4gICAgICAgIFx0XHRcdFx0dG9wOnNlbGYudG9wUG9zIC0gMjAsXHJcbiAgICAgICAgXHRcdFx0XHR3aWR0aDogNDUsXHJcbiAgICAgICAgXHRcdFx0XHRoZWlnaHQ6IDQ1LFxyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgU2hvd0NsdWJCdXR0b246ZnVuY3Rpb24oZmxhZyA9IGZhbHNlKVxyXG4gICAgICAgIHtcclxuXHRcdFx0bGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG5cdFx0XHRcdGlzS3VhaVNob3UgPSB0cnVlO1xyXG5cdFx0XHR9XHJcbiAgICAgICAgXHRpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiB0aGlzLmdhbWVDbHViQnRuICE9IG51bGwgJiYgIWlzS3VhaVNob3UpXHJcbiAgICAgICAgXHR7XHJcbiAgICAgICAgXHRcdGlmKGZsYWcgPT0gdHJ1ZSlcclxuICAgICAgICBcdFx0XHR0aGlzLmdhbWVDbHViQnRuLnNob3coKTtcclxuICAgICAgICBcdFx0ZWxzZVxyXG4gICAgICAgIFx0XHRcdHRoaXMuZ2FtZUNsdWJCdG4uaGlkZSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8v6ZqP5py65LiA5Liq5ZCN5a2XXHJcbiAgICAgICAgSW5pdFJhbmROaWNrTmFtZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIFx0dmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMjQpICsgMTtcclxuICAgICAgICBcdHRoaXMubmlja05hbWUgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiTmFtZVwiKyBzZWVkKTtcclxuICAgICAgICBcdGNjLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IFwiICsgdGhpcy5uaWNrTmFtZSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL+WPs+S4iuinkueahOi9rOWPkeaMiemSrlxyXG4gICAgICAgIFNoYXJlVG9wTmF2OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNik7XHJcblx0ICAgICAgICBsZXQgaW5mbyA9IGNjLk1nci5TaGFyZUluZm9zLmdldFNoYXJlSW5mb3MoaW5kZXgpO1xyXG5cdFx0XHRsZXQgaXNLdWFpU2hvdSA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcblx0XHRcdFx0aXNLdWFpU2hvdSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHQgICAgICAgIGlmKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLldFQ0hBVF9HQU1FICYmICFpc0t1YWlTaG91KVxyXG5cdCAgICAgICAge1xyXG5cdCAgICAgICAgICAgIHd4LnNob3dTaGFyZU1lbnUoe3dpdGhTaGFyZVRpY2tldDp0cnVlfSk7XHJcblx0ICAgICAgICAgICAgd3gub25TaGFyZUFwcE1lc3NhZ2UoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyDnlKjmiLfngrnlh7vkuobigJzovazlj5HigJ3mjInpkq5cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgICB0aXRsZTogXCLjgJDmnInkurpA5L2g44CR5oiR5Zyo6L+Z5Liq5ri45oiP6YeM6Z2i5oyj5LqG5LiA5Liq5Lq/XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgaW1hZ2VVcmxJZDogJ2R3TWctcUJQUzhTN01JV2s0VlJIeHcnLFxyXG5cdCAgICAgICAgICAgICAgICAgIGltYWdlVXJsOiBcImh0dHBzOi8vcGFvcGFvLnRhbGt5dW4uY29tLmNuL3lpeWkvMS5qcGdcIixcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJZVEVEQU5DRV9HQU1FKVxyXG5cdCAgICAgICAge1xyXG5cdCAgICAgICAgICAgIHR0LnNob3dTaGFyZU1lbnUoZmFsc2UpO1xyXG5cdCAgICAgICAgICAgIHR0Lm9uU2hhcmVBcHBNZXNzYWdlKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8g55So5oi354K55Ye75LqG4oCc6L2s5Y+R4oCd5oyJ6ZKuXHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgdGl0bGU6IGluZm8udGV4dCxcclxuXHQgICAgICAgICAgICAgICAgICAvL2ltYWdlVXJsSWQ6ICdJazE0UlpqN1NWMkJ0aWdydEUzZDFnJyxcclxuXHQgICAgICAgICAgICAgICAgICBpbWFnZVVybDogaW5mby51cmwsXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CQUlEVV9HQU1FKVxyXG5cdCAgICAgICAge1xyXG5cdCAgICAgICAgICAgIHN3YW4uc2hvd1NoYXJlTWVudShmYWxzZSk7XHJcblx0ICAgICAgICAgICAgc3dhbi5vblNoYXJlQXBwTWVzc2FnZShmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIOeUqOaIt+eCueWHu+S6huKAnOi9rOWPkeKAneaMiemSrlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgIHRpdGxlOiBpbmZvLnRleHQsXHJcblx0ICAgICAgICAgICAgICAgICAgaW1hZ2VVcmw6IGluZm8udXJsXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8v6L2s5Y+R5LiA5q615paH5pysXHJcbiAgICAgICAgU2hhcmVUb0ZyaWVuZFR4dDpmdW5jdGlvbihzdHIpe1xyXG5cdFx0XHRsZXQgaXNLdWFpU2hvdSA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcblx0XHRcdFx0aXNLdWFpU2hvdSA9IHRydWU7XHJcblx0XHRcdH1cclxuICAgICAgICBcdGlmKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLldFQ0hBVF9HQU1FICYmICFpc0t1YWlTaG91KVxyXG5cdCAgICAgICAge1xyXG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi54K55Ye75LqG5YiG5Lqr5ZWKXCIpO1xyXG5cdCAgICAgICAgICAgIHd4LnNoYXJlQXBwTWVzc2FnZSh7XHJcblx0ICAgICAgICAgICAgICAgIHRpdGxlOiBzdHIsXHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQllURURBTkNFX0dBTUUpXHJcblx0ICAgICAgICB7XHJcblx0ICAgICAgICAgICAgdHQuc2hhcmVBcHBNZXNzYWdlKHtcclxuXHQgICAgICAgICAgICAgICAgdGl0bGU6IHN0cixcclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CQUlEVV9HQU1FKVxyXG5cdCAgICAgICAge1xyXG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi54K55Ye75LqG5YiG5Lqr5ZWKXCIpO1xyXG5cdCAgICAgICAgICAgIHN3YW4uc2hhcmVBcHBNZXNzYWdlKHtcclxuXHQgICAgICAgICAgICAgICAgdGl0bGU6IHN0cixcclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgfVxyXG5cdFx0XHRlbHNlIGlmKGlzS3VhaVNob3UpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRrcy5zaGFyZUFwcE1lc3NhZ2Uoe30pXHJcblx0XHRcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL+iHquWumuS5iei9rOWPkVxyXG4gICAgICAgIFNoYXJlVG9GcmllbmQ6ZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgICAgIFx0dmFyIGluZm8gPSBjYy5NZ3IuU2hhcmVJbmZvcy5nZXRTaGFyZUluZm9zKGluZGV4KTtcclxuXHRcdFx0bGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG5cdFx0XHRcdGlzS3VhaVNob3UgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0ICAgICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcIueCueWHu+S6huWIhuS6q+WVilwiKTtcclxuXHQgICAgICAgICAgICB3eC5zaGFyZUFwcE1lc3NhZ2Uoe1xyXG5cdCAgICAgICAgICAgICAgICB0aXRsZTogaW5mby50ZXh0LFxyXG5cdCAgICAgICAgICAgICAgICBpbWFnZVVybDogaW5mby51cmwsXHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQllURURBTkNFX0dBTUUpXHJcblx0ICAgICAgICB7XHJcblx0ICAgICAgICAgICAgdHQuc2hhcmVBcHBNZXNzYWdlKHtcclxuXHQgICAgICAgICAgICAgICAgdGl0bGU6IGluZm8udGV4dCxcclxuXHQgICAgICAgICAgICAgICAgaW1hZ2VVcmw6IGluZm8udXJsXHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcIueCueWHu+S6huWIhuS6q+WVilwiKTtcclxuXHQgICAgICAgICAgICBzd2FuLnNoYXJlQXBwTWVzc2FnZSh7XHJcblx0ICAgICAgICAgICAgICAgIHRpdGxlOiBpbmZvLnRleHQsXHJcblx0ICAgICAgICAgICAgICAgIGltYWdlVXJsOiBpbmZvLnVybFxyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICB9XHJcblx0XHRcdGVsc2UgaWYoaXNLdWFpU2hvdSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGtzLnNoYXJlQXBwTWVzc2FnZSh7fSlcclxuXHRcdFx0fVxyXG4gICAgICAgIH0sXHJcbiBcdFx0Ly/mmL7npLrlubPlj7DnmoTlsI/lvLnnqpcg5Zue6LCD55SoXHJcbiAgICAgICAgc2hvd1RvYXN0OmZ1bmN0aW9uKHRleHQpXHJcblx0ICAgIHtcclxuXHRcdFx0bGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG5cdFx0XHRcdGlzS3VhaVNob3UgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0ICAgICAgICBjYy5sb2codGV4dCk7XHJcblx0ICAgICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICB3eC5zaG93VG9hc3Qoe1xyXG5cdCAgICAgICAgICAgICAgICB0aXRsZTogdGV4dCxcclxuXHQgICAgICAgICAgICAgICAgaWNvbjogJ3N1Y2Nlc3MnLFxyXG5cdCAgICAgICAgICAgICAgICBkdXJhdGlvbjogMjAwMFxyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJZVEVEQU5DRV9HQU1FKVxyXG5cdCAgICAgICAge1xyXG5cdCAgICAgICAgICAgIHR0LnNob3dUb2FzdCh7XHJcblx0ICAgICAgICAgICAgICAgIHRpdGxlOiB0ZXh0LFxyXG5cdCAgICAgICAgICAgICAgICBpY29uOiAnc3VjY2VzcycsXHJcblx0ICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAyMDAwXHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICBzd2FuLnNob3dUb2FzdCh7XHJcblx0ICAgICAgICAgICAgICAgIHRpdGxlOiB0ZXh0LFxyXG5cdCAgICAgICAgICAgICAgICBpY29uOiAnc3VjY2VzcycsXHJcblx0ICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAyMDAwXHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgIH1cclxuXHRcdFx0ZWxzZSBpZihpc0t1YWlTaG91KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0a3Muc2hvd1RvYXN0KHtcclxuXHRcdFx0XHRcdHRpdGxlOiB0ZXh0LFxyXG5cdFx0XHRcdFx0aWNvbjogJ3N1Y2Nlc3MnLFxyXG5cdFx0XHRcdFx0ZHVyYXRpb246IDIwMDBcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9XHJcblx0ICAgIH0sXHJcblx0ICAgIC8v5b6u5L+h5byA5pS+5pWw5o2u5a2Y5YKoIHNjb3JlIOS7o+ihqOW9k+WJjeimgeS/neWtmOeahOS4nOilv1xyXG5cdCAgICBzZXRVc2VyQ2xvdWRTdG9yYWdlOmZ1bmN0aW9uKHNvY3JlKSBcclxuXHQgICAge1xyXG5cdCAgICBcdGlmKCF0aGlzLklzTG9naW5TeW5jKCkpXHJcblx0ICAgIFx0e1xyXG5cdCAgICBcdFx0cmV0dXJuO1xyXG5cdCAgICBcdH1cclxuXHRcdFx0bGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG5cdFx0XHRcdGlzS3VhaVNob3UgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0ICAgIFx0XHJcblx0ICAgICAgICBjYy5sb2coXCJzZXRVc2VyQ2xvdWRTdG9yYWdlIHNvY3JlID0gXCIgKyBzb2NyZSk7XHJcblx0ICAgICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICB2YXIga3ZEYXRhPXt9O1xyXG5cdCAgICAgICAgICAgIGt2RGF0YS53eGdhbWU9e307XHJcblx0ICAgICAgICAgICAga3ZEYXRhLnd4Z2FtZS5zY29yZSA9IHNvY3JlO1xyXG5cdCAgICAgICAgICAgIGt2RGF0YS53eGdhbWUudXBkYXRlX3RpbWUgPSAgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoa3ZEYXRhKSk7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciBrdkRhdGFMaXN0ID0gbmV3IEFycmF5KCk7XHJcblx0ICAgICAgICAgICAga3ZEYXRhTGlzdC5wdXNoKHtrZXk6IFwiXGJ4bWJTY29yZVwiLCB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoa3ZEYXRhKX0pO1xyXG5cdCAgICAgICAgICAgIHd4LnNldFVzZXJDbG91ZFN0b3JhZ2Uoe1xyXG5cdFx0ICAgICAgICAgICAgS1ZEYXRhTGlzdDoga3ZEYXRhTGlzdCxcclxuXHRcdCAgICAgICAgICAgIHN1Y2Nlc3M6IHJlcyA9PiB7XHJcblx0XHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdWNjZXNzOlwiICsgSlNPTi5zdHJpbmdpZnkocmVzKSlcclxuXHRcdCAgICAgICAgICAgIH0sXHJcblx0XHQgICAgICAgICAgICBmYWlsOiByZXMgPT4ge1xyXG5cdFx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFpbCA6IFwiICsgcmVzKTtcclxuXHRcdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgIFx0dmFyIGt2RGF0YT17fTtcclxuXHQgICAgICAgICAgICBrdkRhdGEud3hnYW1lPXt9O1xyXG5cdCAgICAgICAgICAgIGt2RGF0YS53eGdhbWUuc2NvcmUgPSBzb2NyZTtcclxuXHQgICAgICAgICAgICBrdkRhdGEud3hnYW1lLnVwZGF0ZV90aW1lID0gIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGt2RGF0YSkpO1xyXG5cclxuXHQgICAgICAgICAgICB2YXIga3ZEYXRhTGlzdCA9IG5ldyBBcnJheSgpO1xyXG5cdCAgICAgICAgICAgIGt2RGF0YUxpc3QucHVzaCh7a2V5OiBcIlxieG1iU2NvcmVcIiwgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGt2RGF0YSl9KTtcclxuXHJcblx0ICAgICAgICBcdHN3YW4uc2V0VXNlckNsb3VkU3RvcmFnZSh7XHJcblx0XHRcdFx0XHRLVkRhdGFMaXN0OiBrdkRhdGFMaXN0LFxyXG5cdFx0XHRcdFx0c3VjY2VzczogcmVzID0+IGNvbnNvbGUubG9nKFwic3VjY2VzcyBcIityZXMpLFxyXG5cdFx0XHRcdFx0ZmFpbDogcmVzID0+IGNvbnNvbGUubG9nKFwiZmFpbCBcIityZXMpLFxyXG5cdFx0XHRcdFx0Y29tcGxldGU6IHJlcyA9PiBjb25zb2xlLmxvZyhcImNvbXBsZXRlIFwiK3JlcylcclxuXHRcdFx0XHR9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSxcclxuXHJcblx0ICAgIC8v5piv5ZCm5pSv5oyB5o6S6KGM5Yqf6IO9XHJcblx0ICAgIElzU3VwcG9ydFJhbms6ZnVuY3Rpb24oKVxyXG5cdCAgICB7XHJcblx0XHRcdGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcblx0XHRcdGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuXHRcdFx0XHRpc0t1YWlTaG91ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdCAgICAgICAgaWYoKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLldFQ0hBVF9HQU1FICYmICFpc0t1YWlTaG91KSB8fCBjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CQUlEVV9HQU1FKVxyXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIC8v5pi+56S65a2Q5Z+fXHJcblx0ICAgIHNob3dTdWJDb250ZW50VmlldzpmdW5jdGlvbigpXHJcblx0ICAgIHtcclxuXHRcdFx0bGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG5cdFx0XHRcdGlzS3VhaVNob3UgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0ICAgICAgICBpZigoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuV0VDSEFUX0dBTUUgJiYgIWlzS3VhaVNob3UpIHx8IGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJBSURVX0dBTUUgKVxyXG5cdCAgICAgICAge1xyXG5cdFx0ICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuXHRcdCAgICAgICAgcGFyYW0uZmxhZyA9IHRydWU7XHJcblx0XHQgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlNob3dSYW5rLCBwYXJhbSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBoaWRlU3ViQ29udGVudFZpZXc6ZnVuY3Rpb24oKVxyXG5cdCAgICB7XHJcblx0XHRcdGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcblx0XHRcdGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuXHRcdFx0XHRpc0t1YWlTaG91ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdCAgICAgICAgaWYoKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLldFQ0hBVF9HQU1FICYmICFpc0t1YWlTaG91KSB8fCBjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CQUlEVV9HQU1FIClcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuXHRcdCAgICAgICAgcGFyYW0uZmxhZyA9IGZhbHNlO1xyXG5cdFx0ICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5TaG93UmFuaywgcGFyYW0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgU2VuZE1lc3NhZ2VUb1N1YlZpZXc6ZnVuY3Rpb24oY29kZSxjdXJTY29yZT0wKVxyXG5cdCAgICB7XHJcblx0ICAgICAgICB2YXIgbXNnPXt9O1xyXG5cdCAgICAgICAgbXNnLmNvZGUgPSBjb2RlO1xyXG5cdCAgICAgICAgbXNnLmN1clNjb3JlID0gY3VyU2NvcmU7XHJcblx0XHRcdGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcblx0XHRcdGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuXHRcdFx0XHRpc0t1YWlTaG91ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdCAgICAgICAgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuV0VDSEFUX0dBTUUgJiYgIWlzS3VhaVNob3UpXHJcblx0ICAgICAgICB7XHJcblx0ICAgICAgICAgICAgd3guZ2V0T3BlbkRhdGFDb250ZXh0KCkucG9zdE1lc3NhZ2Uoe1xyXG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgIFx0c3dhbi5nZXRPcGVuRGF0YUNvbnRleHQoKS5wb3N0TWVzc2FnZSh7XHJcblx0XHRcdFx0ICAgIG1lc3NhZ2U6IG1zZ1xyXG5cdFx0XHRcdH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgLy/mlbTnkIbmlbDmja5cclxuXHQgICAgQ29sbGF0ZURhdGE6ZnVuY3Rpb24oZGF0YSlcclxuXHQgICAge1xyXG5cdCAgICAgICAgdGhpcy51c2VySW5mbyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGogPSAwO1xyXG5cdCAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgaWYoZGF0YVtpXS5LVkRhdGFMaXN0Lmxlbmd0aCA9PSAwKVxyXG5cdCAgICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb21iRGF0YSDmsqHmnInmraTpobnmlbDmja5cIik7XHJcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAvL3tcIm9wZW5pZFwiOlwibzBPaFo1S24yeE85YjVGVlI4VEUwWVhPbDNXY1wiLFwibmlja25hbWVcIjpcIuadqOW9rFwiLFwiYXZhdGFyVXJsXCI6XCJodHRwczovL3d4LnFsb2dvLmNuL21tb3Blbi92aV8zMi9GY1JpYkdQa2ljU0tobjZMQTFPV2ZMN2ljdGlhS2lhanppYnpXOHp3UWlia0dLZENKbW1pYXN2aWJjUmFzSTJLeXRjVnRXOENsSDVJUVRzT3MzQ0I4dnlNU1VBT2FyQS8xMzJcIixcIktWRGF0YUxpc3RcIjpbe1wia2V5XCI6XCJcXGJlbHNma1Njb3JlXCIsXCJ2YWx1ZVwiOlwie1xcXCJ3eGdhbWVcXFwiOntcXFwic2NvcmVcXFwiOjE4ODksXFxcInVwZGF0ZV90aW1lXFxcIjoxNTUzODI0MzY5OTIwfX1cIn1dfVxyXG5cdCAgICAgICAgICAgIHRoaXMudXNlckluZm9bal09e307XHJcblx0ICAgICAgICAgICAgdGhpcy51c2VySW5mb1tqXS5vcGVuaWQgPSBkYXRhW2ldLm9wZW5pZDtcclxuXHQgICAgICAgICAgICB0aGlzLnVzZXJJbmZvW2pdLm5pY2tuYW1lID0gZGF0YVtpXS5uaWNrbmFtZTtcclxuXHQgICAgICAgICAgICB0aGlzLnVzZXJJbmZvW2pdLmF2YXRhclVybCA9IGRhdGFbaV0uYXZhdGFyVXJsO1xyXG5cclxuXHQgICAgICAgICAgICB2YXIga1ZEYXRhTGlzdFZhbHVlc3RyID0gZGF0YVtpXS5LVkRhdGFMaXN0WzBdLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIGtWRGF0YUxpc3RWYWx1ZXN0ciA9IGtWRGF0YUxpc3RWYWx1ZXN0ci5zdWJzdHIoMSk7IC8v5Yig6Zmk56ys5LiA5Liq5a2X56ymXHJcblx0ICAgICAgICAgICAga1ZEYXRhTGlzdFZhbHVlc3RyID0ga1ZEYXRhTGlzdFZhbHVlc3RyLnN1YnN0cigwLCBrVkRhdGFMaXN0VmFsdWVzdHIubGVuZ3RoLTEpOyBcclxuXHQgICAgICAgICAgICBrVkRhdGFMaXN0VmFsdWVzdHIgPSBcIntcIiArIGtWRGF0YUxpc3RWYWx1ZXN0ciArIFwifVwiO1xyXG5cdCAgICAgICAgICAgIHZhciBnYW1lU2NvcmUgPSBKU09OLnBhcnNlKGtWRGF0YUxpc3RWYWx1ZXN0cikud3hnYW1lO1xyXG5cdCAgICAgICAgICAgIHRoaXMudXNlckluZm9bal0uc2NvcmUgPSBnYW1lU2NvcmUuc2NvcmU7XHJcblx0ICAgICAgICAgICAgaisrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy/nu5nnlKjmiLfmlbDmja7ov5vooYzmjpLluo9cclxuXHQgICAgICAgIHRoaXMudXNlckluZm8uc29ydCgoYSxiKT0+e1xyXG5cdCAgICAgICAgICAgICAgICBpZihhLnNjb3JlPGIuc2NvcmUpXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZihhLnNjb3JlPmIuc2NvcmUpXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTFcclxuXHQgICAgICAgICAgICAgICAgZWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgKTtcclxuXHQgICAgICAgIGNvbnNvbGUubG9nKFwiQ29sbGF0ZURhdGEtLS0gXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJJbmZvKSk7XHJcblx0ICAgICAgICBmb3IodmFyIGk9MCA7aTx0aGlzLnVzZXJJbmZvLmxlbmd0aDtpKyspXHJcblx0ICAgICAgICB7XHQvL+aMkeWHuuiHquW3seeahOaOkuWQjVxyXG5cdCAgICAgICAgICAgIGlmKHRoaXMudXNlckluZm9baV0uYXZhdGFyVXJsID09IHRoaXMuYXZhdGFyVXJsKVxyXG5cdCAgICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5teVNvcmRJZCA9IGk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSBcclxuXHQgICAgfSxcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXRmb3JtQ29udHJvbGxlcjtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/ShareInfos.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ecf05SSwXpJOrO5OpN+e4NG', 'ShareInfos');
// Scripts/Core/ShareInfos.js

"use strict";

var ShareInfos = cc.Class({
  "extends": cc.Component,
  statics: {
    init: function init() {
      this.Infos = [{
        text: "【有人@你】我在这个游戏里面挣了一个亿",
        url: "https://paopao.talkyun.com.cn/yiyi/1.jpg"
      }, {
        text: "迎娶白富美，开着法拉利。这才是我想要的人生巅峰",
        url: "https://paopao.talkyun.com.cn/yiyi/2.jpg"
      }, {
        text: "开局几万块，看我如何打遍商界无敌手。",
        url: "https://paopao.talkyun.com.cn/yiyi/3.jpg"
      }, {
        text: "不看不知道，我的资产在好友中排名居然是。。。。",
        url: "https://paopao.talkyun.com.cn/yiyi/3.jpg"
      }, {
        text: "空姐和超模同时看上我，我该如何选择？",
        url: "https://paopao.talkyun.com.cn/yiyi/4.jpg"
      }, {
        text: "2019我定了一个小目标，没想到这么快就完成了。",
        url: "https://paopao.talkyun.com.cn/yiyi/5.jpg"
      }];
    },
    getShareInfos: function getShareInfos(index) {
      return this.Infos[index];
    }
  }
});
module.exports = ShareInfos;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcU2hhcmVJbmZvcy5qcyJdLCJuYW1lcyI6WyJTaGFyZUluZm9zIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInN0YXRpY3MiLCJpbml0IiwiSW5mb3MiLCJ0ZXh0IiwidXJsIiwiZ2V0U2hhcmVJbmZvcyIsImluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxVQUFVLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3RCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUNyQkMsT0FBTyxFQUFDO0lBQ0pDLElBQUksRUFBQyxTQUFBQSxLQUFBLEVBQ0w7TUFDSSxJQUFJLENBQUNDLEtBQUssR0FBRyxDQUNWO1FBQUNDLElBQUksRUFBQyxxQkFBcUI7UUFBQ0MsR0FBRyxFQUFDO01BQTBDLENBQUMsRUFDM0U7UUFBQ0QsSUFBSSxFQUFDLHlCQUF5QjtRQUFDQyxHQUFHLEVBQUM7TUFBMEMsQ0FBQyxFQUMvRTtRQUFDRCxJQUFJLEVBQUMsb0JBQW9CO1FBQUNDLEdBQUcsRUFBQztNQUEwQyxDQUFDLEVBQzFFO1FBQUNELElBQUksRUFBQyx5QkFBeUI7UUFBQ0MsR0FBRyxFQUFDO01BQTBDLENBQUMsRUFDL0U7UUFBQ0QsSUFBSSxFQUFDLG9CQUFvQjtRQUFDQyxHQUFHLEVBQUM7TUFBMEMsQ0FBQyxFQUMxRTtRQUFDRCxJQUFJLEVBQUMsMEJBQTBCO1FBQUNDLEdBQUcsRUFBQztNQUEwQyxDQUFDLENBQ2xGO0lBQ0wsQ0FBQztJQUVEQyxhQUFhLEVBQUMsU0FBQUEsY0FBU0MsS0FBSyxFQUFDO01BQ3pCLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNJLEtBQUssQ0FBQztJQUM1QjtFQUNKO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWixVQUFVIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIFNoYXJlSW5mb3MgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcbiAgICBzdGF0aWNzOntcclxuICAgICAgICBpbml0OmZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuSW5mb3MgPSBbXHJcbiAgICAgICAgICAgICAgIHt0ZXh0Olwi44CQ5pyJ5Lq6QOS9oOOAkeaIkeWcqOi/meS4qua4uOaIj+mHjOmdouaMo+S6huS4gOS4quS6v1wiLHVybDpcImh0dHBzOi8vcGFvcGFvLnRhbGt5dW4uY29tLmNuL3lpeWkvMS5qcGdcIn0sXHJcbiAgICAgICAgICAgICAgIHt0ZXh0Olwi6L+O5ai255m95a+M576O77yM5byA552A5rOV5ouJ5Yip44CC6L+Z5omN5piv5oiR5oOz6KaB55qE5Lq655Sf5beF5bOwXCIsdXJsOlwiaHR0cHM6Ly9wYW9wYW8udGFsa3l1bi5jb20uY24veWl5aS8yLmpwZ1wifSxcclxuICAgICAgICAgICAgICAge3RleHQ6XCLlvIDlsYDlh6DkuIflnZfvvIznnIvmiJHlpoLkvZXmiZPpgY3llYbnlYzml6DmlYzmiYvjgIJcIix1cmw6XCJodHRwczovL3Bhb3Bhby50YWxreXVuLmNvbS5jbi95aXlpLzMuanBnXCJ9LFxyXG4gICAgICAgICAgICAgICB7dGV4dDpcIuS4jeeci+S4jeefpemBk++8jOaIkeeahOi1hOS6p+WcqOWlveWPi+S4reaOkuWQjeWxheeEtuaYr+OAguOAguOAguOAglwiLHVybDpcImh0dHBzOi8vcGFvcGFvLnRhbGt5dW4uY29tLmNuL3lpeWkvMy5qcGdcIn0sXHJcbiAgICAgICAgICAgICAgIHt0ZXh0Olwi56m65aeQ5ZKM6LaF5qih5ZCM5pe255yL5LiK5oiR77yM5oiR6K+l5aaC5L2V6YCJ5oup77yfXCIsdXJsOlwiaHR0cHM6Ly9wYW9wYW8udGFsa3l1bi5jb20uY24veWl5aS80LmpwZ1wifSxcclxuICAgICAgICAgICAgICAge3RleHQ6XCIyMDE55oiR5a6a5LqG5LiA5Liq5bCP55uu5qCH77yM5rKh5oOz5Yiw6L+Z5LmI5b+r5bCx5a6M5oiQ5LqG44CCXCIsdXJsOlwiaHR0cHM6Ly9wYW9wYW8udGFsa3l1bi5jb20uY24veWl5aS81LmpwZ1wifSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRTaGFyZUluZm9zOmZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSW5mb3NbaW5kZXhdO1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBTaGFyZUluZm9zOyJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/UserState.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '56bc61URDlPyZpfSEmHzgw+', 'UserState');
// Scripts/Core/UserState.js

"use strict";

//玩家状态
var UserState = cc.Enum({
  OK: 1,
  //健康状态
  NotOK: 2 //非健康状态
});

module.exports = UserState;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcVXNlclN0YXRlLmpzIl0sIm5hbWVzIjpbIlVzZXJTdGF0ZSIsImNjIiwiRW51bSIsIk9LIiwiTm90T0siLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsSUFBSUEsU0FBUyxHQUFHQyxFQUFFLENBQUNDLElBQUksQ0FBQztFQUNwQkMsRUFBRSxFQUFDLENBQUM7RUFBQztFQUNMQyxLQUFLLEVBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDOztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR04sU0FBUyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLy/njqnlrrbnirbmgIFcclxudmFyIFVzZXJTdGF0ZSA9IGNjLkVudW0oe1xyXG4gICAgT0s6MSwvL+WBpeW6t+eKtuaAgVxyXG4gICAgTm90T0s6MiwvL+mdnuWBpeW6t+eKtuaAgVxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBVc2VyU3RhdGU7Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/MapDataMgr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd28551OkKNJvql/1WnFj+bS', 'MapDataMgr');
// Scripts/DataMap/MapDataMgr.js

"use strict";

var CarMapDecoder = require("CarMapDecoder");
var CompanyMapDecoder = require("CompanyMapDecoder");
var GoodMapDecoder = require("GoodMapDecoder");
var HouseMapDecoder = require("HouseMapDecoder");
var MateMapDecoder = require("MateMapDecoder");
var SkillMapDecoder = require("SkillMapDecoder");
var CashMapDecoder = require("CashMapDecoder");
var AchieveMapDecoder = require("AchieveMapDecoder");
var EventMapDecoder = require("EventMapDecoder");
var ItemType = require("ItemType");
var MapDataMgr = cc.Class({
  "extends": cc.Component,
  properties: {
    carMap: null,
    companyMap: null,
    goodsMap: null,
    houseMap: null,
    mateMap: null,
    skillMap: null,
    cashMap: null,
    achieveMap: null,
    eventDataMap: null,
    decodeAll: 0
  },
  checkInitMapSuc: function checkInitMapSuc() {
    if (this.decodeAll == 100) {
      //cc.log("数据解析完了");
    }
  },
  //初始化解析数据表
  initMaps: function initMaps() {
    cc.log("开始解析数据了");
    cc.Mgr.Parse = false;
    this.goodsMap = new GoodMapDecoder();
    this.cashMap = new CashMapDecoder();
    this.houseMap = new HouseMapDecoder();
    this.companyMap = new CompanyMapDecoder();
    this.carMap = new CarMapDecoder();
    this.mateMap = new MateMapDecoder();
    this.skillMap = new SkillMapDecoder();
    this.achieveMap = new AchieveMapDecoder();
    this.eventDataMap = new EventMapDecoder();
    var self = this;
    this.decodeAll = 0;
    this.carMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 汽车" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.companyMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 公司" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.houseMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 房子"+ self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.mateMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 小伙伴" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.skillMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 技能" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.cashMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 现金" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.achieveMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 成就" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.eventDataMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 10;
        //cc.log("===解析数据成功=== 事件" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
    this.goodsMap.DecodeJson(function (result) {
      if (result) {
        self.decodeAll += 20;
        //cc.log("===解析数据成功=== 货物" + self.decodeAll);
        if (self.decodeAll == 100) {
          cc.Mgr.Parse = true;
          cc.director.GlobalEvent.emit(cc.Mgr.Event.ParseFinish, {});
        }
      }
    });
  },
  getDataByItemTypeAndId: function getDataByItemTypeAndId(itemType, itemId) {
    var data = null;
    //cc.log("ItemType = " + itemType + "  Id = " + itemId);
    switch (itemType) {
      case ItemType.Cash:
        data = this.cashMap.getDataByItemId(itemId);
        break;
      case ItemType.Goods:
        data = this.goodsMap.getDataByItemId(itemId);
        break;
      case ItemType.Skill:
        data = this.skillMap.getDataByItemId(itemId);
        break;
      case ItemType.Company:
        data = this.companyMap.getDataByItemId(itemId);
        break;
      case ItemType.House:
        data = this.houseMap.getDataByItemId(itemId);
        break;
      case ItemType.Car:
        data = this.carMap.getDataByItemId(itemId);
        break;
      case ItemType.Mate:
        data = this.mateMap.getDataByItemId(itemId);
        break;
      case ItemType.Achieve:
        data = this.achieveMap.getDataByItemId(itemId);
        break;
      case ItemType.EventData:
        data = this.eventDataMap.getDataByItemId(itemId);
        break;
    }
    return data;
  },
  getDataLengthByItemType: function getDataLengthByItemType(itemType) {
    var len = 0;
    switch (itemType) {
      case ItemType.Cash:
        len = this.cashMap.getJsonLength();
        break;
      case ItemType.Goods:
        len = this.goodsMap.getJsonLength();
        break;
      case ItemType.Skill:
        len = this.skillMap.getJsonLength();
        break;
      case ItemType.Company:
        len = this.companyMap.getJsonLength();
        break;
      case ItemType.House:
        len = this.houseMap.getJsonLength();
        break;
      case ItemType.Car:
        len = this.carMap.getJsonLength();
        break;
      case ItemType.Mate:
        len = this.mateMap.getJsonLength();
        break;
      case ItemType.Achieve:
        len = this.achieveMap.getJsonLength();
        break;
      case ItemType.EventData:
        len = this.eventDataMap.getJsonLength();
        break;
    }
    return len;
  },
  getDataListByItemType: function getDataListByItemType(itemType) {
    var dataList = null;
    //cc.log("拿数据 = " + itemType);
    switch (itemType) {
      case ItemType.Cash:
        dataList = this.cashMap.getDataList();
        break;
      case ItemType.Goods:
        dataList = this.goodsMap.getDataList();
        break;
      case ItemType.Skill:
        dataList = this.skillMap.getDataList();
        break;
      case ItemType.Company:
        dataList = this.companyMap.getDataList();
        break;
      case ItemType.House:
        dataList = this.houseMap.getDataList();
        break;
      case ItemType.Car:
        dataList = this.carMap.getDataList();
        break;
      case ItemType.Mate:
        dataList = this.mateMap.getDataList();
        break;
      case ItemType.Achieve:
        dataList = this.achieveMap.getDataList();
        break;
      case ItemType.EventData:
        dataList = this.eventDataMap.getDataList();
        break;
    }
    //cc.log("取得数据 " + dataList.length);
    return dataList;
  },
  //专门给技能的数据获取用
  getSkillListById: function getSkillListById(Id) {
    return this.skillMap.getSkillListById(Id);
  },
  getSkillDataByTwoId: function getSkillDataByTwoId(Id, subId) {
    return this.skillMap.getSkillDataByTwoId(Id);
  },
  getUpgradeCostByTwoId: function getUpgradeCostByTwoId(Id, subId, tolv) {
    return this.skillMap.getUpgradeCostByTwoId(Id, subId, tolv);
  },
  getSkillAddBonusByTwoIdAndLv: function getSkillAddBonusByTwoIdAndLv(Id, subId, tolv) {
    return this.skillMap.getSkillAddBonusByTwoIdAndLv(Id, subId, tolv);
  },
  //获取对应性别的购买物品
  getDataListBySex: function getDataListBySex(Sex) {
    return this.goodsMap.getDataListBySex(Sex);
  }
});
module.exports = MapDataMgr;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcTWFwRGF0YU1nci5qcyJdLCJuYW1lcyI6WyJDYXJNYXBEZWNvZGVyIiwicmVxdWlyZSIsIkNvbXBhbnlNYXBEZWNvZGVyIiwiR29vZE1hcERlY29kZXIiLCJIb3VzZU1hcERlY29kZXIiLCJNYXRlTWFwRGVjb2RlciIsIlNraWxsTWFwRGVjb2RlciIsIkNhc2hNYXBEZWNvZGVyIiwiQWNoaWV2ZU1hcERlY29kZXIiLCJFdmVudE1hcERlY29kZXIiLCJJdGVtVHlwZSIsIk1hcERhdGFNZ3IiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImNhck1hcCIsImNvbXBhbnlNYXAiLCJnb29kc01hcCIsImhvdXNlTWFwIiwibWF0ZU1hcCIsInNraWxsTWFwIiwiY2FzaE1hcCIsImFjaGlldmVNYXAiLCJldmVudERhdGFNYXAiLCJkZWNvZGVBbGwiLCJjaGVja0luaXRNYXBTdWMiLCJpbml0TWFwcyIsImxvZyIsIk1nciIsIlBhcnNlIiwic2VsZiIsIkRlY29kZUpzb24iLCJyZXN1bHQiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiUGFyc2VGaW5pc2giLCJnZXREYXRhQnlJdGVtVHlwZUFuZElkIiwiaXRlbVR5cGUiLCJpdGVtSWQiLCJkYXRhIiwiQ2FzaCIsImdldERhdGFCeUl0ZW1JZCIsIkdvb2RzIiwiU2tpbGwiLCJDb21wYW55IiwiSG91c2UiLCJDYXIiLCJNYXRlIiwiQWNoaWV2ZSIsIkV2ZW50RGF0YSIsImdldERhdGFMZW5ndGhCeUl0ZW1UeXBlIiwibGVuIiwiZ2V0SnNvbkxlbmd0aCIsImdldERhdGFMaXN0QnlJdGVtVHlwZSIsImRhdGFMaXN0IiwiZ2V0RGF0YUxpc3QiLCJnZXRTa2lsbExpc3RCeUlkIiwiSWQiLCJnZXRTa2lsbERhdGFCeVR3b0lkIiwic3ViSWQiLCJnZXRVcGdyYWRlQ29zdEJ5VHdvSWQiLCJ0b2x2IiwiZ2V0U2tpbGxBZGRCb251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dCI6WyJ2YXIgQ2FyTWFwRGVjb2RlciA9IHJlcXVpcmUoXCJDYXJNYXBEZWNvZGVyXCIpOyBcclxudmFyIENvbXBhbnlNYXBEZWNvZGVyID0gcmVxdWlyZShcIkNvbXBhbnlNYXBEZWNvZGVyXCIpO1xyXG52YXIgR29vZE1hcERlY29kZXIgPSByZXF1aXJlKFwiR29vZE1hcERlY29kZXJcIik7XHJcbnZhciBIb3VzZU1hcERlY29kZXIgPSByZXF1aXJlKFwiSG91c2VNYXBEZWNvZGVyXCIpO1xyXG52YXIgTWF0ZU1hcERlY29kZXIgPSByZXF1aXJlKFwiTWF0ZU1hcERlY29kZXJcIik7XHJcbnZhciBTa2lsbE1hcERlY29kZXIgPSByZXF1aXJlKFwiU2tpbGxNYXBEZWNvZGVyXCIpO1xyXG52YXIgQ2FzaE1hcERlY29kZXIgPSByZXF1aXJlKFwiQ2FzaE1hcERlY29kZXJcIik7XHJcbnZhciBBY2hpZXZlTWFwRGVjb2RlciA9IHJlcXVpcmUoXCJBY2hpZXZlTWFwRGVjb2RlclwiKTtcclxudmFyIEV2ZW50TWFwRGVjb2RlciA9IHJlcXVpcmUoXCJFdmVudE1hcERlY29kZXJcIik7XHJcblxyXG52YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcblxyXG52YXIgTWFwRGF0YU1nciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgY2FyTWFwOm51bGwsICBcclxuICAgICAgICBjb21wYW55TWFwOm51bGwsXHJcbiAgICAgICAgZ29vZHNNYXA6bnVsbCxcclxuICAgICAgICBob3VzZU1hcDpudWxsLFxyXG4gICAgICAgIG1hdGVNYXA6bnVsbCxcclxuICAgICAgICBza2lsbE1hcDpudWxsLFxyXG4gICAgICAgIGNhc2hNYXA6bnVsbCxcclxuICAgICAgICBhY2hpZXZlTWFwOm51bGwsXHJcbiAgICAgICAgZXZlbnREYXRhTWFwOm51bGwsXHJcblxyXG4gICAgICAgIGRlY29kZUFsbDowLFxyXG4gICAgfSxcclxuXHJcbiAgICBjaGVja0luaXRNYXBTdWM6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZih0aGlzLmRlY29kZUFsbCA9PSAxMDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuaVsOaNruino+aekOWujOS6hlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yid5aeL5YyW6Kej5p6Q5pWw5o2u6KGoXHJcbiAgICBpbml0TWFwczpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2MubG9nKFwi5byA5aeL6Kej5p6Q5pWw5o2u5LqGXCIpO1xyXG4gICAgICAgIGNjLk1nci5QYXJzZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ29vZHNNYXAgPSBuZXcgR29vZE1hcERlY29kZXIoKTtcclxuICAgICAgICB0aGlzLmNhc2hNYXAgPSBuZXcgQ2FzaE1hcERlY29kZXIoKTtcclxuICAgICAgICB0aGlzLmhvdXNlTWFwID0gbmV3IEhvdXNlTWFwRGVjb2RlcigpO1xyXG4gICAgICAgIHRoaXMuY29tcGFueU1hcCA9IG5ldyBDb21wYW55TWFwRGVjb2RlcigpO1xyXG4gICAgICAgIHRoaXMuY2FyTWFwID0gbmV3IENhck1hcERlY29kZXIoKTtcclxuICAgICAgICB0aGlzLm1hdGVNYXAgPSBuZXcgTWF0ZU1hcERlY29kZXIoKTtcclxuICAgICAgICB0aGlzLnNraWxsTWFwID0gbmV3IFNraWxsTWFwRGVjb2RlcigpO1xyXG4gICAgICAgIHRoaXMuYWNoaWV2ZU1hcCA9IG5ldyBBY2hpZXZlTWFwRGVjb2RlcigpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREYXRhTWFwID0gbmV3IEV2ZW50TWFwRGVjb2RlcigpO1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5kZWNvZGVBbGwgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmNhck1hcC5EZWNvZGVKc29uKGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICAgICAgICAgIGlmKHJlc3VsdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVBbGwgKz0xMDtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5pWw5o2u5oiQ5YqfPT09IOaxvei9plwiICsgc2VsZi5kZWNvZGVBbGwpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5kZWNvZGVBbGwgPT0gMTAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5QYXJzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuUGFyc2VGaW5pc2gsIHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmNvbXBhbnlNYXAuRGVjb2RlSnNvbihmdW5jdGlvbihyZXN1bHQpe1xyXG4gICAgICAgICAgICBpZihyZXN1bHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlQWxsICs9MTA7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIj09Peino+aekOaVsOaNruaIkOWKnz09PSDlhazlj7hcIiArIHNlbGYuZGVjb2RlQWxsKTtcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYuZGVjb2RlQWxsID09IDEwMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuUGFyc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlBhcnNlRmluaXNoLCB7fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5ob3VzZU1hcC5EZWNvZGVKc29uKGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICAgICAgICAgIGlmKHJlc3VsdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVBbGwgKz0xMDtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5pWw5o2u5oiQ5YqfPT09IOaIv+WtkFwiKyBzZWxmLmRlY29kZUFsbCk7XHJcbiAgICAgICAgICAgICAgICBpZihzZWxmLmRlY29kZUFsbCA9PSAxMDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlBhcnNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5QYXJzZUZpbmlzaCwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWF0ZU1hcC5EZWNvZGVKc29uKGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICAgICAgICAgIGlmKHJlc3VsdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVBbGwgKz0xMDtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5pWw5o2u5oiQ5YqfPT09IOWwj+S8meS8tFwiICsgc2VsZi5kZWNvZGVBbGwpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5kZWNvZGVBbGwgPT0gMTAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5QYXJzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuUGFyc2VGaW5pc2gsIHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnNraWxsTWFwLkRlY29kZUpzb24oZnVuY3Rpb24ocmVzdWx0KXtcclxuICAgICAgICAgICAgaWYocmVzdWx0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUFsbCArPTEwO1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCI9PT3op6PmnpDmlbDmja7miJDlip89PT0g5oqA6IO9XCIgKyBzZWxmLmRlY29kZUFsbCk7XHJcbiAgICAgICAgICAgICAgICBpZihzZWxmLmRlY29kZUFsbCA9PSAxMDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlBhcnNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5QYXJzZUZpbmlzaCwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FzaE1hcC5EZWNvZGVKc29uKGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICAgICAgICAgIGlmKHJlc3VsdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVBbGwgKz0xMDtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5pWw5o2u5oiQ5YqfPT09IOeOsOmHkVwiICsgc2VsZi5kZWNvZGVBbGwpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5kZWNvZGVBbGwgPT0gMTAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5QYXJzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuUGFyc2VGaW5pc2gsIHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFjaGlldmVNYXAuRGVjb2RlSnNvbihmdW5jdGlvbihyZXN1bHQpe1xyXG4gICAgICAgICAgICBpZihyZXN1bHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlQWxsICs9MTA7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIj09Peino+aekOaVsOaNruaIkOWKnz09PSDmiJDlsLFcIiArIHNlbGYuZGVjb2RlQWxsKTtcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYuZGVjb2RlQWxsID09IDEwMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuUGFyc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlBhcnNlRmluaXNoLCB7fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudERhdGFNYXAuRGVjb2RlSnNvbihmdW5jdGlvbihyZXN1bHQpe1xyXG4gICAgICAgICAgICBpZihyZXN1bHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlQWxsICs9MTA7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIj09Peino+aekOaVsOaNruaIkOWKnz09PSDkuovku7ZcIiArIHNlbGYuZGVjb2RlQWxsKTtcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYuZGVjb2RlQWxsID09IDEwMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuUGFyc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlBhcnNlRmluaXNoLCB7fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5nb29kc01hcC5EZWNvZGVKc29uKGZ1bmN0aW9uKHJlc3VsdCl7XHJcbiAgICAgICAgICAgIGlmKHJlc3VsdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVBbGwgKz0yMDtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwiPT096Kej5p6Q5pWw5o2u5oiQ5YqfPT09IOi0p+eJqVwiICsgc2VsZi5kZWNvZGVBbGwpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5kZWNvZGVBbGwgPT0gMTAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5QYXJzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuUGFyc2VGaW5pc2gsIHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXREYXRhQnlJdGVtVHlwZUFuZElkOmZ1bmN0aW9uKGl0ZW1UeXBlLCBpdGVtSWQpe1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICAvL2NjLmxvZyhcIkl0ZW1UeXBlID0gXCIgKyBpdGVtVHlwZSArIFwiICBJZCA9IFwiICsgaXRlbUlkKTtcclxuICAgICAgICBzd2l0Y2goaXRlbVR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkNhc2g6XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5jYXNoTWFwLmdldERhdGFCeUl0ZW1JZChpdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuR29vZHM6XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5nb29kc01hcC5nZXREYXRhQnlJdGVtSWQoaXRlbUlkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLlNraWxsOlxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuc2tpbGxNYXAuZ2V0RGF0YUJ5SXRlbUlkKGl0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5Db21wYW55OlxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuY29tcGFueU1hcC5nZXREYXRhQnlJdGVtSWQoaXRlbUlkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkhvdXNlOlxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuaG91c2VNYXAuZ2V0RGF0YUJ5SXRlbUlkKGl0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5DYXI6XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5jYXJNYXAuZ2V0RGF0YUJ5SXRlbUlkKGl0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5NYXRlOlxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMubWF0ZU1hcC5nZXREYXRhQnlJdGVtSWQoaXRlbUlkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkFjaGlldmU6XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5hY2hpZXZlTWFwLmdldERhdGFCeUl0ZW1JZChpdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuRXZlbnREYXRhOlxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZXZlbnREYXRhTWFwLmdldERhdGFCeUl0ZW1JZChpdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXREYXRhTGVuZ3RoQnlJdGVtVHlwZTpmdW5jdGlvbihpdGVtVHlwZSl7XHJcbiAgICAgICAgdmFyIGxlbiA9IDA7XHJcbiAgICAgICAgc3dpdGNoKGl0ZW1UeXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5DYXNoOlxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5jYXNoTWFwLmdldEpzb25MZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkdvb2RzOlxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5nb29kc01hcC5nZXRKc29uTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5Ta2lsbDpcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuc2tpbGxNYXAuZ2V0SnNvbkxlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuQ29tcGFueTpcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuY29tcGFueU1hcC5nZXRKc29uTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5Ib3VzZTpcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuaG91c2VNYXAuZ2V0SnNvbkxlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuQ2FyOlxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5jYXJNYXAuZ2V0SnNvbkxlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuTWF0ZTpcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubWF0ZU1hcC5nZXRKc29uTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5BY2hpZXZlOlxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5hY2hpZXZlTWFwLmdldEpzb25MZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkV2ZW50RGF0YTpcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuZXZlbnREYXRhTWFwLmdldEpzb25MZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGVuO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXREYXRhTGlzdEJ5SXRlbVR5cGU6ZnVuY3Rpb24oaXRlbVR5cGUpe1xyXG4gICAgICAgIHZhciBkYXRhTGlzdCA9IG51bGw7XHJcbiAgICAgICAgLy9jYy5sb2coXCLmi7/mlbDmja4gPSBcIiArIGl0ZW1UeXBlKTtcclxuICAgICAgICBzd2l0Y2goaXRlbVR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkNhc2g6XHJcbiAgICAgICAgICAgICAgICBkYXRhTGlzdCA9IHRoaXMuY2FzaE1hcC5nZXREYXRhTGlzdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuR29vZHM6XHJcbiAgICAgICAgICAgICAgICBkYXRhTGlzdCA9IHRoaXMuZ29vZHNNYXAuZ2V0RGF0YUxpc3QoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLlNraWxsOlxyXG4gICAgICAgICAgICAgICAgZGF0YUxpc3QgPSB0aGlzLnNraWxsTWFwLmdldERhdGFMaXN0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5Db21wYW55OlxyXG4gICAgICAgICAgICAgICAgZGF0YUxpc3QgPSB0aGlzLmNvbXBhbnlNYXAuZ2V0RGF0YUxpc3QoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkhvdXNlOlxyXG4gICAgICAgICAgICAgICAgZGF0YUxpc3QgPSB0aGlzLmhvdXNlTWFwLmdldERhdGFMaXN0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5DYXI6XHJcbiAgICAgICAgICAgICAgICBkYXRhTGlzdCA9IHRoaXMuY2FyTWFwLmdldERhdGFMaXN0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBJdGVtVHlwZS5NYXRlOlxyXG4gICAgICAgICAgICAgICAgZGF0YUxpc3QgPSB0aGlzLm1hdGVNYXAuZ2V0RGF0YUxpc3QoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEl0ZW1UeXBlLkFjaGlldmU6XHJcbiAgICAgICAgICAgICAgICBkYXRhTGlzdCA9IHRoaXMuYWNoaWV2ZU1hcC5nZXREYXRhTGlzdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgSXRlbVR5cGUuRXZlbnREYXRhOlxyXG4gICAgICAgICAgICAgICAgZGF0YUxpc3QgPSB0aGlzLmV2ZW50RGF0YU1hcC5nZXREYXRhTGlzdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY2MubG9nKFwi5Y+W5b6X5pWw5o2uIFwiICsgZGF0YUxpc3QubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gZGF0YUxpc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5LiT6Zeo57uZ5oqA6IO955qE5pWw5o2u6I635Y+W55SoXHJcbiAgICBnZXRTa2lsbExpc3RCeUlkOmZ1bmN0aW9uKElkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNraWxsTWFwLmdldFNraWxsTGlzdEJ5SWQoSWQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTa2lsbERhdGFCeVR3b0lkOmZ1bmN0aW9uKElkLCBzdWJJZCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpbGxNYXAuZ2V0U2tpbGxEYXRhQnlUd29JZChJZCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVwZ3JhZGVDb3N0QnlUd29JZDpmdW5jdGlvbihJZCwgc3ViSWQsIHRvbHYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpbGxNYXAuZ2V0VXBncmFkZUNvc3RCeVR3b0lkKElkLCBzdWJJZCwgdG9sdik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNraWxsQWRkQm9udXNCeVR3b0lkQW5kTHY6ZnVuY3Rpb24gKElkLCBzdWJJZCwgdG9sdikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNraWxsTWFwLmdldFNraWxsQWRkQm9udXNCeVR3b0lkQW5kTHYoSWQsIHN1YklkLCB0b2x2KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/ojrflj5blr7nlupTmgKfliKvnmoTotK3kubDnianlk4FcclxuICAgIGdldERhdGFMaXN0QnlTZXg6ZnVuY3Rpb24oU2V4KXtcclxuICAgICAgICByZXR1cm4gdGhpcy5nb29kc01hcC5nZXREYXRhTGlzdEJ5U2V4KFNleCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hcERhdGFNZ3I7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/TutorialStep.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0592a+UO8RMNYlxga078oZp', 'TutorialStep');
// Scripts/Core/TutorialStep.js

"use strict";

var _cc$Enum;
var TutorialStep = cc.Enum((_cc$Enum = {
  Market_1: 11,
  Market_2: 12,
  Market_3: 13,
  Market_4: 14
}, _cc$Enum["Market_1"] = 15, _cc$Enum.MateDate_1 = 21, _cc$Enum.MateDate_2 = 22, _cc$Enum.MateDate_3 = 23, _cc$Enum.Business_1 = 31, _cc$Enum.Business_2 = 32, _cc$Enum.Business_3 = 33, _cc$Enum.StockBonus_1 = 41, _cc$Enum.DateToMarry_1 = 51, _cc$Enum));
module.exports = TutorialStep;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcVHV0b3JpYWxTdGVwLmpzIl0sIm5hbWVzIjpbIlR1dG9yaWFsU3RlcCIsImNjIiwiRW51bSIsIl9jYyRFbnVtIiwiTWFya2V0XzEiLCJNYXJrZXRfMiIsIk1hcmtldF8zIiwiTWFya2V0XzQiLCJNYXRlRGF0ZV8xIiwiTWF0ZURhdGVfMiIsIk1hdGVEYXRlXzMiLCJCdXNpbmVzc18xIiwiQnVzaW5lc3NfMiIsIkJ1c2luZXNzXzMiLCJTdG9ja0JvbnVzXzEiLCJEYXRlVG9NYXJyeV8xIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxHQUFHQyxFQUFFLENBQUNDLElBQUksRUFBQUMsUUFBQTtFQUN0QkMsUUFBUSxFQUFDLEVBQUU7RUFDWEMsUUFBUSxFQUFDLEVBQUU7RUFDWEMsUUFBUSxFQUFDLEVBQUU7RUFDWEMsUUFBUSxFQUFDO0FBQUUsR0FBQUosUUFBQSxlQUNGLEVBQUUsRUFBQUEsUUFBQSxDQUVYSyxVQUFVLEdBQUMsRUFBRSxFQUFBTCxRQUFBLENBQ2JNLFVBQVUsR0FBQyxFQUFFLEVBQUFOLFFBQUEsQ0FDYk8sVUFBVSxHQUFDLEVBQUUsRUFBQVAsUUFBQSxDQUViUSxVQUFVLEdBQUMsRUFBRSxFQUFBUixRQUFBLENBQ2JTLFVBQVUsR0FBQyxFQUFFLEVBQUFULFFBQUEsQ0FDYlUsVUFBVSxHQUFDLEVBQUUsRUFBQVYsUUFBQSxDQUViVyxZQUFZLEdBQUMsRUFBRSxFQUFBWCxRQUFBLENBRWZZLGFBQWEsR0FBQyxFQUFFLEVBQUFaLFFBQUEsRUFDbEI7QUFDRmEsTUFBTSxDQUFDQyxPQUFPLEdBQUdqQixZQUFZIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVHV0b3JpYWxTdGVwID0gY2MuRW51bSh7XHJcbiAgICBNYXJrZXRfMToxMSxcclxuICAgIE1hcmtldF8yOjEyLFxyXG4gICAgTWFya2V0XzM6MTMsXHJcbiAgICBNYXJrZXRfNDoxNCxcclxuICAgIE1hcmtldF8xOjE1LFxyXG5cclxuICAgIE1hdGVEYXRlXzE6MjEsXHJcbiAgICBNYXRlRGF0ZV8yOjIyLFxyXG4gICAgTWF0ZURhdGVfMzoyMyxcclxuXHJcbiAgICBCdXNpbmVzc18xOjMxLFxyXG4gICAgQnVzaW5lc3NfMjozMixcclxuICAgIEJ1c2luZXNzXzM6MzMsXHJcblxyXG4gICAgU3RvY2tCb251c18xOjQxLC8v6IKh56Wo5YiG57qiXHJcblxyXG4gICAgRGF0ZVRvTWFycnlfMTo1MSwvL+S6suWvhuW6plxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBUdXRvcmlhbFN0ZXA7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/UserDataMgr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ce713zmIxdFJqdsbJKrBLY2', 'UserDataMgr');
// Scripts/Core/UserDataMgr.js

"use strict";

var _cc$Class;
var ItemType = require("ItemType");
var RewardType = require("RewardType");
var MateBonusType = require("MateBonusType");
var SkillType = require("SkillType");
var MateUnLockType = require("MateUnLockType");
var MateGetType = require("MateGetType");
var UserState = require("UserState");
var AchieveCondData = require("AchieveCondData");
var AchieveCond = require("AchieveCond");

//以下的数据要做永久保存
var SkillStruct = require("SkillStruct");
var AchieveStruct = require("AchieveStruct");
var RecordStruct = require("RecordStruct");
//下面的数值是不会永久保存的  指只会当局游戏保存
var GoodsStruct = require("GoodsStruct");
var CarStruct = require("CarStruct");
var HouseStruct = require("HouseStruct");
var CompanyStruct = require("CompanyStruct");
var MateStruct = require("MateStruct");
var eyouClientTiktok = require("EyouClientTiktok");
var eyouClientKs = require("EyouClientKs");
var eyouClient = require("eyouClient");
var httpUtil = require("httpUtil");
var crypto = require("crypto");

//数据操作结构
var UserDataMgr = cc.Class((_cc$Class = {
  "extends": cc.Component,
  properties: {
    //本地保存数据
    userId: "",
    tutorialInBus: false,
    tutorialInDate: false,
    tutorialInMarket: false,
    tutorialStockBonus: false,
    tutorialMatePoint: false,
    VideoLastTime: "",
    //每天看视频时间记录
    VideoAdsTimes: cc.Integer,
    //次数

    playTimes: cc.Integer,
    //游戏次数
    playerName: "Alex",
    Sex: cc.Integer,
    //1 man  2 woman
    SkillList: {
      "default": [],
      type: [SkillStruct]
    },
    AchievementList: {
      "default": [],
      type: [AchieveStruct]
    },
    RecordList: {
      "default": [],
      type: [RecordStruct]
    },
    MarryAge: cc.Integer,
    MarryRoleId: cc.Integer,
    DivorceAge: cc.Integer,
    FundationAge: cc.Integer,
    FundationCompanyId: cc.Integer,
    BankruptAge: cc.Integer,
    MillionAge: cc.Integer,
    TenMillionAge: cc.Integer,
    HundredMillionAge: cc.Integer,
    //非本地保存数据
    RetireAge: cc.Integer,
    //退休年龄 这个值跟成就有关
    BetWinRatio: 0.15,
    //賭博贏概率
    DateSuccescRatio: 0.2,
    //約會成功概率
    //BetCost:cc.Integer,//赌博花费
    HighAssets: cc.Integer,
    //资产巅峰值
    InitMoney: cc.Integer,
    //刚出来闯荡时候的所有资产
    Cash: cc.Integer,
    //现金
    HpPoint: cc.Integer,
    //健康指数
    Age: cc.Integer,
    //年龄
    Honor: cc.Integer,
    //头衔 1 百万富翁 等等  这个在玩到一亿元之后会有新的玩意
    Reputation: cc.Integer,
    //名声指数
    AssetsMoney: cc.Integer,
    //总资产
    WareHouseCapcity: cc.Integer,
    //仓库剩余容量
    WareHouseAllCapcity: cc.Integer,
    //仓库总容量
    hasCompany: false,
    //是否已经创办公司
    CanGetStockProfit: false,
    //能否计算股票收益了
    RecoverYear: 0,
    // 从恢复健康 剩余年限

    SkillBonusPoint: 0,
    //技能点

    //加成点 伴侣加成  技能加成 
    TreatBonus: 0.0,
    //治疗花费降低百分点
    WareHouseCapcityBonus: 0,
    //仓储加成
    CashBonus: 0,
    //金钱加成 每年加成
    CashRationBonus: 0,
    ReputationBonus: 0,
    //名声加成 每年
    HpPointBonus: 0,
    //健康加成
    WareHouseBonusEveryYear: 0,
    //每年的仓储加成
    RetireBonus: 0,
    //增加退休年限
    DateBonus: 0.0,
    //增加约会成功概率
    InitMoneyBonus: 0,
    //增加初始现金
    StockAddBonus: 0.0,
    //增加公司收益
    StockUpBonus: 0.0,
    //股票上涨 概率增加
    DateMoneyBonus: 0.0,
    //约会花费降低
    BetBonus: 0.0,
    //赌博赢钱概率上升
    SkillPointGetBonus: 0.0,
    //结算技能点获得提升
    ReputationInitBonus: 0,
    //初始名声加成
    CarBuyBonus: 0,
    //购买汽车价格降低
    EventCostBonus: 0,
    //事件消耗金钱降低
    HouseBuyBonuse: 0,
    //购买房屋 价格降低

    HistoryHighAssets: 0,
    // 记录历史退休最高资产

    userState: {
      "default": UserState.OK,
      type: UserState
    },
    // 玩家状态

    EventDataIdList: {
      "default": [],
      type: [cc.Integer]
    },
    //事件弹出 Id列表

    GoodsList: {
      "default": [],
      type: [GoodsStruct]
    },
    CarList: {
      "default": [],
      type: [CarStruct]
    },
    HouseList: {
      "default": [],
      type: [HouseStruct]
    },
    CompanyList: {
      "default": [],
      type: [CompanyStruct]
    },
    MateList: {
      "default": [],
      type: [MateStruct]
    },
    //当前显示的五个物品 每次只显示五个物品  只保存 Id
    ShowGoodsList: {
      "default": [],
      type: [cc.Integer]
    }
  },
  JudeGoodsOwned: function JudeGoodsOwned(Id) {
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      if (this.GoodsList[i].Id == Id && this.GoodsList[i].ownNum > 0) {
        return true;
      }
    }
    return false;
  },
  //清理市场显示数据
  ClearShowGoodsList: function ClearShowGoodsList() {
    this.ShowGoodsList.splice(0, this.ShowGoodsList.length);
  },
  //向显示数组中插入一个 显示数据 Id
  InsertGoodsIdToList: function InsertGoodsIdToList(Id) {
    this.ShowGoodsList.push(Id);
  },
  //检查Id 是否当前显示
  CheckIdIsInShowList: function CheckIdIsInShowList(Id) {
    var flag = false;
    for (var i = this.ShowGoodsList.length - 1; i >= 0; i--) {
      if (this.ShowGoodsList[i] == Id) {
        flag = true;
        break;
      }
    }
    return flag;
  },
  initData: function initData() {
    var _this = this;
    cc.Mgr.initData = false;
    this.userState = UserState.OK; //健康状态

    cc.Mgr.global.InitEventHappenAge();
    if (!cc.Mgr.UserDataMgr.userId) {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        eyouClientTiktok.getIns().init(9000009, function (initResp) {
          eyouClientTiktok.getIns().login(function (loginResp) {
            _this.tiktokGameVerifySession(loginResp.data.code).then(function (tiktokOpenId) {
              _this.execAfterObtainAccount(tiktokOpenId);
              cc.Mgr.initData = true;
            })["catch"](function (err) {
              return cc.log('登录失败:>', err);
            });
          });
        });
        return;
      } else if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        eyouClient.getIns().init(9000021, function (initResp) {
          eyouClient.getIns().login(function (loginResp) {
            _this.wechatGameVerifySession(loginResp.data.code).then(function (wxOpenId) {
              _this.execAfterObtainAccount(wxOpenId);
              cc.Mgr.initData = true;
            })["catch"](function (err) {
              return console.log('登录失败:>', err);
            });
          });
        });
        return;
      } else if (isKuaiShou) {
        console.log("运行在快手平台");
        eyouClientKs.getIns().init(9000005, function (initResp) {
          eyouClientKs.getIns().login(function (loginResp) {
            _this.kuaiShouGameVerifySession(loginResp.data.code).then(function (ksOpenId) {
              _this.execAfterObtainAccount(ksOpenId);
              cc.Mgr.initData = true;
            })["catch"](function (err) {
              return cc.log('登录失败:>', err);
            });
          });
        });
        return;
      }
    }
    this.execAfterObtainAccount('default');
    cc.Mgr.initData = true;
  },
  tiktokGameVerifySession: function tiktokGameVerifySession(code) {
    return new Promise(function (resolve, reject) {
      var reqObj = {
        gameId: 9000009,
        platformId: 2,
        code: code,
        timeStamp: Math.floor(Date.now() / 1000)
      };
      var secStr = "c-a-0-0-1-6-e-6-e-e-c-e-a-6-2-e-b-d-1-a-d-e-a-3-f-7-e-2-f-c-b-f-c-1-b-8-6-d-4-2";
      var signStr = reqObj.gameId + "-" + reqObj.platformId + "-" + reqObj.code + "-" + reqObj.timeStamp + "-" + secStr.replaceAll("-", "");
      reqObj.sign = crypto.createHash('md5').update(signStr, 'utf8').digest('hex');
      httpUtil.postJson("https://games.hndibei.com/market-multi-game-server/tiktokServer/verifySession", reqObj, function (reqFlag, resp) {
        if (reqFlag && resp.code === 0) {
          resolve(resp.data.userId);
        } else {
          reject(resp);
        }
      });
    });
  },
  wechatGameVerifySession: function wechatGameVerifySession(code) {
    return new Promise(function (resolve, reject) {
      var reqObj = {
        gameId: 9000021,
        platformId: 1,
        code: code,
        timeStamp: Math.floor(Date.now() / 1000)
      };
      // let secStr = "5-6-e-3-2-2-9-c-5-b-3-2-2-f-2-7-5-e-8-c-e-b-3-8-c-b-6-1-2-5-d-a" //首富养成记
      var secStr = "9-1-e-1-3-a-7-a-5-3-5-1-c-5-2-a-3-9-9-3-3-4-7-2-1-5-5-4-2-9-5-3"; //疯狂挪车王
      var signStr = reqObj.gameId + "-" + reqObj.platformId + "-" + reqObj.code + "-" + reqObj.timeStamp + "-" + secStr.replaceAll("-", "");
      reqObj.sign = crypto.createHash('md5').update(signStr, 'utf8').digest('hex');
      httpUtil.postJson("https://games.hndibei.com/market-wechat-game-server/wxServer/verifySession", reqObj, function (reqFlag, resp) {
        if (reqFlag && resp.code === 0) {
          resolve(resp.data.userId);
        } else {
          reject(resp);
        }
      });
    });
  },
  kuaiShouGameVerifySession: function kuaiShouGameVerifySession(code) {
    return new Promise(function (resolve, reject) {
      var reqObj = {
        gameId: 9000005,
        platformId: 9,
        code: code,
        timeStamp: Math.floor(Date.now() / 1000)
      };
      var secStr = "kki6E0EQWnigLYv272zIRA";
      var signStr = reqObj.gameId + "-" + reqObj.platformId + "-" + reqObj.code + "-" + reqObj.timeStamp + "-" + secStr.replaceAll("-", "");
      reqObj.sign = crypto.createHash('md5').update(signStr, 'utf8').digest('hex');
      httpUtil.post("https://games.hndibei.com/market-multi-game-server/kuaiShouServer/verifySession", reqObj, function (reqFlag, resp) {
        if (reqFlag && resp.code === 0) {
          resolve(resp.data.userId);
        } else {
          reject(resp);
        }
      });
    });
  },
  execAfterObtainAccount: function execAfterObtainAccount(userId) {
    this.userId = userId;

    //本地存储数据
    var StorageData = cc.sys.localStorage.getItem('XMB_userdata_' + this.userId); //作为一个整体保存起来
    if (StorageData == null || StorageData == "") {
      //cc.log("还没有保存过持久数据");
      var userdata = {};
      userdata.SkillList = null;
      userdata.AchievementList = null;
      userdata.playerName = "";
      userdata.Sex = 1;
      userdata.playTimes = 0;
      userdata.SkillBonusPoint = 0;
      userdata.tutorialInBus = false;
      userdata.tutorialInDate = false;
      userdata.tutorialInMarket = false;
      userdata.tutorialStockBonus = false;
      userdata.tutorialMatePoint = false;
      userdata.VideoAdsTimes = 0;
      userdata.VideoLastTime = "";
      userdata.HistoryHighAssets = 0;
      this.VideoLastTime = "";
      this.VideoAdsTimes = 0;
      this.playerName = userdata.playerName;
      this.Sex = userdata.Sex;
      this.playTimes = userdata.playTimes;
      this.tutorialInBus = userdata.tutorialInBus;
      this.tutorialInMarket = userdata.tutorialInMarket;
      this.tutorialInDate = userdata.tutorialInDate;
      this.tutorialStockBonus = userdata.tutorialStockBonus;
      this.tutorialMatePoint = userdata.tutorialMatePoint;
      this.SkillBonusPoint = userdata.SkillBonusPoint;
      var SkillList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Skill);
      for (var i = 0; i < SkillList.length; i++) {
        var data = SkillList[i];
        var sk = new SkillStruct();
        sk.name = data.name;
        sk.icon = data.icon;
        sk.Id = data.Id;
        sk.desId = data.desId;
        sk.subId = data.subId;
        sk.Uplv = data.upLevel;
        sk.skillType = data.skillType;
        sk.level = 0;
        this.SkillList[i] = sk;
      }
      var AchievementList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Achieve);
      for (var i = 0; i < AchievementList.length; i++) {
        var data = AchievementList[i];
        var ac = new AchieveStruct();
        ac.Id = data.Id;
        ac.icon = data.icon;
        ac.name = data.name;
        ac.desId = data.desId;
        ac.hasFinish = false;
        this.AchievementList[i] = ac;
      }
      userdata.SkillList = this.SkillList;
      userdata.AchievementList = this.AchievementList;
      userdata.RecordList = this.RecordList;
      cc.sys.localStorage.setItem('XMB_userdata_' + this.userId, JSON.stringify(userdata));
    } else {
      //cc.log("有之前保存的持久数据存在");
      var Data = JSON.parse(StorageData);
      this.playerName = Data.playerName;
      this.Sex = Data.Sex;
      this.playTimes = Data.playTimes;
      this.tutorialInBus = Data.tutorialInBus;
      this.tutorialInMarket = Data.tutorialInMarket;
      this.tutorialInDate = Data.tutorialInDate;
      this.tutorialStockBonus = Data.tutorialStockBonus;
      this.tutorialMatePoint = Data.tutorialMatePoint;
      this.HistoryHighAssets = Data.HistoryHighAssets;
      this.SkillList = Data.SkillList;
      this.SkillBonusPoint = Data.SkillBonusPoint;
      this.AchievementList = Data.AchievementList;
      this.VideoLastTime = Data.VideoLastTime;
      var testDate = new Date();

      //cc.log("++++++++++++++++++++++++++ " + testDate.toDateString());
      if (Data.VideoLastTime != testDate.toDateString()) {
        this.VideoAdsTimes = 0;
      } else {
        this.VideoAdsTimes = Data.VideoAdsTimes;
      }
      if (Data.RecordList != null) this.RecordList = Data.RecordList;
    }

    //获取其实天赋点加成
    this.GetInitSkillBonus(this.SkillList);
    this.MarryAge = 0;
    this.MarryRoleId = 0;
    this.DivorceAge = 0;
    this.FundationAge = 0;
    this.FundationCompanyId = 0;
    this.BankruptAge = 0;
    this.MillionAge = 0;
    this.TenMillionAge = 0;
    this.HundredMillionAge = 0;

    //初始化 玩一局的数据
    this.retireAge = cc.Mgr.global.RetireInitAge + this.RetireBonus;
    this.BetWinRatio = cc.Mgr.global.BetWinRatio + this.BetBonus / 100; //后面还会要加上加成
    this.DateSuccescRatio = cc.Mgr.global.DateSuccescRatio + this.DateBonus / 100;
    this.Cash = 0;
    this.HighAssets = 0;
    this.HpPoint = 100;
    this.RecoverYear = 0;
    this.userState = UserState.OK;
    this.Age = 20;
    this.Honor = 0; //没有头衔
    this.Reputation = this.ReputationInitBonus; //名声
    this.AssetsMoney = 0; //资产

    this.WareHouseBonusEveryYear = 0;
    this.WareHouseCapcity = cc.Mgr.global.InitWareHouseCapcity + this.WareHouseCapcityBonus; //仓库容量初始定100  这个值到时要根据 成就定
    this.WareHouseAllCapcity = cc.Mgr.global.InitWareHouseCapcity + this.WareHouseCapcityBonus;
    this.hasCompany = false; //没有公司
    this.CanGetStockProfit = false; //还不能计算股票收益

    var GoodsList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Goods);
    for (var i = 0; i < GoodsList.length; i++) {
      var data = GoodsList[i];
      var ac = new GoodsStruct();
      ac.name = data.name;
      ac.Id = data.Id;
      ac.icon = data.icon;
      ac.ownNum = 0;
      ac.buyPrice = 0; //买入价格
      ac.marketPrice = 0; //市场价格
      this.GoodsList[i] = ac;
    }
    var CarList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Car);
    for (var i = 0; i < CarList.length; i++) {
      var data = CarList[i];
      var ac = new CarStruct();
      ac.Id = data.Id;
      ac.icon = data.icon;
      ac.name = data.name;
      ac.ownNum = 0;
      ac.price = data.price;
      ac.addBonus = data.addBonus;
      ac.addHp = data.addHp;
      ac.addDate = data.addDate;
      this.CarList[i] = ac;
    }
    var HouseList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.House);
    for (var i = 0; i < HouseList.length; i++) {
      var data = HouseList[i];
      var ac = new HouseStruct();
      ac.Id = data.Id;
      ac.icon = data.icon;
      ac.name = data.name;
      ac.ownNum = 0;
      ac.price = data.price;
      ac.addBonus = data.addBonus;
      ac.addHp = data.addHp;
      this.HouseList[i] = ac;
    }
    var CompanyList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Company);
    for (var i = 0; i < CompanyList.length; i++) {
      var data = CompanyList[i];
      var ac = new CompanyStruct();
      ac.Id = data.Id;
      ac.icon = data.icon;
      ac.name = data.name;
      ac.bonusRatio = data.bonusRatio;
      ac.isOwned = false;
      ac.stockNum = 0;
      ac.stockCost = 0;
      ac.bankruptPrice = data.outPrice;
      ac.stockPrice = data.inPrice;
      ac.LimitYear = data.LimitYear;
      this.CompanyList[i] = ac;
    }
    var MateList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Mate);
    for (var i = 0; i < MateList.length; i++) {
      var data = MateList[i];
      var ac = new MateStruct();
      ac.Id = data.Id;
      ac.icon = data.icon;
      ac.name = data.name;
      ac.sex = data.sex;
      ac.LovePoint = 0;
      ac.canDate = false;
      ac.unlockCond = data.unlockCond;
      if (data.unlockCond == MateUnLockType.NULL) {
        ac.canDate = true;
      }
      ////cc.log(data.name + " 是否可以直接约会 " + data.unlockCond);
      ac.curLevel = 0; //等级
      ac.UpLv = false; //没有满级
      this.MateList[i] = ac;
    }
    //保存下 事件Id 每次刷一次事件  就会剔除一次
    var EventList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.EventData);
    for (var i = 0; i < EventList.length; i++) {
      var data = EventList[i];
      this.EventDataIdList[i] = data.Id;
    }
  },
  //初始 天赋技能获得加成数据
  GetInitSkillBonus: function GetInitSkillBonus(skillList) {
    this.TreatBonus = 0; //治疗花费降低百分点
    this.WareHouseCapcityBonus = 0; //仓储加成
    this.CashBonus = 0; //金钱加成 每年加成
    this.CashRationBonus = 0;
    this.ReputationBonus = 0; //名声加成 每年
    this.HpPointBonus = 0; //健康加成
    this.RetireBonus = 0; //增加退休年限
    this.DateBonus = 0; //增加约会成功概率
    this.InitMoneyBonus = 0; //增加初始现金
    this.StockAddBonus = 0; //增加公司收益
    this.StockUpBonus = 0; //股票上涨 概率增加
    this.DateMoneyBonus = 0; //约会花费降低
    this.BetBonus = 0; //赌博赢钱概率上升
    this.SkillPointGetBonus = 0; //结算技能点提升
    this.ReputationInitBonus = 0; //初始名声加成
    this.CarBuyBonus = 0; //购买汽车价格降低
    this.EventCostBonus = 0; //事件消耗金钱降低
    this.HouseBuyBonuse = 0; //购买房屋 价格降低

    for (var i = 0; i < skillList.length; i++) {
      var data = skillList[i];
      //获得数据
      var bonus = cc.Mgr.MapDataMgr.getSkillAddBonusByTwoIdAndLv(data.Id, data.subId, data.level);
      ////cc.log(data.skillType + "++++++++++++初始技能加成+++++++++++"+bonus);
      switch (data.skillType) {
        case SkillType.WLNS:
          this.WareHouseCapcityBonus = bonus; //已經計算
          break;
        case SkillType.THY:
          this.DateBonus = bonus; //百分比  已經計算
          break;
        case SkillType.XSJY:
          this.CashRationBonus = bonus; //已经加入计算
          break;
        case SkillType.FGZJ:
          this.InitMoneyBonus = bonus; //已经计算
          break;
        case SkillType.GSGL:
          this.StockAddBonus = bonus; //百分百 已经计算
          break;
        case SkillType.TPGS:
          this.StockUpBonus = bonus; //百分比 已经计算
          break;
        case SkillType.JZCC:
          this.SkillPointGetBonus = bonus; //百分比  已經計算
          break;
        case SkillType.MLSZ:
          this.DateMoneyBonus = bonus; //百分比 一计算
          break;
        case SkillType.DS:
          this.BetBonus = bonus; //百分比 已經計算
          break;
        case SkillType.LDYZ:
          this.RetireBonus = bonus; //已經算進去
          break;
        case SkillType.NSCM:
          this.ReputationInitBonus = bonus; //已經計算
          break;
        case SkillType.QCDR:
          this.CarBuyBonus = bonus; //百分比 一計算
          break;
        case SkillType.HYLL:
          this.EventCostBonus = bonus; //百分比 一计算
          break;
        case SkillType.DCZJ:
          this.HouseBuyBonuse = bonus; //百分比 一計算
          break;
      }
    }
  },
  //获取每年都会获得的加成数额
  GetBonusRewardEveryYear: function GetBonusRewardEveryYear() {
    // 包括 金钱 名声 健康值
    this.Cash += this.CashBonus;
    this.Cash = Math.floor(this.Cash * (1 + this.CashRationBonus));
    if (this.Cash < 100) this.Cash = 0;
    this.Reputation += this.ReputationBonus;
    if (this.Reputation < 0) this.Reputation = 0;
    this.HpPoint += this.HpPointBonus;
    if (this.HpPoint > 100) {
      this.HpPoint = 100;
    }
    this.WareHouseCapcity += this.WareHouseBonusEveryYear;
    this.WareHouseAllCapcity += this.WareHouseBonusEveryYear;
    if (this.WareHouseCapcity > 200) this.WareHouseCapcity = 200;
    if (this.WareHouseAllCapcity > 200) this.WareHouseAllCapcity = 200;
  },
  //获取一次事件id  并从数列中剔除这个 Id
  GetEventDataAndSpliceId: function GetEventDataAndSpliceId() {
    var len = this.EventDataIdList.length;
    //cc.log("11 事件数据剩余个数 = " + len);
    var seed = Math.floor(Math.random() * len);
    var out = this.EventDataIdList[seed];
    this.EventDataIdList.splice(seed, 1);
    //cc.log(out + "  事件数据剩余个数 = " + this.EventDataIdList.length);
    return out;
  },
  RefreshHistoryHighAsset: function RefreshHistoryHighAsset(asset) {
    this.HistoryHighAssets = asset;
  },
  //保存本地数据
  SaveUserData: function SaveUserData() {
    var userdata = {};
    userdata.playerName = this.playerName;
    userdata.Sex = this.Sex;
    userdata.SkillList = this.SkillList;
    //引导步骤
    userdata.tutorialInMarket = this.tutorialInMarket;
    userdata.tutorialInDate = this.tutorialInDate;
    userdata.tutorialInBus = this.tutorialInBus;
    userdata.tutorialStockBonus = this.tutorialStockBonus;
    userdata.tutorialMatePoint = this.tutorialMatePoint;
    userdata.HistoryHighAssets = this.HistoryHighAssets;
    userdata.VideoAdsTimes = this.VideoAdsTimes;
    userdata.VideoLastTime = this.VideoLastTime;
    userdata.playTimes = this.playTimes;
    userdata.AchievementList = this.AchievementList;
    userdata.RecordList = this.RecordList;
    userdata.SkillBonusPoint = this.SkillBonusPoint;
    cc.sys.localStorage.setItem('XMB_userdata_' + this.userId, JSON.stringify(userdata));
  },
  CreateRecord: function CreateRecord() {
    var reD = new RecordStruct();
    var asLv = 0;
    var td = Math.floor(this.AssetsMoney / 1000000);
    if (td > 0 && td < 10) {
      asLv = 1;
    } else if (td > 10 && td < 100) {
      asLv = 2;
    } else if (td > 100) {
      asLv = 3;
    }
    reD.retireAge = this.Age;
    reD.level = asLv;
    reD.assets = this.AssetsMoney;
    reD.highAssets = this.HighAssets;
    this.RecordList.push(reD);
    //this.SaveUserData();
  },

  //升级技能点
  UpGradeSkill: function UpGradeSkill(Id, subId, toLv) {
    var isOk = false;
    var NeedCost = cc.Mgr.MapDataMgr.getUpgradeCostByTwoId(Id, subId, toLv);
    if (this.SkillBonusPoint < NeedCost) return false;

    //不要求升级满技能即可升级下一个技能
    for (var i = 0; i < this.SkillList.length; i++) {
      if (this.SkillList[i].Id == Id && this.SkillList[i].subId + 1 == subId) {
        if (this.SkillList[i].level == 0) {
          //cc.log("上一个技能还没有升级到满级");
          return false;
        }
        //if(this.SkillList[i].level != this.SkillList[i].Uplv)
        //{
        //cc.log("上一个技能还没有升级到满级");
        //	return false;
        //}
      }
    }

    for (var i = 0; i < this.SkillList.length; i++) {
      if (this.SkillList[i].Id == Id && this.SkillList[i].subId == subId) {
        if (this.SkillList[i].level < this.SkillList[i].Uplv) {
          this.SkillList[i].level++;
          this.SkillBonusPoint -= NeedCost;
          isOk = true;
        } else {
          isOk = false;
        }
        break;
      }
    }
    return isOk;
  },
  CanShowUpTip: function CanShowUpTip(Id, subId, toLv) {
    var isOk = false;
    var NeedCost = cc.Mgr.MapDataMgr.getUpgradeCostByTwoId(Id, subId, toLv);
    if (this.SkillBonusPoint < NeedCost) return false;
    for (var i = 0; i < this.SkillList.length; i++) {
      if (this.SkillList[i].Id == Id && this.SkillList[i].subId + 1 == subId) {
        if (this.SkillList[i].level == 0) {
          //cc.log("上一个技能还没有升级到满级");
          return false;
        }
        //if(this.SkillList[i].level != this.SkillList[i].Uplv)
        //{
        //cc.log("上一个技能还没有升级到满级");
        //	return false;
        //}
      }
    }

    for (var i = 0; i < this.SkillList.length; i++) {
      if (this.SkillList[i].Id == Id && this.SkillList[i].subId == subId) {
        if (this.SkillList[i].level < this.SkillList[i].Uplv) {
          isOk = true;
        } else {
          isOk = false;
        }
        break;
      }
    }
    return isOk;
  },
  //完成指定成就
  FinishAchievement: function FinishAchievement(Id) {
    var isOk = false;
    for (var i = 0; i < this.AchievementList.length; i++) {
      if (this.AchievementList[i].Id == Id) {
        this.AchievementList[i].hasFinish = true;
        isOk = true;
        break;
      }
    }
    return isOk;
  },
  //买入物品
  BuyGoods: function BuyGoods(data) {
    //data 包含 Id buyprire buynum
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      if (data.Id == this.GoodsList[i].Id) {
        return this.GoodsList[i].RefeshDataAfterBuy(data);
      }
    }
  },
  //出售物品
  SaleGoods: function SaleGoods(data) {
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      if (data.Id == this.GoodsList[i].Id) {
        return this.GoodsList[i].RefeshDataAfterSale(data);
      }
    }
  },
  //创办公司
  CreateCompany: function CreateCompany(data) {
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      if (data.Id == this.CompanyList[i].Id) {
        return this.CompanyList[i].RefreshDataAfterOper(data);
      }
    }
  },
  //查看一下是否已经拥有五種物品
  CheckOwnedGoodsNum: function CheckOwnedGoodsNum() {
    var Num = 0;
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      if (this.GoodsList[i].ownNum > 0) {
        Num += 1;
      }
    }
    var Isfull = false;
    if (Num == 5) {
      Isfull = true;
    }
    return Isfull;
  },
  //购买股票
  BuyStocks: function BuyStocks(data) {
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      if (data.Id == this.CompanyList[i].Id) {
        return this.CompanyList[i].RefreshDataAfterOper(data);
      }
    }
  },
  //出售股票
  SaleStocks: function SaleStocks(data) {
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      if (data.Id == this.CompanyList[i].Id) {
        return this.CompanyList[i].RefreshDataAfterSale(data);
      }
    }
  },
  BuySaleCommonItem: function BuySaleCommonItem(data) {
    //cc.log("=============" + data.Type + "  Id = "+ data.Id)
    if (data.Type == ItemType.Car) {
      for (var i = this.CarList.length - 1; i >= 0; i--) {
        if (this.CarList[i].Id == data.Id) {
          this.CarList[i].RefreshData(data.addNum);
        }
      }
    } else if (data.Type == ItemType.House) {
      for (var i = this.HouseList.length - 1; i >= 0; i--) {
        if (this.HouseList[i].Id == data.Id) {
          this.HouseList[i].RefreshData(data.addNum);
        }
      }
    }
  },
  //刷新约会的亲密度
  RefreshMateData: function RefreshMateData(Id) {
    for (var i = this.MateList.length - 1; i >= 0; i--) {
      if (Id == this.MateList[i].Id) {
        return this.MateList[i].RefreshAfterLvUp();
      }
    }
  },
  //根據id解除婚姻
  DisvorceMateById: function DisvorceMateById(Id) {
    for (var i = 0; i < this.MateList.length; i++) {
      if (this.MateList[i].Id == Id) {
        this.MateList[i].ReturnInitState();
        var data = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, Id);
        this.DeleteMateBonusReward(data.bonusList);
        //现金 股票减少 名声 健康受损
        this.Cash = Math.floor(this.Cash * 0.8);
        this.HpPoint = Math.floor(this.HpPoint * 0.8);
        this.Reputation = Math.floor(this.Reputation * 0.8);
        this.DisvorceDelStocks();
        break;
      }
    }
  },
  DisvorceDelStocks: function DisvorceDelStocks() {
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      if (this.CompanyList[i].stockNum > 0) {
        this.CompanyList[i].RefreshDataAfterDisvorce();
        return;
      }
    }
  },
  //获得伴侣加成 结婚后获得
  getMateBonusReward: function getMateBonusReward(data) {
    for (var i = 0; i < data.length; i++) {
      var dt = data[i];
      //cc.log("+++++++++++++++++++++oooooo+++++++++++++++++++++++" + dt.bonusNum);
      if (dt.bonusType == MateBonusType.NULL) {
        //cc.log("伴侣加成什么也没有");
      } else if (dt.bonusType == MateBonusType.HP) {
        this.HpPointBonus += dt.bonusNum;
      } else if (dt.bonusType == MateBonusType.Money) {
        this.CashBonus += dt.bonusNum;
      } else if (dt.bonusType == MateBonusType.Reputation) {
        this.ReputationBonus += dt.bonusNum;
      } else if (dt.bonusType == MateBonusType.WareHouseCapcity) {
        this.WareHouseCapcity += dt.bonusNum;
        this.WareHouseAllCapcity += dt.bonusNum;
        this.WareHouseBonusEveryYear += dt.bonusNum;
        if (this.WareHouseAllCapcity > 200) this.WareHouseAllCapcity = 200;
        if (this.WareHouseCapcity > 200) this.WareHouseCapcity = 200;
      } else if (dt.bonusType == MateBonusType.Treat) {
        this.TreatBonus += dt.bonusNum;
      }
    }
  },
  //移除伴侣获得的天赋加成
  DeleteMateBonusReward: function DeleteMateBonusReward(data) {
    for (var i = 0; i < data.length; i++) {
      var dt = data[i];
      //cc.log("+++++++++++++++++++++oooooo+++++++++++++++++++++++" + dt.bonusNum);
      if (dt.bonusType == MateBonusType.NULL) {
        //cc.log("伴侣加成什么也没有");
      } else if (dt.bonusType == MateBonusType.HP) {
        this.HpPointBonus -= dt.bonusNum;
      } else if (dt.bonusType == MateBonusType.Money) {
        this.CashBonus -= dt.bonusNum;
      } else if (dt.bonusType == MateBonusType.Reputation) {
        this.ReputationBonus -= dt.bonusNum;
        if (this.ReputationBonus < 0) this.ReputationBonus = 0;
      } else if (dt.bonusType == MateBonusType.WareHouseCapcity) {
        //this.WareHouseCapcity -= dt.bonusNum;
        //this.WareHouseAllCapcity -= dt.bonusNum;
        this.WareHouseBonusEveryYear -= dt.bonusNum;
        if (this.WareHouseBonusEveryYear < 0) this.WareHouseBonusEveryYear = 0;
      } else if (dt.bonusType == MateBonusType.Treat) {
        this.TreatBonus -= dt.bonusNum;
      }
    }
  },
  getOwnDataListByType: function getOwnDataListByType(itemType) {
    var dataList = null;
    switch (itemType) {
      case ItemType.Goods:
        dataList = this.GoodsList;
        break;
      case ItemType.Skill:
        dataList = this.SkillList;
        break;
      case ItemType.Car:
        dataList = this.CarList;
        break;
      case ItemType.House:
        dataList = this.HouseList;
        break;
      case ItemType.Achieve:
        dataList = this.AchievementList;
        break;
      case ItemType.Company:
        dataList = this.CompanyList;
        break;
      case ItemType.Mate:
        dataList = this.MateList;
        break;
    }
    return dataList;
  },
  //获取已有数据 根据 类型和Id
  getDataByItemTypeAndId: function getDataByItemTypeAndId(itemType, Id) {
    var dataList = null;
    switch (itemType) {
      case ItemType.Goods:
        dataList = this.GoodsList;
        break;
      case ItemType.Skill:
        dataList = this.SkillList;
        break;
      case ItemType.Car:
        dataList = this.CarList;
        break;
      case ItemType.House:
        dataList = this.HouseList;
        break;
      case ItemType.Achieve:
        dataList = this.AchievementList;
        break;
      case ItemType.Company:
        dataList = this.CompanyList;
        break;
      case ItemType.Mate:
        dataList = this.MateList;
        break;
    }
    if (dataList != null) {
      for (var i = dataList.length - 1; i >= 0; i--) {
        if (Id == dataList[i].Id) {
          return dataList[i];
        }
      }
    }
    //如果没有数据 为 null
    return null;
  },
  //刷新物品市场价格
  RefreshGoodsMarKetPrice: function RefreshGoodsMarKetPrice(Id, marketPrice) {
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      if (Id == this.GoodsList[i].Id) {
        this.GoodsList[i].marketPrice = marketPrice;
        break;
      }
    }
  },
  //刷新股票商场价格和成本
  RefreshStockData: function RefreshStockData(Id, param) {
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      if (Id == this.CompanyList[i].Id) {
        this.CompanyList[i].stockPrice = param.stockPrice;
        this.CompanyList[i].stockCost = param.stockCost;
        break;
      }
    }
  },
  //获取拥有的物品对应数据
  getGoodsDataById: function getGoodsDataById(Id) {
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      if (Id == this.GoodsList[i].Id) {
        return this.GoodsList[i];
      }
    }
  },
  //刷新个人资产  //caculateStock 是否計算股票收益
  RefreshUserAssets: function RefreshUserAssets(caculateStock) {
    var lastAsset = this.AssetsMoney;
    var assets = 0;
    //计算所拥有物品总价
    for (var i = this.GoodsList.length - 1; i >= 0; i--) {
      var data = this.GoodsList[i];
      var flag = this.CheckIdIsInShowList(data.Id);
      if (flag == true) {
        assets += data.ownNum * data.marketPrice;
      } else {
        assets += data.ownNum * data.buyPrice;
      }
    }
    //计算房屋拥有
    for (var i = this.HouseList.length - 1; i >= 0; i--) {
      var dt = this.HouseList[i];
      if (dt.ownNum > 0) {
        ////cc.log(dt.Id + " 房子的数量和价格 " + dt.ownNum + " " + dt.price);
        assets += dt.ownNum * dt.price;
      }
    }
    //计算车子所有
    for (var i = this.CarList.length - 1; i >= 0; i--) {
      var dt = this.CarList[i];
      if (dt.ownNum > 0) {
        assets += dt.ownNum * dt.price;
      }
    }

    //后面再加上 股票收益
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      var da = this.CompanyList[i];
      if (da.stockNum > 0) {
        //this.Reputation += cc.Mgr.global.HasCompanyReputationAdd;
        assets += Math.floor(da.stockNum * da.stockPrice);
        if (this.CanGetStockProfit == true && caculateStock == true) {
          this.Cash += Math.floor(da.stockNum * da.stockPrice * (da.bonusRatio + this.StockAddBonus / 100));
        }
      }
    }
    assets += this.Cash;
    //资产暴涨时候健康迅速下降 暴涨5倍下降30
    this.AssetsMoney = assets;
    this.JudeFinishAnyAchievement(5); //成就 Id = 5 资产相关
    this.JudeFinishAnyAchievement(4); //成就 Id = 6  

    cc.log(lastAsset + " L =========他妈的资产问题======== N " + assets);
    if (assets > this.HighAssets) {
      this.HighAssets = assets;
    }
    if (assets > 1000000 && this.MillionAge == 0) {
      this.MillionAge = this.Age;
    }
    if (assets > 10000000 && this.TenMillionAge == 0) {
      this.TenMillionAge = this.Age;
    }
    if (assets > 100000000 && this.HundredMillionAge == 0) {
      this.HundredMillionAge = this.Age;
    }
    if (Math.floor(assets / lastAsset) >= cc.Mgr.global.AssetExplorRate || assets / lastAsset <= cc.Mgr.global.AssetExplorDownRate) {
      if (this.userState == UserState.NotOK) return;
      this.HpPoint -= cc.Mgr.global.AssetBurden;
      if (this.HpPoint < cc.Mgr.global.HealthLine) {
        this.userState = UserState.NotOK;
        cc.Mgr.global.goToHospital += 1;
        this.RecoverYear = cc.Mgr.global.YearRecover;
        var param = {};
        param.forWhat = "HealthLine";
        param.text = cc.Mgr.global.getTranslation("RecoverHealth");
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);

        //this.UnLockMateByInHospital(MateUnLockType.InHospital, this.Sex);
      } else {
        var param = {};
        param.forWhat = "";
        param.text = cc.Mgr.global.getTranslation("RecoverHealthD");
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      }
    }
  },
  JudeFinishAnyAchievement: function JudeFinishAnyAchievement(Id) {
    //cc.log(this.AchievementList.length + "======================判断成就是否完成" + Id);
    for (var i = 0; i < this.AchievementList.length; i++) {
      if (this.AchievementList[i].Id == Id) {
        if (this.AchievementList[i].hasFinish == true) {
          //cc.log("该成就已经完成了");
          return;
        }
      }
    }
    var acD = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Achieve, Id);
    cc.log("======================判断成就是否完成 = " + acD.name);
    var condList = acD.condList;
    var finished = this.JudeCanFinishAchievementByCond(condList);
    if (finished) {
      for (var i = 0; i < this.AchievementList.length; i++) {
        if (this.AchievementList[i].Id == Id) {
          this.AchievementList[i].hasFinish = true;
          return;
        }
      }
    }
  },
  CaculateReputationFromCompany: function CaculateReputationFromCompany() {
    //后面再加上 股票造成的
    for (var i = this.CompanyList.length - 1; i >= 0; i--) {
      var da = this.CompanyList[i];
      if (da.stockNum > 0) {
        this.Reputation += cc.Mgr.global.HasCompanyReputationAdd;
        return;
      }
    }
  },
  JudeCanFinishAchievementByCond: function JudeCanFinishAchievementByCond(condList) {
    var finishedList = [];
    for (var i = 0; i < condList.length; i++) {
      var cond = condList[i];
      var finished = false;
      cc.log("类型要求 = " + cond.condType + "  数值要求 = " + cond.value);
      switch (cond.condType) {
        case AchieveCond.AssetMoneyUp:
          finished = this.JudeAssetCond(cond.value);
          break;
        case AchieveCond.InHospital:
          finished = this.JudegoToHosTimesCond(cond.value);
          break;
        case AchieveCond.Bankrupt:
          finished = this.JudeBankruptTimesCond(cond.value);
          break;
        case AchieveCond.CreateBusiness:
          finished = this.JudeCreateCompanyCond(cond.value);
          break;
        case AchieveCond.AgeCond:
          finished = this.JudeAgeCond(cond.value);
          break;
        case AchieveCond.HasMarryCond:
          finished = this.JudeHasMarryCond();
          break;
        case AchieveCond.LovePointCond:
          finished = this.JudeLovePointCond(cond.value);
          break;
        case AchieveCond.AssetMoneyDown:
          finished = this.JudeAssetDownCond(cond.value);
          break;
        case AchieveCond.NoMarryCond:
          finished = this.JudeNotMarryCond(cond.value);
          break;
        case AchieveCond.AgeCondUp:
          finished = this.JudeAgeCondUp(cond.value);
          break;
      }
      cc.log("是否完成 = " + finished);
      finishedList.push(finished);
    }
    for (var i = 0; i < finishedList.length; i++) {
      if (finishedList[i] == false) return false;
    }
    return true;
  },
  JudeAssetDownCond: function JudeAssetDownCond(value) {
    if (this.AssetsMoney < value * 1000000) return true;else return false;
  },
  //成就完成 资产限制
  JudeAssetCond: function JudeAssetCond(value) {
    if (this.AssetsMoney >= value * 1000000) return true;else return false;
  },
  //成就完成 年龄限制 小于
  JudeAgeCond: function JudeAgeCond(value) {
    if (this.Age <= value) return true;else return false;
  },
  JudeAgeCondUp: function JudeAgeCondUp(value) {
    if (this.Age >= value) return true;else return false;
  },
  //成就完成 进医院次数
  JudegoToHosTimesCond: function JudegoToHosTimesCond(value) {
    if (cc.Mgr.global.goToHospital > value) return true;else return false;
  },
  //成就完成 破产次数
  JudeBankruptTimesCond: function JudeBankruptTimesCond(value) {
    if (cc.Mgr.global.BankruptTimes > value) return true;else return false;
  },
  //成就完成 创业次数
  JudeCreateCompanyCond: function JudeCreateCompanyCond(value) {
    if (cc.Mgr.global.CreateCompanyTimes > value) return true;else return false;
  },
  //成就完成 是否已婚
  JudeHasMarryCond: function JudeHasMarryCond() {
    for (var i = 0; i < this.MateList.length; i++) {
      if (this.MateList[i].LovePoint == 100) {
        return true;
      }
    }
    return false;
  },
  JudeHasCar: function JudeHasCar() {
    for (var i = this.CarList.length - 1; i >= 0; i--) {
      if (this.CarList[i].ownNum > 0) {
        return true;
      }
    }
    return false;
  },
  JudeHasCarById: function JudeHasCarById(Id) {
    for (var i = this.CarList.length - 1; i >= 0; i--) {
      if (this.CarList[i].ownNum > 0 && this.CarList[i].Id == Id) {
        return true;
      }
    }
    return false;
  },
  JudeHasHouse: function JudeHasHouse() {
    for (var i = this.HouseList.length - 1; i >= 0; i--) {
      if (this.HouseList[i].ownNum > 0) {
        return true;
      }
    }
    return false;
  },
  JudeHasHouseById: function JudeHasHouseById(Id) {
    for (var i = this.HouseList.length - 1; i >= 0; i--) {
      if (this.HouseList[i].ownNum > 0 && this.HouseList[i].Id == Id) {
        return true;
      }
    }
    return false;
  },
  //成就完成 是否未婚
  JudeNotMarryCond: function JudeNotMarryCond() {
    for (var i = 0; i < this.MateList.length; i++) {
      if (this.MateList[i].LovePoint == 100) {
        return false;
      }
    }
    return true;
  },
  //成就完成 亲密度人数
  JudeLovePointCond: function JudeLovePointCond(value) {
    var num = 0;
    for (var i = 0; i < this.MateList.length; i++) {
      if (this.MateList[i].LovePoint == 99) {
        num += 1;
      }
    }
    if (num >= value) return true;else return false;
  },
  //刷新用户年龄
  RefreshUserAge: function RefreshUserAge() {
    this.Age += 1;
    if (this.Age == this.retireAge + 1 && cc.Mgr.global.useRetireAds == false) {
      cc.director.GlobalEvent.emit(cc.Mgr.Event.UseRetireAdsSkill, {});
    } else if (this.Age > this.retireAge && cc.Mgr.global.useRetireAds == true) {
      cc.director.GlobalEvent.emit(cc.Mgr.Event.Retire, {});
    }
    this.CaculateReputationFromCompany();
  },
  //刷新个人健康指数
  RefreshHealthHp: function RefreshHealthHp() {
    if (this.RecoverYear > 0 && this.userState == UserState.NotOK) {
      this.RecoverYear -= 1;
      return;
    } else if (this.RecoverYear == 0 && this.userState == UserState.NotOK) {
      this.RecoverYear = 0;
      this.userState = UserState.OK;
      this.HpPoint = 100;
      return;
    }
    if (this.Age >= cc.Mgr.global.HealthSubAge && this.HpPoint > 0) {
      var seed = 2 + Math.floor(Math.random() * 3);
      this.HpPoint -= seed;
      if (this.HpPoint < cc.Mgr.global.HealthLine) {
        this.userState = UserState.NotOK;
        cc.Mgr.global.goToHospital += 1;
        this.RecoverYear = cc.Mgr.global.YearRecover;
        var param = {};
        param.forWhat = "HealthLine";
        param.text = cc.Mgr.global.getTranslation("RecoverHealth");
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
        //this.UnLockMateByInHospital(MateUnLockType.InHospital, this.Sex);
      }
    }
  },

  //技能天赋数据获取
  getSkillDataByTwoId: function getSkillDataByTwoId(Id, subId) {
    var dt = null;
    for (var i = this.SkillList.length - 1; i >= 0; i--) {
      var data = this.SkillList[i];
      if (data.Id == Id && data.subId == subId) {
        dt = data;
        return data;
      }
    }
    return dt;
  },
  getSkillListById: function getSkillListById(Id) {
    var param = [];
    for (var i = this.SkillList.length - 1; i >= 0; i--) {
      var data = this.SkillList[i];
      if (data.Id == Id) {
        param.push(data);
      }
    }
    return param;
  },
  //花销和获得根据 
  GetOrCostDataByRewardType: function GetOrCostDataByRewardType(rewardType, num, subId)
  //对于物品  会有一个subId
  {
    var Pdata = {};
    Pdata.Id = -1;
    Pdata.companyId = -1;
    //cc.log("++++++rewardType++++++" + rewardType);
    if (rewardType == RewardType.NULL) {
      //cc.log("啥也没有");
    } else if (rewardType == RewardType.Cash) {
      if (num < 0)
        //好运连连
        {
          num = num + Math.floor(-num * this.EventCostBonus);
        } else {
        num + Math.floor(num * this.EventCostBonus);
      }
      this.Cash += num;
      if (this.Cash < 0) this.Cash = 0;
    } else if (rewardType == RewardType.HP) {
      this.HpPoint += num;
      if (this.HpPoint > 100) this.HpPoint = 100;
    } else if (rewardType == RewardType.Reputation) {
      this.Reputation += num;
      if (this.Reputation < 0) this.Reputation = 0;
    } else if (rewardType == RewardType.Goods) {
      for (var i = 0; i < this.GoodsList.length; i++) {
        if (this.GoodsList[i].Id == subId) {
          if (this.WareHouseCapcity >= num) {
            var averagePrice = Math.floor(this.GoodsList[i].buyPrice * this.GoodsList[i].ownNum / (this.GoodsList[i].ownNum + num));
            this.GoodsList[i].ownNum += num;
            //仓库减少数值
            this.WareHouseCapcity -= num;
            Pdata.Id = subId;
            Pdata.buyPrice = averagePrice; //this.GoodsList[i].buyPrice;
            Pdata.ownNum = this.GoodsList[i].ownNum;
          }
          break;
        }
      }
    } else if (rewardType == RewardType.Car) {
      for (var i = 0; i < this.CarList.length; i++) {
        if (this.CarList[i].Id == subId) {
          this.CarList[i].ownNum += num;
          this.Reputation += this.CarList[i].addBonus;
          this.HpPoint += this.CarList[i].addHp;
          if (this.HpPoint > 100) this.HpPoint = 100;
          break;
        }
      }
    } else if (rewardType == RewardType.House) {
      for (var i = 0; i < this.HouseList.length; i++) {
        if (this.HouseList[i].Id == subId) {
          this.HouseList[i].ownNum += num;
          this.Reputation += this.HouseList[i].addBonus;
          this.HpPoint += this.HouseList[i].addHp;
          if (this.HpPoint > 100) this.HpPoint = 100;
          break;
        }
      }
    } else if (rewardType == RewardType.Stock) {
      for (var i = 0; i < this.CompanyList.length; i++) {
        if (this.CompanyList[i].Id == subId) {
          this.CompanyList[i].stockNum += num;
          Pdata.companyId = subId;
          break;
        }
      }
    } else if (rewardType == RewardType.StockPrice) {
      for (var i = 0; i < this.CompanyList.length; i++) {
        if (this.CompanyList[i].Id == subId) {
          if (this.CompanyList[i].stockNum > 0) {
            this.CompanyList[i].stockPrice += num;
            Pdata.companyId = subId;
            break;
          }
        }
      }
    }
    return Pdata;
  }
}, _cc$Class["JudeHasHouse"] = function JudeHasHouse(value) {
  var flag = false;
  if (value == 0) {
    for (var i = 0; i < this.HouseList.length; i++) {
      if (this.HouseList[i].ownNum > 0) {
        return true;
      }
    }
  } else {
    for (var i = 0; i < this.HouseList.length; i++) {
      if (this.HouseList[i].ownNum > 0 && value == this.HouseList[i].Id) {
        return true;
      }
    }
  }
  return flag;
}, _cc$Class["JudeHasCar"] = function JudeHasCar(value) {
  var flag = false;
  if (value == 0) {
    for (var i = 0; i < this.CarList.length; i++) {
      if (this.CarList[i].ownNum > 0) {
        return true;
      }
    }
  } else {
    for (var i = 0; i < this.CarList.length; i++) {
      if (this.CarList[i].ownNum > 0 && this.CarList[i].Id == value) {
        return true;
      }
    }
  }
  return flag;
}, _cc$Class.JudeAsset = function JudeAsset(needNum) {
  var flag = false;
  if (needNum <= this.AssetsMoney) {
    return true;
  }
  return flag;
}, _cc$Class.JudeReputation = function JudeReputation(needNum) {
  var flag = false;
  if (needNum <= this.Reputation) {
    return true;
  }
  return flag;
}, _cc$Class.JudeHpPoint = function JudeHpPoint(needNum) {
  var flag = false;
  if (needNum <= this.HpPoint) {
    return true;
  }
  return flag;
}, _cc$Class.JudeHasCompany = function JudeHasCompany() {
  return this.hasCompany;
}, _cc$Class.UnLockOneMate = function UnLockOneMate(unlockCond, offSex) {
  var Id = -1;
  for (var i = 0; i < this.MateList.length; i++) {
    //var dt = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate , this.MateList[i].Id);
    if (this.MateList[i].sex == offSex && this.MateList[i].canDate == false && this.MateList[i].unlockCond == unlockCond) {
      this.MateList[i].canDate = true;
      Id = this.MateList[i].Id;
      var param = {};
      param.icon = this.MateList[i].icon;
      param.des = cc.Mgr.global.getTranslation("UnLockMate_" + Id);
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenUnLockMate, param);
      return Id;
    }
  }
  return Id;
}, _cc$Class.UnLockMateByInHospital = function UnLockMateByInHospital(unlockCond, offSex) {
  var Id = -1;
  for (var i = 0; i < this.MateList.length; i++) {
    //var dt = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate , this.MateList[i].Id);
    if (this.MateList[i].sex == offSex && this.MateList[i].canDate == false && this.MateList[i].unlockCond == unlockCond) {
      this.MateList[i].canDate = true;
      Id = this.MateList[i].Id;
      var param = {};
      param.icon = this.MateList[i].icon;
      param.des = cc.Mgr.global.getTranslation("UnLockMateByInHos");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenUnLockMate, param);
      return Id;
    }
  }
  return Id;
}, _cc$Class.JudeHasAnyMate = function JudeHasAnyMate() {
  var flag = false;
  for (var i = 0; i < this.MateList.length; i++) {
    //cc.log("是否已经结婚了 "+ this.MateList[i].Uplv);
    if (this.MateList[i].UpLv == true) {
      flag = true;
      return flag;
    }
  }
  return flag;
}, _cc$Class));
module.exports = UserDataMgr;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcVXNlckRhdGFNZ3IuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiUmV3YXJkVHlwZSIsIk1hdGVCb251c1R5cGUiLCJTa2lsbFR5cGUiLCJNYXRlVW5Mb2NrVHlwZSIsIk1hdGVHZXRUeXBlIiwiVXNlclN0YXRlIiwiQWNoaWV2ZUNvbmREYXRhIiwiQWNoaWV2ZUNvbmQiLCJTa2lsbFN0cnVjdCIsIkFjaGlldmVTdHJ1Y3QiLCJSZWNvcmRTdHJ1Y3QiLCJHb29kc1N0cnVjdCIsIkNhclN0cnVjdCIsIkhvdXNlU3RydWN0IiwiQ29tcGFueVN0cnVjdCIsIk1hdGVTdHJ1Y3QiLCJleW91Q2xpZW50VGlrdG9rIiwiZXlvdUNsaWVudEtzIiwiZXlvdUNsaWVudCIsImh0dHBVdGlsIiwiY3J5cHRvIiwiVXNlckRhdGFNZ3IiLCJjYyIsIkNsYXNzIiwiX2NjJENsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsInVzZXJJZCIsInR1dG9yaWFsSW5CdXMiLCJ0dXRvcmlhbEluRGF0ZSIsInR1dG9yaWFsSW5NYXJrZXQiLCJ0dXRvcmlhbFN0b2NrQm9udXMiLCJ0dXRvcmlhbE1hdGVQb2ludCIsIlZpZGVvTGFzdFRpbWUiLCJWaWRlb0Fkc1RpbWVzIiwiSW50ZWdlciIsInBsYXlUaW1lcyIsInBsYXllck5hbWUiLCJTZXgiLCJTa2lsbExpc3QiLCJ0eXBlIiwiQWNoaWV2ZW1lbnRMaXN0IiwiUmVjb3JkTGlzdCIsIk1hcnJ5QWdlIiwiTWFycnlSb2xlSWQiLCJEaXZvcmNlQWdlIiwiRnVuZGF0aW9uQWdlIiwiRnVuZGF0aW9uQ29tcGFueUlkIiwiQmFua3J1cHRBZ2UiLCJNaWxsaW9uQWdlIiwiVGVuTWlsbGlvbkFnZSIsIkh1bmRyZWRNaWxsaW9uQWdlIiwiUmV0aXJlQWdlIiwiQmV0V2luUmF0aW8iLCJEYXRlU3VjY2VzY1JhdGlvIiwiSGlnaEFzc2V0cyIsIkluaXRNb25leSIsIkNhc2giLCJIcFBvaW50IiwiQWdlIiwiSG9ub3IiLCJSZXB1dGF0aW9uIiwiQXNzZXRzTW9uZXkiLCJXYXJlSG91c2VDYXBjaXR5IiwiV2FyZUhvdXNlQWxsQ2FwY2l0eSIsImhhc0NvbXBhbnkiLCJDYW5HZXRTdG9ja1Byb2ZpdCIsIlJlY292ZXJZZWFyIiwiU2tpbGxCb251c1BvaW50IiwiVHJlYXRCb251cyIsIldhcmVIb3VzZUNhcGNpdHlCb251cyIsIkNhc2hCb251cyIsIkNhc2hSYXRpb25Cb251cyIsIlJlcHV0YXRpb25Cb251cyIsIkhwUG9pbnRCb251cyIsIldhcmVIb3VzZUJvbnVzRXZlcnlZZWFyIiwiUmV0aXJlQm9udXMiLCJEYXRlQm9udXMiLCJJbml0TW9uZXlCb251cyIsIlN0b2NrQWRkQm9udXMiLCJTdG9ja1VwQm9udXMiLCJEYXRlTW9uZXlCb251cyIsIkJldEJvbnVzIiwiU2tpbGxQb2ludEdldEJvbnVzIiwiUmVwdXRhdGlvbkluaXRCb251cyIsIkNhckJ1eUJvbnVzIiwiRXZlbnRDb3N0Qm9udXMiLCJIb3VzZUJ1eUJvbnVzZSIsIkhpc3RvcnlIaWdoQXNzZXRzIiwidXNlclN0YXRlIiwiT0siLCJFdmVudERhdGFJZExpc3QiLCJHb29kc0xpc3QiLCJDYXJMaXN0IiwiSG91c2VMaXN0IiwiQ29tcGFueUxpc3QiLCJNYXRlTGlzdCIsIlNob3dHb29kc0xpc3QiLCJKdWRlR29vZHNPd25lZCIsIklkIiwiaSIsImxlbmd0aCIsIm93bk51bSIsIkNsZWFyU2hvd0dvb2RzTGlzdCIsInNwbGljZSIsIkluc2VydEdvb2RzSWRUb0xpc3QiLCJwdXNoIiwiQ2hlY2tJZElzSW5TaG93TGlzdCIsImZsYWciLCJpbml0RGF0YSIsIl90aGlzIiwiTWdyIiwiZ2xvYmFsIiwiSW5pdEV2ZW50SGFwcGVuQWdlIiwiaXNLdWFpU2hvdSIsImtzIiwic3lzIiwicGxhdGZvcm0iLCJCWVRFREFOQ0VfR0FNRSIsImdldElucyIsImluaXQiLCJpbml0UmVzcCIsImxvZ2luIiwibG9naW5SZXNwIiwidGlrdG9rR2FtZVZlcmlmeVNlc3Npb24iLCJkYXRhIiwiY29kZSIsInRoZW4iLCJ0aWt0b2tPcGVuSWQiLCJleGVjQWZ0ZXJPYnRhaW5BY2NvdW50IiwiZXJyIiwibG9nIiwiV0VDSEFUX0dBTUUiLCJ3ZWNoYXRHYW1lVmVyaWZ5U2Vzc2lvbiIsInd4T3BlbklkIiwiY29uc29sZSIsImt1YWlTaG91R2FtZVZlcmlmeVNlc3Npb24iLCJrc09wZW5JZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxT2JqIiwiZ2FtZUlkIiwicGxhdGZvcm1JZCIsInRpbWVTdGFtcCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJzZWNTdHIiLCJzaWduU3RyIiwicmVwbGFjZUFsbCIsInNpZ24iLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwicG9zdEpzb24iLCJyZXFGbGFnIiwicmVzcCIsInBvc3QiLCJTdG9yYWdlRGF0YSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ1c2VyZGF0YSIsIk1hcERhdGFNZ3IiLCJnZXREYXRhTGlzdEJ5SXRlbVR5cGUiLCJTa2lsbCIsInNrIiwibmFtZSIsImljb24iLCJkZXNJZCIsInN1YklkIiwiVXBsdiIsInVwTGV2ZWwiLCJza2lsbFR5cGUiLCJsZXZlbCIsIkFjaGlldmUiLCJhYyIsImhhc0ZpbmlzaCIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiRGF0YSIsInBhcnNlIiwidGVzdERhdGUiLCJ0b0RhdGVTdHJpbmciLCJHZXRJbml0U2tpbGxCb251cyIsInJldGlyZUFnZSIsIlJldGlyZUluaXRBZ2UiLCJJbml0V2FyZUhvdXNlQ2FwY2l0eSIsIkdvb2RzIiwiYnV5UHJpY2UiLCJtYXJrZXRQcmljZSIsIkNhciIsInByaWNlIiwiYWRkQm9udXMiLCJhZGRIcCIsImFkZERhdGUiLCJIb3VzZSIsIkNvbXBhbnkiLCJib251c1JhdGlvIiwiaXNPd25lZCIsInN0b2NrTnVtIiwic3RvY2tDb3N0IiwiYmFua3J1cHRQcmljZSIsIm91dFByaWNlIiwic3RvY2tQcmljZSIsImluUHJpY2UiLCJMaW1pdFllYXIiLCJNYXRlIiwic2V4IiwiTG92ZVBvaW50IiwiY2FuRGF0ZSIsInVubG9ja0NvbmQiLCJOVUxMIiwiY3VyTGV2ZWwiLCJVcEx2IiwiRXZlbnRMaXN0IiwiRXZlbnREYXRhIiwic2tpbGxMaXN0IiwiYm9udXMiLCJnZXRTa2lsbEFkZEJvbnVzQnlUd29JZEFuZEx2IiwiV0xOUyIsIlRIWSIsIlhTSlkiLCJGR1pKIiwiR1NHTCIsIlRQR1MiLCJKWkNDIiwiTUxTWiIsIkRTIiwiTERZWiIsIk5TQ00iLCJRQ0RSIiwiSFlMTCIsIkRDWkoiLCJHZXRCb251c1Jld2FyZEV2ZXJ5WWVhciIsIkdldEV2ZW50RGF0YUFuZFNwbGljZUlkIiwibGVuIiwic2VlZCIsInJhbmRvbSIsIm91dCIsIlJlZnJlc2hIaXN0b3J5SGlnaEFzc2V0IiwiYXNzZXQiLCJTYXZlVXNlckRhdGEiLCJDcmVhdGVSZWNvcmQiLCJyZUQiLCJhc0x2IiwidGQiLCJhc3NldHMiLCJoaWdoQXNzZXRzIiwiVXBHcmFkZVNraWxsIiwidG9MdiIsImlzT2siLCJOZWVkQ29zdCIsImdldFVwZ3JhZGVDb3N0QnlUd29JZCIsIkNhblNob3dVcFRpcCIsIkZpbmlzaEFjaGlldmVtZW50IiwiQnV5R29vZHMiLCJSZWZlc2hEYXRhQWZ0ZXJCdXkiLCJTYWxlR29vZHMiLCJSZWZlc2hEYXRhQWZ0ZXJTYWxlIiwiQ3JlYXRlQ29tcGFueSIsIlJlZnJlc2hEYXRhQWZ0ZXJPcGVyIiwiQ2hlY2tPd25lZEdvb2RzTnVtIiwiTnVtIiwiSXNmdWxsIiwiQnV5U3RvY2tzIiwiU2FsZVN0b2NrcyIsIlJlZnJlc2hEYXRhQWZ0ZXJTYWxlIiwiQnV5U2FsZUNvbW1vbkl0ZW0iLCJUeXBlIiwiUmVmcmVzaERhdGEiLCJhZGROdW0iLCJSZWZyZXNoTWF0ZURhdGEiLCJSZWZyZXNoQWZ0ZXJMdlVwIiwiRGlzdm9yY2VNYXRlQnlJZCIsIlJldHVybkluaXRTdGF0ZSIsImdldERhdGFCeUl0ZW1UeXBlQW5kSWQiLCJEZWxldGVNYXRlQm9udXNSZXdhcmQiLCJib251c0xpc3QiLCJEaXN2b3JjZURlbFN0b2NrcyIsIlJlZnJlc2hEYXRhQWZ0ZXJEaXN2b3JjZSIsImdldE1hdGVCb251c1Jld2FyZCIsImR0IiwiYm9udXNUeXBlIiwiSFAiLCJib251c051bSIsIk1vbmV5IiwiVHJlYXQiLCJnZXRPd25EYXRhTGlzdEJ5VHlwZSIsIml0ZW1UeXBlIiwiZGF0YUxpc3QiLCJSZWZyZXNoR29vZHNNYXJLZXRQcmljZSIsIlJlZnJlc2hTdG9ja0RhdGEiLCJwYXJhbSIsImdldEdvb2RzRGF0YUJ5SWQiLCJSZWZyZXNoVXNlckFzc2V0cyIsImNhY3VsYXRlU3RvY2siLCJsYXN0QXNzZXQiLCJkYSIsIkp1ZGVGaW5pc2hBbnlBY2hpZXZlbWVudCIsIkFzc2V0RXhwbG9yUmF0ZSIsIkFzc2V0RXhwbG9yRG93blJhdGUiLCJOb3RPSyIsIkFzc2V0QnVyZGVuIiwiSGVhbHRoTGluZSIsImdvVG9Ib3NwaXRhbCIsIlllYXJSZWNvdmVyIiwiZm9yV2hhdCIsInRleHQiLCJnZXRUcmFuc2xhdGlvbiIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiRXZlbnQiLCJPcGVuQ29tbW9uVGlwIiwiYWNEIiwiY29uZExpc3QiLCJmaW5pc2hlZCIsIkp1ZGVDYW5GaW5pc2hBY2hpZXZlbWVudEJ5Q29uZCIsIkNhY3VsYXRlUmVwdXRhdGlvbkZyb21Db21wYW55IiwiSGFzQ29tcGFueVJlcHV0YXRpb25BZGQiLCJmaW5pc2hlZExpc3QiLCJjb25kIiwiY29uZFR5cGUiLCJ2YWx1ZSIsIkFzc2V0TW9uZXlVcCIsIkp1ZGVBc3NldENvbmQiLCJJbkhvc3BpdGFsIiwiSnVkZWdvVG9Ib3NUaW1lc0NvbmQiLCJCYW5rcnVwdCIsIkp1ZGVCYW5rcnVwdFRpbWVzQ29uZCIsIkNyZWF0ZUJ1c2luZXNzIiwiSnVkZUNyZWF0ZUNvbXBhbnlDb25kIiwiQWdlQ29uZCIsIkp1ZGVBZ2VDb25kIiwiSGFzTWFycnlDb25kIiwiSnVkZUhhc01hcnJ5Q29uZCIsIkxvdmVQb2ludENvbmQiLCJKdWRlTG92ZVBvaW50Q29uZCIsIkFzc2V0TW9uZXlEb3duIiwiSnVkZUFzc2V0RG93bkNvbmQiLCJOb01hcnJ5Q29uZCIsIkp1ZGVOb3RNYXJyeUNvbmQiLCJBZ2VDb25kVXAiLCJKdWRlQWdlQ29uZFVwIiwiQmFua3J1cHRUaW1lcyIsIkNyZWF0ZUNvbXBhbnlUaW1lcyIsIkp1ZGVIYXNDYXIiLCJKdWRlSGFzQ2FyQnlJZCIsIkp1ZGVIYXNIb3VzZSIsIkp1ZGVIYXNIb3VzZUJ5SWQiLCJudW0iLCJSZWZyZXNoVXNlckFnZSIsInVzZVJldGlyZUFkcyIsIlVzZVJldGlyZUFkc1NraWxsIiwiUmV0aXJlIiwiUmVmcmVzaEhlYWx0aEhwIiwiSGVhbHRoU3ViQWdlIiwiZ2V0U2tpbGxEYXRhQnlUd29JZCIsImdldFNraWxsTGlzdEJ5SWQiLCJHZXRPckNvc3REYXRhQnlSZXdhcmRUeXBlIiwicmV3YXJkVHlwZSIsIlBkYXRhIiwiY29tcGFueUlkIiwiYXZlcmFnZVByaWNlIiwiU3RvY2siLCJTdG9ja1ByaWNlIiwiSnVkZUFzc2V0IiwibmVlZE51bSIsIkp1ZGVSZXB1dGF0aW9uIiwiSnVkZUhwUG9pbnQiLCJKdWRlSGFzQ29tcGFueSIsIlVuTG9ja09uZU1hdGUiLCJvZmZTZXgiLCJkZXMiLCJPcGVuVW5Mb2NrTWF0ZSIsIlVuTG9ja01hdGVCeUluSG9zcGl0YWwiLCJKdWRlSGFzQW55TWF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxVQUFVLEdBQUdELE9BQU8sQ0FBQyxZQUFZLENBQUM7QUFDdEMsSUFBSUUsYUFBYSxHQUFHRixPQUFPLENBQUMsZUFBZSxDQUFDO0FBQzVDLElBQUlHLFNBQVMsR0FBR0gsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUNwQyxJQUFJSSxjQUFjLEdBQUdKLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztBQUM5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LE1BQU0sQ0FBQ3VNLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQztNQUM3RGpTLEVBQUUsQ0FBQ2tTLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUNwUyxFQUFFLENBQUN5RixHQUFHLENBQUM0TSxLQUFLLENBQUM4RCxjQUFjLEVBQUVsRixLQUFLLENBQUM7TUFDN0QsT0FBT3BNLEVBQUU7SUFDVjtFQUNEO0VBQ0EsT0FBT0EsRUFBRTtBQUNWLENBQUMsRUFBQTNFLFNBQUEsQ0FFRG1XLGNBQWMsR0FBQyxTQUFBQSxlQUFBLEVBQVU7RUFDeEIsSUFBSS9RLElBQUksR0FBRyxLQUFLO0VBQ2hCLEtBQUssSUFBSVIsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHLElBQUksQ0FBQ0osUUFBUSxDQUFDSyxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQzlDO0lBQ0EsSUFBRyxJQUFJLENBQUNKLFFBQVEsQ0FBQ0ksQ0FBQyxDQUFDLENBQUNvSCxJQUFJLElBQUksSUFBSSxFQUNoQztNQUNDNUcsSUFBSSxHQUFHLElBQUk7TUFDWCxPQUFPQSxJQUFJO0lBQ1o7RUFDRDtFQUNBLE9BQU9BLElBQUk7QUFDWixDQUFDLEVBQUFwRixTQUFBLEVBRUg7QUFFRm9XLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHeFcsV0FBVyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgUmV3YXJkVHlwZSA9IHJlcXVpcmUoXCJSZXdhcmRUeXBlXCIpO1xyXG52YXIgTWF0ZUJvbnVzVHlwZSA9IHJlcXVpcmUoXCJNYXRlQm9udXNUeXBlXCIpO1xyXG52YXIgU2tpbGxUeXBlID0gcmVxdWlyZShcIlNraWxsVHlwZVwiKTtcclxudmFyIE1hdGVVbkxvY2tUeXBlID0gcmVxdWlyZShcIk1hdGVVbkxvY2tUeXBlXCIpO1xyXG52YXIgTWF0ZUdldFR5cGUgPSByZXF1aXJlKFwiTWF0ZUdldFR5cGVcIik7XHJcbnZhciBVc2VyU3RhdGUgPSByZXF1aXJlKFwiVXNlclN0YXRlXCIpO1xyXG52YXIgQWNoaWV2ZUNvbmREYXRhID0gcmVxdWlyZShcIkFjaGlldmVDb25kRGF0YVwiKTtcclxudmFyIEFjaGlldmVDb25kID0gcmVxdWlyZShcIkFjaGlldmVDb25kXCIpO1xyXG5cclxuLy/ku6XkuIvnmoTmlbDmja7opoHlgZrmsLjkuYXkv53lrZhcclxudmFyIFNraWxsU3RydWN0ID0gcmVxdWlyZShcIlNraWxsU3RydWN0XCIpO1xyXG52YXIgQWNoaWV2ZVN0cnVjdCA9IHJlcXVpcmUoXCJBY2hpZXZlU3RydWN0XCIpO1xyXG52YXIgUmVjb3JkU3RydWN0ID0gcmVxdWlyZShcIlJlY29yZFN0cnVjdFwiKTtcclxuLy/kuIvpnaLnmoTmlbDlgLzmmK/kuI3kvJrmsLjkuYXkv53lrZjnmoQgIOaMh+WPquS8muW9k+WxgOa4uOaIj+S/neWtmFxyXG52YXIgR29vZHNTdHJ1Y3QgPSByZXF1aXJlKFwiR29vZHNTdHJ1Y3RcIik7XHJcbnZhciBDYXJTdHJ1Y3QgPSByZXF1aXJlKFwiQ2FyU3RydWN0XCIpO1xyXG52YXIgSG91c2VTdHJ1Y3QgPSByZXF1aXJlKFwiSG91c2VTdHJ1Y3RcIik7XHJcbnZhciBDb21wYW55U3RydWN0ID0gcmVxdWlyZShcIkNvbXBhbnlTdHJ1Y3RcIik7XHJcbnZhciBNYXRlU3RydWN0ID0gcmVxdWlyZShcIk1hdGVTdHJ1Y3RcIik7XHJcblxyXG52YXIgZXlvdUNsaWVudFRpa3RvayA9IHJlcXVpcmUoXCJFeW91Q2xpZW50VGlrdG9rXCIpO1xyXG52YXIgZXlvdUNsaWVudEtzID0gcmVxdWlyZShcIkV5b3VDbGllbnRLc1wiKTtcclxudmFyIGV5b3VDbGllbnQgPSByZXF1aXJlKFwiZXlvdUNsaWVudFwiKTtcclxudmFyIGh0dHBVdGlsID0gcmVxdWlyZShcImh0dHBVdGlsXCIpO1xyXG52YXIgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcclxuXHJcbi8v5pWw5o2u5pON5L2c57uT5p6EXHJcbnZhciBVc2VyRGF0YU1nciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOntcclxuICAgIFx0Ly/mnKzlnLDkv53lrZjmlbDmja5cclxuXHRcdHVzZXJJZDogXCJcIixcclxuXHJcbiAgICBcdHR1dG9yaWFsSW5CdXM6ZmFsc2UsXHJcbiAgICBcdHR1dG9yaWFsSW5EYXRlOmZhbHNlLFxyXG4gICAgXHR0dXRvcmlhbEluTWFya2V0OmZhbHNlLFxyXG4gICAgXHR0dXRvcmlhbFN0b2NrQm9udXM6ZmFsc2UsXHJcbiAgICBcdHR1dG9yaWFsTWF0ZVBvaW50OmZhbHNlLFxyXG5cclxuICAgIFx0VmlkZW9MYXN0VGltZTpcIlwiLC8v5q+P5aSp55yL6KeG6aKR5pe26Ze06K6w5b2VXHJcbiAgICBcdFZpZGVvQWRzVGltZXM6Y2MuSW50ZWdlciwvL+asoeaVsFxyXG5cclxuICAgIFx0cGxheVRpbWVzOmNjLkludGVnZXIsLy/muLjmiI/mrKHmlbBcclxuXHRcdHBsYXllck5hbWU6XCJBbGV4XCIsXHJcblx0XHRTZXg6Y2MuSW50ZWdlciwgLy8xIG1hbiAgMiB3b21hblxyXG4gICAgICAgIFNraWxsTGlzdDp7XHJcbiAgICAgICAgXHRkZWZhdWx0OltdLFxyXG4gICAgICAgIFx0dHlwZTpbU2tpbGxTdHJ1Y3RdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQWNoaWV2ZW1lbnRMaXN0OntcclxuICAgICAgICBcdGRlZmF1bHQ6W10sXHJcbiAgICAgICAgXHR0eXBlOltBY2hpZXZlU3RydWN0XSxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBSZWNvcmRMaXN0OntcclxuICAgICAgICBcdGRlZmF1bHQ6W10sXHJcbiAgICAgICAgXHR0eXBlOltSZWNvcmRTdHJ1Y3RdLFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIE1hcnJ5QWdlOmNjLkludGVnZXIsXHJcbiAgICAgICAgTWFycnlSb2xlSWQ6Y2MuSW50ZWdlcixcclxuICAgICAgICBEaXZvcmNlQWdlOmNjLkludGVnZXIsXHJcbiAgICAgICAgRnVuZGF0aW9uQWdlOmNjLkludGVnZXIsXHJcbiAgICAgICAgRnVuZGF0aW9uQ29tcGFueUlkOmNjLkludGVnZXIsXHJcbiAgICAgICAgQmFua3J1cHRBZ2U6Y2MuSW50ZWdlcixcclxuICAgICAgICBNaWxsaW9uQWdlOmNjLkludGVnZXIsXHJcbiAgICAgICAgVGVuTWlsbGlvbkFnZTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIEh1bmRyZWRNaWxsaW9uQWdlOmNjLkludGVnZXIsXHJcblxyXG4gICAgICAgIC8v6Z2e5pys5Zyw5L+d5a2Y5pWw5o2uXHJcbiAgICAgICAgUmV0aXJlQWdlOmNjLkludGVnZXIsIC8v6YCA5LyR5bm06b6EIOi/meS4quWAvOi3n+aIkOWwseacieWFs1xyXG4gICAgICAgIEJldFdpblJhdGlvOjAuMTUsIC8v6LOt5Y2a6LSP5qaC546HXHJcbiAgICAgICAgRGF0ZVN1Y2Nlc2NSYXRpbzowLjIsIC8v57SE5pyD5oiQ5Yqf5qaC546HXHJcbiAgICAgICAgLy9CZXRDb3N0OmNjLkludGVnZXIsLy/otYzljZroirHotLlcclxuICAgICAgICBIaWdoQXNzZXRzOmNjLkludGVnZXIsLy/otYTkuqflt4Xls7DlgLxcclxuICAgICAgICBJbml0TW9uZXk6Y2MuSW50ZWdlciwvL+WImuWHuuadpemXr+iNoeaXtuWAmeeahOaJgOaciei1hOS6p1xyXG4gICAgICAgIENhc2g6Y2MuSW50ZWdlciwvL+eOsOmHkVxyXG5cdFx0SHBQb2ludDpjYy5JbnRlZ2VyLC8v5YGl5bq35oyH5pWwXHJcblx0XHRBZ2U6Y2MuSW50ZWdlciwvL+W5tOm+hFxyXG5cdFx0SG9ub3I6Y2MuSW50ZWdlciwgLy/lpLTooZQgMSDnmb7kuIflr4znv4Eg562J562JICDov5nkuKrlnKjnjqnliLDkuIDkur/lhYPkuYvlkI7kvJrmnInmlrDnmoTnjqnmhI9cclxuXHRcdFJlcHV0YXRpb246Y2MuSW50ZWdlciwgLy/lkI3lo7DmjIfmlbBcclxuXHRcdEFzc2V0c01vbmV5OmNjLkludGVnZXIsIC8v5oC76LWE5LqnXHJcblx0XHRXYXJlSG91c2VDYXBjaXR5OmNjLkludGVnZXIsLy/ku5PlupPliankvZnlrrnph49cclxuXHRcdFdhcmVIb3VzZUFsbENhcGNpdHk6Y2MuSW50ZWdlciwvL+S7k+W6k+aAu+WuuemHj1xyXG5cdFx0aGFzQ29tcGFueTpmYWxzZSwvL+aYr+WQpuW3sue7j+WIm+WKnuWFrOWPuFxyXG5cdFx0Q2FuR2V0U3RvY2tQcm9maXQ6ZmFsc2UsIC8v6IO95ZCm6K6h566X6IKh56Wo5pS255uK5LqGXHJcblx0XHRSZWNvdmVyWWVhcjowLC8vIOS7juaBouWkjeWBpeW6tyDliankvZnlubTpmZBcclxuXHJcblx0XHRTa2lsbEJvbnVzUG9pbnQ6MCwvL+aKgOiDveeCuVxyXG5cclxuXHRcdC8v5Yqg5oiQ54K5IOS8tOS+o+WKoOaIkCAg5oqA6IO95Yqg5oiQIFxyXG5cdFx0VHJlYXRCb251czogMC4wLCAvL+ayu+eWl+iKsei0uemZjeS9jueZvuWIhueCuVxyXG5cdFx0V2FyZUhvdXNlQ2FwY2l0eUJvbnVzOjAsIC8v5LuT5YKo5Yqg5oiQXHJcblx0XHRDYXNoQm9udXM6MCwgLy/ph5HpkrHliqDmiJAg5q+P5bm05Yqg5oiQXHJcblx0XHRDYXNoUmF0aW9uQm9udXM6MCxcclxuXHRcdFJlcHV0YXRpb25Cb251czowLCAvL+WQjeWjsOWKoOaIkCDmr4/lubRcclxuXHRcdEhwUG9pbnRCb251czowLCAvL+WBpeW6t+WKoOaIkFxyXG5cdFx0V2FyZUhvdXNlQm9udXNFdmVyeVllYXI6MCwgLy/mr4/lubTnmoTku5PlgqjliqDmiJBcclxuXHRcdFJldGlyZUJvbnVzOjAsIC8v5aKe5Yqg6YCA5LyR5bm06ZmQXHJcblx0XHREYXRlQm9udXM6MC4wLCAvL+WinuWKoOe6puS8muaIkOWKn+amgueOh1xyXG5cdFx0SW5pdE1vbmV5Qm9udXM6MCwvL+WinuWKoOWIneWni+eOsOmHkVxyXG5cdFx0U3RvY2tBZGRCb251czowLjAsIC8v5aKe5Yqg5YWs5Y+45pS255uKXHJcblx0XHRTdG9ja1VwQm9udXM6MC4wLCAvL+iCoeelqOS4iua2qCDmpoLnjoflop7liqBcclxuXHRcdERhdGVNb25leUJvbnVzOjAuMCwgLy/nuqbkvJroirHotLnpmY3kvY5cclxuXHRcdEJldEJvbnVzOjAuMCwgLy/otYzljZrotaLpkrHmpoLnjofkuIrljYdcclxuXHRcdFNraWxsUG9pbnRHZXRCb251czowLjAgLC8v57uT566X5oqA6IO954K56I635b6X5o+Q5Y2HXHJcblx0XHRSZXB1dGF0aW9uSW5pdEJvbnVzOjAsIC8v5Yid5aeL5ZCN5aOw5Yqg5oiQXHJcblx0XHRDYXJCdXlCb251czowLCAvL+i0reS5sOaxvei9puS7t+agvOmZjeS9jlxyXG5cdFx0RXZlbnRDb3N0Qm9udXM6MCwgLy/kuovku7bmtojogJfph5HpkrHpmY3kvY5cclxuXHRcdEhvdXNlQnV5Qm9udXNlOjAsIC8v6LSt5Lmw5oi/5bGLIOS7t+agvOmZjeS9jlxyXG5cclxuXHRcdEhpc3RvcnlIaWdoQXNzZXRzOjAsLy8g6K6w5b2V5Y6G5Y+y6YCA5LyR5pyA6auY6LWE5LqnXHJcblxyXG5cdFx0dXNlclN0YXRlOntcclxuXHRcdFx0ZGVmYXVsdDpVc2VyU3RhdGUuT0ssXHJcblx0XHRcdHR5cGU6VXNlclN0YXRlLFxyXG5cdFx0fSwvLyDnjqnlrrbnirbmgIFcclxuXHJcblx0XHRFdmVudERhdGFJZExpc3Q6e1xyXG5cdFx0XHRkZWZhdWx0OltdLFxyXG5cdFx0XHR0eXBlOltjYy5JbnRlZ2VyXSxcclxuXHRcdH0sLy/kuovku7blvLnlh7ogSWTliJfooahcclxuXHJcblx0XHRHb29kc0xpc3Q6e1xyXG5cdFx0XHRkZWZhdWx0OltdLFxyXG5cdFx0XHR0eXBlOltHb29kc1N0cnVjdF0sXHJcblx0XHR9LFxyXG5cdFx0Q2FyTGlzdDp7XHJcblx0XHRcdGRlZmF1bHQ6W10sXHJcblx0XHRcdHR5cGU6W0NhclN0cnVjdF0sXHJcblx0XHR9LFxyXG5cdFx0SG91c2VMaXN0OntcclxuXHRcdFx0ZGVmYXVsdDpbXSxcclxuXHRcdFx0dHlwZTpbSG91c2VTdHJ1Y3RdLFxyXG5cdFx0fSxcclxuXHRcdENvbXBhbnlMaXN0OntcclxuXHRcdFx0ZGVmYXVsdDpbXSxcclxuXHRcdFx0dHlwZTpbQ29tcGFueVN0cnVjdF0sXHJcblx0XHR9LFxyXG5cdFx0TWF0ZUxpc3Q6e1xyXG5cdFx0XHRkZWZhdWx0OltdLFxyXG5cdFx0XHR0eXBlOltNYXRlU3RydWN0XSxcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly/lvZPliY3mmL7npLrnmoTkupTkuKrnianlk4Eg5q+P5qyh5Y+q5pi+56S65LqU5Liq54mp5ZOBICDlj6rkv53lrZggSWRcclxuXHRcdFNob3dHb29kc0xpc3Q6e1xyXG5cdFx0XHRkZWZhdWx0OltdLFxyXG5cdFx0XHR0eXBlOltjYy5JbnRlZ2VyXSxcclxuXHRcdH0sXHJcblxyXG5cdH0sXHJcblxyXG5cdEp1ZGVHb29kc093bmVkOmZ1bmN0aW9uKElkKXtcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkdvb2RzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZih0aGlzLkdvb2RzTGlzdFtpXS5JZCA9PSBJZCAmJiB0aGlzLkdvb2RzTGlzdFtpXS5vd25OdW0gPiAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL+a4heeQhuW4guWcuuaYvuekuuaVsOaNrlxyXG5cdENsZWFyU2hvd0dvb2RzTGlzdDpmdW5jdGlvbigpe1xyXG5cdFx0dGhpcy5TaG93R29vZHNMaXN0LnNwbGljZSgwLCB0aGlzLlNob3dHb29kc0xpc3QubGVuZ3RoKTtcclxuXHR9LFxyXG5cclxuXHQvL+WQkeaYvuekuuaVsOe7hOS4reaPkuWFpeS4gOS4qiDmmL7npLrmlbDmja4gSWRcclxuXHRJbnNlcnRHb29kc0lkVG9MaXN0OmZ1bmN0aW9uKElkKXtcclxuXHRcdHRoaXMuU2hvd0dvb2RzTGlzdC5wdXNoKElkKTtcclxuXHR9LFxyXG5cdC8v5qOA5p+lSWQg5piv5ZCm5b2T5YmN5pi+56S6XHJcblx0Q2hlY2tJZElzSW5TaG93TGlzdDpmdW5jdGlvbihJZCl7XHJcblx0XHR2YXIgZmxhZyA9IGZhbHNlO1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuU2hvd0dvb2RzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZih0aGlzLlNob3dHb29kc0xpc3RbaV0gPT0gSWQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRmbGFnID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZsYWc7XHJcblx0fSxcclxuXHJcblx0aW5pdERhdGE6ZnVuY3Rpb24gKCkge1xyXG5cdFx0Y2MuTWdyLmluaXREYXRhID0gZmFsc2U7XHJcblx0XHR0aGlzLnVzZXJTdGF0ZSA9IFVzZXJTdGF0ZS5PSzsvL+WBpeW6t+eKtuaAgVxyXG5cclxuXHRcdGNjLk1nci5nbG9iYWwuSW5pdEV2ZW50SGFwcGVuQWdlKCk7XHJcblxyXG5cdFx0aWYgKCFjYy5NZ3IuVXNlckRhdGFNZ3IudXNlcklkKSB7XHJcblx0XHRcdGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcblx0XHRcdGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuXHRcdFx0XHRpc0t1YWlTaG91ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQllURURBTkNFX0dBTUUpIHtcclxuXHRcdFx0XHRleW91Q2xpZW50VGlrdG9rLmdldElucygpLmluaXQoOTAwMDAwOSwgaW5pdFJlc3AgPT4ge1xyXG5cdFx0XHRcdFx0ZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5sb2dpbihsb2dpblJlc3AgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRpa3Rva0dhbWVWZXJpZnlTZXNzaW9uKGxvZ2luUmVzcC5kYXRhLmNvZGUpXHJcblx0XHRcdFx0XHRcdFx0LnRoZW4odGlrdG9rT3BlbklkID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZXhlY0FmdGVyT2J0YWluQWNjb3VudCh0aWt0b2tPcGVuSWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2MuTWdyLmluaXREYXRhID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHRcdC5jYXRjaChlcnIgPT4gY2MubG9nKCfnmbvlvZXlpLHotKU6PicsIGVycikpXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9ZWxzZSBpZiAoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuV0VDSEFUX0dBTUUgJiYgIWlzS3VhaVNob3UpIHtcclxuXHRcdFx0XHRleW91Q2xpZW50LmdldElucygpLmluaXQoOTAwMDAyMSwgaW5pdFJlc3AgPT4ge1xyXG5cdFx0XHRcdFx0ZXlvdUNsaWVudC5nZXRJbnMoKS5sb2dpbihsb2dpblJlc3AgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLndlY2hhdEdhbWVWZXJpZnlTZXNzaW9uKGxvZ2luUmVzcC5kYXRhLmNvZGUpXHJcblx0XHRcdFx0XHRcdFx0LnRoZW4od3hPcGVuSWQgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5leGVjQWZ0ZXJPYnRhaW5BY2NvdW50KHd4T3BlbklkKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y2MuTWdyLmluaXREYXRhID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHRcdC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coJ+eZu+W9leWksei0pTo+JywgZXJyKSlcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1lbHNlIGlmIChpc0t1YWlTaG91KXtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIui/kOihjOWcqOW/q+aJi+W5s+WPsFwiKVxyXG5cdFx0XHRcdGV5b3VDbGllbnRLcy5nZXRJbnMoKS5pbml0KDkwMDAwMDUsIGluaXRSZXNwID0+IHtcclxuXHRcdFx0XHRcdGV5b3VDbGllbnRLcy5nZXRJbnMoKS5sb2dpbihsb2dpblJlc3AgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmt1YWlTaG91R2FtZVZlcmlmeVNlc3Npb24obG9naW5SZXNwLmRhdGEuY29kZSlcclxuXHRcdFx0XHRcdFx0XHQudGhlbihrc09wZW5JZCA9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmV4ZWNBZnRlck9idGFpbkFjY291bnQoa3NPcGVuSWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2MuTWdyLmluaXREYXRhID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHRcdC5jYXRjaChlcnIgPT4gY2MubG9nKCfnmbvlvZXlpLHotKU6PicsIGVycikpXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLmV4ZWNBZnRlck9idGFpbkFjY291bnQoJ2RlZmF1bHQnKVxyXG5cdFx0Y2MuTWdyLmluaXREYXRhID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHR0aWt0b2tHYW1lVmVyaWZ5U2Vzc2lvbihjb2RlKSB7XHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cdFx0XHRsZXQgcmVxT2JqID0ge1xyXG5cdFx0XHRcdGdhbWVJZDogOTAwMDAwOSxcclxuXHRcdFx0XHRwbGF0Zm9ybUlkOiAyLFxyXG5cdFx0XHRcdGNvZGU6IGNvZGUsXHJcblx0XHRcdFx0dGltZVN0YW1wOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBzZWNTdHIgPSBcImMtYS0wLTAtMS02LWUtNi1lLWUtYy1lLWEtNi0yLWUtYi1kLTEtYS1kLWUtYS0zLWYtNy1lLTItZi1jLWItZi1jLTEtYi04LTYtZC00LTJcIlxyXG5cdFx0XHRsZXQgc2lnblN0ciA9IHJlcU9iai5nYW1lSWQgKyBcIi1cIiArIHJlcU9iai5wbGF0Zm9ybUlkICsgXCItXCIgKyByZXFPYmouY29kZSArIFwiLVwiICsgcmVxT2JqLnRpbWVTdGFtcCArIFwiLVwiICsgc2VjU3RyLnJlcGxhY2VBbGwoXCItXCIsIFwiXCIpO1xyXG5cdFx0XHRyZXFPYmouc2lnbiA9IGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoc2lnblN0ciwgJ3V0ZjgnKS5kaWdlc3QoJ2hleCcpO1xyXG5cdFx0XHRodHRwVXRpbC5wb3N0SnNvbihcclxuXHRcdFx0XHRcImh0dHBzOi8vZ2FtZXMuaG5kaWJlaS5jb20vbWFya2V0LW11bHRpLWdhbWUtc2VydmVyL3Rpa3Rva1NlcnZlci92ZXJpZnlTZXNzaW9uXCIsXHJcblx0XHRcdFx0cmVxT2JqLFxyXG5cdFx0XHRcdChyZXFGbGFnLCByZXNwKSA9PiB7XHJcblx0XHRcdFx0XHRpZiAocmVxRmxhZyAmJiByZXNwLmNvZGUgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwLmRhdGEudXNlcklkKVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3ApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQpXHJcblx0XHR9KVxyXG5cdH0sXHJcblxyXG5cdHdlY2hhdEdhbWVWZXJpZnlTZXNzaW9uKGNvZGUpIHtcclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblx0XHRcdGxldCByZXFPYmogPSB7XHJcblx0XHRcdFx0Z2FtZUlkOiA5MDAwMDIxLFxyXG5cdFx0XHRcdHBsYXRmb3JtSWQ6IDEsXHJcblx0XHRcdFx0Y29kZTogY29kZSxcclxuXHRcdFx0XHR0aW1lU3RhbXA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApXHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gbGV0IHNlY1N0ciA9IFwiNS02LWUtMy0yLTItOS1jLTUtYi0zLTItMi1mLTItNy01LWUtOC1jLWUtYi0zLTgtYy1iLTYtMS0yLTUtZC1hXCIgLy/pppblr4zlhbvmiJDorrBcclxuXHRcdFx0bGV0IHNlY1N0ciA9IFwiOS0xLWUtMS0zLWEtNy1hLTUtMy01LTEtYy01LTItYS0zLTktOS0zLTMtNC03LTItMS01LTUtNC0yLTktNS0zXCIgLy/nlq/ni4LmjKrovabnjotcclxuXHRcdFx0bGV0IHNpZ25TdHIgPSByZXFPYmouZ2FtZUlkICsgXCItXCIgKyByZXFPYmoucGxhdGZvcm1JZCArIFwiLVwiICsgcmVxT2JqLmNvZGUgKyBcIi1cIiArIHJlcU9iai50aW1lU3RhbXAgKyBcIi1cIiArIHNlY1N0ci5yZXBsYWNlQWxsKFwiLVwiLCBcIlwiKTtcclxuXHRcdFx0cmVxT2JqLnNpZ24gPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHNpZ25TdHIsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcclxuXHRcdFx0aHR0cFV0aWwucG9zdEpzb24oXHJcblx0XHRcdFx0XCJodHRwczovL2dhbWVzLmhuZGliZWkuY29tL21hcmtldC13ZWNoYXQtZ2FtZS1zZXJ2ZXIvd3hTZXJ2ZXIvdmVyaWZ5U2Vzc2lvblwiLFxyXG5cdFx0XHRcdHJlcU9iaixcclxuXHRcdFx0XHQocmVxRmxhZywgcmVzcCkgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKHJlcUZsYWcgJiYgcmVzcC5jb2RlID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzcC5kYXRhLnVzZXJJZClcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJlamVjdChyZXNwKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0KVxyXG5cdFx0fSlcclxuXHR9LFxyXG5cclxuXHRrdWFpU2hvdUdhbWVWZXJpZnlTZXNzaW9uKGNvZGUpIHtcclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblx0XHRcdGxldCByZXFPYmogPSB7XHJcblx0XHRcdFx0Z2FtZUlkOiA5MDAwMDA1LFxyXG5cdFx0XHRcdHBsYXRmb3JtSWQ6IDksXHJcblx0XHRcdFx0Y29kZTogY29kZSxcclxuXHRcdFx0XHR0aW1lU3RhbXA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApXHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHNlY1N0ciA9IFwia2tpNkUwRVFXbmlnTFl2MjcyeklSQVwiXHJcblx0XHRcdGxldCBzaWduU3RyID0gcmVxT2JqLmdhbWVJZCArIFwiLVwiICsgcmVxT2JqLnBsYXRmb3JtSWQgKyBcIi1cIiArIHJlcU9iai5jb2RlICsgXCItXCIgKyByZXFPYmoudGltZVN0YW1wICsgXCItXCIgKyBzZWNTdHIucmVwbGFjZUFsbChcIi1cIiwgXCJcIik7XHJcblx0XHRcdHJlcU9iai5zaWduID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShzaWduU3RyLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XHJcblx0XHRcdGh0dHBVdGlsLnBvc3QoXHJcblx0XHRcdFx0XCJodHRwczovL2dhbWVzLmhuZGliZWkuY29tL21hcmtldC1tdWx0aS1nYW1lLXNlcnZlci9rdWFpU2hvdVNlcnZlci92ZXJpZnlTZXNzaW9uXCIsXHJcblx0XHRcdFx0cmVxT2JqLFxyXG5cdFx0XHRcdChyZXFGbGFnLCByZXNwKSA9PiB7XHJcblx0XHRcdFx0XHRpZiAocmVxRmxhZyAmJiByZXNwLmNvZGUgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwLmRhdGEudXNlcklkKVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3ApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQpXHJcblx0XHR9KVxyXG5cdH0sXHJcblxyXG5cclxuXHRleGVjQWZ0ZXJPYnRhaW5BY2NvdW50KHVzZXJJZCkge1xyXG5cdFx0dGhpcy51c2VySWQgPSB1c2VySWQ7XHJcblxyXG5cdFx0Ly/mnKzlnLDlrZjlgqjmlbDmja5cclxuXHRcdHZhciBTdG9yYWdlRGF0YSA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnWE1CX3VzZXJkYXRhXycgKyB0aGlzLnVzZXJJZCk7IC8v5L2c5Li65LiA5Liq5pW05L2T5L+d5a2Y6LW35p2lXHJcblx0XHRpZihTdG9yYWdlRGF0YSA9PSBudWxsIHx8IFN0b3JhZ2VEYXRhID09IFwiXCIpXHJcblx0XHR7XHJcblx0XHRcdC8vY2MubG9nKFwi6L+Y5rKh5pyJ5L+d5a2Y6L+H5oyB5LmF5pWw5o2uXCIpO1xyXG5cdFx0XHR2YXIgdXNlcmRhdGEgPSB7fTtcclxuXHRcdFx0dXNlcmRhdGEuU2tpbGxMaXN0ID0gbnVsbDtcclxuXHRcdFx0dXNlcmRhdGEuQWNoaWV2ZW1lbnRMaXN0ID0gbnVsbDtcclxuXHRcdFx0dXNlcmRhdGEucGxheWVyTmFtZSA9IFwiXCI7XHJcblx0XHRcdHVzZXJkYXRhLlNleCA9IDE7XHJcblx0XHRcdHVzZXJkYXRhLnBsYXlUaW1lcyA9IDA7XHJcblx0XHRcdHVzZXJkYXRhLlNraWxsQm9udXNQb2ludCA9IDA7XHJcblxyXG5cdFx0XHR1c2VyZGF0YS50dXRvcmlhbEluQnVzID0gZmFsc2U7XHJcblx0XHRcdHVzZXJkYXRhLnR1dG9yaWFsSW5EYXRlID0gZmFsc2U7XHJcblx0XHRcdHVzZXJkYXRhLnR1dG9yaWFsSW5NYXJrZXQgPSBmYWxzZTtcclxuXHRcdFx0dXNlcmRhdGEudHV0b3JpYWxTdG9ja0JvbnVzID0gZmFsc2U7XHJcblx0XHRcdHVzZXJkYXRhLnR1dG9yaWFsTWF0ZVBvaW50ID0gZmFsc2U7XHJcblxyXG5cdFx0XHR1c2VyZGF0YS5WaWRlb0Fkc1RpbWVzID0gMDtcclxuXHRcdFx0dXNlcmRhdGEuVmlkZW9MYXN0VGltZSA9IFwiXCI7XHJcblx0XHRcdHVzZXJkYXRhLkhpc3RvcnlIaWdoQXNzZXRzID0gMDtcclxuXHJcblx0XHRcdHRoaXMuVmlkZW9MYXN0VGltZSA9IFwiXCI7XHJcblx0XHRcdHRoaXMuVmlkZW9BZHNUaW1lcyA9IDA7XHJcblxyXG5cdFx0XHR0aGlzLnBsYXllck5hbWUgPSB1c2VyZGF0YS5wbGF5ZXJOYW1lO1xyXG5cdFx0XHR0aGlzLlNleCA9IHVzZXJkYXRhLlNleDtcclxuXHRcdFx0dGhpcy5wbGF5VGltZXMgPSB1c2VyZGF0YS5wbGF5VGltZXM7XHJcblx0XHRcdHRoaXMudHV0b3JpYWxJbkJ1cyA9IHVzZXJkYXRhLnR1dG9yaWFsSW5CdXM7XHJcblx0XHRcdHRoaXMudHV0b3JpYWxJbk1hcmtldCA9IHVzZXJkYXRhLnR1dG9yaWFsSW5NYXJrZXQ7XHJcblx0XHRcdHRoaXMudHV0b3JpYWxJbkRhdGUgPSB1c2VyZGF0YS50dXRvcmlhbEluRGF0ZTtcclxuXHRcdFx0dGhpcy50dXRvcmlhbFN0b2NrQm9udXMgPSB1c2VyZGF0YS50dXRvcmlhbFN0b2NrQm9udXM7XHJcblx0XHRcdHRoaXMudHV0b3JpYWxNYXRlUG9pbnQgPSB1c2VyZGF0YS50dXRvcmlhbE1hdGVQb2ludDtcclxuXHJcblxyXG5cdFx0XHR0aGlzLlNraWxsQm9udXNQb2ludCA9IHVzZXJkYXRhLlNraWxsQm9udXNQb2ludDtcclxuXHJcblx0XHRcdHZhciBTa2lsbExpc3QgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhTGlzdEJ5SXRlbVR5cGUoSXRlbVR5cGUuU2tpbGwpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IFNraWxsTGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBkYXRhID0gU2tpbGxMaXN0W2ldO1xyXG5cdFx0XHRcdHZhciBzayA9IG5ldyBTa2lsbFN0cnVjdCgpO1xyXG5cdFx0XHRcdHNrLm5hbWUgPSBkYXRhLm5hbWU7XHJcblx0XHRcdFx0c2suaWNvbiA9IGRhdGEuaWNvbjtcclxuXHRcdFx0XHRzay5JZCA9IGRhdGEuSWQ7XHJcblx0XHRcdFx0c2suZGVzSWQgPSBkYXRhLmRlc0lkO1xyXG5cdFx0XHRcdHNrLnN1YklkID0gZGF0YS5zdWJJZDtcclxuXHRcdFx0XHRzay5VcGx2ID0gZGF0YS51cExldmVsO1xyXG5cdFx0XHRcdHNrLnNraWxsVHlwZSA9IGRhdGEuc2tpbGxUeXBlO1xyXG5cdFx0XHRcdHNrLmxldmVsID0gMDtcclxuXHRcdFx0XHR0aGlzLlNraWxsTGlzdFtpXSA9IHNrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBBY2hpZXZlbWVudExpc3QgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhTGlzdEJ5SXRlbVR5cGUoSXRlbVR5cGUuQWNoaWV2ZSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgQWNoaWV2ZW1lbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBBY2hpZXZlbWVudExpc3RbaV07XHJcblx0XHRcdFx0dmFyIGFjID0gbmV3IEFjaGlldmVTdHJ1Y3QoKTtcclxuXHRcdFx0XHRhYy5JZCA9IGRhdGEuSWQ7XHJcblx0XHRcdFx0YWMuaWNvbiA9IGRhdGEuaWNvbjtcclxuXHRcdFx0XHRhYy5uYW1lID0gZGF0YS5uYW1lO1xyXG5cdFx0XHRcdGFjLmRlc0lkID0gZGF0YS5kZXNJZDtcclxuXHRcdFx0XHRhYy5oYXNGaW5pc2ggPSBmYWxzZTtcclxuXHRcdFx0XHR0aGlzLkFjaGlldmVtZW50TGlzdFtpXSA9IGFjO1xyXG5cdFx0XHR9XHJcblx0XHRcdHVzZXJkYXRhLlNraWxsTGlzdCA9IHRoaXMuU2tpbGxMaXN0O1xyXG5cdFx0XHR1c2VyZGF0YS5BY2hpZXZlbWVudExpc3QgPSB0aGlzLkFjaGlldmVtZW50TGlzdDtcclxuXHJcblx0XHRcdHVzZXJkYXRhLlJlY29yZExpc3QgPSB0aGlzLlJlY29yZExpc3Q7XHJcblxyXG5cdFx0XHRjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ1hNQl91c2VyZGF0YV8nICsgdGhpcy51c2VySWQsSlNPTi5zdHJpbmdpZnkodXNlcmRhdGEpKTtcclxuXHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdC8vY2MubG9nKFwi5pyJ5LmL5YmN5L+d5a2Y55qE5oyB5LmF5pWw5o2u5a2Y5ZyoXCIpO1xyXG5cdFx0XHR2YXIgRGF0YSA9IEpTT04ucGFyc2UoU3RvcmFnZURhdGEpO1xyXG5cdFx0XHR0aGlzLnBsYXllck5hbWUgPSBEYXRhLnBsYXllck5hbWU7XHJcblx0XHRcdHRoaXMuU2V4ID0gRGF0YS5TZXg7XHJcblx0XHRcdHRoaXMucGxheVRpbWVzID0gRGF0YS5wbGF5VGltZXM7XHJcblx0XHRcdHRoaXMudHV0b3JpYWxJbkJ1cyA9IERhdGEudHV0b3JpYWxJbkJ1cztcclxuXHRcdFx0dGhpcy50dXRvcmlhbEluTWFya2V0ID0gRGF0YS50dXRvcmlhbEluTWFya2V0O1xyXG5cdFx0XHR0aGlzLnR1dG9yaWFsSW5EYXRlID0gRGF0YS50dXRvcmlhbEluRGF0ZTtcclxuXHRcdFx0dGhpcy50dXRvcmlhbFN0b2NrQm9udXMgPSBEYXRhLnR1dG9yaWFsU3RvY2tCb251cztcclxuXHRcdFx0dGhpcy50dXRvcmlhbE1hdGVQb2ludCA9IERhdGEudHV0b3JpYWxNYXRlUG9pbnQ7XHJcblxyXG5cdFx0XHR0aGlzLkhpc3RvcnlIaWdoQXNzZXRzID0gRGF0YS5IaXN0b3J5SGlnaEFzc2V0cztcclxuXHJcblx0XHRcdHRoaXMuU2tpbGxMaXN0ID0gRGF0YS5Ta2lsbExpc3Q7XHJcblx0XHRcdHRoaXMuU2tpbGxCb251c1BvaW50ID0gRGF0YS5Ta2lsbEJvbnVzUG9pbnQ7XHJcblx0XHRcdHRoaXMuQWNoaWV2ZW1lbnRMaXN0ID0gRGF0YS5BY2hpZXZlbWVudExpc3Q7XHJcblx0XHRcdHRoaXMuVmlkZW9MYXN0VGltZSA9IERhdGEuVmlkZW9MYXN0VGltZTtcclxuXHJcblx0XHRcdHZhciB0ZXN0RGF0ZSA9IG5ldyBEYXRlKCk7XHJcblxyXG5cdFx0XHQvL2NjLmxvZyhcIisrKysrKysrKysrKysrKysrKysrKysrKysrIFwiICsgdGVzdERhdGUudG9EYXRlU3RyaW5nKCkpO1xyXG5cdFx0XHRpZihEYXRhLlZpZGVvTGFzdFRpbWUgIT0gdGVzdERhdGUudG9EYXRlU3RyaW5nKCkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLlZpZGVvQWRzVGltZXMgPSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuVmlkZW9BZHNUaW1lcyA9IERhdGEuVmlkZW9BZHNUaW1lcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoRGF0YS5SZWNvcmRMaXN0ICE9IG51bGwpXHJcblx0XHRcdFx0dGhpcy5SZWNvcmRMaXN0ID0gRGF0YS5SZWNvcmRMaXN0O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8v6I635Y+W5YW25a6e5aSp6LWL54K55Yqg5oiQXHJcblx0XHR0aGlzLkdldEluaXRTa2lsbEJvbnVzKHRoaXMuU2tpbGxMaXN0KTtcclxuXHJcblx0XHR0aGlzLk1hcnJ5QWdlID0gMDtcclxuXHRcdHRoaXMuTWFycnlSb2xlSWQgPSAwO1xyXG5cdFx0dGhpcy5EaXZvcmNlQWdlID0gMDtcclxuXHRcdHRoaXMuRnVuZGF0aW9uQWdlID0gMDtcclxuXHRcdHRoaXMuRnVuZGF0aW9uQ29tcGFueUlkID0gMDtcclxuXHRcdHRoaXMuQmFua3J1cHRBZ2UgPSAwO1xyXG5cdFx0dGhpcy5NaWxsaW9uQWdlID0gMDtcclxuXHRcdHRoaXMuVGVuTWlsbGlvbkFnZSA9IDA7XHJcblx0XHR0aGlzLkh1bmRyZWRNaWxsaW9uQWdlID0gMDtcclxuXHJcblxyXG5cdFx0Ly/liJ3lp4vljJYg546p5LiA5bGA55qE5pWw5o2uXHJcblx0XHR0aGlzLnJldGlyZUFnZSA9IGNjLk1nci5nbG9iYWwuUmV0aXJlSW5pdEFnZSArIHRoaXMuUmV0aXJlQm9udXM7XHJcblx0XHR0aGlzLkJldFdpblJhdGlvID0gY2MuTWdyLmdsb2JhbC5CZXRXaW5SYXRpbyArICh0aGlzLkJldEJvbnVzIC8gMTAwKTsgLy/lkI7pnaLov5jkvJropoHliqDkuIrliqDmiJBcclxuXHRcdHRoaXMuRGF0ZVN1Y2Nlc2NSYXRpbyA9IGNjLk1nci5nbG9iYWwuRGF0ZVN1Y2Nlc2NSYXRpbyArICh0aGlzLkRhdGVCb251cyAvIDEwMCk7XHJcblx0XHR0aGlzLkNhc2ggPSAwO1xyXG5cdFx0dGhpcy5IaWdoQXNzZXRzID0gMDtcclxuXHRcdHRoaXMuSHBQb2ludCA9IDEwMDtcclxuXHRcdHRoaXMuUmVjb3ZlclllYXIgPSAwO1xyXG5cdFx0dGhpcy51c2VyU3RhdGUgPSBVc2VyU3RhdGUuT0s7XHJcblx0XHR0aGlzLkFnZSA9IDIwO1xyXG5cdFx0dGhpcy5Ib25vciA9IDA7IC8v5rKh5pyJ5aS06KGUXHJcblx0XHR0aGlzLlJlcHV0YXRpb24gPSB0aGlzLlJlcHV0YXRpb25Jbml0Qm9udXM7IC8v5ZCN5aOwXHJcblx0XHR0aGlzLkFzc2V0c01vbmV5ID0gMDsvL+i1hOS6p1xyXG5cclxuXHRcdHRoaXMuV2FyZUhvdXNlQm9udXNFdmVyeVllYXIgPSAwO1xyXG5cclxuXHRcdHRoaXMuV2FyZUhvdXNlQ2FwY2l0eSA9IGNjLk1nci5nbG9iYWwuSW5pdFdhcmVIb3VzZUNhcGNpdHkgKyB0aGlzLldhcmVIb3VzZUNhcGNpdHlCb251czsvL+S7k+W6k+WuuemHj+WIneWni+WumjEwMCAg6L+Z5Liq5YC85Yiw5pe26KaB5qC55o2uIOaIkOWwseWumlxyXG5cdFx0dGhpcy5XYXJlSG91c2VBbGxDYXBjaXR5ID0gY2MuTWdyLmdsb2JhbC5Jbml0V2FyZUhvdXNlQ2FwY2l0eSArIHRoaXMuV2FyZUhvdXNlQ2FwY2l0eUJvbnVzO1xyXG5cdFx0dGhpcy5oYXNDb21wYW55ID0gZmFsc2U7Ly/msqHmnInlhazlj7hcclxuXHRcdHRoaXMuQ2FuR2V0U3RvY2tQcm9maXQgPSBmYWxzZTsvL+i/mOS4jeiDveiuoeeul+iCoeelqOaUtuebilxyXG5cclxuXHJcblx0XHR2YXIgR29vZHNMaXN0ID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUxpc3RCeUl0ZW1UeXBlKEl0ZW1UeXBlLkdvb2RzKTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgR29vZHNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkYXRhID0gR29vZHNMaXN0W2ldO1xyXG5cdFx0XHR2YXIgYWMgPSBuZXcgR29vZHNTdHJ1Y3QoKTtcclxuXHRcdFx0YWMubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0YWMuSWQgPSBkYXRhLklkO1xyXG5cdFx0XHRhYy5pY29uID0gZGF0YS5pY29uO1xyXG5cdFx0XHRhYy5vd25OdW0gPSAwO1xyXG5cdFx0XHRhYy5idXlQcmljZSA9IDA7IC8v5Lmw5YWl5Lu35qC8XHJcblx0XHRcdGFjLm1hcmtldFByaWNlID0gMDsvL+W4guWcuuS7t+agvFxyXG5cdFx0XHR0aGlzLkdvb2RzTGlzdFtpXSA9IGFjO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBDYXJMaXN0ID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUxpc3RCeUl0ZW1UeXBlKEl0ZW1UeXBlLkNhcik7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IENhckxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRhdGEgPSBDYXJMaXN0W2ldO1xyXG5cdFx0XHR2YXIgYWMgPSBuZXcgQ2FyU3RydWN0KCk7XHJcblx0XHRcdGFjLklkID0gZGF0YS5JZDtcclxuXHRcdFx0YWMuaWNvbiA9IGRhdGEuaWNvbjtcclxuXHRcdFx0YWMubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0YWMub3duTnVtID0gMDtcclxuXHRcdFx0YWMucHJpY2UgPSBkYXRhLnByaWNlO1xyXG5cdFx0XHRhYy5hZGRCb251cyA9IGRhdGEuYWRkQm9udXM7XHJcblx0XHRcdGFjLmFkZEhwID0gZGF0YS5hZGRIcDtcclxuXHRcdFx0YWMuYWRkRGF0ZSA9IGRhdGEuYWRkRGF0ZTtcclxuXHRcdFx0dGhpcy5DYXJMaXN0W2ldID0gYWM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIEhvdXNlTGlzdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFMaXN0QnlJdGVtVHlwZShJdGVtVHlwZS5Ib3VzZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IEhvdXNlTGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZGF0YSA9IEhvdXNlTGlzdFtpXTtcclxuXHRcdFx0dmFyIGFjID0gbmV3IEhvdXNlU3RydWN0KCk7XHJcblx0XHRcdGFjLklkID0gZGF0YS5JZDtcclxuXHRcdFx0YWMuaWNvbiA9IGRhdGEuaWNvbjtcclxuXHRcdFx0YWMubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0YWMub3duTnVtID0gMDtcclxuXHRcdFx0YWMucHJpY2UgPSBkYXRhLnByaWNlO1xyXG5cdFx0XHRhYy5hZGRCb251cyA9IGRhdGEuYWRkQm9udXM7XHJcblx0XHRcdGFjLmFkZEhwID0gZGF0YS5hZGRIcDtcclxuXHRcdFx0dGhpcy5Ib3VzZUxpc3RbaV0gPSBhYztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgQ29tcGFueUxpc3QgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhTGlzdEJ5SXRlbVR5cGUoSXRlbVR5cGUuQ29tcGFueSk7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IENvbXBhbnlMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkYXRhID0gQ29tcGFueUxpc3RbaV07XHJcblx0XHRcdHZhciBhYyA9IG5ldyBDb21wYW55U3RydWN0KCk7XHJcblx0XHRcdGFjLklkID0gZGF0YS5JZDtcclxuXHRcdFx0YWMuaWNvbiA9IGRhdGEuaWNvbjtcclxuXHRcdFx0YWMubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0YWMuYm9udXNSYXRpbyA9IGRhdGEuYm9udXNSYXRpbztcclxuXHRcdFx0YWMuaXNPd25lZCA9IGZhbHNlO1xyXG5cdFx0XHRhYy5zdG9ja051bSA9IDA7XHJcblx0XHRcdGFjLnN0b2NrQ29zdCA9IDA7XHJcblx0XHRcdGFjLmJhbmtydXB0UHJpY2UgPSBkYXRhLm91dFByaWNlO1xyXG5cdFx0XHRhYy5zdG9ja1ByaWNlID0gZGF0YS5pblByaWNlO1xyXG5cdFx0XHRhYy5MaW1pdFllYXIgPSBkYXRhLkxpbWl0WWVhcjtcclxuXHRcdFx0dGhpcy5Db21wYW55TGlzdFtpXSA9IGFjO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBNYXRlTGlzdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFMaXN0QnlJdGVtVHlwZShJdGVtVHlwZS5NYXRlKTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgTWF0ZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRhdGEgPSBNYXRlTGlzdFtpXTtcclxuXHRcdFx0dmFyIGFjID0gbmV3IE1hdGVTdHJ1Y3QoKTtcclxuXHRcdFx0YWMuSWQgPSBkYXRhLklkO1xyXG5cdFx0XHRhYy5pY29uID0gZGF0YS5pY29uO1xyXG5cdFx0XHRhYy5uYW1lID0gZGF0YS5uYW1lO1xyXG5cdFx0XHRhYy5zZXggPSBkYXRhLnNleDtcclxuXHRcdFx0YWMuTG92ZVBvaW50ID0gMDtcclxuXHRcdFx0YWMuY2FuRGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRhYy51bmxvY2tDb25kID0gZGF0YS51bmxvY2tDb25kO1xyXG5cdFx0XHRpZihkYXRhLnVubG9ja0NvbmQgPT0gTWF0ZVVuTG9ja1R5cGUuTlVMTClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGFjLmNhbkRhdGUgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vLy9jYy5sb2coZGF0YS5uYW1lICsgXCIg5piv5ZCm5Y+v5Lul55u05o6l57qm5LyaIFwiICsgZGF0YS51bmxvY2tDb25kKTtcclxuXHRcdFx0YWMuY3VyTGV2ZWwgPSAwOy8v562J57qnXHJcblx0XHRcdGFjLlVwTHYgPSBmYWxzZTsvL+ayoeaciea7oee6p1xyXG5cdFx0XHR0aGlzLk1hdGVMaXN0W2ldID0gYWM7XHJcblx0XHR9XHJcblx0XHQvL+S/neWtmOS4iyDkuovku7ZJZCDmr4/mrKHliLfkuIDmrKHkuovku7YgIOWwseS8muWJlOmZpOS4gOasoVxyXG5cdFx0dmFyIEV2ZW50TGlzdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFMaXN0QnlJdGVtVHlwZShJdGVtVHlwZS5FdmVudERhdGEpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBFdmVudExpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRhdGEgPSBFdmVudExpc3RbaV07XHJcblx0XHRcdHRoaXMuRXZlbnREYXRhSWRMaXN0W2ldID0gZGF0YS5JZDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL+WIneWniyDlpKnotYvmioDog73ojrflvpfliqDmiJDmlbDmja5cclxuXHRHZXRJbml0U2tpbGxCb251czpmdW5jdGlvbihza2lsbExpc3QpXHJcblx0e1xyXG5cdFx0dGhpcy5UcmVhdEJvbnVzID0gMDsgIC8v5rK755aX6Iqx6LS56ZmN5L2O55m+5YiG54K5XHJcblx0XHR0aGlzLldhcmVIb3VzZUNhcGNpdHlCb251cyA9IDA7ICAvL+S7k+WCqOWKoOaIkFxyXG5cdFx0dGhpcy5DYXNoQm9udXMgPSAwOyAgLy/ph5HpkrHliqDmiJAg5q+P5bm05Yqg5oiQXHJcblx0XHR0aGlzLkNhc2hSYXRpb25Cb251cyA9IDA7XHJcblx0XHR0aGlzLlJlcHV0YXRpb25Cb251cyA9IDA7ICAvL+WQjeWjsOWKoOaIkCDmr4/lubRcclxuXHRcdHRoaXMuSHBQb2ludEJvbnVzID0gMDsgIC8v5YGl5bq35Yqg5oiQXHJcblx0XHR0aGlzLlJldGlyZUJvbnVzID0gMDsgIC8v5aKe5Yqg6YCA5LyR5bm06ZmQXHJcblx0XHR0aGlzLkRhdGVCb251cyA9IDA7ICAvL+WinuWKoOe6puS8muaIkOWKn+amgueOh1xyXG5cdFx0dGhpcy5Jbml0TW9uZXlCb251cyA9IDA7IC8v5aKe5Yqg5Yid5aeL546w6YeRXHJcblx0XHR0aGlzLlN0b2NrQWRkQm9udXMgPSAwOyAgLy/lop7liqDlhazlj7jmlLbnm4pcclxuXHRcdHRoaXMuU3RvY2tVcEJvbnVzID0gMDsgIC8v6IKh56Wo5LiK5raoIOamgueOh+WinuWKoFxyXG5cdFx0dGhpcy5EYXRlTW9uZXlCb251cyA9IDA7ICAvL+e6puS8muiKsei0uemZjeS9jlxyXG5cdFx0dGhpcy5CZXRCb251cyA9IDA7ICAvL+i1jOWNmui1oumSseamgueOh+S4iuWNh1xyXG5cdFx0dGhpcy5Ta2lsbFBvaW50R2V0Qm9udXMgPSAwOyAgLy/nu5PnrpfmioDog73ngrnmj5DljYdcclxuXHRcdHRoaXMuUmVwdXRhdGlvbkluaXRCb251cyA9IDA7ICAvL+WIneWni+WQjeWjsOWKoOaIkFxyXG5cdFx0dGhpcy5DYXJCdXlCb251cyA9IDA7ICAvL+i0reS5sOaxvei9puS7t+agvOmZjeS9jlxyXG5cdFx0dGhpcy5FdmVudENvc3RCb251cyA9IDA7ICAvL+S6i+S7tua2iOiAl+mHkemSsemZjeS9jlxyXG5cdFx0dGhpcy5Ib3VzZUJ1eUJvbnVzZSA9IDA7IC8v6LSt5Lmw5oi/5bGLIOS7t+agvOmZjeS9jlxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2tpbGxMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkYXRhID0gc2tpbGxMaXN0W2ldO1xyXG5cdFx0XHQvL+iOt+W+l+aVsOaNrlxyXG5cdFx0XHR2YXIgYm9udXMgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXRTa2lsbEFkZEJvbnVzQnlUd29JZEFuZEx2KGRhdGEuSWQsIGRhdGEuc3ViSWQsIGRhdGEubGV2ZWwpO1xyXG5cdFx0XHQvLy8vY2MubG9nKGRhdGEuc2tpbGxUeXBlICsgXCIrKysrKysrKysrKyvliJ3lp4vmioDog73liqDmiJArKysrKysrKysrK1wiK2JvbnVzKTtcclxuXHRcdFx0c3dpdGNoIChkYXRhLnNraWxsVHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgU2tpbGxUeXBlLldMTlM6XHJcblx0XHRcdFx0XHR0aGlzLldhcmVIb3VzZUNhcGNpdHlCb251cyA9IGJvbnVzOyAvL+W3sue2k+ioiOeul1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTa2lsbFR5cGUuVEhZOlxyXG5cdFx0XHRcdFx0dGhpcy5EYXRlQm9udXMgPSBib251czsgLy/nmb7liIbmr5QgIOW3sue2k+ioiOeul1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTa2lsbFR5cGUuWFNKWTpcclxuXHRcdFx0XHRcdHRoaXMuQ2FzaFJhdGlvbkJvbnVzID0gYm9udXM7IC8v5bey57uP5Yqg5YWl6K6h566XXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNraWxsVHlwZS5GR1pKOlxyXG5cdFx0XHRcdFx0dGhpcy5Jbml0TW9uZXlCb251cyA9IGJvbnVzOyAvL+W3sue7j+iuoeeul1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTa2lsbFR5cGUuR1NHTDpcclxuXHRcdFx0XHRcdHRoaXMuU3RvY2tBZGRCb251cyA9IGJvbnVzOyAvL+eZvuWIhueZviDlt7Lnu4/orqHnrpdcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU2tpbGxUeXBlLlRQR1M6XHJcblx0XHRcdFx0XHR0aGlzLlN0b2NrVXBCb251cyA9IGJvbnVzOyAvL+eZvuWIhuavlCDlt7Lnu4/orqHnrpdcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU2tpbGxUeXBlLkpaQ0M6XHJcblx0XHRcdFx0XHR0aGlzLlNraWxsUG9pbnRHZXRCb251cyA9IGJvbnVzOyAvL+eZvuWIhuavlCAg5bey57aT6KiI566XXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNraWxsVHlwZS5NTFNaOlxyXG5cdFx0XHRcdFx0dGhpcy5EYXRlTW9uZXlCb251cyA9IGJvbnVzOyAvL+eZvuWIhuavlCDkuIDorqHnrpdcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU2tpbGxUeXBlLkRTOlxyXG5cdFx0XHRcdFx0dGhpcy5CZXRCb251cyA9IGJvbnVzOyAvL+eZvuWIhuavlCDlt7LntpPoqIjnrpdcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU2tpbGxUeXBlLkxEWVo6XHJcblx0XHRcdFx0XHR0aGlzLlJldGlyZUJvbnVzID0gYm9udXM7IC8v5bey57aT566X6YCy5Y67XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNraWxsVHlwZS5OU0NNOlxyXG5cdFx0XHRcdFx0dGhpcy5SZXB1dGF0aW9uSW5pdEJvbnVzID0gYm9udXM7IC8v5bey57aT6KiI566XXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNraWxsVHlwZS5RQ0RSOlxyXG5cdFx0XHRcdFx0dGhpcy5DYXJCdXlCb251cyA9IGJvbnVzOyAvL+eZvuWIhuavlCDkuIDoqIjnrpdcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU2tpbGxUeXBlLkhZTEw6XHJcblx0XHRcdFx0XHR0aGlzLkV2ZW50Q29zdEJvbnVzID0gYm9udXM7IC8v55m+5YiG5q+UIOS4gOiuoeeul1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTa2lsbFR5cGUuRENaSjpcclxuXHRcdFx0XHRcdHRoaXMuSG91c2VCdXlCb251c2UgPSBib251czsgIC8v55m+5YiG5q+UIOS4gOioiOeul1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL+iOt+WPluavj+W5tOmDveS8muiOt+W+l+eahOWKoOaIkOaVsOminVxyXG5cdEdldEJvbnVzUmV3YXJkRXZlcnlZZWFyOmZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIOWMheaLrCDph5HpkrEg5ZCN5aOwIOWBpeW6t+WAvFxyXG5cdFx0dGhpcy5DYXNoICs9IHRoaXMuQ2FzaEJvbnVzO1xyXG5cdFx0dGhpcy5DYXNoID0gTWF0aC5mbG9vcih0aGlzLkNhc2ggKiAoMSt0aGlzLkNhc2hSYXRpb25Cb251cykpO1xyXG5cdFx0aWYodGhpcy5DYXNoIDwgMTAwKVxyXG5cdFx0XHR0aGlzLkNhc2ggPSAwO1xyXG5cdFx0dGhpcy5SZXB1dGF0aW9uICs9IHRoaXMuUmVwdXRhdGlvbkJvbnVzO1xyXG5cdFx0aWYodGhpcy5SZXB1dGF0aW9uIDwgMClcclxuXHRcdFx0dGhpcy5SZXB1dGF0aW9uID0gMDtcclxuXHRcdHRoaXMuSHBQb2ludCArPSB0aGlzLkhwUG9pbnRCb251cztcclxuXHRcdGlmKHRoaXMuSHBQb2ludCA+IDEwMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5IcFBvaW50ID0gMTAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuV2FyZUhvdXNlQ2FwY2l0eSArPSB0aGlzLldhcmVIb3VzZUJvbnVzRXZlcnlZZWFyO1xyXG5cdFx0dGhpcy5XYXJlSG91c2VBbGxDYXBjaXR5ICs9IHRoaXMuV2FyZUhvdXNlQm9udXNFdmVyeVllYXI7XHJcblx0XHRpZih0aGlzLldhcmVIb3VzZUNhcGNpdHkgPiAyMDApXHJcblx0XHRcdHRoaXMuV2FyZUhvdXNlQ2FwY2l0eSA9IDIwMDtcclxuXHRcdGlmKHRoaXMuV2FyZUhvdXNlQWxsQ2FwY2l0eSA+IDIwMClcclxuXHRcdFx0dGhpcy5XYXJlSG91c2VBbGxDYXBjaXR5ID0gMjAwO1xyXG5cdH0sXHJcblxyXG5cdC8v6I635Y+W5LiA5qyh5LqL5Lu2aWQgIOW5tuS7juaVsOWIl+S4reWJlOmZpOi/meS4qiBJZFxyXG5cdEdldEV2ZW50RGF0YUFuZFNwbGljZUlkOmZ1bmN0aW9uKCl7XHJcblx0XHR2YXIgbGVuID0gdGhpcy5FdmVudERhdGFJZExpc3QubGVuZ3RoO1xyXG5cdFx0Ly9jYy5sb2coXCIxMSDkuovku7bmlbDmja7liankvZnkuKrmlbAgPSBcIiArIGxlbik7XHJcblx0XHR2YXIgc2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbik7XHJcblx0XHR2YXIgb3V0ID0gdGhpcy5FdmVudERhdGFJZExpc3Rbc2VlZF07XHJcblx0XHR0aGlzLkV2ZW50RGF0YUlkTGlzdC5zcGxpY2Uoc2VlZCwgMSk7XHJcblx0XHQvL2NjLmxvZyhvdXQgKyBcIiAg5LqL5Lu25pWw5o2u5Ymp5L2Z5Liq5pWwID0gXCIgKyB0aGlzLkV2ZW50RGF0YUlkTGlzdC5sZW5ndGgpO1xyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9LFxyXG5cclxuXHRSZWZyZXNoSGlzdG9yeUhpZ2hBc3NldDpmdW5jdGlvbihhc3NldCl7XHJcblx0XHR0aGlzLkhpc3RvcnlIaWdoQXNzZXRzID0gYXNzZXQ7XHJcblx0fSxcclxuXHJcblx0Ly/kv53lrZjmnKzlnLDmlbDmja5cclxuXHRTYXZlVXNlckRhdGE6ZnVuY3Rpb24oKXtcclxuXHRcdHZhciB1c2VyZGF0YSA9IHt9O1xyXG5cdFx0dXNlcmRhdGEucGxheWVyTmFtZSA9IHRoaXMucGxheWVyTmFtZTtcclxuXHRcdHVzZXJkYXRhLlNleCA9IHRoaXMuU2V4O1xyXG5cdFx0dXNlcmRhdGEuU2tpbGxMaXN0ID0gdGhpcy5Ta2lsbExpc3Q7XHJcblx0XHQvL+W8leWvvOatpemqpFxyXG5cdFx0dXNlcmRhdGEudHV0b3JpYWxJbk1hcmtldCA9IHRoaXMudHV0b3JpYWxJbk1hcmtldDtcclxuXHRcdHVzZXJkYXRhLnR1dG9yaWFsSW5EYXRlID0gdGhpcy50dXRvcmlhbEluRGF0ZTtcclxuXHRcdHVzZXJkYXRhLnR1dG9yaWFsSW5CdXMgPSB0aGlzLnR1dG9yaWFsSW5CdXM7XHJcblx0XHR1c2VyZGF0YS50dXRvcmlhbFN0b2NrQm9udXMgPSB0aGlzLnR1dG9yaWFsU3RvY2tCb251cztcclxuXHRcdHVzZXJkYXRhLnR1dG9yaWFsTWF0ZVBvaW50ID0gdGhpcy50dXRvcmlhbE1hdGVQb2ludDtcclxuXHJcblx0XHR1c2VyZGF0YS5IaXN0b3J5SGlnaEFzc2V0cyA9IHRoaXMuSGlzdG9yeUhpZ2hBc3NldHM7XHJcblxyXG5cdFx0dXNlcmRhdGEuVmlkZW9BZHNUaW1lcyA9IHRoaXMuVmlkZW9BZHNUaW1lcztcclxuXHRcdHVzZXJkYXRhLlZpZGVvTGFzdFRpbWUgPSB0aGlzLlZpZGVvTGFzdFRpbWU7XHJcblxyXG5cdFx0dXNlcmRhdGEucGxheVRpbWVzID0gdGhpcy5wbGF5VGltZXM7XHJcblx0XHR1c2VyZGF0YS5BY2hpZXZlbWVudExpc3QgPSB0aGlzLkFjaGlldmVtZW50TGlzdDtcclxuXHRcdHVzZXJkYXRhLlJlY29yZExpc3QgPSB0aGlzLlJlY29yZExpc3Q7XHJcblx0XHR1c2VyZGF0YS5Ta2lsbEJvbnVzUG9pbnQgPSB0aGlzLlNraWxsQm9udXNQb2ludDtcclxuXHRcdGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnWE1CX3VzZXJkYXRhXycgKyB0aGlzLnVzZXJJZCxKU09OLnN0cmluZ2lmeSh1c2VyZGF0YSkpO1xyXG5cdH0sXHJcblxyXG5cdENyZWF0ZVJlY29yZDpmdW5jdGlvbigpe1xyXG5cdFx0dmFyIHJlRCA9IG5ldyBSZWNvcmRTdHJ1Y3QoKTtcclxuXHRcdFxyXG5cdFx0dmFyIGFzTHYgPSAwO1xyXG5cdFx0dmFyIHRkID0gTWF0aC5mbG9vcih0aGlzLkFzc2V0c01vbmV5IC8gMTAwMDAwMCk7XHJcblx0XHRpZih0ZCA+IDAgJiYgdGQgPCAxMClcclxuXHRcdHtcclxuXHRcdFx0YXNMdiA9IDE7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKHRkID4gMTAgJiYgdGQgPCAxMDApXHJcblx0XHR7XHJcblx0XHRcdGFzTHYgPSAyO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZih0ZCA+IDEwMClcclxuXHRcdHtcclxuXHRcdFx0YXNMdiA9IDM7XHJcblx0XHR9XHJcblx0XHRyZUQucmV0aXJlQWdlID0gdGhpcy5BZ2U7XHJcblx0XHRyZUQubGV2ZWwgPSBhc0x2O1xyXG5cdFx0cmVELmFzc2V0cyA9IHRoaXMuQXNzZXRzTW9uZXk7XHJcblx0XHRyZUQuaGlnaEFzc2V0cyA9IHRoaXMuSGlnaEFzc2V0cztcclxuXHRcdFxyXG5cdFx0dGhpcy5SZWNvcmRMaXN0LnB1c2gocmVEKTtcclxuXHRcdC8vdGhpcy5TYXZlVXNlckRhdGEoKTtcclxuXHR9LFxyXG5cclxuXHQvL+WNh+e6p+aKgOiDveeCuVxyXG5cdFVwR3JhZGVTa2lsbDpmdW5jdGlvbihJZCwgc3ViSWQsIHRvTHYpe1xyXG5cdFx0dmFyIGlzT2sgPSBmYWxzZTtcclxuXHRcdHZhciBOZWVkQ29zdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldFVwZ3JhZGVDb3N0QnlUd29JZChJZCwgc3ViSWQsIHRvTHYpO1xyXG4gICAgICAgIGlmKHRoaXMuU2tpbGxCb251c1BvaW50IDwgTmVlZENvc3QpXHJcbiAgICAgICAgXHRyZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8v5LiN6KaB5rGC5Y2H57qn5ruh5oqA6IO95Y2z5Y+v5Y2H57qn5LiL5LiA5Liq5oqA6IO9XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuU2tpbGxMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHRoaXMuU2tpbGxMaXN0W2ldLklkID09IElkICYmIHRoaXMuU2tpbGxMaXN0W2ldLnN1YklkICsgMSA9PSBzdWJJZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKHRoaXMuU2tpbGxMaXN0W2ldLmxldmVsID09IDApXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Ly9jYy5sb2coXCLkuIrkuIDkuKrmioDog73ov5jmsqHmnInljYfnuqfliLDmu6HnuqdcIik7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vaWYodGhpcy5Ta2lsbExpc3RbaV0ubGV2ZWwgIT0gdGhpcy5Ta2lsbExpc3RbaV0uVXBsdilcclxuXHRcdFx0XHQvL3tcclxuXHRcdFx0XHRcdC8vY2MubG9nKFwi5LiK5LiA5Liq5oqA6IO96L+Y5rKh5pyJ5Y2H57qn5Yiw5ruh57qnXCIpO1xyXG5cdFx0XHRcdC8vXHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0Ly99XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5Ta2lsbExpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYodGhpcy5Ta2lsbExpc3RbaV0uSWQgPT1JZCAmJiB0aGlzLlNraWxsTGlzdFtpXS5zdWJJZCA9PSBzdWJJZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKHRoaXMuU2tpbGxMaXN0W2ldLmxldmVsIDwgdGhpcy5Ta2lsbExpc3RbaV0uVXBsdilcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR0aGlzLlNraWxsTGlzdFtpXS5sZXZlbCsrO1xyXG5cdFx0XHRcdFx0dGhpcy5Ta2lsbEJvbnVzUG9pbnQgLT0gTmVlZENvc3Q7XHJcblx0XHRcdFx0XHRpc09rID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGlzT2sgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cdFxyXG5cdFx0cmV0dXJuIGlzT2s7XHJcblx0fSxcclxuXHJcblx0Q2FuU2hvd1VwVGlwOmZ1bmN0aW9uKElkLCBzdWJJZCwgdG9Mdil7XHJcblx0XHR2YXIgaXNPayA9IGZhbHNlO1xyXG5cdFx0dmFyIE5lZWRDb3N0ID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0VXBncmFkZUNvc3RCeVR3b0lkKElkLCBzdWJJZCwgdG9Mdik7XHJcbiAgICAgICAgaWYodGhpcy5Ta2lsbEJvbnVzUG9pbnQgPCBOZWVkQ29zdClcclxuICAgICAgICBcdHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuU2tpbGxMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHRoaXMuU2tpbGxMaXN0W2ldLklkID09IElkICYmIHRoaXMuU2tpbGxMaXN0W2ldLnN1YklkICsgMSA9PSBzdWJJZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKHRoaXMuU2tpbGxMaXN0W2ldLmxldmVsID09IDApXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Ly9jYy5sb2coXCLkuIrkuIDkuKrmioDog73ov5jmsqHmnInljYfnuqfliLDmu6HnuqdcIik7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vaWYodGhpcy5Ta2lsbExpc3RbaV0ubGV2ZWwgIT0gdGhpcy5Ta2lsbExpc3RbaV0uVXBsdilcclxuXHRcdFx0XHQvL3tcclxuXHRcdFx0XHRcdC8vY2MubG9nKFwi5LiK5LiA5Liq5oqA6IO96L+Y5rKh5pyJ5Y2H57qn5Yiw5ruh57qnXCIpO1xyXG5cdFx0XHRcdC8vXHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0Ly99XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5Ta2lsbExpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYodGhpcy5Ta2lsbExpc3RbaV0uSWQgPT1JZCAmJiB0aGlzLlNraWxsTGlzdFtpXS5zdWJJZCA9PSBzdWJJZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKHRoaXMuU2tpbGxMaXN0W2ldLmxldmVsIDwgdGhpcy5Ta2lsbExpc3RbaV0uVXBsdilcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpc09rID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGlzT2sgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cdFxyXG5cdFx0cmV0dXJuIGlzT2s7XHJcblx0fSxcclxuXHJcblx0Ly/lrozmiJDmjIflrprmiJDlsLFcclxuXHRGaW5pc2hBY2hpZXZlbWVudDpmdW5jdGlvbihJZCl7XHJcblx0XHR2YXIgaXNPayA9IGZhbHNlO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkFjaGlldmVtZW50TGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZih0aGlzLkFjaGlldmVtZW50TGlzdFtpXS5JZCA9PSBJZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuQWNoaWV2ZW1lbnRMaXN0W2ldLmhhc0ZpbmlzaCA9IHRydWU7XHJcblx0XHRcdFx0aXNPayA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBpc09rO1xyXG5cdH0sXHJcblx0Ly/kubDlhaXnianlk4FcclxuXHRCdXlHb29kczpmdW5jdGlvbihkYXRhKXsgLy9kYXRhIOWMheWQqyBJZCBidXlwcmlyZSBidXludW1cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkdvb2RzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZihkYXRhLklkID09IHRoaXMuR29vZHNMaXN0W2ldLklkKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuR29vZHNMaXN0W2ldLlJlZmVzaERhdGFBZnRlckJ1eShkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblx0Ly/lh7rllK7nianlk4FcclxuXHRTYWxlR29vZHM6ZnVuY3Rpb24oZGF0YSl7XHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5Hb29kc0xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYoZGF0YS5JZCA9PSB0aGlzLkdvb2RzTGlzdFtpXS5JZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLkdvb2RzTGlzdFtpXS5SZWZlc2hEYXRhQWZ0ZXJTYWxlKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly/liJvlip7lhazlj7hcclxuXHRDcmVhdGVDb21wYW55OmZ1bmN0aW9uKGRhdGEpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuQ29tcGFueUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYoZGF0YS5JZCA9PSB0aGlzLkNvbXBhbnlMaXN0W2ldLklkKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuQ29tcGFueUxpc3RbaV0uUmVmcmVzaERhdGFBZnRlck9wZXIoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL+afpeeci+S4gOS4i+aYr+WQpuW3sue7j+aLpeacieS6lOeorueJqeWTgVxyXG5cdENoZWNrT3duZWRHb29kc051bTpmdW5jdGlvbigpe1xyXG5cdFx0dmFyIE51bSA9IDA7XHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5Hb29kc0xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYodGhpcy5Hb29kc0xpc3RbaV0ub3duTnVtID4gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdE51bSArPSAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR2YXIgSXNmdWxsID0gZmFsc2U7XHJcblx0XHRpZihOdW0gPT0gNSlcclxuXHRcdHtcclxuXHRcdFx0SXNmdWxsID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBJc2Z1bGw7XHJcblx0fSxcclxuXHJcblx0Ly/otK3kubDogqHnpahcclxuXHRCdXlTdG9ja3M6ZnVuY3Rpb24oZGF0YSl7XHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5Db21wYW55TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZihkYXRhLklkID09IHRoaXMuQ29tcGFueUxpc3RbaV0uSWQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5Db21wYW55TGlzdFtpXS5SZWZyZXNoRGF0YUFmdGVyT3BlcihkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8v5Ye65ZSu6IKh56WoXHJcblx0U2FsZVN0b2NrczpmdW5jdGlvbihkYXRhKXtcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkNvbXBhbnlMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmKGRhdGEuSWQgPT0gdGhpcy5Db21wYW55TGlzdFtpXS5JZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLkNvbXBhbnlMaXN0W2ldLlJlZnJlc2hEYXRhQWZ0ZXJTYWxlKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0QnV5U2FsZUNvbW1vbkl0ZW06ZnVuY3Rpb24oZGF0YSl7XHJcblx0XHQvL2NjLmxvZyhcIj09PT09PT09PT09PT1cIiArIGRhdGEuVHlwZSArIFwiICBJZCA9IFwiKyBkYXRhLklkKVxyXG5cdFx0aWYoZGF0YS5UeXBlID09IEl0ZW1UeXBlLkNhcilcclxuXHRcdHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuQ2FyTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdGlmKHRoaXMuQ2FyTGlzdFtpXS5JZCA9PSBkYXRhLklkKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRoaXMuQ2FyTGlzdFtpXS5SZWZyZXNoRGF0YShkYXRhLmFkZE51bSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKGRhdGEuVHlwZSA9PSBJdGVtVHlwZS5Ib3VzZSlcclxuXHRcdHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuSG91c2VMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0aWYodGhpcy5Ib3VzZUxpc3RbaV0uSWQgPT0gZGF0YS5JZClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR0aGlzLkhvdXNlTGlzdFtpXS5SZWZyZXNoRGF0YShkYXRhLmFkZE51bSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly/liLfmlrDnuqbkvJrnmoTkurLlr4bluqZcclxuXHRSZWZyZXNoTWF0ZURhdGE6ZnVuY3Rpb24oSWQpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuTWF0ZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYoSWQgPT0gdGhpcy5NYXRlTGlzdFtpXS5JZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLk1hdGVMaXN0W2ldLlJlZnJlc2hBZnRlckx2VXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8v5qC55pOaaWTop6PpmaTlqZrlp7tcclxuXHREaXN2b3JjZU1hdGVCeUlkOmZ1bmN0aW9uKElkKXtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5NYXRlTGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZih0aGlzLk1hdGVMaXN0W2ldLklkID09IElkKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5NYXRlTGlzdFtpXS5SZXR1cm5Jbml0U3RhdGUoKTtcclxuXHRcdFx0XHR2YXIgZGF0YSA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuTWF0ZSwgSWQpO1xyXG5cdFx0XHRcdHRoaXMuRGVsZXRlTWF0ZUJvbnVzUmV3YXJkKGRhdGEuYm9udXNMaXN0KTtcclxuXHRcdFx0XHQvL+eOsOmHkSDogqHnpajlh4/lsJEg5ZCN5aOwIOWBpeW6t+WPl+aNn1xyXG5cdFx0XHRcdHRoaXMuQ2FzaCA9IE1hdGguZmxvb3IodGhpcy5DYXNoICogMC44KTtcclxuXHRcdFx0XHR0aGlzLkhwUG9pbnQgPSBNYXRoLmZsb29yKHRoaXMuSHBQb2ludCAqIDAuOCk7XHJcblx0XHRcdFx0dGhpcy5SZXB1dGF0aW9uID0gTWF0aC5mbG9vcih0aGlzLlJlcHV0YXRpb24gKiAwLjgpO1xyXG5cdFx0XHRcdHRoaXMuRGlzdm9yY2VEZWxTdG9ja3MoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdERpc3ZvcmNlRGVsU3RvY2tzOmZ1bmN0aW9uKCl7XHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5Db21wYW55TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZih0aGlzLkNvbXBhbnlMaXN0W2ldLnN0b2NrTnVtID4gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuQ29tcGFueUxpc3RbaV0uUmVmcmVzaERhdGFBZnRlckRpc3ZvcmNlKCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly/ojrflvpfkvLTkvqPliqDmiJAg57uT5ama5ZCO6I635b6XXHJcblx0Z2V0TWF0ZUJvbnVzUmV3YXJkOmZ1bmN0aW9uKGRhdGEpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkdCA9IGRhdGFbaV07XHJcblx0XHRcdC8vY2MubG9nKFwiKysrKysrKysrKysrKysrKysrKysrb29vb29vKysrKysrKysrKysrKysrKysrKysrKytcIiArIGR0LmJvbnVzTnVtKTtcclxuXHRcdFx0aWYoZHQuYm9udXNUeXBlID09IE1hdGVCb251c1R5cGUuTlVMTClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdC8vY2MubG9nKFwi5Ly05L6j5Yqg5oiQ5LuA5LmI5Lmf5rKh5pyJXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoZHQuYm9udXNUeXBlID09IE1hdGVCb251c1R5cGUuSFApXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLkhwUG9pbnRCb251cyArPSBkdC5ib251c051bTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKGR0LmJvbnVzVHlwZSA9PSBNYXRlQm9udXNUeXBlLk1vbmV5KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5DYXNoQm9udXMgKz0gZHQuYm9udXNOdW07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZihkdC5ib251c1R5cGUgPT0gTWF0ZUJvbnVzVHlwZS5SZXB1dGF0aW9uKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5SZXB1dGF0aW9uQm9udXMgKz0gZHQuYm9udXNOdW07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZihkdC5ib251c1R5cGUgPT0gTWF0ZUJvbnVzVHlwZS5XYXJlSG91c2VDYXBjaXR5KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5XYXJlSG91c2VDYXBjaXR5ICs9IGR0LmJvbnVzTnVtO1xyXG5cdFx0XHRcdHRoaXMuV2FyZUhvdXNlQWxsQ2FwY2l0eSArPSBkdC5ib251c051bTtcclxuXHRcdFx0XHR0aGlzLldhcmVIb3VzZUJvbnVzRXZlcnlZZWFyICs9IGR0LmJvbnVzTnVtO1xyXG5cclxuXHRcdFx0XHRpZih0aGlzLldhcmVIb3VzZUFsbENhcGNpdHkgPiAyMDApXHJcblx0XHRcdFx0XHR0aGlzLldhcmVIb3VzZUFsbENhcGNpdHkgPSAyMDA7XHJcblx0XHRcdFx0aWYodGhpcy5XYXJlSG91c2VDYXBjaXR5ID4gMjAwKVxyXG5cdFx0XHRcdFx0dGhpcy5XYXJlSG91c2VDYXBjaXR5ID0gMjAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoZHQuYm9udXNUeXBlID09IE1hdGVCb251c1R5cGUuVHJlYXQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLlRyZWF0Qm9udXMgKz0gZHQuYm9udXNOdW07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL+enu+mZpOS8tOS+o+iOt+W+l+eahOWkqei1i+WKoOaIkFxyXG5cdERlbGV0ZU1hdGVCb251c1Jld2FyZDpmdW5jdGlvbihkYXRhKVxyXG5cdHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZHQgPSBkYXRhW2ldO1xyXG5cdFx0XHQvL2NjLmxvZyhcIisrKysrKysrKysrKysrKysrKysrK29vb29vbysrKysrKysrKysrKysrKysrKysrKysrXCIgKyBkdC5ib251c051bSk7XHJcblx0XHRcdGlmKGR0LmJvbnVzVHlwZSA9PSBNYXRlQm9udXNUeXBlLk5VTEwpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL2NjLmxvZyhcIuS8tOS+o+WKoOaIkOS7gOS5iOS5n+ayoeaciVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKGR0LmJvbnVzVHlwZSA9PSBNYXRlQm9udXNUeXBlLkhQKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5IcFBvaW50Qm9udXMgLT0gZHQuYm9udXNOdW07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZihkdC5ib251c1R5cGUgPT0gTWF0ZUJvbnVzVHlwZS5Nb25leSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuQ2FzaEJvbnVzIC09IGR0LmJvbnVzTnVtO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoZHQuYm9udXNUeXBlID09IE1hdGVCb251c1R5cGUuUmVwdXRhdGlvbilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuUmVwdXRhdGlvbkJvbnVzIC09IGR0LmJvbnVzTnVtO1xyXG5cdFx0XHRcdGlmKHRoaXMuUmVwdXRhdGlvbkJvbnVzIDwgMClcclxuXHRcdFx0XHRcdHRoaXMuUmVwdXRhdGlvbkJvbnVzID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKGR0LmJvbnVzVHlwZSA9PSBNYXRlQm9udXNUeXBlLldhcmVIb3VzZUNhcGNpdHkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL3RoaXMuV2FyZUhvdXNlQ2FwY2l0eSAtPSBkdC5ib251c051bTtcclxuXHRcdFx0XHQvL3RoaXMuV2FyZUhvdXNlQWxsQ2FwY2l0eSAtPSBkdC5ib251c051bTtcclxuXHRcdFx0XHR0aGlzLldhcmVIb3VzZUJvbnVzRXZlcnlZZWFyIC09IGR0LmJvbnVzTnVtO1xyXG5cdFx0XHRcdGlmKHRoaXMuV2FyZUhvdXNlQm9udXNFdmVyeVllYXIgPCAwKVxyXG5cdFx0XHRcdFx0dGhpcy5XYXJlSG91c2VCb251c0V2ZXJ5WWVhciA9IDA7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZihkdC5ib251c1R5cGUgPT0gTWF0ZUJvbnVzVHlwZS5UcmVhdClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuVHJlYXRCb251cyAtPSBkdC5ib251c051bTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldE93bkRhdGFMaXN0QnlUeXBlOmZ1bmN0aW9uKGl0ZW1UeXBlKXtcclxuXHRcdHZhciBkYXRhTGlzdCA9IG51bGw7XHJcblx0XHRzd2l0Y2ggKGl0ZW1UeXBlKSB7XHJcblx0XHRcdGNhc2UgSXRlbVR5cGUuR29vZHM6XHJcblx0XHRcdFx0ZGF0YUxpc3QgPSB0aGlzLkdvb2RzTGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJdGVtVHlwZS5Ta2lsbDpcclxuXHRcdFx0XHRkYXRhTGlzdCA9IHRoaXMuU2tpbGxMaXN0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIEl0ZW1UeXBlLkNhcjpcclxuXHRcdFx0XHRkYXRhTGlzdCA9IHRoaXMuQ2FyTGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJdGVtVHlwZS5Ib3VzZTpcclxuXHRcdFx0XHRkYXRhTGlzdCA9IHRoaXMuSG91c2VMaXN0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIEl0ZW1UeXBlLkFjaGlldmU6XHJcblx0XHRcdFx0ZGF0YUxpc3QgPSB0aGlzLkFjaGlldmVtZW50TGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJdGVtVHlwZS5Db21wYW55OlxyXG5cdFx0XHRcdGRhdGFMaXN0ID0gdGhpcy5Db21wYW55TGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJdGVtVHlwZS5NYXRlOlxyXG5cdFx0XHRcdGRhdGFMaXN0ID0gdGhpcy5NYXRlTGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdHJldHVybiBkYXRhTGlzdDtcclxuXHR9LFxyXG5cclxuXHQvL+iOt+WPluW3suacieaVsOaNriDmoLnmja4g57G75Z6L5ZKMSWRcclxuXHRnZXREYXRhQnlJdGVtVHlwZUFuZElkOmZ1bmN0aW9uKGl0ZW1UeXBlLCBJZCl7XHJcblx0XHR2YXIgZGF0YUxpc3QgPSBudWxsO1xyXG5cdFx0c3dpdGNoIChpdGVtVHlwZSkge1xyXG5cdFx0XHRjYXNlIEl0ZW1UeXBlLkdvb2RzOlxyXG5cdFx0XHRcdGRhdGFMaXN0ID0gdGhpcy5Hb29kc0xpc3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgSXRlbVR5cGUuU2tpbGw6XHJcblx0XHRcdFx0ZGF0YUxpc3QgPSB0aGlzLlNraWxsTGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJdGVtVHlwZS5DYXI6XHJcblx0XHRcdFx0ZGF0YUxpc3QgPSB0aGlzLkNhckxpc3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgSXRlbVR5cGUuSG91c2U6XHJcblx0XHRcdFx0ZGF0YUxpc3QgPSB0aGlzLkhvdXNlTGlzdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJdGVtVHlwZS5BY2hpZXZlOlxyXG5cdFx0XHRcdGRhdGFMaXN0ID0gdGhpcy5BY2hpZXZlbWVudExpc3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgSXRlbVR5cGUuQ29tcGFueTpcclxuXHRcdFx0XHRkYXRhTGlzdCA9IHRoaXMuQ29tcGFueUxpc3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgSXRlbVR5cGUuTWF0ZTpcclxuXHRcdFx0XHRkYXRhTGlzdCA9IHRoaXMuTWF0ZUxpc3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHRpZihkYXRhTGlzdCAhPSBudWxsKVxyXG5cdFx0e1xyXG5cdFx0XHRmb3IgKHZhciBpID0gZGF0YUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZihJZCA9PSBkYXRhTGlzdFtpXS5JZClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRyZXR1cm4gZGF0YUxpc3RbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL+WmguaenOayoeacieaVsOaNriDkuLogbnVsbFxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHQvL+WIt+aWsOeJqeWTgeW4guWcuuS7t+agvFxyXG5cdFJlZnJlc2hHb29kc01hcktldFByaWNlOmZ1bmN0aW9uKElkLG1hcmtldFByaWNlKXtcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkdvb2RzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZihJZCA9PSB0aGlzLkdvb2RzTGlzdFtpXS5JZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuR29vZHNMaXN0W2ldLm1hcmtldFByaWNlID0gbWFya2V0UHJpY2U7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL+WIt+aWsOiCoeelqOWVhuWcuuS7t+agvOWSjOaIkOacrFxyXG5cdFJlZnJlc2hTdG9ja0RhdGE6ZnVuY3Rpb24oSWQsIHBhcmFtKXtcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkNvbXBhbnlMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmKElkID09IHRoaXMuQ29tcGFueUxpc3RbaV0uSWQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLkNvbXBhbnlMaXN0W2ldLnN0b2NrUHJpY2UgPSBwYXJhbS5zdG9ja1ByaWNlO1xyXG5cdFx0XHRcdHRoaXMuQ29tcGFueUxpc3RbaV0uc3RvY2tDb3N0ID0gcGFyYW0uc3RvY2tDb3N0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly/ojrflj5bmi6XmnInnmoTnianlk4Hlr7nlupTmlbDmja5cclxuXHRnZXRHb29kc0RhdGFCeUlkOmZ1bmN0aW9uKElkKXtcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkdvb2RzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZihJZCA9PSB0aGlzLkdvb2RzTGlzdFtpXS5JZClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLkdvb2RzTGlzdFtpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8v5Yi35paw5Liq5Lq66LWE5LqnICAvL2NhY3VsYXRlU3RvY2sg5piv5ZCm6KiI566X6IKh56Wo5pS255uKXHJcblx0UmVmcmVzaFVzZXJBc3NldHM6ZnVuY3Rpb24oY2FjdWxhdGVTdG9jayl7XHJcblx0XHR2YXIgbGFzdEFzc2V0ID0gdGhpcy5Bc3NldHNNb25leTtcclxuXHRcdHZhciBhc3NldHMgPSAwO1xyXG5cdFx0Ly/orqHnrpfmiYDmi6XmnInnianlk4HmgLvku7dcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkdvb2RzTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuR29vZHNMaXN0W2ldO1xyXG5cdFx0XHR2YXIgZmxhZyA9IHRoaXMuQ2hlY2tJZElzSW5TaG93TGlzdChkYXRhLklkKTtcclxuXHRcdFx0aWYoZmxhZyA9PSB0cnVlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0YXNzZXRzICs9IGRhdGEub3duTnVtICogZGF0YS5tYXJrZXRQcmljZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRhc3NldHMgKz0gZGF0YS5vd25OdW0gKiBkYXRhLmJ1eVByaWNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL+iuoeeul+aIv+Wxi+aLpeaciVxyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuSG91c2VMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBkdCA9IHRoaXMuSG91c2VMaXN0W2ldO1xyXG5cdFx0XHRpZihkdC5vd25OdW0gPiAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly8vL2NjLmxvZyhkdC5JZCArIFwiIOaIv+WtkOeahOaVsOmHj+WSjOS7t+agvCBcIiArIGR0Lm93bk51bSArIFwiIFwiICsgZHQucHJpY2UpO1xyXG5cdFx0XHRcdGFzc2V0cyArPSBkdC5vd25OdW0gKiBkdC5wcmljZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly/orqHnrpfovablrZDmiYDmnIlcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLkNhckxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0dmFyIGR0ID0gdGhpcy5DYXJMaXN0W2ldO1xyXG5cdFx0XHRpZihkdC5vd25OdW0gPiAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0YXNzZXRzICs9IGR0Lm93bk51bSAqIGR0LnByaWNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly/lkI7pnaLlho3liqDkuIog6IKh56Wo5pS255uKXHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5Db21wYW55TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR2YXIgZGEgPSB0aGlzLkNvbXBhbnlMaXN0W2ldO1xyXG5cdFx0XHRpZihkYS5zdG9ja051bSA+IDApXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL3RoaXMuUmVwdXRhdGlvbiArPSBjYy5NZ3IuZ2xvYmFsLkhhc0NvbXBhbnlSZXB1dGF0aW9uQWRkO1xyXG5cdFx0XHRcdGFzc2V0cyArPSBNYXRoLmZsb29yKGRhLnN0b2NrTnVtICogZGEuc3RvY2tQcmljZSk7XHJcblx0XHRcdFx0aWYodGhpcy5DYW5HZXRTdG9ja1Byb2ZpdCA9PSB0cnVlICYmIGNhY3VsYXRlU3RvY2sgPT0gdHJ1ZSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR0aGlzLkNhc2ggKz0gTWF0aC5mbG9vcihkYS5zdG9ja051bSAqIGRhLnN0b2NrUHJpY2UgKiAoZGEuYm9udXNSYXRpbyArICh0aGlzLlN0b2NrQWRkQm9udXMgLyAxMDApKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YXNzZXRzICs9IHRoaXMuQ2FzaDtcclxuXHRcdC8v6LWE5Lqn5pq05rao5pe25YCZ5YGl5bq36L+F6YCf5LiL6ZmNIOaatOa2qDXlgI3kuIvpmY0zMFxyXG5cdFx0dGhpcy5Bc3NldHNNb25leSA9IGFzc2V0cztcclxuXHJcblx0XHR0aGlzLkp1ZGVGaW5pc2hBbnlBY2hpZXZlbWVudCg1KTsgLy/miJDlsLEgSWQgPSA1IOi1hOS6p+ebuOWFs1xyXG5cdFx0dGhpcy5KdWRlRmluaXNoQW55QWNoaWV2ZW1lbnQoNCk7IC8v5oiQ5bCxIElkID0gNiAgXHJcblxyXG5cdFx0Y2MubG9nKGxhc3RBc3NldCArIFwiIEwgPT09PT09PT095LuW5aaI55qE6LWE5Lqn6Zeu6aKYPT09PT09PT0gTiBcIiArIGFzc2V0cyk7XHJcblx0XHRpZihhc3NldHMgPiB0aGlzLkhpZ2hBc3NldHMpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuSGlnaEFzc2V0cyA9IGFzc2V0cztcclxuXHRcdH1cclxuXHJcblx0XHRpZihhc3NldHMgPiAxMDAwMDAwICYmIHRoaXMuTWlsbGlvbkFnZSA9PSAwKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLk1pbGxpb25BZ2UgPSB0aGlzLkFnZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihhc3NldHMgPiAxMDAwMDAwMCAmJiB0aGlzLlRlbk1pbGxpb25BZ2UgPT0gMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5UZW5NaWxsaW9uQWdlID0gdGhpcy5BZ2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoYXNzZXRzID4gMTAwMDAwMDAwICYmIHRoaXMuSHVuZHJlZE1pbGxpb25BZ2UgPT0gMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5IdW5kcmVkTWlsbGlvbkFnZSA9IHRoaXMuQWdlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKE1hdGguZmxvb3IoYXNzZXRzIC8gbGFzdEFzc2V0KSA+PSBjYy5NZ3IuZ2xvYmFsLkFzc2V0RXhwbG9yUmF0ZSB8fCAoYXNzZXRzIC8gbGFzdEFzc2V0KSA8PSBjYy5NZ3IuZ2xvYmFsLkFzc2V0RXhwbG9yRG93blJhdGUpXHJcblx0XHR7XHJcblx0XHRcdGlmKHRoaXMudXNlclN0YXRlID09IFVzZXJTdGF0ZS5Ob3RPSylcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR0aGlzLkhwUG9pbnQgLT0gY2MuTWdyLmdsb2JhbC5Bc3NldEJ1cmRlbjtcclxuXHRcdFx0aWYodGhpcy5IcFBvaW50IDwgY2MuTWdyLmdsb2JhbC5IZWFsdGhMaW5lKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy51c2VyU3RhdGUgPSBVc2VyU3RhdGUuTm90T0s7XHJcblx0XHRcdFx0Y2MuTWdyLmdsb2JhbC5nb1RvSG9zcGl0YWwgKz0gMTtcclxuXHRcdFx0XHR0aGlzLlJlY292ZXJZZWFyID0gY2MuTWdyLmdsb2JhbC5ZZWFyUmVjb3ZlcjtcclxuXHRcdFx0XHR2YXIgcGFyYW0gPSB7fTtcclxuXHRcdFx0XHRwYXJhbS5mb3JXaGF0ID0gXCJIZWFsdGhMaW5lXCI7XHJcblx0XHRcdFx0cGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJSZWNvdmVySGVhbHRoXCIpO1xyXG5cdFx0XHRcdGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuXHJcblx0XHRcdFx0Ly90aGlzLlVuTG9ja01hdGVCeUluSG9zcGl0YWwoTWF0ZVVuTG9ja1R5cGUuSW5Ib3NwaXRhbCwgdGhpcy5TZXgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBwYXJhbSA9IHt9O1xyXG5cdFx0XHRcdHBhcmFtLmZvcldoYXQgPSBcIlwiO1xyXG5cdFx0XHRcdHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiUmVjb3ZlckhlYWx0aERcIik7XHJcblx0XHRcdFx0Y2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0SnVkZUZpbmlzaEFueUFjaGlldmVtZW50OmZ1bmN0aW9uIChJZCkge1xyXG5cdFx0Ly9jYy5sb2codGhpcy5BY2hpZXZlbWVudExpc3QubGVuZ3RoICsgXCI9PT09PT09PT09PT09PT09PT09PT095Yik5pat5oiQ5bCx5piv5ZCm5a6M5oiQXCIgKyBJZCk7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQWNoaWV2ZW1lbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHRoaXMuQWNoaWV2ZW1lbnRMaXN0W2ldLklkID09IElkKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYodGhpcy5BY2hpZXZlbWVudExpc3RbaV0uaGFzRmluaXNoID09IHRydWUpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Ly9jYy5sb2coXCLor6XmiJDlsLHlt7Lnu4/lrozmiJDkuoZcIik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR2YXIgYWNEID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5BY2hpZXZlLCBJZCk7XHJcblx0XHRjYy5sb2coXCI9PT09PT09PT09PT09PT09PT09PT095Yik5pat5oiQ5bCx5piv5ZCm5a6M5oiQID0gXCIgKyBhY0QubmFtZSk7XHJcblx0XHR2YXIgY29uZExpc3QgPSBhY0QuY29uZExpc3Q7XHJcblx0XHR2YXIgZmluaXNoZWQgPSB0aGlzLkp1ZGVDYW5GaW5pc2hBY2hpZXZlbWVudEJ5Q29uZChjb25kTGlzdCk7XHJcblx0XHRpZihmaW5pc2hlZClcclxuXHRcdHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkFjaGlldmVtZW50TGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmKHRoaXMuQWNoaWV2ZW1lbnRMaXN0W2ldLklkID09IElkKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRoaXMuQWNoaWV2ZW1lbnRMaXN0W2ldLmhhc0ZpbmlzaCA9IHRydWU7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Q2FjdWxhdGVSZXB1dGF0aW9uRnJvbUNvbXBhbnk6ZnVuY3Rpb24oKXtcclxuXHRcdC8v5ZCO6Z2i5YaN5Yqg5LiKIOiCoeelqOmAoOaIkOeahFxyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuQ29tcGFueUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0dmFyIGRhID0gdGhpcy5Db21wYW55TGlzdFtpXTtcclxuXHRcdFx0aWYoZGEuc3RvY2tOdW0gPiAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5SZXB1dGF0aW9uICs9IGNjLk1nci5nbG9iYWwuSGFzQ29tcGFueVJlcHV0YXRpb25BZGQ7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0SnVkZUNhbkZpbmlzaEFjaGlldmVtZW50QnlDb25kOmZ1bmN0aW9uKGNvbmRMaXN0KXtcclxuXHRcdHZhciBmaW5pc2hlZExpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmRMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25kID0gY29uZExpc3RbaV07XHJcbiAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYy5sb2coXCLnsbvlnovopoHmsYIgPSBcIiArIGNvbmQuY29uZFR5cGUgKyBcIiAg5pWw5YC86KaB5rGCID0gXCIgKyBjb25kLnZhbHVlKTtcclxuICAgICAgICAgICAgc3dpdGNoIChjb25kLmNvbmRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjaGlldmVDb25kLkFzc2V0TW9uZXlVcDpcclxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRoaXMuSnVkZUFzc2V0Q29uZChjb25kLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWNoaWV2ZUNvbmQuSW5Ib3NwaXRhbDpcclxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRoaXMuSnVkZWdvVG9Ib3NUaW1lc0NvbmQoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjaGlldmVDb25kLkJhbmtydXB0OlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdGhpcy5KdWRlQmFua3J1cHRUaW1lc0NvbmQoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjaGlldmVDb25kLkNyZWF0ZUJ1c2luZXNzOlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdGhpcy5KdWRlQ3JlYXRlQ29tcGFueUNvbmQoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjaGlldmVDb25kLkFnZUNvbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0aGlzLkp1ZGVBZ2VDb25kKGNvbmQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBY2hpZXZlQ29uZC5IYXNNYXJyeUNvbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0aGlzLkp1ZGVIYXNNYXJyeUNvbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWNoaWV2ZUNvbmQuTG92ZVBvaW50Q29uZDpcclxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRoaXMuSnVkZUxvdmVQb2ludENvbmQoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjaGlldmVDb25kLkFzc2V0TW9uZXlEb3duOlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdGhpcy5KdWRlQXNzZXREb3duQ29uZChjb25kLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWNoaWV2ZUNvbmQuTm9NYXJyeUNvbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0aGlzLkp1ZGVOb3RNYXJyeUNvbmQoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjaGlldmVDb25kLkFnZUNvbmRVcDpcclxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRoaXMuSnVkZUFnZUNvbmRVcChjb25kLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy5sb2coXCLmmK/lkKblrozmiJAgPSBcIiArIGZpbmlzaGVkKTtcclxuICAgICAgICAgICAgZmluaXNoZWRMaXN0LnB1c2goZmluaXNoZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVkTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIFx0aWYoZmluaXNoZWRMaXN0W2ldID09IGZhbHNlKVxyXG4gICAgICAgIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdEp1ZGVBc3NldERvd25Db25kOmZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0aWYodGhpcy5Bc3NldHNNb25leSA8IHZhbHVlICogMTAwMDAwMClcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL+aIkOWwseWujOaIkCDotYTkuqfpmZDliLZcclxuXHRKdWRlQXNzZXRDb25kOmZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0aWYodGhpcy5Bc3NldHNNb25leSA+PSB2YWx1ZSAqIDEwMDAwMDApXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly/miJDlsLHlrozmiJAg5bm06b6E6ZmQ5Yi2IOWwj+S6jlxyXG5cdEp1ZGVBZ2VDb25kOmZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0aWYodGhpcy5BZ2UgPD0gdmFsdWUpXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0SnVkZUFnZUNvbmRVcDpmdW5jdGlvbih2YWx1ZSl7XHJcblx0XHRpZih0aGlzLkFnZSA+PSB2YWx1ZSlcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHR9LCBcclxuXHJcblxyXG5cdC8v5oiQ5bCx5a6M5oiQIOi/m+WMu+mZouasoeaVsFxyXG5cdEp1ZGVnb1RvSG9zVGltZXNDb25kOmZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0aWYoY2MuTWdyLmdsb2JhbC5nb1RvSG9zcGl0YWwgPiB2YWx1ZSlcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL+aIkOWwseWujOaIkCDnoLTkuqfmrKHmlbBcclxuXHRKdWRlQmFua3J1cHRUaW1lc0NvbmQ6ZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHRpZihjYy5NZ3IuZ2xvYmFsLkJhbmtydXB0VGltZXMgPiB2YWx1ZSlcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL+aIkOWwseWujOaIkCDliJvkuJrmrKHmlbBcclxuXHRKdWRlQ3JlYXRlQ29tcGFueUNvbmQ6ZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHRpZihjYy5NZ3IuZ2xvYmFsLkNyZWF0ZUNvbXBhbnlUaW1lcyA+IHZhbHVlKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8v5oiQ5bCx5a6M5oiQIOaYr+WQpuW3suWpmlxyXG5cdEp1ZGVIYXNNYXJyeUNvbmQ6ZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk1hdGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHRoaXMuTWF0ZUxpc3RbaV0uTG92ZVBvaW50ID09IDEwMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0SnVkZUhhc0NhcjpmdW5jdGlvbigpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuQ2FyTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZih0aGlzLkNhckxpc3RbaV0ub3duTnVtID4gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0SnVkZUhhc0NhckJ5SWQ6ZnVuY3Rpb24oSWQpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuQ2FyTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZih0aGlzLkNhckxpc3RbaV0ub3duTnVtID4gMCAmJiB0aGlzLkNhckxpc3RbaV0uSWQgPT0gSWQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdEp1ZGVIYXNIb3VzZTpmdW5jdGlvbigpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuSG91c2VMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmKHRoaXMuSG91c2VMaXN0W2ldLm93bk51bSA+IDApXHJcblx0XHRcdHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdEp1ZGVIYXNIb3VzZUJ5SWQ6ZnVuY3Rpb24oSWQpe1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuSG91c2VMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmKHRoaXMuSG91c2VMaXN0W2ldLm93bk51bSA+IDAgJiYgdGhpcy5Ib3VzZUxpc3RbaV0uSWQgPT0gSWQpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8v5oiQ5bCx5a6M5oiQIOaYr+WQpuacquWpmlxyXG5cdEp1ZGVOb3RNYXJyeUNvbmQ6ZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk1hdGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHRoaXMuTWF0ZUxpc3RbaV0uTG92ZVBvaW50ID09IDEwMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly/miJDlsLHlrozmiJAg5Lqy5a+G5bqm5Lq65pWwXHJcblx0SnVkZUxvdmVQb2ludENvbmQ6ZnVuY3Rpb24odmFsdWUpe1xyXG5cdFx0dmFyIG51bSA9IDA7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuTWF0ZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYodGhpcy5NYXRlTGlzdFtpXS5Mb3ZlUG9pbnQgPT0gOTkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRudW0gKz0gMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYobnVtID49IHZhbHVlKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8v5Yi35paw55So5oi35bm06b6EXHJcblx0UmVmcmVzaFVzZXJBZ2U6ZnVuY3Rpb24oKXtcclxuXHRcdHRoaXMuQWdlICs9IDE7XHJcblx0XHRpZih0aGlzLkFnZSA9PSAodGhpcy5yZXRpcmVBZ2UgKyAxKSAmJiBjYy5NZ3IuZ2xvYmFsLnVzZVJldGlyZUFkcyA9PSBmYWxzZSlcclxuXHRcdHtcclxuXHRcdFx0Y2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuVXNlUmV0aXJlQWRzU2tpbGwsIHt9KTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYodGhpcy5BZ2UgPiB0aGlzLnJldGlyZUFnZSAmJiBjYy5NZ3IuZ2xvYmFsLnVzZVJldGlyZUFkcyA9PSB0cnVlKVxyXG5cdFx0e1xyXG5cdFx0XHRjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5SZXRpcmUsIHt9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLkNhY3VsYXRlUmVwdXRhdGlvbkZyb21Db21wYW55KCk7XHJcblx0fSxcclxuXHJcblx0Ly/liLfmlrDkuKrkurrlgaXlurfmjIfmlbBcclxuXHRSZWZyZXNoSGVhbHRoSHA6ZnVuY3Rpb24oKXtcclxuXHRcdGlmKHRoaXMuUmVjb3ZlclllYXIgPiAwICYmIHRoaXMudXNlclN0YXRlID09IFVzZXJTdGF0ZS5Ob3RPSylcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5SZWNvdmVyWWVhciAtPSAxO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKHRoaXMuUmVjb3ZlclllYXIgPT0gMCAmJiB0aGlzLnVzZXJTdGF0ZSA9PSBVc2VyU3RhdGUuTm90T0spXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuUmVjb3ZlclllYXIgPSAwO1xyXG5cdFx0XHR0aGlzLnVzZXJTdGF0ZSA9IFVzZXJTdGF0ZS5PSztcclxuXHRcdFx0dGhpcy5IcFBvaW50ID0gMTAwO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5BZ2UgPj0gY2MuTWdyLmdsb2JhbC5IZWFsdGhTdWJBZ2UgJiYgdGhpcy5IcFBvaW50ID4gMClcclxuXHRcdHtcclxuXHRcdFx0dmFyIHNlZWQgPSAyICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjMpO1xyXG5cdFx0XHR0aGlzLkhwUG9pbnQgLT0gc2VlZDtcclxuXHRcdFx0aWYodGhpcy5IcFBvaW50IDwgY2MuTWdyLmdsb2JhbC5IZWFsdGhMaW5lKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy51c2VyU3RhdGUgPSBVc2VyU3RhdGUuTm90T0s7XHJcblx0XHRcdFx0Y2MuTWdyLmdsb2JhbC5nb1RvSG9zcGl0YWwgKz0gMTtcclxuXHRcdFx0XHR0aGlzLlJlY292ZXJZZWFyID0gY2MuTWdyLmdsb2JhbC5ZZWFyUmVjb3ZlcjtcclxuXHJcblx0XHRcdFx0dmFyIHBhcmFtID0ge307XHJcblx0XHRcdFx0cGFyYW0uZm9yV2hhdCA9IFwiSGVhbHRoTGluZVwiO1xyXG5cdFx0XHRcdHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiUmVjb3ZlckhlYWx0aFwiKTtcclxuXHRcdFx0XHRjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwLCBwYXJhbSk7XHJcblx0XHRcdFx0Ly90aGlzLlVuTG9ja01hdGVCeUluSG9zcGl0YWwoTWF0ZVVuTG9ja1R5cGUuSW5Ib3NwaXRhbCwgdGhpcy5TZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly/mioDog73lpKnotYvmlbDmja7ojrflj5ZcclxuICAgIGdldFNraWxsRGF0YUJ5VHdvSWQ6ZnVuY3Rpb24oSWQsIHN1YklkKXtcclxuICAgICAgICB2YXIgZHQgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLlNraWxsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuU2tpbGxMaXN0W2ldO1xyXG4gICAgICAgICAgICBpZihkYXRhLklkID09IElkICYmIGRhdGEuc3ViSWQgPT0gc3ViSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGR0ID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkdDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2tpbGxMaXN0QnlJZDpmdW5jdGlvbihJZCl7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuU2tpbGxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5Ta2lsbExpc3RbaV07XHJcbiAgICAgICAgICAgIGlmKGRhdGEuSWQgPT0gSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+iKsemUgOWSjOiOt+W+l+agueaNriBcclxuICAgIEdldE9yQ29zdERhdGFCeVJld2FyZFR5cGU6ZnVuY3Rpb24ocmV3YXJkVHlwZSwgbnVtLCBzdWJJZCkgLy/lr7nkuo7nianlk4EgIOS8muacieS4gOS4qnN1YklkXHJcbiAgICB7XHJcbiAgICBcdHZhciBQZGF0YSA9IHt9O1xyXG4gICAgXHRQZGF0YS5JZCA9IC0xO1xyXG4gICAgXHRQZGF0YS5jb21wYW55SWQgPSAtMTtcclxuICAgIFx0Ly9jYy5sb2coXCIrKysrKytyZXdhcmRUeXBlKysrKysrXCIgKyByZXdhcmRUeXBlKTtcclxuXHRcdGlmKHJld2FyZFR5cGUgPT0gUmV3YXJkVHlwZS5OVUxMKVxyXG4gICAgXHR7XHJcbiAgICBcdFx0Ly9jYy5sb2coXCLllaXkuZ/msqHmnIlcIik7XHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZSBpZihyZXdhcmRUeXBlID09IFJld2FyZFR5cGUuQ2FzaClcclxuICAgIFx0e1xyXG4gICAgXHRcdGlmKG51bSA8IDApIC8v5aW96L+Q6L+e6L+eXHJcbiAgICBcdFx0e1xyXG4gICAgXHRcdFx0bnVtID0gbnVtICsgTWF0aC5mbG9vcigoLW51bSkqIHRoaXMuRXZlbnRDb3N0Qm9udXMpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRlbHNlXHJcbiAgICBcdFx0e1xyXG4gICAgXHRcdFx0bnVtICsgTWF0aC5mbG9vcihudW0qIHRoaXMuRXZlbnRDb3N0Qm9udXMpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHR0aGlzLkNhc2ggKz0gbnVtO1xyXG4gICAgXHRcdGlmKHRoaXMuQ2FzaCA8IDApXHJcbiAgICBcdFx0XHR0aGlzLkNhc2ggPSAwO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2UgaWYocmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLkhQKVxyXG4gICAgXHR7XHJcbiAgICBcdFx0dGhpcy5IcFBvaW50ICs9IG51bTtcclxuICAgIFx0XHRpZih0aGlzLkhwUG9pbnQgPjEwMClcclxuICAgIFx0XHRcdHRoaXMuSHBQb2ludCA9MTAwO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2UgaWYocmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLlJlcHV0YXRpb24pXHJcbiAgICBcdHtcclxuICAgIFx0XHR0aGlzLlJlcHV0YXRpb24gKz0gbnVtO1xyXG4gICAgXHRcdGlmKHRoaXMuUmVwdXRhdGlvbiA8IDApXHJcbiAgICBcdFx0XHR0aGlzLlJlcHV0YXRpb24gPSAwO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2UgaWYocmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLkdvb2RzKVxyXG4gICAgXHR7XHJcbiAgICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkdvb2RzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdFx0aWYodGhpcy5Hb29kc0xpc3RbaV0uSWQgPT0gc3ViSWQpXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdGlmKHRoaXMuV2FyZUhvdXNlQ2FwY2l0eSA+PSBudW0pXHJcbiAgICBcdFx0XHRcdHtcclxuICAgIFx0XHRcdFx0XHR2YXIgYXZlcmFnZVByaWNlID0gTWF0aC5mbG9vcigodGhpcy5Hb29kc0xpc3RbaV0uYnV5UHJpY2UgKiB0aGlzLkdvb2RzTGlzdFtpXS5vd25OdW0pIC8gKHRoaXMuR29vZHNMaXN0W2ldLm93bk51bSArIG51bSkpO1xyXG5cdCAgICBcdFx0XHRcdHRoaXMuR29vZHNMaXN0W2ldLm93bk51bSArPSBudW07XHJcblx0ICAgIFx0XHRcdFx0Ly/ku5PlupPlh4/lsJHmlbDlgLxcclxuXHQgICAgXHRcdFx0XHR0aGlzLldhcmVIb3VzZUNhcGNpdHkgLT0gbnVtO1xyXG5cclxuXHQgICAgXHRcdFx0XHRQZGF0YS5JZCA9IHN1YklkO1xyXG5cdCAgICBcdFx0XHRcdFBkYXRhLmJ1eVByaWNlID0gYXZlcmFnZVByaWNlOy8vdGhpcy5Hb29kc0xpc3RbaV0uYnV5UHJpY2U7XHJcblx0ICAgIFx0XHRcdFx0UGRhdGEub3duTnVtID0gdGhpcy5Hb29kc0xpc3RbaV0ub3duTnVtO1xyXG4gICAgXHRcdFx0XHR9XHJcbiAgICBcdFx0XHRcdGJyZWFrO1xyXG4gICAgXHRcdFx0fVxyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgXHRlbHNlIGlmKHJld2FyZFR5cGUgPT0gUmV3YXJkVHlwZS5DYXIpXHJcbiAgICBcdHtcclxuICAgIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ2FyTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdFx0aWYodGhpcy5DYXJMaXN0W2ldLklkID09IHN1YklkKVxyXG4gICAgXHRcdFx0e1xyXG4gICAgXHRcdFx0XHR0aGlzLkNhckxpc3RbaV0ub3duTnVtICs9IG51bTtcclxuICAgIFx0XHRcdFx0dGhpcy5SZXB1dGF0aW9uICs9IHRoaXMuQ2FyTGlzdFtpXS5hZGRCb251cztcclxuICAgIFx0XHRcdFx0dGhpcy5IcFBvaW50ICs9IHRoaXMuQ2FyTGlzdFtpXS5hZGRIcDtcclxuICAgIFx0XHRcdFx0aWYodGhpcy5IcFBvaW50ID4gMTAwKVxyXG4gICAgXHRcdFx0XHRcdHRoaXMuSHBQb2ludCA9IDEwMDtcclxuICAgIFx0XHRcdFx0YnJlYWs7XHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICBcdGVsc2UgaWYocmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLkhvdXNlKVxyXG4gICAgXHR7XHJcbiAgICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkhvdXNlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdFx0aWYodGhpcy5Ib3VzZUxpc3RbaV0uSWQgPT0gc3ViSWQpXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdHRoaXMuSG91c2VMaXN0W2ldLm93bk51bSArPSBudW07XHJcbiAgICBcdFx0XHRcdHRoaXMuUmVwdXRhdGlvbiArPSB0aGlzLkhvdXNlTGlzdFtpXS5hZGRCb251cztcclxuICAgIFx0XHRcdFx0dGhpcy5IcFBvaW50ICs9IHRoaXMuSG91c2VMaXN0W2ldLmFkZEhwO1xyXG4gICAgXHRcdFx0XHRpZih0aGlzLkhwUG9pbnQgPiAxMDApXHJcbiAgICBcdFx0XHRcdFx0dGhpcy5IcFBvaW50ID0gMTAwO1xyXG4gICAgXHRcdFx0XHRicmVhaztcclxuICAgIFx0XHRcdH1cclxuICAgIFx0XHR9XHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZSBpZihyZXdhcmRUeXBlID09IFJld2FyZFR5cGUuU3RvY2spXHJcbiAgICBcdHtcclxuICAgIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ29tcGFueUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIFx0XHRcdGlmKHRoaXMuQ29tcGFueUxpc3RbaV0uSWQgPT0gc3ViSWQpXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdHRoaXMuQ29tcGFueUxpc3RbaV0uc3RvY2tOdW0gKz0gbnVtO1xyXG4gICAgXHRcdFx0XHRQZGF0YS5jb21wYW55SWQgPSBzdWJJZDtcclxuICAgIFx0XHRcdFx0YnJlYWs7XHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICBcdGVsc2UgaWYocmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLlN0b2NrUHJpY2UpXHJcbiAgICBcdHtcclxuICAgIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ29tcGFueUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIFx0XHRcdGlmKHRoaXMuQ29tcGFueUxpc3RbaV0uSWQgPT0gc3ViSWQpXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdGlmKHRoaXMuQ29tcGFueUxpc3RbaV0uc3RvY2tOdW0gPiAwKVxyXG4gICAgXHRcdFx0XHR7XHJcbiAgICBcdFx0XHRcdFx0dGhpcy5Db21wYW55TGlzdFtpXS5zdG9ja1ByaWNlICs9IG51bTtcclxuICAgIFx0XHRcdFx0XHRQZGF0YS5jb21wYW55SWQgPSBzdWJJZDtcclxuICAgIFx0XHRcdFx0XHRicmVhaztcclxuICAgIFx0XHRcdFx0fVxyXG4gICAgXHRcdFx0fVxyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG5cdCAgICByZXR1cm4gUGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yik5pat5piv5ZCm5pyJ5oi/XHJcbiAgICBKdWRlSGFzSG91c2U6ZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgXHR2YXIgZmxhZyA9IGZhbHNlO1xyXG4gICAgXHRpZih2YWx1ZSA9PSAwKVxyXG4gICAgXHR7XHJcblx0ICAgIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkhvdXNlTGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBcdFx0aWYodGhpcy5Ib3VzZUxpc3RbaV0ub3duTnVtID4gMClcclxuXHQgICAgXHRcdHtcclxuXHQgICAgXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0ICAgIFx0XHR9XHJcblx0ICAgIFx0fVxyXG4gICAgXHR9XHJcbiAgICBcdGVsc2VcclxuICAgIFx0e1xyXG4gICAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5Ib3VzZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgXHRcdGlmKHRoaXMuSG91c2VMaXN0W2ldLm93bk51bSA+IDAgJiYgdmFsdWUgPT0gdGhpcy5Ib3VzZUxpc3RbaV0uSWQpXHJcblx0ICAgIFx0XHR7XHJcblx0ICAgIFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdCAgICBcdFx0fVxyXG5cdCAgICBcdH1cclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gZmxhZztcclxuICAgIH0sXHJcbiAgICAvL+WIpOaWreaYr+WQpuaciei9plxyXG4gICAgSnVkZUhhc0NhcjpmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICBcdHZhciBmbGFnID0gZmFsc2U7XHJcbiAgICBcdGlmKHZhbHVlID09IDApXHJcbiAgICBcdHtcclxuXHQgICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ2FyTGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBcdFx0aWYodGhpcy5DYXJMaXN0W2ldLm93bk51bSA+IDApXHJcblx0ICAgIFx0XHR7XHJcblx0ICAgIFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdCAgICBcdFx0fVxyXG5cdCAgICBcdH1cclxuICAgIFx0fVxyXG4gICAgXHRlbHNlXHJcbiAgICBcdHtcclxuICAgIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ2FyTGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBcdFx0aWYodGhpcy5DYXJMaXN0W2ldLm93bk51bSA+IDAgJiYgdGhpcy5DYXJMaXN0W2ldLklkID09IHZhbHVlKVxyXG5cdCAgICBcdFx0e1xyXG5cdCAgICBcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHQgICAgXHRcdH1cclxuXHQgICAgXHR9XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGZsYWc7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yik5pat6LWE5Lqn5piv5ZCm5ruh6Laz5LiA5a6a6KaB5rGCXHJcbiAgICBKdWRlQXNzZXQ6ZnVuY3Rpb24obmVlZE51bSlcclxuICAgIHtcclxuICAgIFx0dmFyIGZsYWcgPSBmYWxzZTtcclxuICAgIFx0aWYobmVlZE51bSA8PSB0aGlzLkFzc2V0c01vbmV5KVxyXG4gICAgXHR7XHJcbiAgICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGZsYWc7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yik5pat5ZCN5aOw5piv5ZCm5ruh6Laz6KaB5rGCXHJcbiAgICBKdWRlUmVwdXRhdGlvbjpmdW5jdGlvbihuZWVkTnVtKXtcclxuICAgIFx0dmFyIGZsYWcgPSBmYWxzZTtcclxuICAgIFx0aWYobmVlZE51bSA8PSB0aGlzLlJlcHV0YXRpb24pXHJcbiAgICBcdHtcclxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gZmxhZztcclxuICAgIH0sXHJcblxyXG4gICAgLy/liKTmlq3lgaXlurfmmK/lkKbmu6HotrPopoHmsYJcclxuICAgIEp1ZGVIcFBvaW50OmZ1bmN0aW9uKG5lZWROdW0pe1xyXG4gICAgXHR2YXIgZmxhZyA9IGZhbHNlO1xyXG4gICAgXHRpZihuZWVkTnVtIDw9IHRoaXMuSHBQb2ludClcclxuICAgIFx0e1xyXG4gICAgXHRcdHJldHVybiB0cnVlO1xyXG4gICAgXHR9XHJcbiAgICBcdHJldHVybiBmbGFnO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+WIpOaWreaYr+WQpuacieWFrOWPuFxyXG4gICAgSnVkZUhhc0NvbXBhbnk6ZnVuY3Rpb24oKXtcclxuICAgIFx0cmV0dXJuIHRoaXMuaGFzQ29tcGFueTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/lvIDmlL7or6XmnaHku7bkuIvnmoTkuIDkuKog5Y+v57qm5Lya5a+56LGhXHJcbiAgICBVbkxvY2tPbmVNYXRlOmZ1bmN0aW9uKHVubG9ja0NvbmQsIG9mZlNleCl7XHJcbiAgICBcdHZhciBJZCA9IC0xO1xyXG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuTWF0ZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIFx0XHQvL3ZhciBkdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuTWF0ZSAsIHRoaXMuTWF0ZUxpc3RbaV0uSWQpO1xyXG4gICAgXHRcdGlmKHRoaXMuTWF0ZUxpc3RbaV0uc2V4ID09IG9mZlNleCAmJiB0aGlzLk1hdGVMaXN0W2ldLmNhbkRhdGUgPT0gZmFsc2UgJiYgdGhpcy5NYXRlTGlzdFtpXS51bmxvY2tDb25kID09IHVubG9ja0NvbmQpXHJcbiAgICBcdFx0e1xyXG4gICAgXHRcdFx0dGhpcy5NYXRlTGlzdFtpXS5jYW5EYXRlID0gdHJ1ZTtcclxuICAgIFx0XHRcdElkID0gdGhpcy5NYXRlTGlzdFtpXS5JZDtcclxuXHJcblx0XHRcdFx0dmFyIHBhcmFtID0ge307XHJcblx0XHRcdFx0cGFyYW0uaWNvbiA9IHRoaXMuTWF0ZUxpc3RbaV0uaWNvbjtcclxuXHRcdFx0XHRwYXJhbS5kZXMgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiVW5Mb2NrTWF0ZV9cIiArIElkKTtcclxuXHRcdFx0XHRjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuVW5Mb2NrTWF0ZSwgcGFyYW0pO1xyXG4gICAgXHRcdFx0cmV0dXJuIElkO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gSWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIFVuTG9ja01hdGVCeUluSG9zcGl0YWw6ZnVuY3Rpb24odW5sb2NrQ29uZCwgb2ZmU2V4KXtcclxuICAgIFx0dmFyIElkID0gLTE7XHJcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5NYXRlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdC8vdmFyIGR0ID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5NYXRlICwgdGhpcy5NYXRlTGlzdFtpXS5JZCk7XHJcbiAgICBcdFx0aWYodGhpcy5NYXRlTGlzdFtpXS5zZXggPT0gb2ZmU2V4ICYmIHRoaXMuTWF0ZUxpc3RbaV0uY2FuRGF0ZSA9PSBmYWxzZSAmJiB0aGlzLk1hdGVMaXN0W2ldLnVubG9ja0NvbmQgPT0gdW5sb2NrQ29uZClcclxuICAgIFx0XHR7XHJcbiAgICBcdFx0XHR0aGlzLk1hdGVMaXN0W2ldLmNhbkRhdGUgPSB0cnVlO1xyXG4gICAgXHRcdFx0SWQgPSB0aGlzLk1hdGVMaXN0W2ldLklkO1xyXG5cclxuXHRcdFx0XHR2YXIgcGFyYW0gPSB7fTtcclxuXHRcdFx0XHRwYXJhbS5pY29uID0gdGhpcy5NYXRlTGlzdFtpXS5pY29uO1xyXG5cdFx0XHRcdHBhcmFtLmRlcyA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJVbkxvY2tNYXRlQnlJbkhvc1wiKTtcclxuXHRcdFx0XHRjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuVW5Mb2NrTWF0ZSwgcGFyYW0pO1xyXG4gICAgXHRcdFx0cmV0dXJuIElkO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gSWQ7XHJcbiAgICB9LFxyXG4gICAgLy/liKTmlq3mmK/lkKblt7Lnu4/mi6XmnInkuIDkuKrkvLTkvqNcclxuICAgIEp1ZGVIYXNBbnlNYXRlOmZ1bmN0aW9uKCl7XHJcbiAgICBcdHZhciBmbGFnID0gZmFsc2U7XHJcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5NYXRlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdC8vY2MubG9nKFwi5piv5ZCm5bey57uP57uT5ama5LqGIFwiKyB0aGlzLk1hdGVMaXN0W2ldLlVwbHYpO1xyXG4gICAgXHRcdGlmKHRoaXMuTWF0ZUxpc3RbaV0uVXBMdiA9PSB0cnVlKVxyXG4gICAgXHRcdHtcclxuICAgIFx0XHRcdGZsYWcgPSB0cnVlO1xyXG4gICAgXHRcdFx0cmV0dXJuIGZsYWc7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICBcdHJldHVybiBmbGFnO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVc2VyRGF0YU1nclxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Achieve/AchieveCondData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4aa4aQnGTZFX5fmP4gSZhed', 'AchieveCondData');
// Scripts/DataMap/Achieve/AchieveCondData.js

"use strict";

var AchieveCondData = cc.Class({
  name: "AchieveCondData",
  properties: {
    condType: cc.Integer,
    value: cc.Integer
  }
});
module.exports = AchieveCondData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQWNoaWV2ZVxcQWNoaWV2ZUNvbmREYXRhLmpzIl0sIm5hbWVzIjpbIkFjaGlldmVDb25kRGF0YSIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsImNvbmRUeXBlIiwiSW50ZWdlciIsInZhbHVlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxlQUFlLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzNCQyxJQUFJLEVBQUMsaUJBQWlCO0VBQ3RCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDSixFQUFFLENBQUNLLE9BQU87SUFDbkJDLEtBQUssRUFBQ04sRUFBRSxDQUFDSztFQUNiO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZFLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHVCxlQUFlIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIEFjaGlldmVDb25kRGF0YSA9IGNjLkNsYXNzKHtcclxuICAgIG5hbWU6XCJBY2hpZXZlQ29uZERhdGFcIixcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBjb25kVHlwZTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIHZhbHVlOmNjLkludGVnZXIsXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBBY2hpZXZlQ29uZERhdGE7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Car/CarData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '6ffebwUdpRDNL1Tn+OopYeC', 'CarData');
// Scripts/DataMap/Car/CarData.js

"use strict";

var CarData = cc.Class({
  name: "CarData",
  properties: {
    Id: cc.Integer,
    icon: "",
    name: "",
    price: cc.Integer,
    addBonus: cc.Integer,
    //增加名声
    addHp: cc.Integer,
    //增加健康值
    addDate: 0 //增加约会成功率
  }
});

module.exports = CarData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQ2FyXFxDYXJEYXRhLmpzIl0sIm5hbWVzIjpbIkNhckRhdGEiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJJZCIsIkludGVnZXIiLCJpY29uIiwicHJpY2UiLCJhZGRCb251cyIsImFkZEhwIiwiYWRkRGF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsT0FBTyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN0QkMsSUFBSSxFQUFDLFNBQVM7RUFDWEMsVUFBVSxFQUFFO0lBQ1JDLEVBQUUsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ2JDLElBQUksRUFBQyxFQUFFO0lBQ1BKLElBQUksRUFBQyxFQUFFO0lBQ1BLLEtBQUssRUFBQ1AsRUFBRSxDQUFDSyxPQUFPO0lBQ2hCRyxRQUFRLEVBQUNSLEVBQUUsQ0FBQ0ssT0FBTztJQUFFO0lBQzNCSSxLQUFLLEVBQUNULEVBQUUsQ0FBQ0ssT0FBTztJQUFDO0lBQ2pCSyxPQUFPLEVBQUMsQ0FBQyxDQUFDO0VBQ1I7QUFDSixDQUFDLENBQUM7O0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHYixPQUFPIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIENhckRhdGEgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIkNhckRhdGFcIixcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGljb246XCJcIixcclxuICAgICAgICBuYW1lOlwiXCIsXHJcbiAgICAgICAgcHJpY2U6Y2MuSW50ZWdlcixcclxuICAgICAgICBhZGRCb251czpjYy5JbnRlZ2VyLCAvL+WinuWKoOWQjeWjsFxyXG5cdFx0YWRkSHA6Y2MuSW50ZWdlciwvL+WinuWKoOWBpeW6t+WAvFxyXG5cdFx0YWRkRGF0ZTowLC8v5aKe5Yqg57qm5Lya5oiQ5Yqf546HXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBDYXJEYXRhO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/AchieveCond.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '6d3adUN5n5Hv7wPNOxwCZc9', 'AchieveCond');
// Scripts/Core/AchieveCond.js

"use strict";

var AchieveCond = cc.Enum({
  AssetMoneyUp: 1,
  //资产超过
  InHospital: 2,
  //住院
  Bankrupt: 3,
  //公司破产
  CreateBusiness: 4,
  //创办公司
  AgeCond: 5,
  //年龄限制

  HasMarryCond: 6,
  //是否已婚
  LovePointCond: 7,
  //亲密度要求
  AssetMoneyDown: 8,
  //资产低于
  NoMarryCond: 9,
  //没结婚
  AgeCondUp: 10 //年龄限制
});

module.exports = AchieveCond;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcQWNoaWV2ZUNvbmQuanMiXSwibmFtZXMiOlsiQWNoaWV2ZUNvbmQiLCJjYyIsIkVudW0iLCJBc3NldE1vbmV5VXAiLCJJbkhvc3BpdGFsIiwiQmFua3J1cHQiLCJDcmVhdGVCdXNpbmVzcyIsIkFnZUNvbmQiLCJIYXNNYXJyeUNvbmQiLCJMb3ZlUG9pbnRDb25kIiwiQXNzZXRNb25leURvd24iLCJOb01hcnJ5Q29uZCIsIkFnZUNvbmRVcCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsV0FBVyxHQUFHQyxFQUFFLENBQUNDLElBQUksQ0FBQztFQUN0QkMsWUFBWSxFQUFDLENBQUM7RUFBRTtFQUNoQkMsVUFBVSxFQUFDLENBQUM7RUFBQztFQUNiQyxRQUFRLEVBQUMsQ0FBQztFQUFFO0VBQ1pDLGNBQWMsRUFBQyxDQUFDO0VBQUU7RUFDbEJDLE9BQU8sRUFBQyxDQUFDO0VBQUM7O0VBRVZDLFlBQVksRUFBQyxDQUFDO0VBQUM7RUFDZkMsYUFBYSxFQUFDLENBQUM7RUFBQztFQUNoQkMsY0FBYyxFQUFDLENBQUM7RUFBQztFQUNqQkMsV0FBVyxFQUFDLENBQUM7RUFBRTtFQUNmQyxTQUFTLEVBQUMsRUFBRSxDQUFDO0FBQ2pCLENBQUMsQ0FBQzs7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUdkLFdBQVciLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgQWNoaWV2ZUNvbmQgPSBjYy5FbnVtKHtcclxuICAgIEFzc2V0TW9uZXlVcDoxLCAvL+i1hOS6p+i2hei/h1xyXG4gICAgSW5Ib3NwaXRhbDoyLC8v5L2P6ZmiXHJcbiAgICBCYW5rcnVwdDozLCAvL+WFrOWPuOegtOS6p1xyXG4gICAgQ3JlYXRlQnVzaW5lc3M6NCwgLy/liJvlip7lhazlj7hcclxuICAgIEFnZUNvbmQ6NSwvL+W5tOm+hOmZkOWItlxyXG5cclxuICAgIEhhc01hcnJ5Q29uZDo2LC8v5piv5ZCm5bey5amaXHJcbiAgICBMb3ZlUG9pbnRDb25kOjcsLy/kurLlr4bluqbopoHmsYJcclxuICAgIEFzc2V0TW9uZXlEb3duOjgsLy/otYTkuqfkvY7kuo5cclxuICAgIE5vTWFycnlDb25kOjksIC8v5rKh57uT5amaXHJcbiAgICBBZ2VDb25kVXA6MTAsLy/lubTpvoTpmZDliLZcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQWNoaWV2ZUNvbmQ7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Achieve/AchieveData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd509an902dFMKlt6gHvUHp1', 'AchieveData');
// Scripts/DataMap/Achieve/AchieveData.js

"use strict";

var AchieveCondData = require("AchieveCondData");
var AchieveData = cc.Class({
  name: "AchieveData",
  properties: {
    name: "",
    icon: "",
    Id: cc.Integer,
    desId: cc.Integer,
    condList: [AchieveCondData]
    //额外条件 
  }
});

module.exports = AchieveData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQWNoaWV2ZVxcQWNoaWV2ZURhdGEuanMiXSwibmFtZXMiOlsiQWNoaWV2ZUNvbmREYXRhIiwicmVxdWlyZSIsIkFjaGlldmVEYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiaWNvbiIsIklkIiwiSW50ZWdlciIsImRlc0lkIiwiY29uZExpc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLGVBQWUsR0FBR0MsT0FBTyxDQUFDLGlCQUFpQixDQUFDO0FBQ2hELElBQUlDLFdBQVcsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDdkJDLElBQUksRUFBQyxhQUFhO0VBRWxCQyxVQUFVLEVBQUU7SUFDWEQsSUFBSSxFQUFDLEVBQUU7SUFDUEUsSUFBSSxFQUFDLEVBQUU7SUFDSkMsRUFBRSxFQUFDTCxFQUFFLENBQUNNLE9BQU87SUFDYkMsS0FBSyxFQUFDUCxFQUFFLENBQUNNLE9BQU87SUFDaEJFLFFBQVEsRUFBQyxDQUFDWCxlQUFlO0lBQzFCO0VBQ0g7QUFDSixDQUFDLENBQUM7O0FBQ0ZZLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWCxXQUFXIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQWNoaWV2ZUNvbmREYXRhID0gcmVxdWlyZShcIkFjaGlldmVDb25kRGF0YVwiKTtcclxudmFyIEFjaGlldmVEYXRhID0gY2MuQ2xhc3Moe1xyXG4gICAgbmFtZTpcIkFjaGlldmVEYXRhXCIsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgXHRuYW1lOlwiXCIsXHJcbiAgICBcdGljb246XCJcIixcclxuICAgICAgICBJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGRlc0lkOmNjLkludGVnZXIsXHJcbiAgICAgICAgY29uZExpc3Q6W0FjaGlldmVDb25kRGF0YV0sXHJcbiAgICAgICAvL+mineWkluadoeS7tiBcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFjaGlldmVEYXRhO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Company/CompanyMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2be05W0/DhDcKVepJyGN9sd', 'CompanyMapDecoder');
// Scripts/DataMap/Company/CompanyMapDecoder.js

"use strict";

var CompanyData = require("CompanyData");
var ProData = require("ProData");
var CompanyMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "company",
    companyList: {
      "default": [],
      type: [CompanyData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析公司数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.company;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var comData = new CompanyData();
        comData.Id = jsonRoot[i].Id;
        comData.icon = jsonRoot[i].icon;
        comData.name = jsonRoot[i].name;
        comData.inPrice = jsonRoot[i].inPrice;
        comData.outPrice = jsonRoot[i].outPrice; //破产点
        comData.LimitYear = jsonRoot[i].LimitYear;
        comData.bonusRatio = jsonRoot[i].bonusRatio;
        //买到后刷这个比例
        for (var j = 0; j < jsonRoot[i].proList.length; j++) {
          var proD = new ProData();
          proD.lowRatio = jsonRoot[i].proList[j][0];
          proD.upRatio = jsonRoot[i].proList[j][1];
          proD.weight = jsonRoot[i].proList[j][2];
          comData.proList[j] = proD;
        }
        //没有买时候刷这个比例
        for (var j = 0; j < jsonRoot[i].unList.length; j++) {
          var proD = new ProData();
          proD.lowRatio = jsonRoot[i].unList[j][0];
          proD.upRatio = jsonRoot[i].unList[j][1];
          proD.weight = jsonRoot[i].unList[j][2];
          comData.unList[j] = proD;
        }
        self.companyList[i] = comData;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.companyList.length - 1; i >= 0; i--) {
      if (name == this.companyList[i].name) {
        data = this.companyList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.companyList.length - 1; i >= 0; i--) {
      if (itemId == this.companyList[i].Id) {
        data = this.companyList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.companyList.length;
  },
  getDataList: function getDataList() {
    return this.companyList;
  }
});
module.exports = CompanyMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQ29tcGFueVxcQ29tcGFueU1hcERlY29kZXIuanMiXSwibmFtZXMiOlsiQ29tcGFueURhdGEiLCJyZXF1aXJlIiwiUHJvRGF0YSIsIkNvbXBhbnlNYXBEZWNvZGVyIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJqc29uTmFtZSIsImNvbXBhbnlMaXN0IiwidHlwZSIsIkRlY29kZUpzb24iLCJldmVudCIsInNlbGYiLCJyZUNiIiwibG9hZGVyIiwibG9hZFJlcyIsImVycm9yIiwib2JqIiwianNvblJvb3QiLCJqc29uIiwiY29tcGFueSIsImkiLCJsZW5ndGgiLCJjb21EYXRhIiwiSWQiLCJpY29uIiwibmFtZSIsImluUHJpY2UiLCJvdXRQcmljZSIsIkxpbWl0WWVhciIsImJvbnVzUmF0aW8iLCJqIiwicHJvTGlzdCIsInByb0QiLCJsb3dSYXRpbyIsInVwUmF0aW8iLCJ3ZWlnaHQiLCJ1bkxpc3QiLCJnZXREYXRhQnlOYW1lIiwiZGF0YSIsImdldERhdGFCeUl0ZW1JZCIsIml0ZW1JZCIsImdldEpzb25MZW5ndGgiLCJnZXREYXRhTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsV0FBVyxHQUFHQyxPQUFPLENBQUMsYUFBYSxDQUFDO0FBQ3hDLElBQUlDLE9BQU8sR0FBR0QsT0FBTyxDQUFDLFNBQVMsQ0FBQztBQUNoQyxJQUFJRSxpQkFBaUIsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDN0IsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDLFNBQVM7SUFDbEJDLFdBQVcsRUFBQztNQUNSLFdBQVEsRUFBRTtNQUNWQyxJQUFJLEVBQUMsQ0FBQ1YsV0FBVztJQUNyQjtFQUNKLENBQUM7RUFFRDtFQUNBVyxVQUFVLEVBQUMsU0FBQUEsV0FBVUMsS0FBSyxF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QUNsQyxXQUFXLENBQUNjLE1BQU07RUFDbEMsQ0FBQztFQUVEcUIsV0FBVyxFQUFDLFNBQUFBLFlBQUEsRUFBVTtJQUNsQixPQUFPLElBQUksQ0FBQ25DLFdBQVc7RUFDM0I7QUFFSixDQUFDLENBQUM7QUFDRm9DLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHM0MsaUJBQWlCIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcGFueURhdGEgPSByZXF1aXJlKFwiQ29tcGFueURhdGFcIik7XHJcbnZhciBQcm9EYXRhID0gcmVxdWlyZShcIlByb0RhdGFcIik7XHJcbnZhciBDb21wYW55TWFwRGVjb2RlciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAganNvbk5hbWU6XCJjb21wYW55XCIsXHJcbiAgICAgICAgY29tcGFueUxpc3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltDb21wYW55RGF0YV0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgLy/op6PmnpDmlbDmja5cclxuICAgIERlY29kZUpzb246ZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgLy9jYy5sb2coXCI9PT3op6PmnpDlhazlj7jmlbDmja49PT1cIik7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYucmVDYiA9IGV2ZW50O1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKFwianNvbi9cIitzZWxmLmpzb25OYW1lLCBmdW5jdGlvbiAoZXJyb3IsIG9iaikge1xyXG4gICAgICAgICAgICBpZihlcnJvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCIrKyvop6PmnpDlh7rplJnvvIzmn6XkuItqc29uKysrXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlQ2IoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIganNvblJvb3QgPSBvYmouanNvbi5jb21wYW55O1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIj09PeaVsOaNrumVv+W6pj09PVwiICsganNvblJvb3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uUm9vdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbURhdGEgPSBuZXcgQ29tcGFueURhdGEoKTtcclxuICAgICAgICAgICAgICAgIGNvbURhdGEuSWQgPSBqc29uUm9vdFtpXS5JZDtcclxuICAgICAgICAgICAgICAgIGNvbURhdGEuaWNvbiA9IGpzb25Sb290W2ldLmljb247XHJcbiAgICAgICAgICAgICAgICBjb21EYXRhLm5hbWUgPSBqc29uUm9vdFtpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgY29tRGF0YS5pblByaWNlID0ganNvblJvb3RbaV0uaW5QcmljZTtcclxuICAgICAgICAgICAgICAgIGNvbURhdGEub3V0UHJpY2UgPSBqc29uUm9vdFtpXS5vdXRQcmljZTsgLy/noLTkuqfngrlcclxuICAgICAgICAgICAgICAgIGNvbURhdGEuTGltaXRZZWFyID0ganNvblJvb3RbaV0uTGltaXRZZWFyO1xyXG4gICAgICAgICAgICAgICAgY29tRGF0YS5ib251c1JhdGlvID0ganNvblJvb3RbaV0uYm9udXNSYXRpbztcclxuICAgICAgICAgICAgICAgIC8v5Lmw5Yiw5ZCO5Yi36L+Z5Liq5q+U5L6LXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpzb25Sb290W2ldLnByb0xpc3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvRCA9IG5ldyBQcm9EYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvRC5sb3dSYXRpbyA9IGpzb25Sb290W2ldLnByb0xpc3Rbal1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvRC51cFJhdGlvID0ganNvblJvb3RbaV0ucHJvTGlzdFtqXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ELndlaWdodCA9IGpzb25Sb290W2ldLnByb0xpc3Rbal1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgY29tRGF0YS5wcm9MaXN0W2pdID0gcHJvRDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8v5rKh5pyJ5Lmw5pe25YCZ5Yi36L+Z5Liq5q+U5L6LXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpzb25Sb290W2ldLnVuTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9EID0gbmV3IFByb0RhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ELmxvd1JhdGlvID0ganNvblJvb3RbaV0udW5MaXN0W2pdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb0QudXBSYXRpbyA9IGpzb25Sb290W2ldLnVuTGlzdFtqXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ELndlaWdodCA9IGpzb25Sb290W2ldLnVuTGlzdFtqXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBjb21EYXRhLnVuTGlzdFtqXSA9IHByb0Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBhbnlMaXN0W2ldID0gY29tRGF0YTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5yZUNiKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+mAmui/h+WQjeWtl+aLv+WIsOW9k+WJjeeahOaVsOaNriDkuI3lu7rorq7nlKjvvIzkvaDopoHnlKjmiJHkuZ/msqHlip7ms5VcclxuICAgIGdldERhdGFCeU5hbWU6ZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY29tcGFueUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYobmFtZSA9PSB0aGlzLmNvbXBhbnlMaXN0W2ldLm5hbWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmNvbXBhbnlMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6YCa6L+HaXRlbWlk6I635Y+W5pWw5o2uXHJcbiAgICBnZXREYXRhQnlJdGVtSWQ6ZnVuY3Rpb24oaXRlbUlkKXtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY29tcGFueUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYoaXRlbUlkID09IHRoaXMuY29tcGFueUxpc3RbaV0uSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmNvbXBhbnlMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEpzb25MZW5ndGg6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYW55TGlzdC5sZW5ndGhcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGF0YUxpc3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYW55TGlzdDtcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBDb21wYW55TWFwRGVjb2RlcjtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/EventData/EventTipData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '12ea3sV9XBJQZFiznCm+/8r', 'EventTipData');
// Scripts/DataMap/EventData/EventTipData.js

"use strict";

var EventCost = require("EventCost");
var EventResult = require("EventResult");
var EventTipData = cc.Class({
  name: "EventTipData",
  properties: {
    name: "",
    Id: cc.Integer,
    desId: cc.Integer,
    cost: [EventCost],
    YResults: [EventResult],
    NResults: [EventResult]
  }
});
module.exports = EventTipData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcRXZlbnREYXRhXFxFdmVudFRpcERhdGEuanMiXSwibmFtZXMiOlsiRXZlbnRDb3N0IiwicmVxdWlyZSIsIkV2ZW50UmVzdWx0IiwiRXZlbnRUaXBEYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiSWQiLCJJbnRlZ2VyIiwiZGVzSWQiLCJjb3N0IiwiWVJlc3VsdHMiLCJOUmVzdWx0cyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxHQUFHQyxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlDLFdBQVcsR0FBR0QsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUN4QyxJQUFJRSxZQUFZLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCQyxJQUFJLEVBQUMsY0FBYztFQUNuQkMsVUFBVSxFQUFFO0lBQ1JELElBQUksRUFBQyxFQUFFO0lBQ1BFLEVBQUUsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ2JDLEtBQUssRUFBQ04sRUFBRSxDQUFDSyxPQUFPO0lBQ25CRSxJQUFJLEVBQUMsQ0FBQ1gsU0FBUyxDQUFDO0lBQ2hCWSxRQUFRLEVBQUMsQ0FBQ1YsV0FBVyxDQUFDO0lBQ3RCVyxRQUFRLEVBQUMsQ0FBQ1gsV0FBVztFQUN0QjtBQUNKLENBQUMsQ0FBQztBQUNGWSxNQUFNLENBQUNDLE9BQU8sR0FBR1osWUFBWSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50Q29zdCA9IHJlcXVpcmUoXCJFdmVudENvc3RcIik7XHJcbnZhciBFdmVudFJlc3VsdCA9IHJlcXVpcmUoXCJFdmVudFJlc3VsdFwiKTtcclxudmFyIEV2ZW50VGlwRGF0YSA9IGNjLkNsYXNzKHtcclxuICAgIG5hbWU6XCJFdmVudFRpcERhdGFcIixcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBuYW1lOlwiXCIsXHJcbiAgICAgICAgSWQ6Y2MuSW50ZWdlcixcclxuICAgICAgICBkZXNJZDpjYy5JbnRlZ2VyLFxyXG4gICAgXHRjb3N0OltFdmVudENvc3RdLFxyXG4gICAgXHRZUmVzdWx0czpbRXZlbnRSZXN1bHRdLFxyXG4gICAgXHROUmVzdWx0czpbRXZlbnRSZXN1bHRdLFxyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUaXBEYXRhO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/ExtraData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '375cbfm5aFC0JkiIvXZWV/Q', 'ExtraData');
// Scripts/DataMap/ExtraData.js

"use strict";

//作为额外条件 数据
var ExtraData = cc.Class({
  name: "ExtraData",
  properties: {
    ItemType: cc.Integer,
    ItemId: cc.Integer
  }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcRXh0cmFEYXRhLmpzIl0sIm5hbWVzIjpbIkV4dHJhRGF0YSIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsIkl0ZW1UeXBlIiwiSW50ZWdlciIsIkl0ZW1JZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLElBQUlBLFNBQVMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDeEJDLElBQUksRUFBQyxXQUFXO0VBQ2JDLFVBQVUsRUFBRTtJQUNUQyxRQUFRLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUNuQkMsTUFBTSxFQUFDTixFQUFFLENBQUNLO0VBQ2I7QUFDSixDQUFDLENBQUMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8v5L2c5Li66aKd5aSW5p2h5Lu2IOaVsOaNrlxyXG52YXIgRXh0cmFEYXRhID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJFeHRyYURhdGFcIixcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgIEl0ZW1UeXBlOmNjLkludGVnZXIsXHJcbiAgICAgICBJdGVtSWQ6Y2MuSW50ZWdlcixcclxuICAgIH0sXHJcbn0pO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Goods/GoodMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '08823KuKwxPSq8h7YOSb282', 'GoodMapDecoder');
// Scripts/DataMap/Goods/GoodMapDecoder.js

"use strict";

var GoodsData = require("GoodsData");
var PriceData = require("PriceData");
var GoodMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "goods",
    goodsList: {
      "default": [],
      type: [GoodsData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析物品数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.goods;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var goodsData = new GoodsData();
        goodsData.sex = jsonRoot[i].sex;
        goodsData.Id = jsonRoot[i].itemId;
        goodsData.icon = jsonRoot[i].icon;
        goodsData.name = jsonRoot[i].name;
        for (var j = 0; j < jsonRoot[i].priceList.length; j++) {
          var price = new PriceData();
          var data = jsonRoot[i].priceList[j];
          price.lowprice = data[0];
          price.highprice = data[1];
          price.probability = data[2];
          goodsData.priceList[j] = price;
        }
        self.goodsList[i] = goodsData;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.goodsList.length - 1; i >= 0; i--) {
      if (name == this.goodsList[i].name) {
        data = this.goodsList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.goodsList.length - 1; i >= 0; i--) {
      if (itemId == this.goodsList[i].Id) {
        data = this.goodsList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.goodsList.length;
  },
  getDataList: function getDataList() {
    return this.goodsList;
  },
  getDataListBySex: function getDataListBySex(Sex) {
    var dataList = [];
    //var index = 0;
    for (var i = 0; i < this.goodsList.length; i++) {
      if (this.goodsList[i].sex == Sex || this.goodsList[i].sex == 0) {
        //dataList[index] = this.goodsList[i];
        //index += 1;
        dataList.push(this.goodsList[i]);
      }
    }
    //cc.log("对应性别的玩家展示物品种类 ====== " + dataList.length);
    return dataList;
  }
});
module.exports = GoodMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcR29vZHNcXEdvb2RNYXBEZWNvZGVyLmpzIl0sIm5hbWVzIjpbIkdvb2RzRGF0YSIsInJlcXVpcmUiLCJQcmljZURhdGEiLCJHb29kTWFwRGVjb2RlciIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwianNvbk5hbWUiLCJnb29kc0xpc3QiLCJ0eXBlIiwiRGVjb2RlSnNvbiIsImV2ZW50Iiwic2VsZiIsInJlQ2IiLCJsb2FkZXIiLCJsb2FkUmVzIiwiZXJyb3IiLCJvYmoiLCJqc29uUm9vdCIsImpzb24iLCJnb29kcyIsImkiLCJsZW5ndGgiLCJnb29kc0RhdGEiLCJzZXgiLCJJZCIsIml0ZW1JZCIsImljb24iLCJuYW1lIiwiaiIsInByaWNlTGlzdCIsInByaWNlIiwiZGF0YSIsImxvd3ByaWNlIiwiaGlnaHByaWNlIiwicHJvYmFiaWxpdHkiLCJnZXREYXRhQnlOYW1lIiwiZ2V0RGF0YUJ5SXRlbUlkIiwiZ2V0SnNvbkxlbmd0aCIsImdldERhdGFMaXN0IiwiZ2V0RGF0YUxpc3RCeVNleCIsIlNleCIsImRhdGFMaXN0IiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxHQUFHQyxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlDLFNBQVMsR0FBR0QsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUNwQyxJQUFJRSxjQUFjLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzFCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFFBQVEsRUFBQyxPQUFPO0lBQ2hCQyxTQUFTLEVBQUM7TUFDTixXQUFRLEVBQUU7TUFDVkMsSUFBSSxFQUFDLENBQUNWLFNBQVM7SUFDbkI7RUFDSixDQUFDO0VBRUQ7RUFDQVcsVUFBVSxFQUFDLFNBQUFBLFdBQVVDLEtBQUssRUFBRTtJQUN4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SSxHQUFHLElBQUksQ0FBQ3hCLFNBQVMsQ0FBQ2EsQ0FBQyxDQUFDO1FBQ3hCO01BQ0o7SUFDSjtJQUNBLE9BQU9XLElBQUk7RUFDZixDQUFDO0VBRURNLGFBQWEsRUFBQyxTQUFBQSxjQUFBLEVBQVU7SUFDcEIsT0FBTyxJQUFJLENBQUM5QixTQUFTLENBQUNjLE1BQU07RUFDaEMsQ0FBQztFQUVEaUIsV0FBVyxFQUFDLFNBQUFBLFlBQUEsRUFBVTtJQUNsQixPQUFPLElBQUksQ0FBQy9CLFNBQVM7RUFDekIsQ0FBQztFQUVEZ0MsZ0JBQWdCLEVBQUMsU0FBQUEsaUJBQVNDLEdBQUcsRUFBQztJQUMxQixJQUFJQyxRQUFRLEdBQUcsRUFBRTtJQUNqQjtJQUNBLEtBQUssSUFBSXJCLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRyxJQUFJLENBQUNiLFNBQVMsQ0FBQ2MsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUM1QyxJQUFHLElBQUksQ0FBQ2IsU0FBUyxDQUFDYSxDQUFDLENBQUMsQ0FBQ0csR0FBRyxJQUFJaUIsR0FBRyxJQUFJLElBQUksQ0FBQ2pDLFNBQVMsQ0FBQ2EsQ0FBQyxDQUFDLENBQUNHLEdBQUcsSUFBSSxDQUFDLEVBQzdEO1FBQ0k7UUFDQTtRQUNBa0IsUUFBUSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDbkMsU0FBUyxDQUFDYSxDQUFDLENBQUMsQ0FBQztNQUNwQztJQUNKO0lBQ0E7SUFDQSxPQUFPcUIsUUFBUTtFQUNuQjtBQUNKLENBQUMsQ0FBQztBQUNGRSxNQUFNLENBQUNDLE9BQU8sR0FBRzNDLGNBQWMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBHb29kc0RhdGEgPSByZXF1aXJlKFwiR29vZHNEYXRhXCIpO1xyXG52YXIgUHJpY2VEYXRhID0gcmVxdWlyZShcIlByaWNlRGF0YVwiKTtcclxudmFyIEdvb2RNYXBEZWNvZGVyID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBqc29uTmFtZTpcImdvb2RzXCIsXHJcbiAgICAgICAgZ29vZHNMaXN0OntcclxuICAgICAgICAgICAgZGVmYXVsdDpbXSxcclxuICAgICAgICAgICAgdHlwZTpbR29vZHNEYXRhXSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuXHJcbiAgICAvL+ino+aekOaVsOaNrlxyXG4gICAgRGVjb2RlSnNvbjpmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAvL2NjLmxvZyhcIj09Peino+aekOeJqeWTgeaVsOaNrj09PVwiKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5yZUNiID0gZXZlbnQ7XHJcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoXCJqc29uL1wiK3NlbGYuanNvbk5hbWUsIGZ1bmN0aW9uIChlcnJvciwgb2JqKSB7XHJcbiAgICAgICAgICAgIGlmKGVycm9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIisrK+ino+aekOWHuumUme+8jOafpeS4i2pzb24rKytcIiArIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHNlbGYucmVDYihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBqc29uUm9vdCA9IG9iai5qc29uLmdvb2RzO1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIj09PeaVsOaNrumVv+W6pj09PVwiICsganNvblJvb3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uUm9vdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdvb2RzRGF0YSA9IG5ldyBHb29kc0RhdGEoKTtcclxuICAgICAgICAgICAgICAgIGdvb2RzRGF0YS5zZXggPSBqc29uUm9vdFtpXS5zZXg7XHJcbiAgICAgICAgICAgICAgICBnb29kc0RhdGEuSWQgPSBqc29uUm9vdFtpXS5pdGVtSWQ7XHJcbiAgICAgICAgICAgICAgICBnb29kc0RhdGEuaWNvbiA9IGpzb25Sb290W2ldLmljb247XHJcbiAgICAgICAgICAgICAgICBnb29kc0RhdGEubmFtZSA9IGpzb25Sb290W2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpzb25Sb290W2ldLnByaWNlTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmljZSA9IG5ldyBQcmljZURhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGpzb25Sb290W2ldLnByaWNlTGlzdFtqXTtcclxuICAgICAgICAgICAgICAgICAgICBwcmljZS5sb3dwcmljZSA9IGRhdGFbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpY2UuaGlnaHByaWNlID0gZGF0YVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBwcmljZS5wcm9iYWJpbGl0eSA9IGRhdGFbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgZ29vZHNEYXRhLnByaWNlTGlzdFtqXSA9ICBwcmljZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYuZ29vZHNMaXN0W2ldID0gZ29vZHNEYXRhOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnJlQ2IodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6YCa6L+H5ZCN5a2X5ou/5Yiw5b2T5YmN55qE5pWw5o2uIOS4jeW7uuiurueUqO+8jOS9oOimgeeUqOaIkeS5n+ayoeWKnuazlVxyXG4gICAgZ2V0RGF0YUJ5TmFtZTpmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5nb29kc0xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYobmFtZSA9PSB0aGlzLmdvb2RzTGlzdFtpXS5uYW1lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5nb29kc0xpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgJrov4dpdGVtaWTojrflj5bmlbDmja5cclxuICAgIGdldERhdGFCeUl0ZW1JZDpmdW5jdGlvbihpdGVtSWQpe1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5nb29kc0xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYoaXRlbUlkID09IHRoaXMuZ29vZHNMaXN0W2ldLklkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5nb29kc0xpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SnNvbkxlbmd0aDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdvb2RzTGlzdC5sZW5ndGhcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGF0YUxpc3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5nb29kc0xpc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGFMaXN0QnlTZXg6ZnVuY3Rpb24oU2V4KXtcclxuICAgICAgICB2YXIgZGF0YUxpc3QgPSBbXTtcclxuICAgICAgICAvL3ZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdvb2RzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZih0aGlzLmdvb2RzTGlzdFtpXS5zZXggPT0gU2V4IHx8IHRoaXMuZ29vZHNMaXN0W2ldLnNleCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2RhdGFMaXN0W2luZGV4XSA9IHRoaXMuZ29vZHNMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgLy9pbmRleCArPSAxO1xyXG4gICAgICAgICAgICAgICAgZGF0YUxpc3QucHVzaCh0aGlzLmdvb2RzTGlzdFtpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NjLmxvZyhcIuWvueW6lOaAp+WIq+eahOeOqeWutuWxleekuueJqeWTgeenjeexuyA9PT09PT0gXCIgKyBkYXRhTGlzdC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBkYXRhTGlzdDtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEdvb2RNYXBEZWNvZGVyO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Company/ProData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4e1b05PteZAdI9Ijj7OZHcm', 'ProData');
// Scripts/DataMap/Company/ProData.js

"use strict";

var ProData = cc.Class({
  name: "ProData",
  properties: {
    lowRatio: 0.8,
    //盈利亏损比例
    upRatio: 0.9,
    weight: 0.5 //权值
  }
});

module.exports = ProData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcQ29tcGFueVxcUHJvRGF0YS5qcyJdLCJuYW1lcyI6WyJQcm9EYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwibG93UmF0aW8iLCJ1cFJhdGlvIiwid2VpZ2h0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxPQUFPLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ25CQyxJQUFJLEVBQUMsU0FBUztFQUNkQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDLEdBQUc7SUFBRTtJQUNkQyxPQUFPLEVBQUMsR0FBRztJQUNYQyxNQUFNLEVBQUMsR0FBRyxDQUFDO0VBQ2Y7QUFDSixDQUFDLENBQUM7O0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHVCxPQUFPIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUHJvRGF0YSA9IGNjLkNsYXNzKHtcclxuICAgIG5hbWU6XCJQcm9EYXRhXCIsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgbG93UmF0aW86MC44LCAvL+ebiOWIqeS6j+aNn+avlOS+i1xyXG4gICAgICAgIHVwUmF0aW86MC45LFxyXG4gICAgICAgIHdlaWdodDowLjUsLy/mnYPlgLxcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFByb0RhdGE7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Goods/PriceData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b1ae83pxnVFQpySv+2WQ5Oz', 'PriceData');
// Scripts/DataMap/Goods/PriceData.js

"use strict";

var PriceData = cc.Class({
  name: "PriceData",
  properties: {
    lowprice: cc.Integer,
    highprice: cc.Integer,
    probability: 0.25
  }
});
module.exports = PriceData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcR29vZHNcXFByaWNlRGF0YS5qcyJdLCJuYW1lcyI6WyJQcmljZURhdGEiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJsb3dwcmljZSIsIkludGVnZXIiLCJoaWdocHJpY2UiLCJwcm9iYWJpbGl0eSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN4QkMsSUFBSSxFQUFDLFdBQVc7RUFDYkMsVUFBVSxFQUFFO0lBQ1JDLFFBQVEsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ25CQyxTQUFTLEVBQUNOLEVBQUUsQ0FBQ0ssT0FBTztJQUNwQkUsV0FBVyxFQUFDO0VBQ2hCO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHVixTQUFTIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUHJpY2VEYXRhID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJQcmljZURhdGFcIixcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBsb3dwcmljZTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGhpZ2hwcmljZTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIHByb2JhYmlsaXR5OjAuMjUsXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBQcmljZURhdGE7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/EventData/EventCost.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3caccHc0GxJi5LolPSPC3vq', 'EventCost');
// Scripts/DataMap/EventData/EventCost.js

"use strict";

var EventCost = cc.Class({
  name: "EventCost",
  properties: {
    costType: cc.Integer,
    costNum: cc.Integer,
    desId: cc.Integer
  }
});
module.exports = EventCost;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcRXZlbnREYXRhXFxFdmVudENvc3QuanMiXSwibmFtZXMiOlsiRXZlbnRDb3N0IiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiY29zdFR5cGUiLCJJbnRlZ2VyIiwiY29zdE51bSIsImRlc0lkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxTQUFTLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3JCQyxJQUFJLEVBQUMsV0FBVztFQUNoQkMsVUFBVSxFQUFFO0lBQ1JDLFFBQVEsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ25CQyxPQUFPLEVBQUNOLEVBQUUsQ0FBQ0ssT0FBTztJQUNsQkUsS0FBSyxFQUFDUCxFQUFFLENBQUNLO0VBQ2I7QUFDSixDQUFDLENBQUM7QUFDRkcsTUFBTSxDQUFDQyxPQUFPLEdBQUdWLFNBQVMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgRXZlbnRDb3N0ID0gY2MuQ2xhc3Moe1xyXG4gICAgbmFtZTpcIkV2ZW50Q29zdFwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGNvc3RUeXBlOmNjLkludGVnZXIsXHJcbiAgICAgICAgY29zdE51bTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGRlc0lkOmNjLkludGVnZXIsXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvc3Q7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/EventData/EventResult.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a61delrW3ZFS5ww7YVqJjQQ', 'EventResult');
// Scripts/DataMap/EventData/EventResult.js

"use strict";

var EventResult = cc.Class({
  name: "EventResult",
  properties: {
    rewardType: cc.Integer,
    rewardNum: cc.Integer,
    rewardId: cc.Integer,
    desId: cc.Integer
  }
});
module.exports = EventResult;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcRXZlbnREYXRhXFxFdmVudFJlc3VsdC5qcyJdLCJuYW1lcyI6WyJFdmVudFJlc3VsdCIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsInJld2FyZFR5cGUiLCJJbnRlZ2VyIiwicmV3YXJkTnVtIiwicmV3YXJkSWQiLCJkZXNJZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsV0FBVyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN2QkMsSUFBSSxFQUFFLGFBQWE7RUFDbkJDLFVBQVUsRUFBRTtJQUNSQyxVQUFVLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUNyQkMsU0FBUyxFQUFDTixFQUFFLENBQUNLLE9BQU87SUFDcEJFLFFBQVEsRUFBQ1AsRUFBRSxDQUFDSyxPQUFPO0lBQ25CRyxLQUFLLEVBQUNSLEVBQUUsQ0FBQ0s7RUFDYjtBQUNKLENBQUMsQ0FBQztBQUNGSSxNQUFNLENBQUNDLE9BQU8sR0FBR1gsV0FBVyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBFdmVudFJlc3VsdCA9IGNjLkNsYXNzKHtcclxuICAgIG5hbWU6IFwiRXZlbnRSZXN1bHRcIixcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICByZXdhcmRUeXBlOmNjLkludGVnZXIsXHJcbiAgICAgICAgcmV3YXJkTnVtOmNjLkludGVnZXIsXHJcbiAgICAgICAgcmV3YXJkSWQ6Y2MuSW50ZWdlcixcclxuICAgICAgICBkZXNJZDpjYy5JbnRlZ2VyLFxyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRSZXN1bHQ7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/InitCash/CashData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '95b736a9kxM+onSeIwd5Tbs', 'CashData');
// Scripts/DataMap/InitCash/CashData.js

"use strict";

var CashData = cc.Class({
  name: "CashData",
  properties: {
    name: "",
    Id: cc.Integer,
    cash: cc.Integer,
    weight: 0.4
  }
});
module.exports = CashData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcSW5pdENhc2hcXENhc2hEYXRhLmpzIl0sIm5hbWVzIjpbIkNhc2hEYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiSWQiLCJJbnRlZ2VyIiwiY2FzaCIsIndlaWdodCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsUUFBUSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNwQkMsSUFBSSxFQUFDLFVBQVU7RUFDZkMsVUFBVSxFQUFFO0lBQ1hELElBQUksRUFBQyxFQUFFO0lBQ0pFLEVBQUUsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ2JDLElBQUksRUFBQ04sRUFBRSxDQUFDSyxPQUFPO0lBQ2ZFLE1BQU0sRUFBQztFQUNYO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHVixRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIENhc2hEYXRhID0gY2MuQ2xhc3Moe1xyXG4gICAgbmFtZTpcIkNhc2hEYXRhXCIsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICBcdG5hbWU6XCJcIixcclxuICAgICAgICBJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGNhc2g6Y2MuSW50ZWdlcixcclxuICAgICAgICB3ZWlnaHQ6MC40LFxyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ2FzaERhdGE7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/House/HouseData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd4514ptri1CcIKDp9Qx8e/i', 'HouseData');
// Scripts/DataMap/House/HouseData.js

"use strict";

var HouseData = cc.Class({
  name: "HouseData",
  properties: {
    Id: cc.Integer,
    price: cc.Integer,
    icon: "",
    name: "",
    addBonus: cc.Integer,
    //增加名声
    addHp: cc.Integer //增加健康值
  }
});

module.exports = HouseData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcSG91c2VcXEhvdXNlRGF0YS5qcyJdLCJuYW1lcyI6WyJIb3VzZURhdGEiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJJZCIsIkludGVnZXIiLCJwcmljZSIsImljb24iLCJhZGRCb251cyIsImFkZEhwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxTQUFTLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCQyxJQUFJLEVBQUMsV0FBVztFQUNiQyxVQUFVLEVBQUU7SUFDUkMsRUFBRSxFQUFDSixFQUFFLENBQUNLLE9BQU87SUFDYkMsS0FBSyxFQUFDTixFQUFFLENBQUNLLE9BQU87SUFDaEJFLElBQUksRUFBQyxFQUFFO0lBQ1BMLElBQUksRUFBQyxFQUFFO0lBQ1BNLFFBQVEsRUFBQ1IsRUFBRSxDQUFDSyxPQUFPO0lBQUU7SUFDM0JJLEtBQUssRUFBQ1QsRUFBRSxDQUFDSyxPQUFPLENBQUM7RUFDZjtBQUVKLENBQUMsQ0FBQzs7QUFDRkssTUFBTSxDQUFDQyxPQUFPLEdBQUdaLFNBQVMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIb3VzZURhdGEgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIkhvdXNlRGF0YVwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIElkOmNjLkludGVnZXIsXHJcbiAgICAgICAgcHJpY2U6Y2MuSW50ZWdlcixcclxuICAgICAgICBpY29uOlwiXCIsXHJcbiAgICAgICAgbmFtZTpcIlwiLFxyXG4gICAgICAgIGFkZEJvbnVzOmNjLkludGVnZXIsIC8v5aKe5Yqg5ZCN5aOwXHJcblx0XHRhZGRIcDpjYy5JbnRlZ2VyLC8v5aKe5Yqg5YGl5bq35YC8XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gSG91c2VEYXRhO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Mate/MateMapDecoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '7f3b3DmP6JH66SZKW6JkCF9', 'MateMapDecoder');
// Scripts/DataMap/Mate/MateMapDecoder.js

"use strict";

var LovePointCost = require("LovePointCost");
var MateData = require("MateData");
var MateBonus = require("MateBonus");
var MateGetCond = require("MateGetCond");
var MateMapDecoder = cc.Class({
  "extends": cc.Component,
  properties: {
    jsonName: "mate",
    mateList: {
      "default": [],
      type: [MateData]
    }
  },
  //解析数据
  DecodeJson: function DecodeJson(event) {
    //cc.log("===解析伴侣数据===");
    var self = this;
    self.reCb = event;
    cc.loader.loadRes("json/" + self.jsonName, function (error, obj) {
      if (error) {
        //cc.log("+++解析出错，查下json+++" + error);
        self.reCb(false);
        return;
      }
      var jsonRoot = obj.json.mate;
      //cc.log("===数据长度===" + jsonRoot.length);
      for (var i = 0; i < jsonRoot.length; i++) {
        var mateData = new MateData();
        mateData.Id = jsonRoot[i].Id;
        mateData.icon = jsonRoot[i].icon;
        mateData.sex = jsonRoot[i].sex;
        mateData.name = jsonRoot[i].name;
        mateData.unlockCond = jsonRoot[i].unlockCond; //可以约会条件
        ////cc.log(jsonRoot[i].name + " 是否可以直接约会的" + mateData.unlockCond);
        for (var j = 0; j < jsonRoot[i].getCond.length; j++) {
          var getCond = new MateGetCond();
          getCond.unlockType = jsonRoot[i].getCond[j][0];
          getCond.value = jsonRoot[i].getCond[j][1];
          mateData.getCondList[j] = getCond;
        }
        for (var j = 0; j < jsonRoot[i].lovePointList.length; j++) {
          var lpCost = new LovePointCost();
          lpCost.cost = jsonRoot[i].lovePointList[j][2];
          lpCost.LovePoint = jsonRoot[i].lovePointList[j][1];
          lpCost.curLevel = jsonRoot[i].lovePointList[j][0];
          mateData.lovePointList[j] = lpCost;
        }
        for (var j = 0; j < jsonRoot[i].bonusList.length; j++) {
          var lpCost = new MateBonus();
          lpCost.bonusType = jsonRoot[i].bonusList[j][0];
          lpCost.bonusNum = jsonRoot[i].bonusList[j][1];
          mateData.bonusList[j] = lpCost;
        }
        self.mateList[i] = mateData;
      }
      self.reCb(true);
    });
  },
  //通过名字拿到当前的数据 不建议用，你要用我也没办法
  getDataByName: function getDataByName(name) {
    var data = null;
    for (var i = this.mateListmateList.length - 1; i >= 0; i--) {
      if (name == this.mateList[i].name) {
        data = this.mateList[i];
        break;
      }
    }
    return data;
  },
  //通过itemid获取数据
  getDataByItemId: function getDataByItemId(itemId) {
    var data = null;
    for (var i = this.mateList.length - 1; i >= 0; i--) {
      if (itemId == this.mateList[i].Id) {
        data = this.mateList[i];
        break;
      }
    }
    return data;
  },
  getJsonLength: function getJsonLength() {
    return this.mateList.length;
  },
  getDataList: function getDataList() {
    return this.mateList;
  }
});
module.exports = MateMapDecoder;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcTWF0ZVxcTWF0ZU1hcERlY29kZXIuanMiXSwibmFtZXMiOlsiTG92ZVBvaW50Q29zdCIsInJlcXVpcmUiLCJNYXRlRGF0YSIsIk1hdGVCb251cyIsIk1hdGVHZXRDb25kIiwiTWF0ZU1hcERlY29kZXIiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImpzb25OYW1lIiwibWF0ZUxpc3QiLCJ0eXBlIiwiRGVjb2RlSnNvbiIsImV2ZW50Iiwic2VsZiIsInJlQ2IiLCJsb2FkZXIiLCJsb2FkUmVzIiwiZXJyb3IiLCJvYmoiLCJqc29uUm9vdCIsImpzb24iLCJtYXRlIiwiaSIsImxlbmd0aCIsIm1hdGVEYXRhIiwiSWQiLCJpY29uIiwic2V4IiwibmFtZSIsInVubG9ja0NvbmQiLCJqIiwiZ2V0Q29uZCIsInVubG9ja1R5cGUiLCJ2YWx1ZSIsImdldENvbmRMaXN0IiwibG92ZVBvaW50TGlzdCIsImxwQ29zdCIsImNvc3QiLCJMb3ZlUG9pbnQiLCJjdXJMZXZlbCIsImJvbnVzTGlzdCIsImJvbnVzVHlwZSIsImJvbnVzTnVtIiwiZ2V0RGF0YUJ5TmFtZSIsImRhdGEiLCJtYXRlTGlzdG1hdGVMaXN0IiwiZ2V0RGF0YUJ5SXRlbUlkIiwiaXRlbUlkIiwiZ2V0SnNvbkxlbmd0aCIsImdldERhdGFMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxhQUFhLEdBQUdDLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFDNUMsSUFBSUMsUUFBUSxHQUFHRCxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlFLFNBQVMsR0FBR0YsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUNwQyxJQUFJRyxXQUFXLEdBQUdILE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDeEMsSUFBSUksY0FBYyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUMxQixXQUFT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LElBQUlILElBQUksR0FBRyxJQUFJO0lBQ2YsS0FBSyxJQUFJdEIsQ0FBQyxHQUFHLElBQUksQ0FBQ2IsUUFBUSxDQUFDYyxNQUFNLEdBQUcsQ0FBQyxFQUFFRCxDQUFDLElBQUksQ0FBQyxFQUFFQSxDQUFDLEVBQUUsRUFBRTtNQUNoRCxJQUFHeUIsTUFBTSxJQUFJLElBQUksQ0FBQ3RDLFFBQVEsQ0FBQ2EsQ0FBQyxDQUFDLENBQUNHLEVBQUUsRUFDaEM7UUFDSW1CLElBQUksR0FBRyxJQUFJLENBQUNuQyxRQUFRLENBQUNhLENBQUMsQ0FBQztRQUN2QjtNQUNKO0lBQ0o7SUFDQSxPQUFPc0IsSUFBSTtFQUNmLENBQUM7RUFFREksYUFBYSxFQUFDLFNBQUFBLGNBQUEsRUFBVTtJQUNwQixPQUFPLElBQUksQ0FBQ3ZDLFFBQVEsQ0FBQ2MsTUFBTTtFQUMvQixDQUFDO0VBRUQwQixXQUFXLEVBQUMsU0FBQUEsWUFBQSxFQUFVO0lBQ2xCLE9BQU8sSUFBSSxDQUFDeEMsUUFBUTtFQUN4QjtBQUVKLENBQUMsQ0FBQztBQUNGeUMsTUFBTSxDQUFDQyxPQUFPLEdBQUdoRCxjQUFjIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTG92ZVBvaW50Q29zdCA9IHJlcXVpcmUoXCJMb3ZlUG9pbnRDb3N0XCIpO1xyXG52YXIgTWF0ZURhdGEgPSByZXF1aXJlKFwiTWF0ZURhdGFcIik7XHJcbnZhciBNYXRlQm9udXMgPSByZXF1aXJlKFwiTWF0ZUJvbnVzXCIpO1xyXG52YXIgTWF0ZUdldENvbmQgPSByZXF1aXJlKFwiTWF0ZUdldENvbmRcIik7XHJcbnZhciBNYXRlTWFwRGVjb2RlciA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAganNvbk5hbWU6XCJtYXRlXCIsXHJcbiAgICAgICAgbWF0ZUxpc3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltNYXRlRGF0YV0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgLy/op6PmnpDmlbDmja5cclxuICAgIERlY29kZUpzb246ZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgLy9jYy5sb2coXCI9PT3op6PmnpDkvLTkvqPmlbDmja49PT1cIik7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYucmVDYiA9IGV2ZW50O1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKFwianNvbi9cIitzZWxmLmpzb25OYW1lLCBmdW5jdGlvbiAoZXJyb3IsIG9iaikge1xyXG4gICAgICAgICAgICBpZihlcnJvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCIrKyvop6PmnpDlh7rplJnvvIzmn6XkuItqc29uKysrXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlQ2IoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIganNvblJvb3QgPSBvYmouanNvbi5tYXRlO1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIj09PeaVsOaNrumVv+W6pj09PVwiICsganNvblJvb3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uUm9vdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGVEYXRhID0gbmV3IE1hdGVEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBtYXRlRGF0YS5JZCA9IGpzb25Sb290W2ldLklkO1xyXG4gICAgICAgICAgICAgICAgbWF0ZURhdGEuaWNvbiA9IGpzb25Sb290W2ldLmljb247XHJcbiAgICAgICAgICAgICAgICBtYXRlRGF0YS5zZXggPSBqc29uUm9vdFtpXS5zZXg7XHJcbiAgICAgICAgICAgICAgICBtYXRlRGF0YS5uYW1lID0ganNvblJvb3RbaV0ubmFtZTtcclxuICAgICAgICAgICAgICAgIG1hdGVEYXRhLnVubG9ja0NvbmQgPSBqc29uUm9vdFtpXS51bmxvY2tDb25kOy8v5Y+v5Lul57qm5Lya5p2h5Lu2XHJcbiAgICAgICAgICAgICAgICAvLy8vY2MubG9nKGpzb25Sb290W2ldLm5hbWUgKyBcIiDmmK/lkKblj6/ku6Xnm7TmjqXnuqbkvJrnmoRcIiArIG1hdGVEYXRhLnVubG9ja0NvbmQpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBqc29uUm9vdFtpXS5nZXRDb25kLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldENvbmQgPSBuZXcgTWF0ZUdldENvbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25kLnVubG9ja1R5cGUgPSBqc29uUm9vdFtpXS5nZXRDb25kW2pdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbmQudmFsdWUgPSBqc29uUm9vdFtpXS5nZXRDb25kW2pdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGVEYXRhLmdldENvbmRMaXN0W2pdID0gZ2V0Q29uZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpzb25Sb290W2ldLmxvdmVQb2ludExpc3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbHBDb3N0ID0gbmV3IExvdmVQb2ludENvc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBscENvc3QuY29zdCA9IGpzb25Sb290W2ldLmxvdmVQb2ludExpc3Rbal1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgbHBDb3N0LkxvdmVQb2ludCA9IGpzb25Sb290W2ldLmxvdmVQb2ludExpc3Rbal1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbHBDb3N0LmN1ckxldmVsID0ganNvblJvb3RbaV0ubG92ZVBvaW50TGlzdFtqXVswXTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRlRGF0YS5sb3ZlUG9pbnRMaXN0W2pdID0gbHBDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwganNvblJvb3RbaV0uYm9udXNMaXN0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxwQ29zdCA9IG5ldyBNYXRlQm9udXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBscENvc3QuYm9udXNUeXBlID0ganNvblJvb3RbaV0uYm9udXNMaXN0W2pdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxwQ29zdC5ib251c051bSA9IGpzb25Sb290W2ldLmJvbnVzTGlzdFtqXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRlRGF0YS5ib251c0xpc3Rbal0gPSBscENvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLm1hdGVMaXN0W2ldID0gbWF0ZURhdGE7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYucmVDYih0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pgJrov4flkI3lrZfmi7/liLDlvZPliY3nmoTmlbDmja4g5LiN5bu66K6u55So77yM5L2g6KaB55So5oiR5Lmf5rKh5Yqe5rOVXHJcbiAgICBnZXREYXRhQnlOYW1lOmZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1hdGVMaXN0bWF0ZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYobmFtZSA9PSB0aGlzLm1hdGVMaXN0W2ldLm5hbWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLm1hdGVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v6YCa6L+HaXRlbWlk6I635Y+W5pWw5o2uXHJcbiAgICBnZXREYXRhQnlJdGVtSWQ6ZnVuY3Rpb24oaXRlbUlkKXtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubWF0ZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYoaXRlbUlkID09IHRoaXMubWF0ZUxpc3RbaV0uSWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLm1hdGVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEpzb25MZW5ndGg6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRlTGlzdC5sZW5ndGhcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGF0YUxpc3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRlTGlzdDtcclxuICAgIH0sXHJcbiAgICBcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTWF0ZU1hcERlY29kZXI7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Mate/MateData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '181c6ZoJ+BJ+7w9O+xMT2d3', 'MateData');
// Scripts/DataMap/Mate/MateData.js

"use strict";

var LovePointCost = require("LovePointCost");
var MateGetCond = require("MateGetCond");
var MateBonus = require("MateBonus");
var MateData = cc.Class({
  name: "MateData",
  properties: {
    Id: cc.Integer,
    icon: "",
    name: "",
    bonusList: [MateBonus],
    unlockCond: cc.Integer,
    getCondList: [MateGetCond],
    sex: cc.Integer,
    lovePointList: [LovePointCost]
  }
});
module.exports = MateData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcTWF0ZVxcTWF0ZURhdGEuanMiXSwibmFtZXMiOlsiTG92ZVBvaW50Q29zdCIsInJlcXVpcmUiLCJNYXRlR2V0Q29uZCIsIk1hdGVCb251cyIsIk1hdGVEYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiSWQiLCJJbnRlZ2VyIiwiaWNvbiIsImJvbnVzTGlzdCIsInVubG9ja0NvbmQiLCJnZXRDb25kTGlzdCIsInNleCIsImxvdmVQb2ludExpc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLGFBQWEsR0FBR0MsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUM1QyxJQUFJQyxXQUFXLEdBQUdELE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDeEMsSUFBSUUsU0FBUyxHQUFHRixPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlHLFFBQVEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDdkJDLElBQUksRUFBQyxVQUFVO0VBQ1pDLFVBQVUsRUFBRTtJQUNSQyxFQUFFLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUNiQyxJQUFJLEVBQUMsRUFBRTtJQUNQSixJQUFJLEVBQUMsRUFBRTtJQUNQSyxTQUFTLEVBQUMsQ0FBQ1QsU0FBUyxDQUFDO0lBQ3JCVSxVQUFVLEVBQUNSLEVBQUUsQ0FBQ0ssT0FBTztJQUNyQkksV0FBVyxFQUFDLENBQUNaLFdBQVcsQ0FBQztJQUN6QmEsR0FBRyxFQUFDVixFQUFFLENBQUNLLE9BQU87SUFDZE0sYUFBYSxFQUFDLENBQUNoQixhQUFhO0VBQ2hDO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZpQixNQUFNLENBQUNDLE9BQU8sR0FBR2QsUUFBUSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIExvdmVQb2ludENvc3QgPSByZXF1aXJlKFwiTG92ZVBvaW50Q29zdFwiKTtcclxudmFyIE1hdGVHZXRDb25kID0gcmVxdWlyZShcIk1hdGVHZXRDb25kXCIpO1xyXG52YXIgTWF0ZUJvbnVzID0gcmVxdWlyZShcIk1hdGVCb251c1wiKTtcclxudmFyIE1hdGVEYXRhID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJNYXRlRGF0YVwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIElkOmNjLkludGVnZXIsXHJcbiAgICAgICAgaWNvbjpcIlwiLFxyXG4gICAgICAgIG5hbWU6XCJcIixcclxuICAgICAgICBib251c0xpc3Q6W01hdGVCb251c10sXHJcbiAgICAgICAgdW5sb2NrQ29uZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGdldENvbmRMaXN0OltNYXRlR2V0Q29uZF0sXHJcbiAgICAgICAgc2V4OmNjLkludGVnZXIsXHJcbiAgICAgICAgbG92ZVBvaW50TGlzdDpbTG92ZVBvaW50Q29zdF0sXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlRGF0YTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Skill/CostData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '92ad6/sQ0FEBqil3P2Gs4Nj', 'CostData');
// Scripts/DataMap/Skill/CostData.js

"use strict";

var CostData = cc.Class({
  name: "CostData",
  properties: {
    toLevel: cc.Integer,
    cost: cc.Integer,
    addBonus: cc.Integer
  }
});
module.exports = CostData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcU2tpbGxcXENvc3REYXRhLmpzIl0sIm5hbWVzIjpbIkNvc3REYXRhIiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwidG9MZXZlbCIsIkludGVnZXIiLCJjb3N0IiwiYWRkQm9udXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLFFBQVEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDdkJDLElBQUksRUFBQyxVQUFVO0VBQ1pDLFVBQVUsRUFBRTtJQUNSQyxPQUFPLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUNsQkMsSUFBSSxFQUFDTixFQUFFLENBQUNLLE9BQU87SUFDZkUsUUFBUSxFQUFDUCxFQUFFLENBQUNLO0VBQ2hCO0FBRUosQ0FBQyxDQUFDO0FBQ0ZHLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHVixRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIENvc3REYXRhID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJDb3N0RGF0YVwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHRvTGV2ZWw6Y2MuSW50ZWdlcixcclxuICAgICAgICBjb3N0OmNjLkludGVnZXIsXHJcbiAgICAgICAgYWRkQm9udXM6Y2MuSW50ZWdlcixcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBDb3N0RGF0YTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/GoodsStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '54a6bfQj3VN9pWdfuhsytdD', 'GoodsStruct');
// Scripts/OwnData/GoodsStruct.js

"use strict";

//当前拥有物品  
var GoodsStruct = cc.Class({
  name: "GoodsStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    ownNum: cc.Integer,
    buyPrice: cc.Integer,
    //买入价格
    marketPrice: cc.Integer //当前市场价格
  },

  //购买东西后刷新数据
  RefeshDataAfterBuy: function RefeshDataAfterBuy(data) {
    var allAss = this.buyPrice * this.ownNum + data.price * data.Num;
    this.ownNum += data.Num;
    this.buyPrice = Math.floor(allAss / this.ownNum);
    var param = {};
    param.Id = this.Id;
    param.ownNum = this.ownNum;
    param.buyPrice = this.buyPrice;
    return param;
  },
  //出售
  RefeshDataAfterSale: function RefeshDataAfterSale(data) {
    this.ownNum -= data.Num;
    var param = {};
    param.Id = this.Id;
    param.ownNum = this.ownNum;
    param.buyPrice = this.buyPrice;
    return param;
  }
});
module.exports = GoodsStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcR29vZHNTdHJ1Y3QuanMiXSwibmFtZXMiOlsiR29vZHNTdHJ1Y3QiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJpY29uIiwiSWQiLCJJbnRlZ2VyIiwib3duTnVtIiwiYnV5UHJpY2UiLCJtYXJrZXRQcmljZSIsIlJlZmVzaERhdGFBZnRlckJ1eSIsImRhdGEiLCJhbGxBc3MiLCJwcmljZSIsIk51bSIsIk1hdGgiLCJmbG9vciIsInBhcmFtIiwiUmVmZXNoRGF0YUFmdGVyU2FsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQSxJQUFJQSxXQUFXLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzFCQyxJQUFJLEVBQUMsYUFBYTtFQUNsQkMsVUFBVSxFQUFFO0lBQ1hDLElBQUksRUFBQyxFQUFFO0lBQ1BGLElBQUksRUFBQyxFQUFFO0lBQ1BHLEVBQUUsRUFBQ0wsRUFBRSxDQUFDTSxPQUFPO0lBQ2JDLE1BQU0sRUFBQ1AsRUFBRSxDQUFDTSxPQUFPO0lBQ2pCRSxRQUFRLEVBQUNSLEVBQUUsQ0FBQ00sT0FBTztJQUFDO0lBQ3BCRyxXQUFXLEVBQUNULEVBQUUsQ0FBQ00sT0FBTyxDQUFDO0VBQ3hCLENBQUM7O0VBQ0Q7RUFDQUksa0JBQWtCLEVBQUMsU0FBQUEsbUJBQVVDLElBQUksRUFBRTtJQUNsQyxJQUFJQyxNQUFNLEdBQUksSUFBSSxDQUFDSixRQUFRLEdBQUcsSUFBSSxDQUFDRCxNQUFNLEdBQUtJLElBQUksQ0FBQ0UsS0FBSyxHQUFHRixJQUFJLENBQUNHLEdBQUk7SUFDcEUsSUFBSSxDQUFDUCxNQUFNLElBQUlJLElBQUksQ0FBQ0csR0FBRztJQUN2QixJQUFJLENBQUNOLFFBQVEsR0FBR08sSUFBSSxDQUFDQyxLQUFLLENBQUNKLE1BQU0sR0FBRyxJQUFJLENBQUNMLE1BQU0sQ0FBQztJQUNoRCxJQUFJVSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2RBLEtBQUssQ0FBQ1osRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRTtJQUNsQlksS0FBSyxDQUFDVixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO0lBQzFCVSxLQUFLLENBQUNULFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7SUFDOUIsT0FBT1MsS0FBSztFQUNiLENBQUM7RUFDRDtFQUNBQyxtQkFBbUIsRUFBQyxTQUFBQSxvQkFBVVAsSUFBSSxFQUFFO0lBQ25DLElBQUksQ0FBQ0osTUFBTSxJQUFJSSxJQUFJLENBQUNHLEdBQUc7SUFDdkIsSUFBSUcsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkQSxLQUFLLENBQUNaLEVBQUUsR0FBRyxJQUFJLENBQUNBLEVBQUU7SUFDbEJZLEtBQUssQ0FBQ1YsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtJQUMxQlUsS0FBSyxDQUFDVCxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO0lBQzlCLE9BQU9TLEtBQUs7RUFDYjtBQUNELENBQUMsQ0FBQztBQUNGRSxNQUFNLENBQUNDLE9BQU8sR0FBR3JCLFdBQVciLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vL+W9k+WJjeaLpeacieeJqeWTgSAgXHJcbnZhciBHb29kc1N0cnVjdCA9IGNjLkNsYXNzKHtcclxuXHRuYW1lOlwiR29vZHNTdHJ1Y3RcIixcclxuXHRwcm9wZXJ0aWVzOiB7XHJcblx0XHRpY29uOlwiXCIsXHJcblx0XHRuYW1lOlwiXCIsXHJcblx0XHRJZDpjYy5JbnRlZ2VyLFxyXG5cdFx0b3duTnVtOmNjLkludGVnZXIsXHJcblx0XHRidXlQcmljZTpjYy5JbnRlZ2VyLC8v5Lmw5YWl5Lu35qC8XHJcblx0XHRtYXJrZXRQcmljZTpjYy5JbnRlZ2VyLC8v5b2T5YmN5biC5Zy65Lu35qC8XHJcblx0fSxcclxuXHQvL+i0reS5sOS4nOilv+WQjuWIt+aWsOaVsOaNrlxyXG5cdFJlZmVzaERhdGFBZnRlckJ1eTpmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0dmFyIGFsbEFzcyA9ICh0aGlzLmJ1eVByaWNlICogdGhpcy5vd25OdW0pICsgKGRhdGEucHJpY2UgKiBkYXRhLk51bSk7XHJcblx0XHR0aGlzLm93bk51bSArPSBkYXRhLk51bTtcclxuXHRcdHRoaXMuYnV5UHJpY2UgPSBNYXRoLmZsb29yKGFsbEFzcyAvIHRoaXMub3duTnVtKTtcclxuXHRcdHZhciBwYXJhbSA9IHt9O1xyXG5cdFx0cGFyYW0uSWQgPSB0aGlzLklkO1xyXG5cdFx0cGFyYW0ub3duTnVtID0gdGhpcy5vd25OdW07XHJcblx0XHRwYXJhbS5idXlQcmljZSA9IHRoaXMuYnV5UHJpY2U7XHJcblx0XHRyZXR1cm4gcGFyYW07XHJcblx0fSxcclxuXHQvL+WHuuWUrlxyXG5cdFJlZmVzaERhdGFBZnRlclNhbGU6ZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdHRoaXMub3duTnVtIC09IGRhdGEuTnVtO1xyXG5cdFx0dmFyIHBhcmFtID0ge307XHJcblx0XHRwYXJhbS5JZCA9IHRoaXMuSWQ7XHJcblx0XHRwYXJhbS5vd25OdW0gPSB0aGlzLm93bk51bTtcclxuXHRcdHBhcmFtLmJ1eVByaWNlID0gdGhpcy5idXlQcmljZTtcclxuXHRcdHJldHVybiBwYXJhbTtcclxuXHR9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBHb29kc1N0cnVjdDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Mate/LovePointCost.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd1b08gbpslOm72d/yYbHuaE', 'LovePointCost');
// Scripts/DataMap/Mate/LovePointCost.js

"use strict";

var LovePointCost = cc.Class({
  name: "LovePointCost",
  properties: {
    curLevel: cc.Integer,
    //当前等级
    LovePoint: cc.Integer,
    //好感度
    cost: cc.Integer //升级好感度消耗
  }
});

module.exports = LovePointCost;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcTWF0ZVxcTG92ZVBvaW50Q29zdC5qcyJdLCJuYW1lcyI6WyJMb3ZlUG9pbnRDb3N0IiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiY3VyTGV2ZWwiLCJJbnRlZ2VyIiwiTG92ZVBvaW50IiwiY29zdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsYUFBYSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUM1QkMsSUFBSSxFQUFDLGVBQWU7RUFDakJDLFVBQVUsRUFBRTtJQUNYQyxRQUFRLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUFDO0lBQ2pCQyxTQUFTLEVBQUNOLEVBQUUsQ0FBQ0ssT0FBTztJQUFDO0lBQ3JCRSxJQUFJLEVBQUNQLEVBQUUsQ0FBQ0ssT0FBTyxDQUFDO0VBQ3BCO0FBQ0osQ0FBQyxDQUFDOztBQUNGRyxNQUFNLENBQUNDLE9BQU8sR0FBR1YsYUFBYSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBMb3ZlUG9pbnRDb3N0ID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJMb3ZlUG9pbnRDb3N0XCIsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICBcdGN1ckxldmVsOmNjLkludGVnZXIsLy/lvZPliY3nrYnnuqdcclxuICAgICAgICBMb3ZlUG9pbnQ6Y2MuSW50ZWdlciwvL+WlveaEn+W6plxyXG4gICAgICAgIGNvc3Q6Y2MuSW50ZWdlciwvL+WNh+e6p+WlveaEn+W6pua2iOiAl1xyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTG92ZVBvaW50Q29zdDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Skill/SkillData.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '7075dYkjClIUqCS4DjP/847', 'SkillData');
// Scripts/DataMap/Skill/SkillData.js

"use strict";

var CostData = require("CostData");
var SkillData = cc.Class({
  name: "SkillData",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    subId: cc.Integer,
    upLevel: cc.Integer,
    desId: cc.Integer,
    upCostList: [CostData],
    // 升级消耗
    skillType: cc.Integer
  }
});
module.exports = SkillData;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcU2tpbGxcXFNraWxsRGF0YS5qcyJdLCJuYW1lcyI6WyJDb3N0RGF0YSIsInJlcXVpcmUiLCJTa2lsbERhdGEiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJpY29uIiwiSWQiLCJJbnRlZ2VyIiwic3ViSWQiLCJ1cExldmVsIiwiZGVzSWQiLCJ1cENvc3RMaXN0Iiwic2tpbGxUeXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsU0FBUyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN4QkMsSUFBSSxFQUFDLFdBQVc7RUFDYkMsVUFBVSxFQUFFO0lBQ1RDLElBQUksRUFBQyxFQUFFO0lBQ1BGLElBQUksRUFBQyxFQUFFO0lBQ1BHLEVBQUUsRUFBQ0wsRUFBRSxDQUFDTSxPQUFPO0lBQ2JDLEtBQUssRUFBQ1AsRUFBRSxDQUFDTSxPQUFPO0lBQ2hCRSxPQUFPLEVBQUNSLEVBQUUsQ0FBQ00sT0FBTztJQUNsQkcsS0FBSyxFQUFDVCxFQUFFLENBQUNNLE9BQU87SUFDaEJJLFVBQVUsRUFBQyxDQUFDYixRQUFRLENBQUM7SUFBQztJQUN0QmMsU0FBUyxFQUFDWCxFQUFFLENBQUNNO0VBQ2hCO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZNLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHZCxTQUFTIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29zdERhdGEgPSByZXF1aXJlKFwiQ29zdERhdGFcIik7XHJcbnZhciBTa2lsbERhdGEgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIlNraWxsRGF0YVwiLFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgaWNvbjpcIlwiLFxyXG4gICAgICAgbmFtZTpcIlwiLFxyXG4gICAgICAgSWQ6Y2MuSW50ZWdlcixcclxuICAgICAgIHN1YklkOmNjLkludGVnZXIsXHJcbiAgICAgICB1cExldmVsOmNjLkludGVnZXIsXHJcbiAgICAgICBkZXNJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgdXBDb3N0TGlzdDpbQ29zdERhdGFdLC8vIOWNh+e6p+a2iOiAl1xyXG4gICAgICAgc2tpbGxUeXBlOmNjLkludGVnZXIsXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBTa2lsbERhdGE7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/CompanyStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c205btXSYJIuaVqivU8/buw', 'CompanyStruct');
// Scripts/OwnData/CompanyStruct.js

"use strict";

//公司
var CompanyStruct = cc.Class({
  name: "CompanyStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    LimitYear: cc.Integer,
    //交易收益开发年限
    isOwned: false,
    bonusRatio: 0.02,
    //收益回报率
    stockNum: cc.Integer,
    //股票数量
    stockCost: 0.00,
    //股票成本
    bankruptPrice: 0.00,
    //破产价格
    stockPrice: 15.25 //股票单价
  },

  //创办或者购买完成后
  RefreshDataAfterOper: function RefreshDataAfterOper(data) {
    var allAss = this.stockCost * this.stockNum + data.price * data.Num;
    this.stockNum += data.Num;
    this.stockCost = Math.floor(allAss / this.stockNum * 100) / 100;
    this.stockPrice = data.price;
    if (this.stockNum > 0) this.isOwned = true;else this.isOwned = false;
    cc.Mgr.UserDataMgr.hasCompany = true;
    var param = {};
    param.Id = this.Id;
    param.stockNum = this.stockNum;
    param.stockPrice = this.stockPrice;
    param.stockCost = this.stockCost;
    return param;
  },
  //出售操作刷新
  RefreshDataAfterSale: function RefreshDataAfterSale(data) {
    this.stockNum -= data.Num;
    this.stockPrice = data.price;
    if (this.stockNum > 0) {
      this.isOwned = true;
      cc.Mgr.UserDataMgr.hasCompany = true;
    } else {
      //cc.log("破产或者卖光了");
      this.stockCost = 0; //全部賣光
      cc.Mgr.UserDataMgr.hasCompany = false;
      cc.Mgr.UserDataMgr.CanGetStockProfit = false;
      this.isOwned = false;
    }
    var param = {};
    param.Id = this.Id;
    param.stockNum = this.stockNum;
    param.stockPrice = this.stockPrice;
    param.stockCost = this.stockCost;
    return param;
  },
  //离婚后操作刷新
  RefreshDataAfterDisvorce: function RefreshDataAfterDisvorce() {
    this.stockNum = Math.floor(this.stockNum * 0.8);
  }
});
module.exports = CompanyStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcQ29tcGFueVN0cnVjdC5qcyJdLCJuYW1lcyI6WyJDb21wYW55U3RydWN0IiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiaWNvbiIsIklkIiwiSW50ZWdlciIsIkxpbWl0WWVhciIsImlzT3duZWQiLCJib251c1JhdGlvIiwic3RvY2tOdW0iLCJzdG9ja0Nvc3QiLCJiYW5rcnVwdFByaWNlIiwic3RvY2tQcmljZSIsIlJlZnJlc2hEYXRhQWZ0ZXJPcGVyIiwiZGF0YSIsImFsbEFzcyIsInByaWNlIiwiTnVtIiwiTWF0aCIsImZsb29yIiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJoYXNDb21wYW55IiwicGFyYW0iLCJSZWZyZXNoRGF0YUFmdGVyU2FsZSIsIkNhbkdldFN0b2NrUHJvZml0IiwiUmVmcmVzaERhdGFBZnRlckRpc3ZvcmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBLElBQUlBLGFBQWEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDNUJDLElBQUksRUFBQyxlQUFlO0VBQ3BCQyxVQUFVLEVBQUM7SUFDVkMsSUFBSSxFQUFDLEVBQUU7SUFDUEYsSUFBSSxFQUFDLEVBQUU7SUFDUEcsRUFBRSxFQUFDTCxFQUFFLENBQUNNLE9BQU87SUFDYkMsU0FBUyxFQUFDUCxFQUFFLENBQUNNLE9BQU87SUFBRTtJQUN0QkUsT0FBTyxFQUFDLEtBQUs7SUFDYkMsVUFBVSxFQUFDLElBQUk7SUFBQztJQUNoQkMsUUFBUSxFQUFDVixFQUFFLENBQUNNLE9BQU87SUFBRTtJQUNyQkssU0FBUyxFQUFDLElBQUk7SUFBQztJQUNmQyxhQUFhLEVBQUMsSUFBSTtJQUFFO0lBQ3BCQyxVQUFVLEVBQUMsS0FBSyxDQUFDO0VBQ2xCLENBQUM7O0VBRUQ7RUFDQUMsb0JBQW9CLEVBQUMsU0FBQUEscUJBQVVDLElBQUksRUFBRTtJQUNwQyxJQUFJQyxNQUFNLEdBQUksSUFBSSxDQUFDTCxTQUFTLEdBQUcsSUFBSSxDQUFDRCxRQUFRLEdBQUtLLElBQUksQ0FBQ0UsS0FBSyxHQUFHRixJQUFJLENBQUNHLEdBQUk7SUFDdkUsSUFBSSxDQUFDUixRQUFRLElBQUlLLElBQUksQ0FBQ0csR0FBRztJQUN6QixJQUFJLENBQUNQLFNBQVMsR0FBR1EsSUFBSSxDQUFDQyxLQUFLLENBQUNKLE1BQU0sR0FBRyxJQUFJLENBQUNOLFFBQVEsR0FBRyxHQUFHLENBQUMsR0FBQyxHQUFHO0lBQzdELElBQUksQ0FBQ0csVUFBVSxHQUFHRSxJQUFJLENBQUNFLEtBQUs7SUFDNUIsSUFBRyxJQUFJLENBQUNQLFFBQVEsR0FBRyxDQUFDLEVBQ25CLElBQUksQ0FBQ0YsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUVwQixJQUFJLENBQUNBLE9BQU8sR0FBRyxLQUFLO0lBRXJCUixFQUFFLENBQUNxQixHQUFHLENBQUNDLFdBQVcsQ0FBQ0MsVUFBVSxHQUFHLElBQUk7SUFDcEMsSUFBSUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkQSxLQUFLLENBQUNuQixFQUFFLEdBQUcsSUFBSSxDQUFDQSxFQUFFO0lBQ2xCbUIsS0FBSyxDQUFDZCxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO0lBQzlCYyxLQUFLLENBQUNYLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVU7SUFDbENXLEtBQUssQ0FBQ2IsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztJQUNoQyxPQUFPYSxLQUFLO0VBQ2IsQ0FBQztFQUNEO0VBQ0FDLG9CQUFvQixFQUFDLFNBQUFBLHFCQUFVVixJQUFJLEVBQUU7SUFDcEMsSUFBSSxDQUFDTCxRQUFRLElBQUlLLElBQUksQ0FBQ0csR0FBRztJQUN6QixJQUFJLENBQUNMLFVBQVUsR0FBR0UsSUFBSSxDQUFDRSxLQUFLO0lBQzVCLElBQUcsSUFBSSxDQUFDUCxRQUFRLEdBQUcsQ0FBQyxFQUNwQjtNQUNDLElBQUksQ0FBQ0YsT0FBTyxHQUFHLElBQUk7TUFDbkJSLEVBQUUsQ0FBQ3FCLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDQyxVQUFVLEdBQUcsSUFBSTtJQUNyQyxDQUFDLE1BRUQ7TUFDQztNQUNBLElBQUksQ0FBQ1osU0FBUyxHQUFHLENBQUMsQ0FBQztNQUNuQlgsRUFBRSxDQUFDcUIsR0FBRyxDQUFDQyxXQUFXLENBQUNDLFVBQVUsR0FBRyxLQUFLO01BQ3JDdkIsRUFBRSxDQUFDcUIsR0FBRyxDQUFDQyxXQUFXLENBQUNJLGlCQUFpQixHQUFHLEtBQUs7TUFDNUMsSUFBSSxDQUFDbEIsT0FBTyxHQUFHLEtBQUs7SUFDckI7SUFFQSxJQUFJZ0IsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkQSxLQUFLLENBQUNuQixFQUFFLEdBQUcsSUFBSSxDQUFDQSxFQUFFO0lBQ2xCbUIsS0FBSyxDQUFDZCxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO0lBQzlCYyxLQUFLLENBQUNYLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVU7SUFDbENXLEtBQUssQ0FBQ2IsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztJQUNoQyxPQUFPYSxLQUFLO0VBQ2IsQ0FBQztFQUVEO0VBQ0FHLHdCQUF3QixFQUFDLFNBQUFBLHlCQUFBLEVBQVk7SUFDcEMsSUFBSSxDQUFDakIsUUFBUSxHQUFHUyxJQUFJLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNWLFFBQVEsR0FBRyxHQUFHLENBQUM7RUFDaEQ7QUFHRCxDQUFDLENBQUM7QUFDRmtCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHOUIsYUFBYSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8v5YWs5Y+4XHJcbnZhciBDb21wYW55U3RydWN0ID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJDb21wYW55U3RydWN0XCIsXHJcblx0cHJvcGVydGllczp7XHJcblx0XHRpY29uOlwiXCIsXHJcblx0XHRuYW1lOlwiXCIsXHJcblx0XHRJZDpjYy5JbnRlZ2VyLFxyXG5cdFx0TGltaXRZZWFyOmNjLkludGVnZXIsIC8v5Lqk5piT5pS255uK5byA5Y+R5bm06ZmQXHJcblx0XHRpc093bmVkOmZhbHNlLFxyXG5cdFx0Ym9udXNSYXRpbzowLjAyLC8v5pS255uK5Zue5oql546HXHJcblx0XHRzdG9ja051bTpjYy5JbnRlZ2VyLCAvL+iCoeelqOaVsOmHj1xyXG5cdFx0c3RvY2tDb3N0OjAuMDAsLy/ogqHnpajmiJDmnKxcclxuXHRcdGJhbmtydXB0UHJpY2U6MC4wMCwgLy/noLTkuqfku7fmoLxcclxuXHRcdHN0b2NrUHJpY2U6MTUuMjUsLy/ogqHnpajljZXku7dcclxuXHR9LFxyXG5cclxuXHQvL+WIm+WKnuaIluiAhei0reS5sOWujOaIkOWQjlxyXG5cdFJlZnJlc2hEYXRhQWZ0ZXJPcGVyOmZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHR2YXIgYWxsQXNzID0gKHRoaXMuc3RvY2tDb3N0ICogdGhpcy5zdG9ja051bSkgKyAoZGF0YS5wcmljZSAqIGRhdGEuTnVtKTtcclxuXHRcdHRoaXMuc3RvY2tOdW0gKz0gZGF0YS5OdW07XHJcblx0XHR0aGlzLnN0b2NrQ29zdCA9IE1hdGguZmxvb3IoYWxsQXNzIC8gdGhpcy5zdG9ja051bSAqIDEwMCkvMTAwO1xyXG5cdFx0dGhpcy5zdG9ja1ByaWNlID0gZGF0YS5wcmljZVxyXG5cdFx0aWYodGhpcy5zdG9ja051bSA+IDApXHJcblx0XHRcdHRoaXMuaXNPd25lZCA9IHRydWU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMuaXNPd25lZCA9IGZhbHNlO1xyXG5cclxuXHRcdGNjLk1nci5Vc2VyRGF0YU1nci5oYXNDb21wYW55ID0gdHJ1ZTtcclxuXHRcdHZhciBwYXJhbSA9IHt9O1xyXG5cdFx0cGFyYW0uSWQgPSB0aGlzLklkO1xyXG5cdFx0cGFyYW0uc3RvY2tOdW0gPSB0aGlzLnN0b2NrTnVtO1xyXG5cdFx0cGFyYW0uc3RvY2tQcmljZSA9IHRoaXMuc3RvY2tQcmljZTtcclxuXHRcdHBhcmFtLnN0b2NrQ29zdCA9IHRoaXMuc3RvY2tDb3N0O1xyXG5cdFx0cmV0dXJuIHBhcmFtO1xyXG5cdH0sXHJcblx0Ly/lh7rllK7mk43kvZzliLfmlrBcclxuXHRSZWZyZXNoRGF0YUFmdGVyU2FsZTpmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0dGhpcy5zdG9ja051bSAtPSBkYXRhLk51bTtcclxuXHRcdHRoaXMuc3RvY2tQcmljZSA9IGRhdGEucHJpY2VcclxuXHRcdGlmKHRoaXMuc3RvY2tOdW0gPiAwKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmlzT3duZWQgPSB0cnVlO1xyXG5cdFx0XHRjYy5NZ3IuVXNlckRhdGFNZ3IuaGFzQ29tcGFueSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdC8vY2MubG9nKFwi56C05Lqn5oiW6ICF5Y2W5YWJ5LqGXCIpO1xyXG5cdFx0XHR0aGlzLnN0b2NrQ29zdCA9IDA7Ly/lhajpg6jos6PlhYlcclxuXHRcdFx0Y2MuTWdyLlVzZXJEYXRhTWdyLmhhc0NvbXBhbnkgPSBmYWxzZTtcclxuXHRcdFx0Y2MuTWdyLlVzZXJEYXRhTWdyLkNhbkdldFN0b2NrUHJvZml0ID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuaXNPd25lZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYXJhbSA9IHt9O1xyXG5cdFx0cGFyYW0uSWQgPSB0aGlzLklkO1xyXG5cdFx0cGFyYW0uc3RvY2tOdW0gPSB0aGlzLnN0b2NrTnVtO1xyXG5cdFx0cGFyYW0uc3RvY2tQcmljZSA9IHRoaXMuc3RvY2tQcmljZTtcclxuXHRcdHBhcmFtLnN0b2NrQ29zdCA9IHRoaXMuc3RvY2tDb3N0O1xyXG5cdFx0cmV0dXJuIHBhcmFtO1xyXG5cdH0sXHJcblxyXG5cdC8v56a75ama5ZCO5pON5L2c5Yi35pawXHJcblx0UmVmcmVzaERhdGFBZnRlckRpc3ZvcmNlOmZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc3RvY2tOdW0gPSBNYXRoLmZsb29yKHRoaXMuc3RvY2tOdW0gKiAwLjgpO1xyXG5cdH0sXHJcblxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcGFueVN0cnVjdDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/HouseStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '88d77/aClBHkrfCZBnwiNa5', 'HouseStruct');
// Scripts/OwnData/HouseStruct.js

"use strict";

//房子
var HouseStruct = cc.Class({
  name: "HouseStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    ownNum: cc.Integer,
    //拥有数量
    price: cc.Integer,
    addBonus: cc.Integer,
    //增加名声
    addHp: cc.Integer //增加健康值
  },

  RefreshData: function RefreshData(addNum) {
    //为负值表示卖出去
    this.ownNum += addNum;
  }
});
module.exports = HouseStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcSG91c2VTdHJ1Y3QuanMiXSwibmFtZXMiOlsiSG91c2VTdHJ1Y3QiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJpY29uIiwiSWQiLCJJbnRlZ2VyIiwib3duTnVtIiwicHJpY2UiLCJhZGRCb251cyIsImFkZEhwIiwiUmVmcmVzaERhdGEiLCJhZGROdW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0EsSUFBSUEsV0FBVyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUMxQkMsSUFBSSxFQUFDLGFBQWE7RUFDbEJDLFVBQVUsRUFBQztJQUNWQyxJQUFJLEVBQUMsRUFBRTtJQUNQRixJQUFJLEVBQUMsRUFBRTtJQUNQRyxFQUFFLEVBQUNMLEVBQUUsQ0FBQ00sT0FBTztJQUNiQyxNQUFNLEVBQUNQLEVBQUUsQ0FBQ00sT0FBTztJQUFDO0lBQ2xCRSxLQUFLLEVBQUNSLEVBQUUsQ0FBQ00sT0FBTztJQUNoQkcsUUFBUSxFQUFDVCxFQUFFLENBQUNNLE9BQU87SUFBRTtJQUNyQkksS0FBSyxFQUFDVixFQUFFLENBQUNNLE9BQU8sQ0FBQztFQUNsQixDQUFDOztFQUVESyxXQUFXLEVBQUMsU0FBQUEsWUFBU0MsTUFBTSxFQUFFO0lBQUU7SUFDOUIsSUFBSSxDQUFDTCxNQUFNLElBQUlLLE1BQU07RUFDdEI7QUFDRCxDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUdmLFdBQVciLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vL+aIv+WtkFxyXG52YXIgSG91c2VTdHJ1Y3QgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIkhvdXNlU3RydWN0XCIsXHJcblx0cHJvcGVydGllczp7XHJcblx0XHRpY29uOlwiXCIsXHJcblx0XHRuYW1lOlwiXCIsXHJcblx0XHRJZDpjYy5JbnRlZ2VyLFxyXG5cdFx0b3duTnVtOmNjLkludGVnZXIsLy/mi6XmnInmlbDph49cclxuXHRcdHByaWNlOmNjLkludGVnZXIsXHJcblx0XHRhZGRCb251czpjYy5JbnRlZ2VyLCAvL+WinuWKoOWQjeWjsFxyXG5cdFx0YWRkSHA6Y2MuSW50ZWdlciwvL+WinuWKoOWBpeW6t+WAvFxyXG5cdH0sXHJcblxyXG5cdFJlZnJlc2hEYXRhOmZ1bmN0aW9uKGFkZE51bSkgeyAvL+S4uui0n+WAvOihqOekuuWNluWHuuWOu1xyXG5cdFx0dGhpcy5vd25OdW0gKz0gYWRkTnVtO1xyXG5cdH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEhvdXNlU3RydWN0O1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/DataMap/Mate/MateBonus.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e7486yTEMdIkp+1kwtUFZ3P', 'MateBonus');
// Scripts/DataMap/Mate/MateBonus.js

"use strict";

var MateBonus = cc.Class({
  name: "MateBonus",
  properties: {
    bonusType: cc.Integer,
    //加成类型
    bonusNum: cc.Integer //数值
  }
});

module.exports = MateBonus;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcRGF0YU1hcFxcTWF0ZVxcTWF0ZUJvbnVzLmpzIl0sIm5hbWVzIjpbIk1hdGVCb251cyIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsImJvbnVzVHlwZSIsIkludGVnZXIiLCJib251c051bSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsU0FBUyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNyQkMsSUFBSSxFQUFDLFdBQVc7RUFDaEJDLFVBQVUsRUFBRTtJQUNSQyxTQUFTLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUFDO0lBQ3JCQyxRQUFRLEVBQUNOLEVBQUUsQ0FBQ0ssT0FBTyxDQUFDO0VBQ3hCO0FBQ0osQ0FBQyxDQUFDOztBQUNGRSxNQUFNLENBQUNDLE9BQU8sR0FBR1QsU0FBUyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBNYXRlQm9udXMgPSBjYy5DbGFzcyh7XHJcbiAgICBuYW1lOlwiTWF0ZUJvbnVzXCIsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYm9udXNUeXBlOmNjLkludGVnZXIsLy/liqDmiJDnsbvlnotcclxuICAgICAgICBib251c051bTpjYy5JbnRlZ2VyLC8v5pWw5YC8XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlQm9udXM7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/RecordStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2c9a12JEohPFq+M5dJulvCd', 'RecordStruct');
// Scripts/OwnData/RecordStruct.js

"use strict";

//需要更多源码联系Q:3038745955
//游戏记录
var RecordStruct = cc.Class({
  name: "RecordStruct",
  properties: {
    retireAge: cc.Integer,
    level: cc.Integer,
    // 1 表示百万富翁 2 表示千万 3 表示亿   0 表示低于百万 
    assets: cc.Integer,
    //达到的资产数额
    highAssets: cc.Integer
  }
});
module.exports = RecordStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcUmVjb3JkU3RydWN0LmpzIl0sIm5hbWVzIjpbIlJlY29yZFN0cnVjdCIsImNjIiwiQ2xhc3MiLCJuYW1lIiwicHJvcGVydGllcyIsInJldGlyZUFnZSIsIkludGVnZXIiLCJsZXZlbCIsImFzc2V0cyIsImhpZ2hBc3NldHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxJQUFJQSxZQUFZLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzNCQyxJQUFJLEVBQUMsY0FBYztFQUNuQkMsVUFBVSxFQUFDO0lBQ1ZDLFNBQVMsRUFBQ0osRUFBRSxDQUFDSyxPQUFPO0lBQ3BCQyxLQUFLLEVBQUNOLEVBQUUsQ0FBQ0ssT0FBTztJQUFHO0lBQ25CRSxNQUFNLEVBQUNQLEVBQUUsQ0FBQ0ssT0FBTztJQUFFO0lBQ25CRyxVQUFVLEVBQUNSLEVBQUUsQ0FBQ0s7RUFDZjtBQUNELENBQUMsQ0FBQztBQUNGSSxNQUFNLENBQUNDLE9BQU8sR0FBR1gsWUFBWSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLy/pnIDopoHmm7TlpJrmupDnoIHogZTns7tROjMwMzg3NDU5NTVcclxuLy/muLjmiI/orrDlvZVcclxudmFyIFJlY29yZFN0cnVjdCA9IGNjLkNsYXNzKHtcclxuXHRuYW1lOlwiUmVjb3JkU3RydWN0XCIsXHJcblx0cHJvcGVydGllczp7XHJcblx0XHRyZXRpcmVBZ2U6Y2MuSW50ZWdlcixcclxuXHRcdGxldmVsOmNjLkludGVnZXIsICAvLyAxIOihqOekuueZvuS4h+WvjOe/gSAyIOihqOekuuWNg+S4hyAzIOihqOekuuS6vyAgIDAg6KGo56S65L2O5LqO55m+5LiHIFxyXG5cdFx0YXNzZXRzOmNjLkludGVnZXIsIC8v6L6+5Yiw55qE6LWE5Lqn5pWw6aKdXHJcblx0XHRoaWdoQXNzZXRzOmNjLkludGVnZXIsXHJcblx0fSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVjb3JkU3RydWN0O1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/MateStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'fbed69g4iBKe5LAi0Lvhozn', 'MateStruct');
// Scripts/OwnData/MateStruct.js

"use strict";

var ItemType = require("ItemType");
var MateUnLockType = require("MateUnLockType");
//约会对象//需要更多源码联系Q:3038745955
var MateStruct = cc.Class({
  name: "MateStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    sex: cc.Integer,
    //性别 1表示男  2 表示女
    canDate: false,
    // 当前是否可以直接约会了
    curLevel: cc.Integer,
    unlockCond: cc.Integer,
    //可约条件
    LovePoint: cc.Integer,
    //好感度
    UpLv: false //是否满级
  },

  //离婚后会让伴侣状态恢复为初始状态
  ReturnInitState: function ReturnInitState() {
    this.LovePoint = 0;
    this.canDate = false;
    if (this.unlockCond == MateUnLockType.NULL) this.canDate = true;
    this.curLevel = 0;
    this.UpLv = false;
  },
  //改变当前可约状态
  ChangeCanDateState: function ChangeCanDateState(flag) {
    this.canDate = flag;
  },
  RefreshAfterLvUp: function RefreshAfterLvUp() {
    var outpar = {};
    if (this.UpLv == true) {
      //cc.log("已经可以滚床单了,还约什么");
      outpar.isFull = false;
      outpar.LovePoint = 100;
      return true;
    }
    var mateData = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, this.Id);
    var lovePointList = mateData.lovePointList;
    var bonusList = mateData.bonusList;
    this.curLevel += 1;
    var index = 0;
    for (var i = lovePointList.length - 1; i >= 0; i--) {
      if (lovePointList[i].curLevel == this.curLevel) {
        index = i;
        break;
      }
    }
    this.LovePoint = lovePointList[index].LovePoint;
    if (this.LovePoint == 100) {
      this.UpLv = true; //满级了
      outpar.isFull = true;
    } else {
      outpar.isFull = false;
    }
    outpar.LovePoint = this.LovePoint;
    return outpar;
  }
});
module.exports = MateStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcTWF0ZVN0cnVjdC5qcyJdLCJuYW1lcyI6WyJJdGVtVHlwZSIsInJlcXVpcmUiLCJNYXRlVW5Mb2NrVHlwZSIsIk1hdGVTdHJ1Y3QiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJpY29uIiwiSWQiLCJJbnRlZ2VyIiwic2V4IiwiY2FuRGF0ZSIsImN1ckxldmVsIiwidW5sb2NrQ29uZCIsIkxvdmVQb2ludCIsIlVwTHYiLCJSZXR1cm5Jbml0U3RhdGUiLCJOVUxMIiwiQ2hhbmdlQ2FuRGF0ZVN0YXRlIiwiZmxhZyIsIlJlZnJlc2hBZnRlckx2VXAiLCJvdXRwYXIiLCJpc0Z1bGwiLCJtYXRlRGF0YSIsIk1nciIsIk1hcERhdGFNZ3IiLCJnZXREYXRhQnlJdGVtVHlwZUFuZElkIiwiTWF0ZSIsImxvdmVQb2ludExpc3QiLCJib251c0xpc3QiLCJpbmRleCIsImkiLCJsZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxjQUFjLEdBQUdELE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztBQUM5QztBQUNBLElBQUlFLFVBQVUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDekJDLElBQUksRUFBQyxZQUFZO0VBQ2pCQyxVQUFVLEVBQUM7SUFDVkMsSUFBSSxFQUFDLEVBQUU7SUFDUEYsSUFBSSxFQUFDLEVBQUU7SUFDUEcsRUFBRSxFQUFDTCxFQUFFLENBQUNNLE9BQU87SUFDYkMsR0FBRyxFQUFDUCxFQUFFLENBQUNNLE9BQU87SUFBRTtJQUNoQkUsT0FBTyxFQUFDLEtBQUs7SUFBQztJQUNkQyxRQUFRLEVBQUNULEVBQUUsQ0FBQ00sT0FBTztJQUNuQkksVUFBVSxFQUFDVixFQUFFLENBQUNNLE9BQU87SUFBQztJQUN0QkssU0FBUyxFQUFDWCxFQUFFLENBQUNNLE9BQU87SUFBRztJQUN2Qk0sSUFBSSxFQUFDLEtBQUssQ0FBQztFQUNaLENBQUM7O0VBRUQ7RUFDQUMsZUFBZSxFQUFDLFNBQUFBLGdCQUFBLEVBQVU7SUFDekIsSUFBSSxDQUFDRixTQUFTLEdBQUcsQ0FBQztJQUNsQixJQUFJLENBQUNILE9BQU8sR0FBRyxLQUFLO0lBQ3BCLElBQUcsSUFBSSxDQUFDRSxVQUFVLElBQUlaLGNBQWMsQ0FBQ2dCLElBQUksRUFDeEMsSUFBSSxDQUFDTixPQUFPLEdBQUcsSUFBSTtJQUVwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO0lBQ2pCLElBQUksQ0FBQ0csSUFBSSxHQUFHLEtBQUs7RUFDbEIsQ0FBQztFQUVEO0VBQ0FHLGtCQUFrQixFQUFDLFNBQUFBLG1CQUFXQyxJQUFJLEVBQUU7SUFDbkMsSUFBSSxDQUFDUixPQUFPLEdBQUdRLElBQUk7RUFDcEIsQ0FBQztFQUVEQyxnQkFBZ0IsRUFBQyxTQUFBQSxpQkFBQSxFQUFZO0lBQzVCLElBQUlDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDZixJQUFHLElBQUksQ0FBQ04sSUFBSSxJQUFJLElBQUksRUFDcEI7TUFDQztNQUNBTSxNQUFNLENBQUNDLE1BQU0sR0FBRyxLQUFLO01BQ3JCRCxNQUFNLENBQUNQLFNBQVMsR0FBRyxHQUFHO01BQ3RCLE9BQU8sSUFBSTtJQUNaO0lBQ0EsSUFBSVMsUUFBUSxHQUFHcEIsRUFBRSxDQUFDcUIsR0FBRyxDQUFDQyxVQUFVLENBQUNDLHNCQUFzQixDQUFDM0IsUUFBUSxDQUFDNEIsSUFBSSxFQUFFLElBQUksQ0FBQ25CLEVBQUUsQ0FBQztJQUM1RSxJQUFJb0IsYUFBYSxHQUFHTCxRQUFRLENBQUNLLGFBQWE7SUFDMUMsSUFBSUMsU0FBUyxHQUFHTixRQUFRLENBQUNNLFNBQVM7SUFFckMsSUFBSSxDQUFDakIsUUFBUSxJQUFJLENBQUM7SUFDbEIsSUFBSWtCLEtBQUssR0FBRyxDQUFDO0lBQ2IsS0FBSyxJQUFJQyxDQUFDLEdBQUdILGFBQWEsQ0FBQ0ksTUFBTSxHQUFHLENBQUMsRUFBRUQsQ0FBQyxJQUFJLENBQUMsRUFBRUEsQ0FBQyxFQUFFLEVBQUU7TUFDbkQsSUFBR0gsYUFBYSxDQUFDRyxDQUFDLENBQUMsQ0FBQ25CLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsRUFDN0M7UUFDQ2tCLEtBQUssR0FBR0MsQ0FBQztRQUNUO01BQ0Q7SUFDRDtJQUNBLElBQUksQ0FBQ2pCLFNBQVMsR0FBR2MsYUFBYSxDQUFDRSxLQUFLLENBQUMsQ0FBQ2hCLFNBQVM7SUFDL0MsSUFBRyxJQUFJLENBQUNBLFNBQVMsSUFBSSxHQUFHLEVBQ3hCO01BQ0MsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7TUFDbEJNLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHLElBQUk7SUFDckIsQ0FBQyxNQUVEO01BQ0NELE1BQU0sQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7SUFDdEI7SUFDQUQsTUFBTSxDQUFDUCxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO0lBQ2pDLE9BQU9PLE1BQU07RUFDZDtBQUNELENBQUMsQ0FBQztBQUNGWSxNQUFNLENBQUNDLE9BQU8sR0FBR2hDLFVBQVUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIE1hdGVVbkxvY2tUeXBlID0gcmVxdWlyZShcIk1hdGVVbkxvY2tUeXBlXCIpO1xyXG4vL+e6puS8muWvueixoS8v6ZyA6KaB5pu05aSa5rqQ56CB6IGU57O7UTozMDM4NzQ1OTU1XHJcbnZhciBNYXRlU3RydWN0ID0gY2MuQ2xhc3Moe1xyXG5cdG5hbWU6XCJNYXRlU3RydWN0XCIsXHJcblx0cHJvcGVydGllczp7XHJcblx0XHRpY29uOlwiXCIsXHJcblx0XHRuYW1lOlwiXCIsXHJcblx0XHRJZDpjYy5JbnRlZ2VyLFxyXG5cdFx0c2V4OmNjLkludGVnZXIsIC8v5oCn5YirIDHooajnpLrnlLcgIDIg6KGo56S65aWzXHJcblx0XHRjYW5EYXRlOmZhbHNlLC8vIOW9k+WJjeaYr+WQpuWPr+S7peebtOaOpee6puS8muS6hlxyXG5cdFx0Y3VyTGV2ZWw6Y2MuSW50ZWdlcixcclxuXHRcdHVubG9ja0NvbmQ6Y2MuSW50ZWdlciwvL+WPr+e6puadoeS7tlxyXG5cdFx0TG92ZVBvaW50OmNjLkludGVnZXIsICAvL+WlveaEn+W6plxyXG5cdFx0VXBMdjpmYWxzZSwvL+aYr+WQpua7oee6p1xyXG5cdH0sXHJcblxyXG5cdC8v56a75ama5ZCO5Lya6K6p5Ly05L6j54q25oCB5oGi5aSN5Li65Yid5aeL54q25oCBXHJcblx0UmV0dXJuSW5pdFN0YXRlOmZ1bmN0aW9uKCl7XHJcblx0XHR0aGlzLkxvdmVQb2ludCA9IDA7XHJcblx0XHR0aGlzLmNhbkRhdGUgPSBmYWxzZTtcclxuXHRcdGlmKHRoaXMudW5sb2NrQ29uZCA9PSBNYXRlVW5Mb2NrVHlwZS5OVUxMKVxyXG5cdFx0XHR0aGlzLmNhbkRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuY3VyTGV2ZWwgPSAwO1xyXG5cdFx0dGhpcy5VcEx2ID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly/mlLnlj5jlvZPliY3lj6/nuqbnirbmgIFcclxuXHRDaGFuZ2VDYW5EYXRlU3RhdGU6ZnVuY3Rpb24gKCBmbGFnKSB7XHJcblx0XHR0aGlzLmNhbkRhdGUgPSBmbGFnO1xyXG5cdH0sXHJcblxyXG5cdFJlZnJlc2hBZnRlckx2VXA6ZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG91dHBhciA9IHt9O1xyXG5cdFx0aWYodGhpcy5VcEx2ID09IHRydWUpXHJcblx0XHR7XHJcblx0XHRcdC8vY2MubG9nKFwi5bey57uP5Y+v5Lul5rua5bqK5Y2V5LqGLOi/mOe6puS7gOS5iFwiKTtcclxuXHRcdFx0b3V0cGFyLmlzRnVsbCA9IGZhbHNlO1xyXG5cdFx0XHRvdXRwYXIuTG92ZVBvaW50ID0gMTAwO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHZhciBtYXRlRGF0YSA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuTWF0ZSwgdGhpcy5JZCk7XHJcbiAgICBcdHZhciBsb3ZlUG9pbnRMaXN0ID0gbWF0ZURhdGEubG92ZVBvaW50TGlzdDtcclxuICAgIFx0dmFyIGJvbnVzTGlzdCA9IG1hdGVEYXRhLmJvbnVzTGlzdDtcclxuICAgIFx0XHJcblx0XHR0aGlzLmN1ckxldmVsICs9IDE7XHJcblx0XHR2YXIgaW5kZXggPSAwO1xyXG5cdFx0Zm9yICh2YXIgaSA9IGxvdmVQb2ludExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYobG92ZVBvaW50TGlzdFtpXS5jdXJMZXZlbCA9PSB0aGlzLmN1ckxldmVsKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLkxvdmVQb2ludCA9IGxvdmVQb2ludExpc3RbaW5kZXhdLkxvdmVQb2ludDtcclxuXHRcdGlmKHRoaXMuTG92ZVBvaW50ID09IDEwMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5VcEx2ID0gdHJ1ZTsgLy/mu6HnuqfkuoZcclxuXHRcdFx0b3V0cGFyLmlzRnVsbCA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdG91dHBhci5pc0Z1bGwgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdG91dHBhci5Mb3ZlUG9pbnQgPSB0aGlzLkxvdmVQb2ludDtcclxuXHRcdHJldHVybiBvdXRwYXI7XHJcblx0fSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTWF0ZVN0cnVjdDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/Native.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '980c6Te8dRJ9ZzsyyX+1Tva', 'Native');
// Scripts/OwnData/Native.ts

Object.defineProperty(exports, "__esModule", { value: true });
var Native = /** @class */ (function () {
    function Native() {
    }
    /**
     * 开启、禁用下拉刷新
     * @param enablePullRefresh  true：开启 false：禁用
     */
    Native.enablePullRefresh = function (enablePullRefresh) {
        this.js2android('refresh', enablePullRefresh ? '1' : '0');
    };
    /**
     * 游戏初始化完成
     */
    Native.onCreateSuccess = function () {
        this.js2android('home_loaded', '游戏首页初始化完成');
    };
    /**
     * @param levele 开始某关
     */
    Native.beginLevel = function (levele) {
        this.js2android('begin_level', levele + "");
    };
    /**
    * @param levele 结束某关
    */
    Native.passLevel = function (levele) {
        this.js2android('pass_level', levele + "");
    };
    /**
    * @param levele 进入选关
    */
    Native.showInsertAd = function () {
        this.js2android('show_insert_ad', "1");
    };
    /**
    * @param levele 完成某关
    */
    Native.gamePass = function (levele) {
        this.js2android('game_pass', levele + "");
    };
    /**
    * @param levele 某关失败
    */
    Native.gameFailed = function (levele) {
        this.js2android('game_failed', levele + "");
    };
    Native.openAgreement = function (type) {
        this.js2android('openAgreement', type);
    };
    /**
     * @param 显示激励视频
     *
     */
    Native.showRewardVideo = function () {
        this.js2android('show_reward_video', '1');
    };
    ///激励视频播放完成回调方法 continue_game
    /// Native.android2js("continue_game", ()=>{
    ///     //激励视频播放完成，原生端回调
    /// });
    Native.js2android = function (name, data) {
        console.log("name:" + name + "-data:" + data);
        if (window.injectedObject && window.injectedObject.setJsContent) {
            window.injectedObject.setJsContent(name, data);
        }
    };
    Native.android2js = function (name, fun) {
        window[name] = fun;
    };
    return Native;
}());
exports.default = Native;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcTmF0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtJQUFBO0lBOEVBLENBQUM7SUE1RUc7OztPQUdHO0lBQ0ksd0JBQWlCLEdBQXhCLFVBQXlCLGlCQUEwQjtRQUMvQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBQyxpQkFBaUIsQ0FBQSxDQUFDLENBQUEsR0FBRyxDQUFBLENBQUMsQ0FBQSxHQUFHLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxzQkFBZSxHQUF0QjtRQUNJLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7T0FFRztJQUNJLGlCQUFVLEdBQWpCLFVBQWtCLE1BQWM7UUFDNUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUMsTUFBTSxHQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFQTs7TUFFRTtJQUNJLGdCQUFTLEdBQWhCLFVBQWlCLE1BQWM7UUFDM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUMsTUFBTSxHQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFQTs7TUFFRTtJQUNJLG1CQUFZLEdBQW5CO1FBQ0ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBQyxHQUFHLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUE7O01BRUU7SUFDSSxlQUFRLEdBQWYsVUFBZ0IsTUFBYztRQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBQyxNQUFNLEdBQUMsRUFBRSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVBOztNQUVFO0lBQ0ksaUJBQVUsR0FBakIsVUFBa0IsTUFBYztRQUM1QixJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBQyxNQUFNLEdBQUMsRUFBRSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVNLG9CQUFhLEdBQXBCLFVBQXFCLElBQVk7UUFDN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUE7SUFDMUMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLHNCQUFlLEdBQXRCO1FBQ0ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLENBQUMsQ0FBQTtJQUM3QyxDQUFDO0lBRUQsNkJBQTZCO0lBQzdCLDRDQUE0QztJQUM1Qyx3QkFBd0I7SUFDeEIsT0FBTztJQUNBLGlCQUFVLEdBQWpCLFVBQWtCLElBQVksRUFBRSxJQUFZO1FBQ3hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBUSxJQUFJLGNBQVMsSUFBTSxDQUFDLENBQUM7UUFDekMsSUFBRyxNQUFNLENBQUMsY0FBYyxJQUFJLE1BQU0sQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFDO1lBQzNELE1BQU0sQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNsRDtJQUNMLENBQUM7SUFFTSxpQkFBVSxHQUFqQixVQUFrQixJQUFJLEVBQUUsR0FBRztRQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ3ZCLENBQUM7SUFDTCxhQUFDO0FBQUQsQ0E5RUEsQUE4RUMsSUFBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdGl2ZSB7XG5cbiAgICAvKipcbiAgICAgKiDlvIDlkK/jgIHnpoHnlKjkuIvmi4nliLfmlrBcbiAgICAgKiBAcGFyYW0gZW5hYmxlUHVsbFJlZnJlc2ggIHRydWXvvJrlvIDlkK8gZmFsc2XvvJrnpoHnlKhcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5hYmxlUHVsbFJlZnJlc2goZW5hYmxlUHVsbFJlZnJlc2g6IGJvb2xlYW4pe1xuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ3JlZnJlc2gnLGVuYWJsZVB1bGxSZWZyZXNoPycxJzonMCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa4uOaIj+WIneWni+WMluWujOaIkFxuICAgICAqL1xuICAgIHN0YXRpYyBvbkNyZWF0ZVN1Y2Nlc3MoKXtcbiAgICAgICAgdGhpcy5qczJhbmRyb2lkKCdob21lX2xvYWRlZCcsJ+a4uOaIj+mmlumhteWIneWni+WMluWujOaIkCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsZXZlbGUg5byA5aeL5p+Q5YWzXG4gICAgICovXG4gICAgc3RhdGljIGJlZ2luTGV2ZWwobGV2ZWxlOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ2JlZ2luX2xldmVsJyxsZXZlbGUrXCJcIik7XG4gICAgfVxuXG4gICAgIC8qKlxuICAgICAqIEBwYXJhbSBsZXZlbGUg57uT5p2f5p+Q5YWzXG4gICAgICovXG4gICAgc3RhdGljIHBhc3NMZXZlbChsZXZlbGU6IG51bWJlcil7XG4gICAgICAgIHRoaXMuanMyYW5kcm9pZCgncGFzc19sZXZlbCcsbGV2ZWxlK1wiXCIpO1xuICAgIH1cbiAgICBcbiAgICAgLyoqXG4gICAgICogQHBhcmFtIGxldmVsZSDov5vlhaXpgInlhbNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2hvd0luc2VydEFkKCl7XG4gICAgICAgIHRoaXMuanMyYW5kcm9pZCgnc2hvd19pbnNlcnRfYWQnLFwiMVwiKTtcbiAgICB9XG4gICBcbiAgICAgLyoqXG4gICAgICogQHBhcmFtIGxldmVsZSDlrozmiJDmn5DlhbNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2FtZVBhc3MobGV2ZWxlOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ2dhbWVfcGFzcycsbGV2ZWxlK1wiXCIpO1xuICAgIH1cblxuICAgICAvKipcbiAgICAgKiBAcGFyYW0gbGV2ZWxlIOafkOWFs+Wksei0pVxuICAgICAqL1xuICAgIHN0YXRpYyBnYW1lRmFpbGVkKGxldmVsZTogbnVtYmVyKXtcbiAgICAgICAgdGhpcy5qczJhbmRyb2lkKCdnYW1lX2ZhaWxlZCcsbGV2ZWxlK1wiXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBvcGVuQWdyZWVtZW50KHR5cGU6IHN0cmluZykge1xuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ29wZW5BZ3JlZW1lbnQnLCB0eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSDmmL7npLrmv4DlirHop4bpopFcbiAgICAgKiBcbiAgICAgKi9cbiAgICBzdGF0aWMgc2hvd1Jld2FyZFZpZGVvKCkge1xuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ3Nob3dfcmV3YXJkX3ZpZGVvJywgJzEnKVxuICAgIH1cblxuICAgIC8vL+a/gOWKseinhumikeaSreaUvuWujOaIkOWbnuiwg+aWueazlSBjb250aW51ZV9nYW1lXG4gICAgLy8vIE5hdGl2ZS5hbmRyb2lkMmpzKFwiY29udGludWVfZ2FtZVwiLCAoKT0+e1xuICAgIC8vLyAgICAgLy/mv4DlirHop4bpopHmkq3mlL7lrozmiJDvvIzljp/nlJ/nq6/lm57osINcbiAgICAvLy8gfSk7XG4gICAgc3RhdGljIGpzMmFuZHJvaWQobmFtZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcpe1xuICAgICAgICBjb25zb2xlLmxvZyhgbmFtZToke25hbWV9LWRhdGE6JHtkYXRhfWApO1xuICAgICAgICBpZih3aW5kb3cuaW5qZWN0ZWRPYmplY3QgJiYgd2luZG93LmluamVjdGVkT2JqZWN0LnNldEpzQ29udGVudCl7XG4gICAgICAgICAgICB3aW5kb3cuaW5qZWN0ZWRPYmplY3Quc2V0SnNDb250ZW50KG5hbWUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGFuZHJvaWQyanMobmFtZSwgZnVuKXtcbiAgICAgICAgd2luZG93W25hbWVdID0gZnVuO1xuICAgIH1cbn0iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/AchieveStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '135359mmUBNzJSKPP8LUpRg', 'AchieveStruct');
// Scripts/OwnData/AchieveStruct.js

"use strict";

//达到成就
var AchieveStruct = cc.Class({
  name: "AchieveStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    desId: cc.Integer,
    hasFinish: false
  }
});
module.exports = AchieveStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcQWNoaWV2ZVN0cnVjdC5qcyJdLCJuYW1lcyI6WyJBY2hpZXZlU3RydWN0IiwiY2MiLCJDbGFzcyIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwiaWNvbiIsIklkIiwiSW50ZWdlciIsImRlc0lkIiwiaGFzRmluaXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBLElBQUlBLGFBQWEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDNUJDLElBQUksRUFBQyxlQUFlO0VBQ3BCQyxVQUFVLEVBQUM7SUFDVkMsSUFBSSxFQUFDLEVBQUU7SUFDUEYsSUFBSSxFQUFDLEVBQUU7SUFDUEcsRUFBRSxFQUFDTCxFQUFFLENBQUNNLE9BQU87SUFDYkMsS0FBSyxFQUFDUCxFQUFFLENBQUNNLE9BQU87SUFDaEJFLFNBQVMsRUFBQztFQUNYO0FBQ0QsQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWCxhQUFhIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLy/ovr7liLDmiJDlsLFcclxudmFyIEFjaGlldmVTdHJ1Y3QgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIkFjaGlldmVTdHJ1Y3RcIixcclxuXHRwcm9wZXJ0aWVzOntcclxuXHRcdGljb246XCJcIixcclxuXHRcdG5hbWU6XCJcIixcclxuXHRcdElkOmNjLkludGVnZXIsXHJcblx0XHRkZXNJZDpjYy5JbnRlZ2VyLFxyXG5cdFx0aGFzRmluaXNoOmZhbHNlLFxyXG5cdH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFjaGlldmVTdHJ1Y3Q7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/AppStart.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'fbda7nIgi9GUokSAkqpAOEo', 'AppStart');
// Scripts/UI/AppStart.js

"use strict";

//是否完成过管理工具的初始化
cc.director.initMgr = false;
function initMgr() {
  cc.Mgr = {};
  cc.Mgr.Parse = false;
  cc.Mgr.preLoadingScene = false;
  cc.Mgr.loadSound = false;
  cc.Mgr.initData = false;
  cc.Mgr.global = require("Global");
  cc.Mgr.Event = require("Event");
  cc.Mgr.ShareInfos = require("ShareInfos");
  cc.Mgr.ShareInfos.init();
  cc.Mgr.PlatformController = require("PlatformController");
  cc.Mgr.PlatformController.Init();
  cc.Mgr.AdsMgr = require("AdsMgr");
  cc.Mgr.AdsMgr.Init();

  //声音
  var AudioMgr = require("AudioMgr");
  cc.Mgr.AudioMgr = new AudioMgr();
  cc.Mgr.AudioMgr.init();
  cc.Mgr.AudioMgr.playBGM("bgm");
  var MapDataMgr = require("MapDataMgr");
  cc.Mgr.MapDataMgr = new MapDataMgr();
  cc.Mgr.MapDataMgr.initMaps(); //初始化解析数据表

  var UserDataMgr = require("UserDataMgr");
  cc.Mgr.UserDataMgr = new UserDataMgr();
}
var RankPanel = require("RankPanel");
var HistoryPanel = require("HistoryPanel");
var HonorPanel = require("HonorPanel");
var SkillPanel = require("SkillPanel");
var SkillUpPanel = require("SkillUpPanel");
var SettingPanel = require("SettingPanel");
var CommonTipPanel = require("CommonTipPanel");
cc.Class({
  "extends": cc.Component,
  properties: {
    StartAtlas: cc.SpriteAtlas,
    BtnsNode: cc.Node,
    InputNode: cc.Node,
    InputText: cc.EditBox,
    SexSp: cc.Sprite,
    LoadingNode: cc.Node,
    LoadingJuHua: cc.Node,
    //面板
    rankPanel: RankPanel,
    historyPanel: HistoryPanel,
    honorPanel: HonorPanel,
    skillPanel: SkillPanel,
    skillUpPanel: SkillUpPanel,
    settingPanel: SettingPanel,
    commonTipPanel: CommonTipPanel,
    NameLbl: cc.Label,
    wxSubContextView: cc.Node,
    SwanSubContextView: cc.Node,
    TitleSp: cc.Sprite
  },
  onLoad: function onLoad() {
    //目前我们先不保存任何数据  每次开始清理一次
    //cc.sys.localStorage.clear();
    cc.director.GlobalEvent.clear();
    this.InputNode.active = false;
    if (cc.director.initMgr == false) {
      cc.log("还没有初始化过");
      initMgr();
      //cc.Mgr.global.InitChangeData();
      cc.director.GlobalEvent.on(cc.Mgr.Event.ParseFinish, function () {
        cc.Mgr.UserDataMgr.initData();
        cc.Mgr.PlatformController.setUserCloudStorage(cc.Mgr.UserDataMgr.HistoryHighAssets);
        cc.director.initMgr = true;
      }, this);
    } else {
      //cc.log("之前有过初始化");
      cc.Mgr.global.InitChangeData();
      cc.Mgr.UserDataMgr.initData();
      cc.director.initMgr = true;
    }
  },
  start: function start() {
    // 更换logo
    this.syncPlatformLogo();

    //首先监听右上角的按钮
    cc.Mgr.PlatformController.ShareTopNav();
    cc.Mgr.PlatformController.ShowClubButton(true);
    cc.director.preloadScene("gamescene", function () {
      cc.Mgr.preLoadingScene = true;
    });
    this.NameLbl.string = cc.Mgr.PlatformController.nickName;
    this.LoadingJuHua.runAction(cc.repeatForever(cc.rotateBy(0.2, 45)));
    var action = cc.sequence(cc.callFunc(function () {}, this), cc.fadeIn(2.0), cc.callFunc(function () {}, this));
    this.BtnsNode.runAction(action);

    //注册事件监听
    cc.director.GlobalEvent.on(cc.Mgr.Event.AchieveTip, function (data) {
      //cc.log("提示打开完成成就提示");
      this.commonTipPanel.node.active = true;
      this.commonTipPanel.ShowPanel(data);
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenUpgradeSkill, function (data) {
      //cc.log("提示技能升级提示");
      this.skillUpPanel.node.active = true;
      this.skillUpPanel.ShowPanel(data);
    }, this);
    cc.Mgr.AdsMgr.ShowBannerAds();
  },
  onLoadSuccess: function onLoadSuccess() {},
  syncPlatformLogo: function syncPlatformLogo() {
    var _this = this;
    if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
      cc.loader.loadRes('/atlas/logo' + cc.sys.BYTEDANCE_GAME, cc.SpriteFrame, function (err, spriteFrame) {
        if (err) {
          console.error('set sprite frame failed! err', '/atlas/logo' + cc.sys.BYTEDANCE_GAME, err);
          return;
        }
        _this.TitleSp.getComponent(cc.Sprite).spriteFrame = spriteFrame;
      });
    }
  },
  gotoGameScene: function gotoGameScene() {
    ///* 先注册名字
    if (!cc.Mgr.UserDataMgr.playerName) {
      this.InputNode.active = true;
      return;
    }
    console.log(cc.Mgr.Parse, cc.Mgr.preLoadingScene, cc.Mgr.initData);
    if (cc.Mgr.Parse && cc.Mgr.preLoadingScene && cc.Mgr.initData) {
      cc.Mgr.PlatformController.ShowClubButton(false);
      cc.Mgr.AudioMgr.playSFX("click");
      cc.director.loadScene("gamescene");
    }
  },
  ConfirmYourName: function ConfirmYourName() {
    cc.Mgr.UserDataMgr.playerName = cc.Mgr.PlatformController.nickName;
    this.InputNode.active = false;
    this.gotoGameScene();
    //if(this.InputText.string != "")
    //{
    //    cc.Mgr.AudioMgr.playSFX("click");
    ////cc.log("你选择的名字是 = "+ this.InputText.string);
    //    cc.Mgr.UserDataMgr.playerName = this.InputText.string;
    //    this.InputNode.active = false;
    //    this.gotoGameScene();
    //}
  },
  update: function update(dt) {
    if (cc.Mgr.Parse && cc.Mgr.preLoadingScene && cc.Mgr.initData) {
      this.LoadingNode.active = false;
    }
  },
  ConfrimSexMan: function ConfrimSexMan() {
    cc.Mgr.AudioMgr.playSFX("click");
    cc.Mgr.UserDataMgr.Sex = 1;
    this.SexSp.spriteFrame = this.StartAtlas.getSpriteFrame("manIcon");
  },
  ConfrimSexWoMan: function ConfrimSexWoMan() {
    cc.Mgr.AudioMgr.playSFX("click");
    cc.Mgr.UserDataMgr.Sex = 2;
    this.SexSp.spriteFrame = this.StartAtlas.getSpriteFrame("womanIcon");
  },
  OpenRank: function OpenRank() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (!cc.Mgr.PlatformController.IsLoginSync()) {
      var param = {};
      param.text = "请先登陆手机百度";
      param.forWhat = "Login";
      this.commonTipPanel.node.active = true;
      this.commonTipPanel.ShowPanel(param);
      return;
    }
    cc.Mgr.PlatformController.showSubContentView();
    cc.Mgr.PlatformController.SendMessageToSubView("RankOpen");
    var isKuaiShou = false;
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      isKuaiShou = true;
    }
    if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) this.wxSubContextView.active = true;else if (cc.sys.platform === cc.sys.BAIDU_GAME) this.SwanSubContextView.active = true;
    if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou || cc.sys.platform === cc.sys.BAIDU_GAME) this.rankPanel.node.active = true;
  },
  CloseRankView: function CloseRankView() {
    this.rankPanel.node.active = false;
    cc.Mgr.PlatformController.hideSubContentView();
    cc.Mgr.PlatformController.SendMessageToSubView("RankClose");
    this.wxSubContextView.active = false;
    this.SwanSubContextView.active = false;
  },
  OpenSkill: function OpenSkill() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.skillPanel.node.active = true;
    this.skillPanel.ShowPanel();
  },
  OpenAchieve: function OpenAchieve() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.honorPanel.node.active = true;
    this.honorPanel.ShowPanel();
  },
  OpenRecord: function OpenRecord() {
    cc.Mgr.AudioMgr.playSFX("click");
    //cc.log("历史纪录：++++++" + cc.Mgr.UserDataMgr.RecordList.length);
    if (cc.Mgr.UserDataMgr.RecordList.length == 0) {
      var param = {};
      param.text = "你还未有过游戏记录,请畅快游戏吧";
      param.forWhat = "";
      this.commonTipPanel.node.active = true;
      this.commonTipPanel.ShowPanel(param);
      return;
    }
    this.historyPanel.node.active = true;
    this.historyPanel.ShowPanel();
  },
  OpenCredit: function OpenCredit() {},
  OpenSetting: function OpenSetting() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.settingPanel.node.active = true;
    this.settingPanel.ShowPanel();
  },
  ShareToFriend: function ShareToFriend() {
    var index = Math.floor(Math.random() * 6);
    cc.Mgr.PlatformController.ShareToFriend(index);
  },
  ChangeName: function ChangeName() {
    cc.Mgr.PlatformController.InitRandNickName();
    this.NameLbl.string = cc.Mgr.PlatformController.nickName;
  }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEFwcFN0YXJ0LmpzIl0sIm5hbWVzIjpbImNjIiwiZGlyZWN0b3IiLCJpbml0TWdyIiwiTWdyIiwiUGFyc2UiLCJwcmVMb2FkaW5nU2NlbmUiLCJsb2FkU291bmQiLCJpbml0RGF0YSIsImdsb2JhbCIsInJlcXVpcmUiLCJFdmVudCIsIlNoYXJlSW5mb3MiLCJpbml0IiwiUGxhdGZvcm1Db250cm9sbGVyIiwiSW5pdCIsIkFkc01nciIsIkF1ZGlvTWdyIiwicGxheUJHTSIsIk1hcERhdGFNZ3IiLCJpbml0TWFwcyIsIlVzZXJEYXRhTWdyIiwiUmFua1BhbmVsIiwiSGlzdG9yeVBhbmVsIiwiSG9ub3JQYW5lbCIsIlNraWxsUGFuZWwiLCJTa2lsbFVwUGFuZWwiLCJTZXR0aW5nUGFuZWwiLCJDb21tb25UaXBQYW5lbCIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIlN0YXJ0QXRsYXMiLCJTcHJpdGVBdGxhcyIsIkJ0bnNOb2RlIiwiTm9kZSIsIklucHV0Tm9kZSIsIklucHV0VGV4dCIsIkVkaXRCb3giLCJTZXhTcCIsIlNwcml0ZSIsIkxvYWRpbmdOb2RlIiwiTG9hZGluZ0p1SHVhIiwicmFua1BhbmVsIiwiaGlzdG9yeVBhbmVsIiwiaG9ub3JQYW5lbCIsInNraWxsUGFuZWwiLCJza2lsbFVwUGFuZWwiLCJzZXR0aW5nUGFuZWwiLCJjb21tb25UaXBQYW5lbCIsIk5hbWVMYmwiLCJMYWJlbCIsInd4U3ViQ29udGV4dFZpZXciLCJTd2FuU3ViQ29udGV4dFZpZXciLCJUaXRsZVNwIiwib25Mb2FkIiwiR2xvYmFsRXZlbnQiLCJjbGVhciIsImFjdGl2ZSIsImxvZyIsIm9uIiwiUGFyc2VGaW5pc2giLCJzZXRVc2VyQ2xvdWRTdG9yYWdlIiwiSGlzdG9yeUhpZ2hBc3NldHMiLCJJbml0Q2hhbmdlRGF0YSIsInN0YXJ0Iiwic3luY1BsYXRmb3JtTG9nbyIsIlNoYXJlVG9wTmF2IiwiU2hvd0NsdWJCdXR0b24iLCJwcmVsb2FkU2NlbmUiLCJzdHJpbmciLCJuaWNrTmFtZSIsInJ1bkFjdGlvbiIsInJlcGVhdEZvcmV2ZXIiLCJyb3RhdGVCeSIsImFjdGlvbiIsInNlcXVlbmNlIiwiY2FsbEZ1bmMiLCJmYWRlSW4iLCJBY2hpZXZlVGlwIiwiZGF0YSIsIm5vZGUiLCJTaG93UGFuZWwiLCJPcGVuVXBncmFkZVNraWxsIiwiU2hvd0Jhbm5lckFkcyIsIm9uTG9hZFN1Y2Nlc3MiLCJfdGhpcyIsInN5cyIsInBsYXRmb3JtIiwiQllURURBTkNFX0dBTUUiLCJsb2FkZXIiLCJsb2FkUmVzIiwiU3ByaXRlRnJhbWUiLCJlcnIiLCJzcHJpdGVGcmFtZSIsImNvbnNvbGUiLCJlcnJvciIsImdldENvbXBvbmVudCIsImdvdG9HYW1lU2NlbmUiLCJwbGF5ZXJOYW1lIiwicGxheVNGWCIsImxvYWRTY2VuZSIsIkNvbmZpcm1Zb3VyTmFtZSIsInVwZGF0ZSIsImR0IiwiQ29uZnJpbVNleE1hbiIsIlNleCIsImdldFNwcml0ZUZyYW1lIiwiQ29uZnJpbVNleFdvTWFuIiwiT3BlblJhbmsiLCJJc0xvZ2luU3luYyIsInBhcmFtIiwidGV4dCIsImZvcldoYXQiLCJzaG93U3ViQ29udGVudFZpZXciLCJTZW5kTWVzc2FnZVRvU3ViVmlldyIsImlzS3VhaVNob3UiLCJrcyIsIldFQ0hBVF9HQU1FIiwiQkFJRFVfR0FNRSIsIkNsb3NlUmFua1ZpZXciLCJoaWRlU3ViQ29udGVudFZpZXciLCJPcGVuU2tpbGwiLCJPcGVuQWNoaWV2ZSIsIk9wZW5SZWNvcmQiLCJSZWNvcmRMaXN0IiwibGVuZ3RoIiwiT3BlbkNyZWRpdCIsIk9wZW5TZXR0aW5nIiwiU2hhcmVUb0ZyaWVuZCIsImluZGV4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiQ2hhbmdlTmFtZSIsIkluaXRSYW5kTmlja05hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQUEsRUFBRSxDQUFDQyxRQUFRLENBQUNDLE9BQU8sR0FBRyxLQUFLO0FBRTNC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Q0FBQyxDQUFDO0lBQ3ZDcEksRUFBRSxDQUFDRyxHQUFHLENBQUNVLGtCQUFrQixDQUFDbUgsYUFBYSxDQUFDQyxLQUFLLENBQUM7RUFDbEQsQ0FBQztFQUVESSxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCckksRUFBRSxDQUFDRyxHQUFHLENBQUNVLGtCQUFrQixDQUFDeUgsZ0JBQWdCLEVBQUU7SUFDNUMsSUFBSSxDQUFDckYsT0FBTyxDQUFDb0IsTUFBTSxHQUFHckUsRUFBRSxDQUFDRyxHQUFHLENBQUNVLGtCQUFrQixDQUFDeUQsUUFBUTtFQUM1RDtBQUNKLENBQUMsQ0FBQyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLy/mmK/lkKblrozmiJDov4fnrqHnkIblt6XlhbfnmoTliJ3lp4vljJZcclxuY2MuZGlyZWN0b3IuaW5pdE1nciA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gaW5pdE1ncigpe1xyXG4gICAgY2MuTWdyID0ge307XHJcbiAgICBjYy5NZ3IuUGFyc2UgPSBmYWxzZTtcclxuICAgIGNjLk1nci5wcmVMb2FkaW5nU2NlbmUgPSBmYWxzZTtcclxuICAgIGNjLk1nci5sb2FkU291bmQgPSBmYWxzZTtcclxuICAgIGNjLk1nci5pbml0RGF0YSA9IGZhbHNlO1xyXG5cclxuICAgIGNjLk1nci5nbG9iYWwgPSByZXF1aXJlKFwiR2xvYmFsXCIpO1xyXG4gICAgY2MuTWdyLkV2ZW50ID0gcmVxdWlyZShcIkV2ZW50XCIpO1xyXG4gICAgY2MuTWdyLlNoYXJlSW5mb3MgPSByZXF1aXJlKFwiU2hhcmVJbmZvc1wiKTtcclxuICAgIGNjLk1nci5TaGFyZUluZm9zLmluaXQoKTtcclxuICAgIGNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIgPSByZXF1aXJlKFwiUGxhdGZvcm1Db250cm9sbGVyXCIpO1xyXG4gICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5Jbml0KCk7XHJcblxyXG4gICAgY2MuTWdyLkFkc01nciA9IHJlcXVpcmUoXCJBZHNNZ3JcIik7XHJcbiAgICBjYy5NZ3IuQWRzTWdyLkluaXQoKTtcclxuXHJcbiAgICAvL+WjsOmfs1xyXG4gICAgdmFyIEF1ZGlvTWdyID0gcmVxdWlyZShcIkF1ZGlvTWdyXCIpO1xyXG4gICAgY2MuTWdyLkF1ZGlvTWdyID0gbmV3IEF1ZGlvTWdyKCk7XHJcbiAgICBjYy5NZ3IuQXVkaW9NZ3IuaW5pdCgpO1xyXG4gICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlCR00oXCJiZ21cIik7XHJcblxyXG4gICAgdmFyIE1hcERhdGFNZ3IgPSByZXF1aXJlKFwiTWFwRGF0YU1nclwiKTtcclxuICAgIGNjLk1nci5NYXBEYXRhTWdyID0gbmV3IE1hcERhdGFNZ3IoKTtcclxuICAgIGNjLk1nci5NYXBEYXRhTWdyLmluaXRNYXBzKCk7IC8v5Yid5aeL5YyW6Kej5p6Q5pWw5o2u6KGoXHJcblxyXG4gICAgdmFyIFVzZXJEYXRhTWdyID0gcmVxdWlyZShcIlVzZXJEYXRhTWdyXCIpO1xyXG4gICAgY2MuTWdyLlVzZXJEYXRhTWdyID0gbmV3IFVzZXJEYXRhTWdyKCk7XHJcblxyXG59XHJcblxyXG52YXIgUmFua1BhbmVsID0gcmVxdWlyZShcIlJhbmtQYW5lbFwiKTtcclxudmFyIEhpc3RvcnlQYW5lbCA9IHJlcXVpcmUoXCJIaXN0b3J5UGFuZWxcIik7XHJcbnZhciBIb25vclBhbmVsID0gcmVxdWlyZShcIkhvbm9yUGFuZWxcIik7XHJcbnZhciBTa2lsbFBhbmVsID0gcmVxdWlyZShcIlNraWxsUGFuZWxcIik7XHJcbnZhciBTa2lsbFVwUGFuZWwgPSByZXF1aXJlKFwiU2tpbGxVcFBhbmVsXCIpO1xyXG52YXIgU2V0dGluZ1BhbmVsID0gcmVxdWlyZShcIlNldHRpbmdQYW5lbFwiKTtcclxudmFyIENvbW1vblRpcFBhbmVsID0gcmVxdWlyZShcIkNvbW1vblRpcFBhbmVsXCIpO1xyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgU3RhcnRBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICBCdG5zTm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIElucHV0Tm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIElucHV0VGV4dDpjYy5FZGl0Qm94LFxyXG4gICAgICAgIFNleFNwOmNjLlNwcml0ZSxcclxuXHJcbiAgICAgICAgTG9hZGluZ05vZGU6Y2MuTm9kZSxcclxuICAgICAgICBMb2FkaW5nSnVIdWE6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgLy/pnaLmnb9cclxuICAgICAgICByYW5rUGFuZWw6UmFua1BhbmVsLFxyXG4gICAgICAgIGhpc3RvcnlQYW5lbDpIaXN0b3J5UGFuZWwsXHJcbiAgICAgICAgaG9ub3JQYW5lbDpIb25vclBhbmVsLFxyXG4gICAgICAgIHNraWxsUGFuZWw6U2tpbGxQYW5lbCxcclxuICAgICAgICBza2lsbFVwUGFuZWw6U2tpbGxVcFBhbmVsLFxyXG4gICAgICAgIHNldHRpbmdQYW5lbDpTZXR0aW5nUGFuZWwsXHJcbiAgICAgICAgY29tbW9uVGlwUGFuZWw6Q29tbW9uVGlwUGFuZWwsXHJcblxyXG4gICAgICAgIE5hbWVMYmw6Y2MuTGFiZWwsXHJcblxyXG4gICAgICAgIHd4U3ViQ29udGV4dFZpZXc6Y2MuTm9kZSxcclxuICAgICAgICBTd2FuU3ViQ29udGV4dFZpZXc6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgVGl0bGVTcDogY2MuU3ByaXRlLFxyXG4gICAgfSxcclxuXHJcbiAgICBvbkxvYWQ6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8v55uu5YmN5oiR5Lus5YWI5LiN5L+d5a2Y5Lu75L2V5pWw5o2uICDmr4/mrKHlvIDlp4vmuIXnkIbkuIDmrKFcclxuICAgICAgICAvL2NjLnN5cy5sb2NhbFN0b3JhZ2UuY2xlYXIoKTtcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuSW5wdXROb2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmKGNjLmRpcmVjdG9yLmluaXRNZ3IgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY2MubG9nKFwi6L+Y5rKh5pyJ5Yid5aeL5YyW6L+HXCIpO1xyXG4gICAgICAgICAgICBpbml0TWdyKCk7XHJcbiAgICAgICAgICAgIC8vY2MuTWdyLmdsb2JhbC5Jbml0Q2hhbmdlRGF0YSgpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuUGFyc2VGaW5pc2gsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuaW5pdERhdGEoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLnNldFVzZXJDbG91ZFN0b3JhZ2UoY2MuTWdyLlVzZXJEYXRhTWdyLkhpc3RvcnlIaWdoQXNzZXRzKTtcclxuICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLmluaXRNZ3IgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuS5i+WJjeaciei/h+WIneWni+WMllwiKTtcclxuICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5Jbml0Q2hhbmdlRGF0YSgpO1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuaW5pdERhdGEoKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuaW5pdE1nciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydCAoKSB7XHJcbiAgICAgICAgLy8g5pu05o2ibG9nb1xyXG4gICAgICAgIHRoaXMuc3luY1BsYXRmb3JtTG9nbygpXHJcblxyXG4gICAgICAgIC8v6aaW5YWI55uR5ZCs5Y+z5LiK6KeS55qE5oyJ6ZKuXHJcbiAgICAgICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5TaGFyZVRvcE5hdigpO1xyXG5cclxuICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLlNob3dDbHViQnV0dG9uKHRydWUpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5wcmVsb2FkU2NlbmUoXCJnYW1lc2NlbmVcIiwgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY2MuTWdyLnByZUxvYWRpbmdTY2VuZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuTmFtZUxibC5zdHJpbmcgPSBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLm5pY2tOYW1lO1xyXG5cclxuICAgICAgICB0aGlzLkxvYWRpbmdKdUh1YS5ydW5BY3Rpb24oY2MucmVwZWF0Rm9yZXZlcihjYy5yb3RhdGVCeSgwLjIsNDUpKSk7XHJcblxyXG4gICAgICAgIHZhciBhY3Rpb24gPSBjYy5zZXF1ZW5jZShcclxuICAgICAgICAgICAgY2MuY2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LCB0aGlzKSxcclxuICAgICAgICAgICAgY2MuZmFkZUluKDIuMCksXHJcbiAgICAgICAgICAgIGNjLmNhbGxGdW5jKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LCB0aGlzKSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuQnRuc05vZGUucnVuQWN0aW9uKGFjdGlvbik7XHJcblxyXG4gICAgICAgIC8v5rOo5YaM5LqL5Lu255uR5ZCsXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LkFjaGlldmVUaXAsIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuaPkOekuuaJk+W8gOWujOaIkOaIkOWwseaPkOekulwiKTtcclxuICAgICAgICAgICAgdGhpcy5jb21tb25UaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbW9uVGlwUGFuZWwuU2hvd1BhbmVsKGRhdGEpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlblVwZ3JhZGVTa2lsbCwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5o+Q56S65oqA6IO95Y2H57qn5o+Q56S6XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNraWxsVXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpbGxVcFBhbmVsLlNob3dQYW5lbChkYXRhKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcblxyXG4gICAgICAgIGNjLk1nci5BZHNNZ3IuU2hvd0Jhbm5lckFkcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkxvYWRTdWNjZXNzOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBzeW5jUGxhdGZvcm1Mb2dvOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJZVEVEQU5DRV9HQU1FKSB7XHJcbiAgICAgICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKCcvYXRsYXMvbG9nbycgKyBjYy5zeXMuQllURURBTkNFX0dBTUUsIGNjLlNwcml0ZUZyYW1lLCAoZXJyLCBzcHJpdGVGcmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NldCBzcHJpdGUgZnJhbWUgZmFpbGVkISBlcnInLCAnL2F0bGFzL2xvZ28nICsgY2Muc3lzLkJZVEVEQU5DRV9HQU1FLCBlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLlRpdGxlU3AuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkuc3ByaXRlRnJhbWUgPSBzcHJpdGVGcmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdvdG9HYW1lU2NlbmU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAvLy8qIOWFiOazqOWGjOWQjeWtl1xyXG4gICAgICAgIGlmKCFjYy5NZ3IuVXNlckRhdGFNZ3IucGxheWVyTmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuSW5wdXROb2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coY2MuTWdyLlBhcnNlICwgY2MuTWdyLnByZUxvYWRpbmdTY2VuZSAsIGNjLk1nci5pbml0RGF0YSlcclxuICAgICAgICBpZihjYy5NZ3IuUGFyc2UgJiYgY2MuTWdyLnByZUxvYWRpbmdTY2VuZSAmJiBjYy5NZ3IuaW5pdERhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLlNob3dDbHViQnV0dG9uKGZhbHNlKTtcclxuICAgICAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiZ2FtZXNjZW5lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgQ29uZmlybVlvdXJOYW1lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnBsYXllck5hbWUgPSBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLm5pY2tOYW1lO1xyXG4gICAgICAgIHRoaXMuSW5wdXROb2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ290b0dhbWVTY2VuZSgpO1xyXG4gICAgICAgIC8vaWYodGhpcy5JbnB1dFRleHQuc3RyaW5nICE9IFwiXCIpXHJcbiAgICAgICAgLy97XHJcbiAgICAgICAgLy8gICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICAgICAgLy8vL2NjLmxvZyhcIuS9oOmAieaLqeeahOWQjeWtl+aYryA9IFwiKyB0aGlzLklucHV0VGV4dC5zdHJpbmcpO1xyXG4gICAgICAgIC8vICAgIGNjLk1nci5Vc2VyRGF0YU1nci5wbGF5ZXJOYW1lID0gdGhpcy5JbnB1dFRleHQuc3RyaW5nO1xyXG4gICAgICAgIC8vICAgIHRoaXMuSW5wdXROb2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vICAgIHRoaXMuZ290b0dhbWVTY2VuZSgpO1xyXG4gICAgICAgIC8vfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGUoZHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYoY2MuTWdyLlBhcnNlICYmIGNjLk1nci5wcmVMb2FkaW5nU2NlbmUgJiYgY2MuTWdyLmluaXREYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5Mb2FkaW5nTm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIENvbmZyaW1TZXhNYW46ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5TZXggPSAxO1xyXG4gICAgICAgIHRoaXMuU2V4U3Auc3ByaXRlRnJhbWUgPSB0aGlzLlN0YXJ0QXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJtYW5JY29uXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBDb25mcmltU2V4V29NYW46ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5TZXggPSAyO1xyXG4gICAgICAgIHRoaXMuU2V4U3Auc3ByaXRlRnJhbWUgPSB0aGlzLlN0YXJ0QXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJ3b21hbkljb25cIik7XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5SYW5rOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuXHJcbiAgICAgICAgaWYoIWNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIuSXNMb2dpblN5bmMoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLor7flhYjnmbvpmYbmiYvmnLrnmb7luqZcIjtcclxuICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiTG9naW5cIjtcclxuICAgICAgICAgICAgdGhpcy5jb21tb25UaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbW9uVGlwUGFuZWwuU2hvd1BhbmVsKHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5zaG93U3ViQ29udGVudFZpZXcoKTtcclxuICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLlNlbmRNZXNzYWdlVG9TdWJWaWV3KFwiUmFua09wZW5cIik7XHJcbiAgICAgICAgbGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG4gICAgICAgICAgICBpc0t1YWlTaG91ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuV0VDSEFUX0dBTUUgJiYgIWlzS3VhaVNob3UpXHJcbiAgICAgICAgICAgIHRoaXMud3hTdWJDb250ZXh0Vmlldy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuICAgICAgICAgICAgdGhpcy5Td2FuU3ViQ29udGV4dFZpZXcuYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYoKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLldFQ0hBVF9HQU1FICYmICFpc0t1YWlTaG91KSB8fCBjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CQUlEVV9HQU1FKVxyXG4gICAgICAgICAgICB0aGlzLnJhbmtQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUmFua1ZpZXc6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLnJhbmtQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIuaGlkZVN1YkNvbnRlbnRWaWV3KCk7XHJcbiAgICAgICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5TZW5kTWVzc2FnZVRvU3ViVmlldyhcIlJhbmtDbG9zZVwiKTtcclxuICAgICAgICB0aGlzLnd4U3ViQ29udGV4dFZpZXcuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5Td2FuU3ViQ29udGV4dFZpZXcuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5Ta2lsbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5za2lsbFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNraWxsUGFuZWwuU2hvd1BhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5BY2hpZXZlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLmhvbm9yUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaG9ub3JQYW5lbC5TaG93UGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgT3BlblJlY29yZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgLy9jYy5sb2coXCLljoblj7LnuqrlvZXvvJorKysrKytcIiArIGNjLk1nci5Vc2VyRGF0YU1nci5SZWNvcmRMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLlJlY29yZExpc3QubGVuZ3RoID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5L2g6L+Y5pyq5pyJ6L+H5ri45oiP6K6w5b2VLOivt+eVheW/q+a4uOaIj+WQp1wiO1xyXG4gICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJcIjtcclxuICAgICAgICAgICAgdGhpcy5jb21tb25UaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbW9uVGlwUGFuZWwuU2hvd1BhbmVsKHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhpc3RvcnlQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5oaXN0b3J5UGFuZWwuU2hvd1BhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5DcmVkaXQ6ZnVuY3Rpb24oKXtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5TZXR0aW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLnNldHRpbmdQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5nUGFuZWwuU2hvd1BhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNoYXJlVG9GcmllbmQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNik7XHJcbiAgICAgICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5TaGFyZVRvRnJpZW5kKGluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2hhbmdlTmFtZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIuSW5pdFJhbmROaWNrTmFtZSgpO1xyXG4gICAgICAgIHRoaXMuTmFtZUxibC5zdHJpbmcgPSBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLm5pY2tOYW1lO1xyXG4gICAgfSxcclxufSk7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/OwnData/SkillStruct.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd0b063Aeh1DZKzAUPvVTiFN', 'SkillStruct');
// Scripts/OwnData/SkillStruct.js

"use strict";

//技能天赋
var SkillStruct = cc.Class({
  name: "SkillStruct",
  properties: {
    icon: "",
    name: "",
    Id: cc.Integer,
    subId: cc.Integer,
    level: cc.Integer,
    Uplv: cc.Integer,
    desId: cc.Integer,
    skillType: cc.Integer
  }
});
module.exports = SkillStruct;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcT3duRGF0YVxcU2tpbGxTdHJ1Y3QuanMiXSwibmFtZXMiOlsiU2tpbGxTdHJ1Y3QiLCJjYyIsIkNsYXNzIiwibmFtZSIsInByb3BlcnRpZXMiLCJpY29uIiwiSWQiLCJJbnRlZ2VyIiwic3ViSWQiLCJsZXZlbCIsIlVwbHYiLCJkZXNJZCIsInNraWxsVHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQSxJQUFJQSxXQUFXLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzFCQyxJQUFJLEVBQUMsYUFBYTtFQUNmQyxVQUFVLEVBQUU7SUFDWEMsSUFBSSxFQUFDLEVBQUU7SUFDUEYsSUFBSSxFQUFDLEVBQUU7SUFDUEcsRUFBRSxFQUFDTCxFQUFFLENBQUNNLE9BQU87SUFDYkMsS0FBSyxFQUFDUCxFQUFFLENBQUNNLE9BQU87SUFDYkUsS0FBSyxFQUFDUixFQUFFLENBQUNNLE9BQU87SUFDaEJHLElBQUksRUFBQ1QsRUFBRSxDQUFDTSxPQUFPO0lBQ2ZJLEtBQUssRUFBQ1YsRUFBRSxDQUFDTSxPQUFPO0lBQ2hCSyxTQUFTLEVBQUNYLEVBQUUsQ0FBQ007RUFDakI7QUFDSixDQUFDLENBQUM7QUFDRk0sTUFBTSxDQUFDQyxPQUFPLEdBQUdkLFdBQVciLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vL+aKgOiDveWkqei1i1xyXG52YXIgU2tpbGxTdHJ1Y3QgPSBjYy5DbGFzcyh7XHJcblx0bmFtZTpcIlNraWxsU3RydWN0XCIsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICBcdGljb246XCJcIixcclxuICAgIFx0bmFtZTpcIlwiLFxyXG4gICAgXHRJZDpjYy5JbnRlZ2VyLFxyXG4gICAgXHRzdWJJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGxldmVsOmNjLkludGVnZXIsXHJcbiAgICAgICAgVXBsdjpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIGRlc0lkOmNjLkludGVnZXIsXHJcbiAgICAgICAgc2tpbGxUeXBlOmNjLkludGVnZXIsXHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBTa2lsbFN0cnVjdDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/BelongItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b39f0lCkV5LqZLaCiCHm5Zf', 'BelongItem');
// Scripts/UI/BelongItem.js

"use strict";

var ItemType = require("ItemType");
var BelongItem = cc.Class({
  "extends": cc.Component,
  properties: {
    itemType: {
      "default": ItemType.Car,
      type: ItemType
    },
    Id: cc.Integer,
    ItemName: "",
    icon: cc.Sprite,
    Atlas: cc.SpriteAtlas,
    price: cc.Integer,
    nameLbl: cc.Label,
    desLbl: cc.Label,
    Data: null
  },
  init: function init(data, itemType) {
    this.Id = data.Id;
    this.Data = data;
    this.itemType = itemType;
    this.icon.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    //this.nameLbl.string = data.name;
    this.ItemName = data.name;
    if (data.price == null) this.price = 0;else this.price = data.price;
    if (this.itemType == ItemType.Car || this.itemType == ItemType.House) {
      this.desLbl.string = "x" + data.ownNum;
    } else if (this.itemType == ItemType.Mate) {
      this.desLbl.string = "";
    }
  },
  ClickOpen: function ClickOpen() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (this.itemType == ItemType.Car || this.itemType == ItemType.House) {
      var param = {};
      if (this.itemType == ItemType.Car) param.name = cc.Mgr.global.getTranslation("car_" + this.Id);else param.name = cc.Mgr.global.getTranslation("company_" + this.Id);
      param.Id = this.Id;
      param.Type = ItemType.House;
      if (this.itemType == ItemType.Car) param.Type = ItemType.Car;
      param.price = this.price;
      param.icon = this.Data.icon;
      param.flag = "Sale";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonBuy, param);
    } else if (this.itemType == ItemType.Mate) {
      var param = {};
      param.name = param.name = cc.Mgr.global.getTranslation("role_" + this.Id);
      param.Id = this.Id;
      param.Type = ItemType.Mate;
      param.price = this.price;
      param.flag = "Sale";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonBuy, param);
    }
  },
  Refresh: function Refresh(data) {
    if (this.itemType == ItemType.Car || this.itemType == ItemType.House) {
      this.desLbl.string = "x" + data.ownNum;
    }
  }
});
module.exports = BelongItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEJlbG9uZ0l0ZW0uanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiQmVsb25nSXRlbSIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiaXRlbVR5cGUiLCJDYXIiLCJ0eXBlIiwiSWQiLCJJbnRlZ2VyIiwiSXRlbU5hbWUiLCJpY29uIiwiU3ByaXRlIiwiQXRsYXMiLCJTcHJpdGVBdGxhcyIsInByaWNlIiwibmFtZUxibCIsIkxhYmVsIiwiZGVzTGJsIiwiRGF0YSIsImluaXQiLCJkYXRhIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsIm5hbWUiLCJIb3VzZSIsInN0cmluZyIsIm93bk51bSIsIk1hdGUiLCJDbGlja09wZW4iLCJNZ3IiLCJBdWRpb01nciIsInBsYXlTRlgiLCJwYXJhbSIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwiVHlwZSIsImZsYWciLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vbkJ1eSIsIlJlZnJlc2giLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxVQUFVLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3RCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFFBQVEsRUFBQztNQUNMLFdBQVFQLFFBQVEsQ0FBQ1EsR0FBRztNQUNwQkMsSUFBSSxFQUFDVDtJQUNULENBQUM7SUFDRFUsRUFBRSxFQUFDUCxFQUFFLENBQUNRLE9BQU87SUFDYkMsUUFBUSxFQUFDLEVBQUU7SUFDWEMsSUFBSSxFQUFDVixFQUFFLENBQUNXLE1BQU07SUFDZEMsS0FBSyxFQUFDWixFQUFFLENBQUNhLFdBQVc7SUFDcEJDLEtBQUssRUFBQ2Qs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Q0FBQzhCLElBQUksRUFDdEM7TUFDSSxJQUFJSyxLQUFLLEdBQUcsQ0FBQyxDQUFDO01BQ2RBLEtBQUssQ0FBQ1QsSUFBSSxHQUFHUyxLQUFLLENBQUNULElBQUksR0FBR3ZCLEVBQUUsQ0FBQzZCLEdBQUcsQ0FBQ0ksTUFBTSxDQUFDQyxjQUFjLENBQUMsT0FBTyxHQUFDLElBQUksQ0FBQzNCLEVBQUUsQ0FBQztNQUN2RXlCLEtBQUssQ0FBQ3pCLEVBQUUsR0FBRyxJQUFJLENBQUNBLEVBQUU7TUFDbEJ5QixLQUFLLENBQUNHLElBQUksR0FBR3RDLFFBQVEsQ0FBQzhCLElBQUk7TUFDMUJLLEtBQUssQ0FBQ2xCLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7TUFDeEJrQixLQUFLLENBQUNJLElBQUksR0FBRyxNQUFNO01BQ25CcEMsRUFBRSxDQUFDcUMsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQ3ZDLEVBQUUsQ0FBQzZCLEdBQUcsQ0FBQ1csS0FBSyxDQUFDQyxhQUFhLEVBQUVULEtBQUssQ0FBQztJQUNuRTtFQUVKLENBQUM7RUFFRFUsT0FBTyxFQUFDLFNBQUFBLFFBQVN0QixJQUFJLEVBQUM7SUFDbEIsSUFBRyxJQUFJLENBQUNoQixRQUFRLElBQUlQLFFBQVEsQ0FBQ1EsR0FBRyxJQUFJLElBQUksQ0FBQ0QsUUFBUSxJQUFJUCxRQUFRLENBQUMyQixLQUFLLEVBQ25FO01BQ0ksSUFBSSxDQUFDUCxNQUFNLENBQUNRLE1BQU0sR0FBRyxHQUFHLEdBQUdMLElBQUksQ0FBQ00sTUFBTTtJQUMxQztFQUNKO0FBRUosQ0FBQyxDQUFDO0FBQ0ZpQixNQUFNLENBQUNDLE9BQU8sR0FBRzdDLFVBQVUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIEJlbG9uZ0l0ZW0gPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGl0ZW1UeXBlOntcclxuICAgICAgICAgICAgZGVmYXVsdDpJdGVtVHlwZS5DYXIsXHJcbiAgICAgICAgICAgIHR5cGU6SXRlbVR5cGUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIEl0ZW1OYW1lOlwiXCIsXHJcbiAgICAgICAgaWNvbjpjYy5TcHJpdGUsXHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgcHJpY2U6Y2MuSW50ZWdlcixcclxuICAgICAgICBuYW1lTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIGRlc0xibDpjYy5MYWJlbCxcclxuICAgICAgICBEYXRhOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6ZnVuY3Rpb24gKGRhdGEsIGl0ZW1UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5JZCA9IGRhdGEuSWQ7XHJcbiAgICAgICAgdGhpcy5EYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLml0ZW1UeXBlID0gaXRlbVR5cGU7XHJcbiAgICAgICAgdGhpcy5pY29uLnNwcml0ZUZyYW1lID0gdGhpcy5BdGxhcy5nZXRTcHJpdGVGcmFtZShkYXRhLmljb24pO1xyXG4gICAgICAgIC8vdGhpcy5uYW1lTGJsLnN0cmluZyA9IGRhdGEubmFtZTtcclxuICAgICAgICB0aGlzLkl0ZW1OYW1lID0gZGF0YS5uYW1lO1xyXG4gICAgICAgIGlmKGRhdGEucHJpY2UgPT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5wcmljZSA9IDA7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLnByaWNlID0gZGF0YS5wcmljZTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLkNhciB8fCB0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLkhvdXNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNMYmwuc3RyaW5nID0gXCJ4XCIgKyBkYXRhLm93bk51bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLk1hdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmRlc0xibC5zdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tPcGVuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICBpZih0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLkNhciB8fCB0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLkhvdXNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXRlbVR5cGUgPT0gSXRlbVR5cGUuQ2FyKVxyXG4gICAgICAgICAgICAgICAgcGFyYW0ubmFtZSA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJjYXJfXCIgKyB0aGlzLklkKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcGFyYW0ubmFtZSA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJjb21wYW55X1wiK3RoaXMuSWQpO1xyXG4gICAgICAgICAgICBwYXJhbS5JZCA9IHRoaXMuSWQ7XHJcbiAgICAgICAgICAgIHBhcmFtLlR5cGUgPSBJdGVtVHlwZS5Ib3VzZTtcclxuICAgICAgICAgICAgaWYodGhpcy5pdGVtVHlwZSA9PSBJdGVtVHlwZS5DYXIpXHJcbiAgICAgICAgICAgICAgICBwYXJhbS5UeXBlID0gSXRlbVR5cGUuQ2FyO1xyXG4gICAgICAgICAgICBwYXJhbS5wcmljZSA9IHRoaXMucHJpY2U7XHJcbiAgICAgICAgICAgIHBhcmFtLmljb24gPSB0aGlzLkRhdGEuaWNvbjtcclxuICAgICAgICAgICAgcGFyYW0uZmxhZyA9IFwiU2FsZVwiO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uQnV5LCBwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5pdGVtVHlwZSA9PSBJdGVtVHlwZS5NYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLm5hbWUgPSBwYXJhbS5uYW1lID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcInJvbGVfXCIrdGhpcy5JZCk7XHJcbiAgICAgICAgICAgIHBhcmFtLklkID0gdGhpcy5JZDtcclxuICAgICAgICAgICAgcGFyYW0uVHlwZSA9IEl0ZW1UeXBlLk1hdGU7XHJcbiAgICAgICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5wcmljZTtcclxuICAgICAgICAgICAgcGFyYW0uZmxhZyA9IFwiU2FsZVwiO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uQnV5LCBwYXJhbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaDpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICBpZih0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLkNhciB8fCB0aGlzLml0ZW1UeXBlID09IEl0ZW1UeXBlLkhvdXNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNMYmwuc3RyaW5nID0gXCJ4XCIgKyBkYXRhLm93bk51bTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQmVsb25nSXRlbTsiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/BetPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3e414miwcVCzL4CUcTU1Wbf', 'BetPanel');
// Scripts/UI/BetPanel.js

"use strict";

var TempBonus = require("TempBonus");
var BetPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    CashLbl: cc.Label,
    costLbl: cc.Label,
    cost: cc.Integer,
    CoinNode: cc.Node,
    CoinEffect: cc.Animation,
    zhenNode: cc.Node,
    stateBet: false,
    rate: 0,
    IsWin: false,
    tmpWinRatio: 0 //临时赢钱概率
  },

  ShowPanel: function ShowPanel(data) {
    this.CoinNode.active = false;
    this.stateBet = false;
    this.tmpWinRatio = 0;
    this.zhenNode.rotation = 0;
    this.costLbl.string = "花费金额:" + cc.Mgr.global.BetInitCost;
    this.CashLbl.string = cc.Mgr.UserDataMgr.Cash;
  },
  ClickBet: function ClickBet() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (this.stateBet == true) return;
    if (cc.Mgr.UserDataMgr.Cash < cc.Mgr.global.BetInitCost) {
      var param = {};
      param.forWhat = "";
      param.text = cc.Mgr.global.getTranslation("MoneyNotEnough");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    this.stateBet = true;
    this.GoToBet();
  },
  CaculateWinRatio: function CaculateWinRatio() {
    var seed = Math.random();
    this.IsWin = true;
    this.zhenNode.rotation / 60 % 6;
    var rotateAngle = 360 * 6;
    if (seed < cc.Mgr.global.BetWinNullRatio) {
      this.IsWin = false;
      this.rate = 0;
      var sd = Math.random();
      if (sd < 0.33) rotateAngle += 0;else if (sd < 0.66) rotateAngle += 2 * 60;else rotateAngle += 4 * 60;
    } else if (seed < cc.Mgr.global.BetWinThreeRatio) {
      this.rate = 3;
      rotateAngle += 1 * 60;
    } else if (seed < cc.Mgr.global.BetWinFourRatio) {
      this.rate = 4;
      rotateAngle += 3 * 60;
    } else {
      this.rate = 5;
      rotateAngle += 5 * 60;
    }
    return rotateAngle;
  },
  //0 2 4 位置是 谢谢惠顾
  //1 3 5 是win
  GoToBet: function GoToBet() {
    var _this = this;
    var self = this;
    var seed = Math.floor(Math.random() * 6) + 1;
    cc.Mgr.UserDataMgr.Cash -= cc.Mgr.global.BetInitCost;
    var x = this.CaculateWinRatio();
    var rotation = cc.rotateTo(3, x).easing(cc.easeSineInOut());
    var finished = cc.callFunc(function () {
      cc.log("这就是结局================" + _this.zhenNode.rotation);
      self.EndBet();
    }, this);
    var action = cc.sequence(rotation, finished);
    this.zhenNode.runAction(action);
  },
  ShowResult: function ShowResult() {
    if (this.IsWin) {
      var param = {};
      var getMoney = cc.Mgr.global.BetInitCost * this.rate;
      if (cc.Mgr.global.TempAdsBetBonus == TempBonus.BetBonus) {
        getMoney = Math.floor(cc.Mgr.global.BetInitCost * this.rate * 1.2);
        //cc.Mgr.global.TempAdsBetBonus = TempBonus.NULL;
      }

      cc.Mgr.UserDataMgr.Cash += getMoney;
      param.text = cc.Mgr.global.getTranslation("BetWin") + "\n奖励:" + getMoney;
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      this.tmpWinRatio = 0; //临时概率清零
    } else {
      var param = {};
      param.text = cc.Mgr.global.getTranslation("BetLose");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      this.tmpWinRatio += 0.05;
      if (this.tmpWinRatio > 0.25) {
        this.tmpWinRatio = 0.25;
      }
    }
    cc.Mgr.global.BetInitCost = cc.Mgr.global.BetInitCost * 2;
    cc.director.GlobalEvent.emit(cc.Mgr.Event.RefreshCashAsset, {});
    this.costLbl.string = "花费金额:" + cc.Mgr.global.BetInitCost;
    this.CashLbl.string = cc.Mgr.UserDataMgr.Cash;
  },
  EndBet: function EndBet() {
    if (this.IsWin) {
      this.CoinNode.active = true;
      this.CoinEffect.play("betCoin");
      cc.Mgr.AudioMgr.playSFX("goods_4");
    } else {
      this.stateBet = false;
      cc.Mgr.AudioMgr.playSFX("lose");
      this.ShowResult();
    }
  },
  EndCoinEffect: function EndCoinEffect() {
    this.CoinNode.active = false;
    this.stateBet = false;
    this.ShowResult();
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = BetPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEJldFBhbmVsLmpzIl0sIm5hbWVzIjpbIlRlbXBCb251cyIsInJlcXVpcmUiLCJCZXRQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiQXRsYXMiLCJTcHJpdGVBdGxhcyIsIkNhc2hMYmwiLCJMYWJlbCIsImNvc3RMYmwiLCJjb3N0IiwiSW50ZWdlciIsIkNvaW5Ob2RlIiwiTm9kZSIsIkNvaW5FZmZlY3QiLCJBbmltYXRpb24iLCJ6aGVuTm9kZSIsInN0YXRlQmV0IiwicmF0ZSIsIklzV2luIiwidG1wV2luUmF0aW8iLCJTaG93UGFuZWwiLCJkYXRhIiwiYWN0aXZlIiwicm90YXRpb24iLCJzdHJpbmciLCJNZ3IiLCJnbG9iYWwiLCJCZXRJbml0Q29zdCIsIlVzZXJEYXRhTWdyIiwiQ2FzaCIsIkNsaWNrQmV0IiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwicGFyYW0iLCJmb3JXaGF0IiwidGV4dCIsImdldFRyYW5zbGF0aW9uIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIk9wZW5Db21tb25UaXAiLCJHb1RvQmV0IiwiQ2FjdWxhdGVXaW5SYXRpbyIsInNlZWQiLCJNYXRoIiwicmFuZG9tIiwicm90YXRlQW5nbGUiLCJCZXRXaW5OdWxsUmF0aW8iLCJzZCIsIkJldFdpblRocmVlUmF0aW8iLCJCZXRXaW5Gb3VyUmF0aW8iLCJfdGhpcyIsInNlbGYiLCJmbG9vciIsIngiLCJyb3RhdGVUbyIsImVhc2luZyIsImVhc2VTaW5lSW5PdXQiLCJmaW5pc2hlZCIsImNhbGxGdW5jIiwibG9nIiwiRW5kQmV0IiwiYWN0aW9uIiwic2VxdWVuY2UiLCJydW5BY3Rpb24iLCJTaG93UmVzdWx0IiwiZ2V0TW9uZXkiLCJUZW1wQWRzQmV0Qm9udXMiLCJCZXRCb251cyIsIlJlZnJlc2hDYXNoQXNzZXQiLCJwbGF5IiwiRW5kQ29pbkVmZmVjdCIsIkNsb3NlUGFuZWwiLCJub2Rl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QyxXQUFXO0lBQ3ZELElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ2tCLE1BQU0sR0FBR3hCLEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ0csV0FBVyxDQUFDQyxJQUFJO0VBQ2pELENBQUM7RUFFRGlDLE1BQU0sRUFBQyxTQUFBQSxPQUFBLEVBQVU7SUFDYixJQUFHLElBQUksQ0FBQzVDLEtBQUssRUFDYjtNQUNDLElBQUksQ0FBQ1AsUUFBUSxDQUFDVyxNQUFNLEdBQUcsSUFBSTtNQUN4QixJQUFJLENBQUNULFVBQVUsQ0FBQzBELElBQUksQ0FBQyxTQUFTLENBQUM7TUFDL0J2RSxFQUFFLENBQUN5QixHQUFHLENBQUNNLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLFNBQVMsQ0FBQztJQUN0QyxDQUFDLE1BRUQ7TUFDQyxJQUFJLENBQUNoQixRQUFRLEdBQUcsS0FBSztNQUNsQmhCLEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ00sUUFBUSxDQUFDQyxPQUFPLENBQUMsTUFBTSxDQUFDO01BQy9CLElBQUksQ0FBQ2tDLFVBQVUsRUFBRTtJQUNyQjtFQUNKLENBQUM7RUFFRE0sYUFBYSxFQUFDLFNBQUFBLGNBQUEsRUFBVTtJQUN2QixJQUFJLENBQUM3RCxRQUFRLENBQUNXLE1BQU0sR0FBRyxLQUFLO0lBQzVCLElBQUksQ0FBQ04sUUFBUSxHQUFHLEtBQUs7SUFDbEIsSUFBSSxDQUFDa0QsVUFBVSxFQUFFO0VBQ3JCLENBQUM7RUFFRE8sVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBVTtJQUNqQnpFLEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ00sUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUksQ0FBQzBDLElBQUksQ0FBQ3BELE1BQU0sR0FBRyxLQUFLO0VBQzVCO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZxRCxNQUFNLENBQUNDLE9BQU8sR0FBRzdFLFFBQVEiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBUZW1wQm9udXMgPSByZXF1aXJlKFwiVGVtcEJvbnVzXCIpO1xyXG52YXIgQmV0UGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICBDYXNoTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgY29zdExibDpjYy5MYWJlbCxcclxuICAgICAgIGNvc3Q6Y2MuSW50ZWdlcixcclxuXHJcbiAgICAgICBDb2luTm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgQ29pbkVmZmVjdDpjYy5BbmltYXRpb24sXHJcblxyXG4gIFx0ICAgemhlbk5vZGU6Y2MuTm9kZSxcclxuICAgICAgIHN0YXRlQmV0OmZhbHNlLFxyXG4gICAgICAgcmF0ZTowLFxyXG4gICAgICAgSXNXaW46ZmFsc2UsXHJcbiAgICAgICB0bXBXaW5SYXRpbzowLC8v5Li05pe26LWi6ZKx5qaC546HXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgXHR0aGlzLkNvaW5Ob2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgXHR0aGlzLnN0YXRlQmV0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50bXBXaW5SYXRpbyA9IDA7XHJcbiAgICAgICAgdGhpcy56aGVuTm9kZS5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5jb3N0TGJsLnN0cmluZyA9IFwi6Iqx6LS56YeR6aKdOlwiK2NjLk1nci5nbG9iYWwuQmV0SW5pdENvc3Q7XHJcbiAgICAgICAgdGhpcy5DYXNoTGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja0JldDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZUJldCA9PSB0cnVlKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggPCBjYy5NZ3IuZ2xvYmFsLkJldEluaXRDb3N0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIlwiO1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIk1vbmV5Tm90RW5vdWdoXCIpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZUJldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5Hb1RvQmV0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIENhY3VsYXRlV2luUmF0aW86ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VlZCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgdGhpcy5Jc1dpbiA9IHRydWU7XHJcbiAgICAgICAgKHRoaXMuemhlbk5vZGUucm90YXRpb24gLyA2MCkgJSA2O1xyXG4gICAgICAgIHZhciByb3RhdGVBbmdsZSA9IDM2MCAqIDY7XHJcbiAgICAgICAgaWYoc2VlZCA8IGNjLk1nci5nbG9iYWwuQmV0V2luTnVsbFJhdGlvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5Jc1dpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnJhdGUgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc2QgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBpZihzZCA8IDAuMzMpXHJcbiAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSArPSAwO1xyXG4gICAgICAgICAgICBlbHNlIGlmKHNkIDwgMC42NilcclxuICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlICs9IDIgKiA2MDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgKz0gNCAqIDYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNlZWQgPCBjYy5NZ3IuZ2xvYmFsLkJldFdpblRocmVlUmF0aW8pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJhdGUgPSAzO1xyXG4gICAgICAgICAgICByb3RhdGVBbmdsZSArPSAxICogNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc2VlZCA8IGNjLk1nci5nbG9iYWwuQmV0V2luRm91clJhdGlvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yYXRlID0gNDtcclxuICAgICAgICAgICAgcm90YXRlQW5nbGUgKz0gMyAqIDYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJhdGUgPSA1O1xyXG4gICAgICAgICAgICByb3RhdGVBbmdsZSArPSA1ICogNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3RhdGVBbmdsZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8wIDIgNCDkvY3nva7mmK8g6LCi6LCi5oOg6aG+XHJcbiAgICAvLzEgMyA1IOaYr3dpblxyXG4gICAgR29Ub0JldDpmdW5jdGlvbigpe1xyXG4gICAgXHR2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBcdHZhciBzZWVkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNikgKyAxO1xyXG5cclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCAtPSBjYy5NZ3IuZ2xvYmFsLkJldEluaXRDb3N0O1xyXG5cclxuICAgIFx0dmFyIHggPSB0aGlzLkNhY3VsYXRlV2luUmF0aW8oKTtcclxuICAgIFx0dmFyIHJvdGF0aW9uID0gY2Mucm90YXRlVG8oMywgeCkuZWFzaW5nKGNjLmVhc2VTaW5lSW5PdXQoKSk7XHJcbiAgICBcdHZhciBmaW5pc2hlZCA9IGNjLmNhbGxGdW5jKCgpPT57XHJcbiAgICBcdFx0Y2MubG9nKFwi6L+Z5bCx5piv57uT5bGAPT09PT09PT09PT09PT09PVwiICsgdGhpcy56aGVuTm9kZS5yb3RhdGlvbik7XHJcbiAgICBcdFx0c2VsZi5FbmRCZXQoKTtcclxuICAgIFx0fSx0aGlzKTtcclxuXHJcbiAgICBcdHZhciBhY3Rpb24gPSBjYy5zZXF1ZW5jZShyb3RhdGlvbiwgZmluaXNoZWQpO1xyXG4gICAgXHR0aGlzLnpoZW5Ob2RlLnJ1bkFjdGlvbihhY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UmVzdWx0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5Jc1dpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgZ2V0TW9uZXkgPSAoY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdCAqIHRoaXMucmF0ZSk7IFxyXG4gICAgICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLlRlbXBBZHNCZXRCb251cyA9PSBUZW1wQm9udXMuQmV0Qm9udXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdldE1vbmV5ID0gTWF0aC5mbG9vcihjYy5NZ3IuZ2xvYmFsLkJldEluaXRDb3N0ICogdGhpcy5yYXRlICogMS4yKTtcclxuICAgICAgICAgICAgICAgIC8vY2MuTWdyLmdsb2JhbC5UZW1wQWRzQmV0Qm9udXMgPSBUZW1wQm9udXMuTlVMTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCArPSBnZXRNb25leTtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJCZXRXaW5cIikrIFwiXFxu5aWW5YqxOlwiICsgZ2V0TW9uZXk7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgdGhpcy50bXBXaW5SYXRpbyA9IDA7Ly/kuLTml7bmpoLnjofmuIXpm7ZcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiQmV0TG9zZVwiKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICB0aGlzLnRtcFdpblJhdGlvICs9IDAuMDU7XHJcbiAgICAgICAgICAgIGlmKHRoaXMudG1wV2luUmF0aW8gPiAwLjI1KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRtcFdpblJhdGlvID0gMC4yNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5NZ3IuZ2xvYmFsLkJldEluaXRDb3N0ID0gY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdCAqIDI7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuUmVmcmVzaENhc2hBc3NldCwge30pO1xyXG4gICAgICAgIHRoaXMuY29zdExibC5zdHJpbmcgPSBcIuiKsei0uemHkeminTpcIitjYy5NZ3IuZ2xvYmFsLkJldEluaXRDb3N0O1xyXG4gICAgICAgIHRoaXMuQ2FzaExibC5zdHJpbmcgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaDtcclxuICAgIH0sXHJcblxyXG4gICAgRW5kQmV0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5Jc1dpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgXHR0aGlzLkNvaW5Ob2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQ29pbkVmZmVjdC5wbGF5KFwiYmV0Q29pblwiKTtcclxuICAgICAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJnb29kc180XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgIFx0dGhpcy5zdGF0ZUJldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImxvc2VcIik7XHJcbiAgICAgICAgICAgIHRoaXMuU2hvd1Jlc3VsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgRW5kQ29pbkVmZmVjdDpmdW5jdGlvbigpe1xyXG4gICAgXHR0aGlzLkNvaW5Ob2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgXHR0aGlzLnN0YXRlQmV0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5TaG93UmVzdWx0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sIFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBCZXRQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CarItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b4a1bB6YoZJyJWAoX/eo/NJ', 'CarItem');
// Scripts/UI/CarItem.js

"use strict";

var ItemType = require("ItemType");
var CarItem = cc.Class({
  "extends": cc.Component,
  properties: {
    nameLbl: cc.Label,
    icon: cc.Sprite,
    Atlas: cc.SpriteAtlas,
    Data: null
  },
  init: function init(data) {
    this.icon.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.Data = data;
  },
  ClickBuy: function ClickBuy() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.name = this.Data.name;
    param.icon = this.Data.icon;
    param.Id = this.Data.Id;
    param.Type = ItemType.Car;
    param.price = this.Data.price;
    param.flag = "Buy";
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonBuy, param);
  }
});
module.exports = CarItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENhckl0ZW0uanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiQ2FySXRlbSIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwibmFtZUxibCIsIkxhYmVsIiwiaWNvbiIsIlNwcml0ZSIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJEYXRhIiwiaW5pdCIsImRhdGEiLCJzcHJpdGVGcmFtZSIsImdldFNwcml0ZUZyYW1lIiwiQ2xpY2tCdXkiLCJNZ3IiLCJBdWRpb01nciIsInBsYXlTRlgiLCJwYXJhbSIsIm5hbWUiLCJJZCIsIlR5cGUiLCJDYXIiLCJwcmljZSIsImZsYWciLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vbkJ1eSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLE9BQU8sR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDbkIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsT0FBTyxFQUFDSixFQUFFLENBQUNLLEtBQUs7SUFDaEJDLElBQUksRUFBQ04sRUFBRSxDQUFDTyxNQUFNO0lBQ2RDLEtBQUssRUFBQ1IsRUFBRSxDQUFDUyxXQUFXO0lBQ3BCQyxJQUFJLEVBQUM7RUFDVCxDQUFDO0VBRURDLElBQUksRUFBQyxTQUFBQSxLQUFVQyxJQUFJLEVBQUU7SUFDakIsSUFBSSxDQUFDTixJQUFJLENBQUNPLFdBQVcsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ00sY0FBYyxDQUFDRixJQUFJLENBQUNOLElBQUksQ0FBQztJQUM1RCxJQUFJLENBQUNJLElBQUksR0FBR0UsSUFBSTtFQUNwQixDQUFDO0VBRURHLFFBQVEsRUFBQyxTQUFBQSxTQUFBLEVBQVk7SUFDakJmLEVBQUUsQ0FBQ2dCLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZEEsS0FBSyxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDVixJQUFJLENBQUNVLElBQUk7SUFDM0JELEtBQUssQ0FBQ2IsSUFBSSxHQUFHLElBQUksQ0FBQ0ksSUFBSSxDQUFDSixJQUFJO0lBQzNCYSxLQUFLLENBQUNFLEVBQUUsR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ1csRUFBRTtJQUN2QkYsS0FBSyxDQUFDRyxJQUFJLEdBQUd6QixRQUFRLENBQUMwQixHQUFHO0lBQ3pCSixLQUFLLENBQUNLLEtBQUssR0FBRyxJQUFJLENBQUNkLElBQUksQ0FBQ2MsS0FBSztJQUM3QkwsS0FBSyxDQUFDTSxJQUFJLEdBQUcsS0FBSztJQUNsQnpCLEVBQUUsQ0FBQzBCLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUM1QixFQUFFLENBQUNnQixHQUFHLENBQUNhLEtBQUssQ0FBQ0MsYUFBYSxFQUFFWCxLQUFLLENBQUM7RUFDbkU7QUFFSixDQUFDLENBQUM7QUFDRlksTUFBTSxDQUFDQyxPQUFPLEdBQUdqQyxPQUFPIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBDYXJJdGVtID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBuYW1lTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIGljb246Y2MuU3ByaXRlLFxyXG4gICAgICAgIEF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuaWNvbi5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja0J1eTpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5uYW1lID0gdGhpcy5EYXRhLm5hbWU7XHJcbiAgICAgICAgcGFyYW0uaWNvbiA9IHRoaXMuRGF0YS5pY29uO1xyXG4gICAgICAgIHBhcmFtLklkID0gdGhpcy5EYXRhLklkO1xyXG4gICAgICAgIHBhcmFtLlR5cGUgPSBJdGVtVHlwZS5DYXI7XHJcbiAgICAgICAgcGFyYW0ucHJpY2UgPSB0aGlzLkRhdGEucHJpY2U7XHJcbiAgICAgICAgcGFyYW0uZmxhZyA9IFwiQnV5XCI7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vbkJ1eSwgcGFyYW0pO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENhckl0ZW07XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/BelongMateItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3523bgLbAlC/K+QW+EAUwjh', 'BelongMateItem');
// Scripts/UI/BelongMateItem.js

"use strict";

var ItemType = require("ItemType");
var MateBonusType = require("MateBonusType");
var BelongMateItem = cc.Class({
  "extends": cc.Component,
  properties: {
    Atals: cc.SpriteAtlas,
    Icon: cc.Sprite,
    nameSp: cc.Sprite,
    desLbl: cc.Label,
    itemType: {
      "default": ItemType.Car,
      type: ItemType
    },
    Data: null
  },
  init: function init(data, itemType) {
    this.itemType = itemType;
    this.Data = data;
    this.Icon.spriteFrame = this.Atals.getSpriteFrame(data.icon);
    this.nameSp.spriteFrame = this.Atals.getSpriteFrame(data.name);
    var bonusList = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, data.Id).bonusList;
    var str = "";
    for (var i = 0; i < bonusList.length; i++) {
      switch (bonusList[i].bonusType) {
        case MateBonusType.HP:
          if (bonusList[i].bonusNum > 0) str = str + " " + "每年健康:+" + bonusList[i].bonusNum;else str = str + " " + "每年健康:" + bonusList[i].bonusNum;
          break;
        case MateBonusType.Reputation:
          str = str + " " + "每年名声:+" + bonusList[i].bonusNum;
          break;
        case MateBonusType.Money:
          str = str + " " + "每年现金:+" + bonusList[i].bonusNum;
          break;
        case MateBonusType.WareHouseCapcity:
          str = str + " " + "仓储:+" + bonusList[i].bonusNum;
          break;
        case MateBonusType.Treat:
          str = str + " " + "治疗降费:+" + bonusList[i].bonusNum * 100 + "%";
          break;
      }
    }
    this.desLbl.string = str;
  },
  clickOpen: function clickOpen() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.icon = this.Data.icon;
    param.name = this.Data.name;
    param.Id = this.Data.Id;
    param.Type = ItemType.Mate;
    param.price = 0;
    param.flag = "Sale";
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonBuy, param);
  }
});
module.exports = BelongMateItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEJlbG9uZ01hdGVJdGVtLmpzIl0sIm5hbWVzIjpbIkl0ZW1UeXBlIiwicmVxdWlyZSIsIk1hdGVCb251c1R5cGUiLCJCZWxvbmdNYXRlSXRlbSIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiQXRhbHMiLCJTcHJpdGVBdGxhcyIsIkljb24iLCJTcHJpdGUiLCJuYW1lU3AiLCJkZXNMYmwiLCJMYWJlbCIsIml0ZW1UeXBlIiwiQ2FyIiwidHlwZSIsIkRhdGEiLCJpbml0IiwiZGF0YSIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJpY29uIiwibmFtZSIsImJvbnVzTGlzdCIsIk1nciIsIk1hcERhdGFNZ3IiLCJnZXREYXRhQnlJdGVtVHlwZUFuZElkIiwiTWF0ZSIsIklkIiwic3RyIiwiaSIsImxlbmd0aCIsImJvbnVzVHlwZSIsIkhQIiwiYm9udXNOdW0iLCJSZXB1dGF0aW9uIiwiTW9uZXkiLCJXYXJlSG91c2VDYXBjaXR5IiwiVHJlYXQiLCJzdHJpbmciLCJjbGlja09wZW4iLCJBdWRpb01nciIsInBsYXlTRlgiLCJwYXJhbSIsIlR5cGUiLCJwcmljZSIsImZsYWciLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vbkJ1eSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLGFBQWEsR0FBR0QsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUM1QyxJQUFJRSxjQUFjLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzFCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLEtBQUssRUFBQ0osRUFBRSxDQUFDSyxXQUFXO0lBQ3BCQyxJQUFJLEVBQUNOLEVBQUUsQ0FBQ08sTUFB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SUFDM0JxQixLQUFLLENBQUNmLEVBQUUsR0FBRyxJQUFJLENBQUNaLElBQUksQ0FBQ1ksRUFBRTtJQUN2QmUsS0FBSyxDQUFDQyxJQUFJLEdBQUc5QyxRQUFRLENBQUM2QixJQUFJO0lBQzFCZ0IsS0FBSyxDQUFDRSxLQUFLLEdBQUcsQ0FBQztJQUNmRixLQUFLLENBQUNHLElBQUksR0FBRyxNQUFNO0lBQ25CNUMsRUFBRSxDQUFDNkMsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQy9DLEVBQUUsQ0FBQ3NCLEdBQUcsQ0FBQzBCLEtBQUssQ0FBQ0MsYUFBYSxFQUFFUixLQUFLLENBQUM7RUFDbkU7QUFDSixDQUFDLENBQUM7QUFDRlMsTUFBTSxDQUFDQyxPQUFPLEdBQUdwRCxjQUFjIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBNYXRlQm9udXNUeXBlID0gcmVxdWlyZShcIk1hdGVCb251c1R5cGVcIik7XHJcbnZhciBCZWxvbmdNYXRlSXRlbSA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQXRhbHM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgSWNvbjpjYy5TcHJpdGUsXHJcbiAgICAgICAgbmFtZVNwOmNjLlNwcml0ZSxcclxuICAgICAgICBkZXNMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgaXRlbVR5cGU6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Okl0ZW1UeXBlLkNhcixcclxuICAgICAgICAgICAgdHlwZTpJdGVtVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDpmdW5jdGlvbihkYXRhLCBpdGVtVHlwZSl7XHJcbiAgICAgICAgdGhpcy5pdGVtVHlwZSA9IGl0ZW1UeXBlXHJcbiAgICAgICAgdGhpcy5EYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLkljb24uc3ByaXRlRnJhbWUgPSB0aGlzLkF0YWxzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgdGhpcy5uYW1lU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0YWxzLmdldFNwcml0ZUZyYW1lKGRhdGEubmFtZSk7XHJcbiAgICAgICAgdmFyIGJvbnVzTGlzdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuTWF0ZSAsZGF0YS5JZCkuYm9udXNMaXN0O1xyXG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9udXNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaChib251c0xpc3RbaV0uYm9udXNUeXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGVCb251c1R5cGUuSFA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYm9udXNMaXN0W2ldLmJvbnVzTnVtPjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0citcIiBcIiArIFwi5q+P5bm05YGl5bq3OitcIiArIGJvbnVzTGlzdFtpXS5ib251c051bTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0citcIiBcIiArIFwi5q+P5bm05YGl5bq3OlwiICsgYm9udXNMaXN0W2ldLmJvbnVzTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRlQm9udXNUeXBlLlJlcHV0YXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyK1wiIFwiICArIFwi5q+P5bm05ZCN5aOwOitcIiArIGJvbnVzTGlzdFtpXS5ib251c051bTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0ZUJvbnVzVHlwZS5Nb25leTpcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIrXCIgXCIgICsgXCLmr4/lubTnjrDph5E6K1wiICsgYm9udXNMaXN0W2ldLmJvbnVzTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRlQm9udXNUeXBlLldhcmVIb3VzZUNhcGNpdHk6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyK1wiIFwiICArIFwi5LuT5YKoOitcIiArIGJvbnVzTGlzdFtpXS5ib251c051bTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0ZUJvbnVzVHlwZS5UcmVhdDpcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIrXCIgXCIgICsgXCLmsrvnlpfpmY3otLk6K1wiICsgYm9udXNMaXN0W2ldLmJvbnVzTnVtKjEwMCArIFwiJVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVzTGJsLnN0cmluZyA9IHN0cjtcclxuICAgIH0sXHJcblxyXG4gICAgY2xpY2tPcGVuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5pY29uID0gdGhpcy5EYXRhLmljb247XHJcbiAgICAgICAgcGFyYW0ubmFtZSA9IHRoaXMuRGF0YS5uYW1lO1xyXG4gICAgICAgIHBhcmFtLklkID0gdGhpcy5EYXRhLklkO1xyXG4gICAgICAgIHBhcmFtLlR5cGUgPSBJdGVtVHlwZS5NYXRlO1xyXG4gICAgICAgIHBhcmFtLnByaWNlID0gMDtcclxuICAgICAgICBwYXJhbS5mbGFnID0gXCJTYWxlXCI7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vbkJ1eSwgcGFyYW0pO1xyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQmVsb25nTWF0ZUl0ZW07XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/BuyTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'f35497DZwlEFLxbLaqmINkG', 'BuyTipPanel');
// Scripts/UI/BuyTipPanel.js

"use strict";

var Event = require("Event");
var BuyTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    IconSp: cc.Sprite,
    nameSp: cc.Sprite,
    Atlas: cc.SpriteAtlas,
    GoodsName: cc.Label,
    BuyNumLbl: cc.Label,
    Slider: cc.Slider,
    Progress: cc.ProgressBar,
    InPutBox: cc.EditBox,
    DesLbl: cc.Label,
    BuyNum: 0,
    CanBuyNum: 0,
    Data: null
  },
  ShowPanel: function ShowPanel(data) {
    this.Data = null;
    this.CanBuyNum = Math.floor(cc.Mgr.UserDataMgr.Cash / data.price);
    if (this.CanBuyNum > cc.Mgr.UserDataMgr.WareHouseCapcity) {
      this.CanBuyNum = cc.Mgr.UserDataMgr.WareHouseCapcity;
    }
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.BuyNum = this.CanBuyNum;
    this.nameSp.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.BuyNumLbl.string = this.CanBuyNum;
    this.InPutBox.string = this.CanBuyNum;
    this.DesLbl.string = cc.Mgr.global.FormatNum(this.CanBuyNum * data.price);
    this.Slider.progress = 1;
    this.Progress.progress = 1;
    this.Data = data;
  },
  OnSliderChange: function OnSliderChange() {
    this.BuyNum = Math.floor(this.Slider.progress * this.CanBuyNum);
    this.Progress.progress = this.Slider.progress;
    ////cc.log("+++++++++++++++++++++" + this.price);
    this.BuyNumLbl.string = this.BuyNum;
    this.InPutBox.string = this.BuyNum;
    this.DesLbl.string = cc.Mgr.global.FormatNum(this.BuyNum * this.Data.price);
  },
  OnInputBoxEnd: function OnInputBoxEnd() {
    if (this.InPutBox.string != "") {
      if (Number(this.InPutBox.string) != null) {
        if (Number(this.InPutBox.string) > this.CanBuyNum) {
          this.InPutBox.string = this.CanBuyNum;
          this.BuyNum = this.CanBuyNum;
          this.Progress.progress = 1;
          this.Slider.progress = 1;
        } else {
          this.BuyNum = Number(this.InPutBox.string);
          this.Slider.progress = this.BuyNum / this.CanBuyNum;
          this.Progress.progress = this.Slider.progress;
        }
      }
    } else {
      this.InPutBox.string = "0";
      this.BuyNum = 0;
      this.Progress.progress = 0;
      this.Slider.progress = 0;
    }
    this.DesLbl.string = cc.Mgr.global.FormatNum(this.BuyNum * this.Data.price);
  },
  ClickBuyBtn: function ClickBuyBtn() {
    if (this.BuyNum <= 0) {
      cc.Mgr.AudioMgr.playSFX("click");
      return;
    }

    //判断是否已经买了物种物品
    if (cc.Mgr.UserDataMgr.CheckOwnedGoodsNum() == true) {
      this.DesLbl.string = "只能购买拥有5种物品";
      return;
    }
    if (cc.Mgr.UserDataMgr.WareHouseCapcity < this.BuyNum) {
      var param = {};
      param.forWhat = "";
      param.text = "仓库容量不够";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    cc.Mgr.UserDataMgr.WareHouseCapcity -= this.BuyNum;
    cc.Mgr.UserDataMgr.Cash -= this.Data.price * this.BuyNum;
    var param = {};
    param.Num = this.BuyNum;
    param.price = this.Data.price;
    param.Id = this.Data.Id;
    var data = cc.Mgr.UserDataMgr.BuyGoods(param);
    //通知刷新现金
    cc.director.GlobalEvent.emit(cc.Mgr.Event.BuySuccess, data);
    this.ClosePanel();
    return this.Data.Id;
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = BuyTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEJ1eVRpcFBhbmVsLmpzIl0sIm5hbWVzIjpbIkV2ZW50IiwicmVxdWlyZSIsIkJ1eVRpcFBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJJY29uU3AiLCJTcHJpdGUiLCJuYW1lU3AiLCJBdGxhcyIsIlNwcml0ZUF0bGFzIiwiR29vZHNOYW1lIiwiTGFiZWwiLCJCdXlOdW1MYmwiLCJTbGlkZXIiLCJQcm9ncmVzcyIsIlByb2dyZXNzQmFyIiwiSW5QdXRCb3giLCJFZGl0Qm94IiwiRGVzTGJsIiwiQnV5TnVtIiwiQ2FuQnV5TnVtIiwiRGF0YSIsIlNob3dQYW5lbCIsImRhdGEiLCJNYXRoIiwiZmxvb3IiLCJNZ3IiLCJVc2VyRGF0YU1nciIsIkNhc2giLCJwcmljZSIsIldhcmVIb3VzZUNhcGNpdHkiLCJzcHJpdGVGcmFtZSIsImdldFNwcml0ZUZyYW1lIiwiaWNvbiIsIm5hbWUiLCJzdHJpbmciLCJnbG9iYWwiLCJGb3JtYXROdW0iLCJwcm9ncmVzcyIsIk9uU2xpZGVyQ2hhbmdlIiwiT25JbnB1dEJveEVuZCIsIk51bWJlciIsIkNsaWNrQnV5QnRuIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwiQ2hlY2tPd25lZEdvb2RzTnVtIiwicGFyYW0iLCJmb3JXaGF0IiwidGV4dCIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiT3BlbkNvbW1vblRpcCIsIk51bSIsIklkIiwiQnV5R29vZHMiLCJCdXlTdWNjZXNzIiwiQ2xvc2VQYW5lbCIsIm5vZGUiLCJhY3RpdmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLEtBQUssR0FBR0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUM1QixJQUFJQyxXQUFXLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3ZCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLE1BQU0sRUFBQ0osRUFBRSxDQUFDSyxNQUFNO0lBQ2hCQyxNQUFNLEVBQUNOLEVBQUUsQ0FBQ0ssTUFBTTtJQUNoQkUsS0FBSyxFQUFDUCxFQUFFLENBQUNRLFdBQVc7SUFDcEJDLFNBQVMsRUFBQ1QsRUFBRSxDQUFDVSxLQUFLO0lBQ2xCQyxTQUFTLEVBQUNYLEVBQUUsQ0FBQ1UsS0FBSztJQUNsQkUsTUFBTSxFQUFDWixFQUFFLENBQUNZLE1BQU07SUFDaEJDLFFBQVEsRUFBQ2IsRUFBRSxDQUFDYyxXQUFXO0lBQ3ZCQyxRQUFRLEVBQUNmLEVBQUUsQ0FBQ2dCLE9BQU87SUFDbkJDLE1BQU0sRUFBQ2pCLEVBQUUsQ0FBQ1UsS0FBSztJQUNmUSxNQUFNLEVBQUMsQ0FBQztJQUNSQyxTQUFTLEVBQUMsQ0FBQztJQUNYQyxJQUFJLEVBQUM7RUFDVCxDQUFDO0VBRURDLFNBQVMsRUFBQyxTQUFBQSxVQUFVQyxJQUFJLEVBQUU7SUFDdEIsSUFBSSxDQUFDRixJQUFJLEdBQUcsSUFBSTtJQUNoQixJQUFJLENBQUNELFNBQVMsR0FBR0ksSUFBSSxDQUFDQyxLQUFLLENBQUV4QixFQUFFLENBQUN5QixHQUFHLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxHQUFHTCxJQUFJLENBQUNNLEtBQUssQ0FBQztJQUNsRSxJQUFHLElBQUksQ0FBQ1QsU0FBUyxHQUFHbkIsRUFBRSxDQUFDeUIsR0FBRyxDQUFDQyxXQUFXLENBQUNHLGdCQUFnQixFQUN2RDtNQUNJLElBQUksQ0FBQ1YsU0FBUyxHQUFHbkIsRUFBRSxDQUFDeUIsR0FBRyxDQUFDQyxXQUFXLENBQUNHLGdCQUFnQjtJQUN4RDtJQUVBLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQzBCLFdBQVcsR0FBRyxJQUFJLENBQUN2QixLQUFLLENBQUN3QixjQUFjLENBQUNULElBQUksQ0FBQ1UsSUFBSSxDQUFDO0lBQzlELElBQUksQ0FBQ2QsTUFBTSxHQUFHLElBQUksQ0FBQ0MsU0FBUztJQUM1QixJQUFJLENBQUNiLE1BQU0sQ0FBQ3dCLFdBQVcsR0FBRyxJQUFJLENBQUN2QixLQUFLLENBQUN3QixjQUFjLENBQUNULElBQUksQ0FBQ1csSUFBSSxDQUFDO0lBQzlELElBQUksQ0FBQ3RCLFNBQVMsQ0FBQ3VCLE1BQU0sR0FBRyxJQUFJLENBQUNmLFNBQVM7SUFDdEMsSUFBSSxDQUFDSixRQUFRLENBQUNtQixNQUFNLEdBQUcsSUFBSSxDQUFDZixTQUFTO0lBQ3JDLElBQUksQ0FBQ0YsTUFBTSxDQUFDaUIsTUFBTSxHQUFHbEMsRUFBRSxDQUFDeUIsR0FBRyxDQUFDVSxNQUFNLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixTQUFTLEdBQUdHLElBQUksQ0FBQ00sS0FBSyxDQUFDO0lBQ3pFLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ3lCLFFBQVEsR0FBRyxDQUFDO0lBQ3hCLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ3dCLFFBQVEsR0FBRyxDQUFDO0lBQzFCLElBQUksQ0FBQ2pCLElBQUksR0FBR0UsSUFBSTtFQUNwQixDQUFDO0VBRURnQixjQUFjLEVBQUMsU0FBQUEsZUFBQSxFQUFVO0lBQ3JCLElBQUksQ0FBQ3BCLE1BQU0sR0FBR0ssSUFBSSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDWixNQUFNLENBQUN5QixRQUFRLEdBQUcsSUFBSSxDQUFDbEIsU0FBUyxDQUFDO0lBQy9ELElBQUksQ0FBQ04sUUFBUSxDQUFDd0IsUUFBUSxHQUFHLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQ3lCLFFBQVE7SUFDN0M7SUFDQSxJQUFJLENBQUMxQixTQUFTLENBQUN1QixNQUFNLEdBQUcsSUFBSSxDQUFDaEIsTUFBTTtJQUNuQyxJQUFJLENBQUNILFFBQVEsQ0FBQ21CLE1BQU0sR0FBRyxJQUFJLENBQUNoQixNQUFNO0lBQ2xDLElBQUksQ0FBQ0QsTUFBTSxDQUFDaUIsTUFBTSxHQUFHbEMsRUFBRSxDQUFDeUIsR0FBRyxDQUFDVSxNQUFNLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUNsQixNQUFNLEdBQUcsSUFBSSxDQUFDRSxJQUFJLENBQUNRLEtBQUssQ0FBQztFQUMvRSxDQUFDO0VBRURXLGFBQWEsRUFBQyxTQUFBQSxjQUFBLEVBQVU7SUFDdkIsSUFBRyxJQUFJLENBQUN4QixRQUFRLENBQUNtQixNQUFNLElBQUksRUFBRSxFQUM3QjtNQUNDLElBQUdNLE1BQU0sQ0FBQyxJQUFJLENBQUN6QixRQUFRLENBQUNtQixNQUFNLENBQUMsSUFBSSxJQUFJLEVBQ3ZDO1FBQ0MsSUFBR00sTUFBTSxDQUFDLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQ21CLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQ2YsU0FBUyxFQUNoRDtVQUNDLElBQUksQ0FBQ0osUUFBUSxDQUFDbUIsTUFBTSxHQUFHLElBQUksQ0FBQ2YsU0FBUztVQUNyQyxJQUFJLENBQUNELE1BQU0sR0FBRyxJQUFJLENBQUNDLFNBQVM7VUFDNUIsSUFBSSxDQUFDTixRQUFRLENBQUN3QixRQUFRLEdBQUcsQ0FBQztVQUMxQixJQUFJLENBQUN6QixNQUFNLENBQUN5QixRQUFRLEdBQUcsQ0FBQztRQUN6QixDQUFDLE1BRUQ7VUFDQyxJQUFJLENBQUNuQixNQUFNLEdBQUdzQixNQUFNLENBQUMsSUFBSSxDQUFDekIsUUFBUSxDQUFDbUIsTUFBTSxDQUFDO1VBQzFDLElBQUksQ0FBQ3RCLE1BQU0sQ0FBQ3lCLFFBQVEsR0FBSSxJQUFJLENBQUNuQixNQUFNLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1VBQ3BELElBQUksQ0FBQ04sUUFBUSxDQUFDd0IsUUFBUSxHQUFHLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQ3lCLFFBQVE7UUFDOUM7TUFDRDtJQUNELENBQUMsTUFFRDtNQUNDLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ21CLE1BQU0sR0FBRyxHQUFHO01BQzdCLElBQUksQ0FBQ2hCLE1BQU0sR0FBRyxDQUFDO01BQ2YsSUFBSSxDQUFDTCxRQUFRLENBQUN3QixRQUFRLEdBQUcsQ0FBQztNQUMxQixJQUFJLENBQUN6QixNQUFNLENBQUN5QixRQUFRLEdBQUcsQ0FBQztJQUN0QjtJQUNBLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ2lCLE1BQU0sR0FBR2xDLEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ1UsTUFBTSxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDbEIsTUFBTSxHQUFHLElBQUksQ0FBQ0UsSUFBSSxDQUFDUSxLQUFLLENBQUM7RUFDNUUsQ0FBQztFQUVEYSxXQUFXLEVBQUMsU0FBQUEsWUFBQSxFQUFVO0lBQ2xCLElBQUcsSUFBSSxDQUFDdkIsTUFBTSxJQUFJLENBQUMsRUFDbkI7TUFDSWxCLEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ2lCLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztNQUNoQztJQUNKOztJQUVBO0lBQ0EsSUFBRzNDLEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDa0Isa0JBQWtCLEVBQUUsSUFBSSxJQUFJLEVBQ2xEO01BQ0ksSUFBSSxDQUFDM0IsTUFBTSxDQUFDaUIsTUFBTSxHQUFHLFlBQVk7TUFDakM7SUFDSjtJQUVBLElBQUdsQyxFQUFFLENBQUN5QixHQUFHLENBQUNDLFdBQVcsQ0FBQ0csZ0JBQWdCLEdBQUcsSUFBSSxDQUFDWCxNQUFNLEVBQ3BEO01BQ0ksSUFBSTJCLEtBQUssR0FBRyxDQUFDLENBQUM7TUFDZEEsS0FBSyxDQUFDQyxPQUFPLEdBQUcsRUFBRTtNQUNsQkQsS0FBSyxDQUFDRSxJQUFJLEdBQUcsUUFBUTtNQUNyQi9DLEVBQUUsQ0FBQ2dELFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUNsRCxFQUFFLENBQUN5QixHQUFHLENBQUM1QixLQUFLLENBQUNzRCxhQUFhLEVBQUVOLEtBQUssQ0FBQztNQUMvRDtJQUNKO0lBQ0E3QyxFQUFFLENBQUN5QixHQUFHLENBQUNDLFdBQVcsQ0FBQ0csZ0JBQWdCLElBQUksSUFBSSxDQUFDWCxNQUFNO0lBRWxEbEIsRUFBRSxDQUFDeUIsR0FBRyxDQUFDQyxXQUFXLENBQUNDLElBQUksSUFBSyxJQUFJLENBQUNQLElBQUksQ0FBQ1EsS0FBSyxHQUFHLElBQUksQ0FBQ1YsTUFBTztJQUMxRCxJQUFJMkIsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkQSxLQUFLLENBQUNPLEdBQUcsR0FBRyxJQUFJLENBQUNsQyxNQUFNO0lBQ3ZCMkIsS0FBSyxDQUFDakIsS0FBSyxHQUFHLElBQUksQ0FBQ1IsSUFBSSxDQUFDUSxLQUFLO0lBQzdCaUIsS0FBSyxDQUFDUSxFQUFFLEdBQUcsSUFBSSxDQUFDakMsSUFBSSxDQUFDaUMsRUFBRTtJQUN2QixJQUFJL0IsSUFBSSxHQUFHdEIsRUFBRSxDQUFDeUIsR0FBRyxDQUFDQyxXQUFXLENBQUM0QixRQUFRLENBQUNULEtBQUssQ0FBQztJQUM3QztJQUNBN0MsRUFBRSxDQUFDZ0QsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQ2xELEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQzVCLEtBQUssQ0FBQzBELFVBQVUsRUFBRWpDLElBQUksQ0FBQztJQUMzRCxJQUFJLENBQUNrQyxVQUFVLEVBQUU7SUFDakIsT0FBTyxJQUFJLENBQUNwQyxJQUFJLENBQUNpQyxFQUFFO0VBQ3ZCLENBQUM7RUFFREcsVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBVTtJQUNqQnhELEVBQUUsQ0FBQ3lCLEdBQUcsQ0FBQ2lCLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJLENBQUNjLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7RUFDNUI7QUFFSixDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUc3RCxXQUFXIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXZlbnQgPSByZXF1aXJlKFwiRXZlbnRcIik7XHJcbnZhciBCdXlUaXBQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgSWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBuYW1lU3A6Y2MuU3ByaXRlLFxyXG4gICAgICAgIEF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIEdvb2RzTmFtZTpjYy5MYWJlbCxcclxuICAgICAgICBCdXlOdW1MYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgU2xpZGVyOmNjLlNsaWRlcixcclxuICAgICAgICBQcm9ncmVzczpjYy5Qcm9ncmVzc0JhcixcclxuICAgICAgICBJblB1dEJveDpjYy5FZGl0Qm94LFxyXG4gICAgICAgIERlc0xibDpjYy5MYWJlbCxcclxuICAgICAgICBCdXlOdW06MCxcclxuICAgICAgICBDYW5CdXlOdW06MCxcclxuICAgICAgICBEYXRhOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5DYW5CdXlOdW0gPSBNYXRoLmZsb29yKCBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCAvIGRhdGEucHJpY2UpO1xyXG4gICAgICAgIGlmKHRoaXMuQ2FuQnV5TnVtID4gY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUNhcGNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkNhbkJ1eU51bSA9IGNjLk1nci5Vc2VyRGF0YU1nci5XYXJlSG91c2VDYXBjaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5JY29uU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgdGhpcy5CdXlOdW0gPSB0aGlzLkNhbkJ1eU51bTtcclxuICAgICAgICB0aGlzLm5hbWVTcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5uYW1lKTtcclxuICAgICAgICB0aGlzLkJ1eU51bUxibC5zdHJpbmcgPSB0aGlzLkNhbkJ1eU51bTtcclxuICAgICAgICB0aGlzLkluUHV0Qm94LnN0cmluZyA9IHRoaXMuQ2FuQnV5TnVtO1xyXG4gICAgICAgIHRoaXMuRGVzTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKHRoaXMuQ2FuQnV5TnVtICogZGF0YS5wcmljZSk7IFxyXG4gICAgICAgIHRoaXMuU2xpZGVyLnByb2dyZXNzID0gMTtcclxuICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gMTtcclxuICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBPblNsaWRlckNoYW5nZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuQnV5TnVtID0gTWF0aC5mbG9vcih0aGlzLlNsaWRlci5wcm9ncmVzcyAqIHRoaXMuQ2FuQnV5TnVtKTtcclxuICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gdGhpcy5TbGlkZXIucHJvZ3Jlc3M7XHJcbiAgICAgICAgLy8vL2NjLmxvZyhcIisrKysrKysrKysrKysrKysrKysrK1wiICsgdGhpcy5wcmljZSk7XHJcbiAgICAgICAgdGhpcy5CdXlOdW1MYmwuc3RyaW5nID0gdGhpcy5CdXlOdW07XHJcbiAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSB0aGlzLkJ1eU51bVxyXG4gICAgICAgIHRoaXMuRGVzTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKHRoaXMuQnV5TnVtICogdGhpcy5EYXRhLnByaWNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgT25JbnB1dEJveEVuZDpmdW5jdGlvbigpe1xyXG4gICAgXHRpZih0aGlzLkluUHV0Qm94LnN0cmluZyAhPSBcIlwiKVxyXG4gICAgXHR7XHJcbiAgICBcdFx0aWYoTnVtYmVyKHRoaXMuSW5QdXRCb3guc3RyaW5nKSAhPSBudWxsKVxyXG4gICAgXHRcdHtcclxuICAgIFx0XHRcdGlmKE51bWJlcih0aGlzLkluUHV0Qm94LnN0cmluZykgPiB0aGlzLkNhbkJ1eU51bSkgXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdHRoaXMuSW5QdXRCb3guc3RyaW5nID0gdGhpcy5DYW5CdXlOdW07XHJcbiAgICBcdFx0XHRcdHRoaXMuQnV5TnVtID0gdGhpcy5DYW5CdXlOdW07XHJcbiAgICBcdFx0XHRcdHRoaXMuUHJvZ3Jlc3MucHJvZ3Jlc3MgPSAxO1xyXG4gICAgXHRcdFx0XHR0aGlzLlNsaWRlci5wcm9ncmVzcyA9IDE7XHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0XHRlbHNlXHJcbiAgICBcdFx0XHR7XHJcbiAgICBcdFx0XHRcdHRoaXMuQnV5TnVtID0gTnVtYmVyKHRoaXMuSW5QdXRCb3guc3RyaW5nKTtcclxuICAgIFx0XHRcdFx0dGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAgdGhpcy5CdXlOdW0gLyB0aGlzLkNhbkJ1eU51bTtcclxuICAgIFx0XHRcdFx0dGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IHRoaXMuU2xpZGVyLnByb2dyZXNzO1xyXG4gICAgXHRcdFx0fVxyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgXHRlbHNlXHJcbiAgICBcdHtcclxuICAgIFx0XHR0aGlzLkluUHV0Qm94LnN0cmluZyA9IFwiMFwiO1xyXG5cdFx0XHR0aGlzLkJ1eU51bSA9IDA7XHJcblx0XHRcdHRoaXMuUHJvZ3Jlc3MucHJvZ3Jlc3MgPSAwO1xyXG5cdFx0XHR0aGlzLlNsaWRlci5wcm9ncmVzcyA9IDA7XHJcbiAgICBcdH1cclxuICAgIFx0dGhpcy5EZXNMYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0odGhpcy5CdXlOdW0gKiB0aGlzLkRhdGEucHJpY2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja0J1eUJ0bjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuQnV5TnVtIDw9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL+WIpOaWreaYr+WQpuW3sue7j+S5sOS6hueJqeenjeeJqeWTgVxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5DaGVja093bmVkR29vZHNOdW0oKSA9PSB0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5EZXNMYmwuc3RyaW5nID0gXCLlj6rog73otK3kubDmi6XmnIk156eN54mp5ZOBXCI7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUNhcGNpdHkgPCB0aGlzLkJ1eU51bSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJcIjtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5LuT5bqT5a656YeP5LiN5aSfXCI7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuIDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUNhcGNpdHkgLT0gdGhpcy5CdXlOdW07XHJcblxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIC09ICh0aGlzLkRhdGEucHJpY2UgKiB0aGlzLkJ1eU51bSk7XHJcbiAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgcGFyYW0uTnVtID0gdGhpcy5CdXlOdW07XHJcbiAgICAgICAgcGFyYW0ucHJpY2UgPSB0aGlzLkRhdGEucHJpY2U7XHJcbiAgICAgICAgcGFyYW0uSWQgPSB0aGlzLkRhdGEuSWQ7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQnV5R29vZHMocGFyYW0pO1xyXG4gICAgICAgIC8v6YCa55+l5Yi35paw546w6YeRXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuQnV5U3VjY2VzcywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRGF0YS5JZDtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1eVRpcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CommonBuyPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c6183kj8RFBUqr5fDHnNMDY', 'CommonBuyPanel');
// Scripts/UI/CommonBuyPanel.js

"use strict";

var ItemType = require("ItemType");
var UserState = require("UserState");
var CommonBuyPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    MainAtlas: cc.SpriteAtlas,
    Atlas: cc.SpriteAtlas,
    titleLbl: cc.Sprite,
    carhosueDes: cc.Node,
    des1: cc.Label,
    des2: cc.Label,
    des3: cc.Label,
    des4: cc.Label,
    disdesLbl: cc.Label,
    iconSp: cc.Sprite,
    nameSp: cc.Sprite,
    price: cc.Integer,
    Id: cc.Integer,
    flag: "",
    Type: {
      "default": ItemType.Car,
      type: ItemType
    }
  },
  ShowPanel: function ShowPanel(param) {
    var data = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(param.Type, param.Id);
    this.nameSp.spriteFrame = this.Atlas.getSpriteFrame(param.name);
    var price = param.price;
    if (param.flag == "Buy") {
      if (param.Type == ItemType.Car) {
        this.des4.node.active = true;
        this.des1.node.active = false;
        this.des4.string = "+" + data.addDate * 100 + "%";
        this.titleLbl.spriteFrame = this.MainAtlas.getSpriteFrame("text_buycar");
        price = param.price - Math.floor(param.price * cc.Mgr.UserDataMgr.CarBuyBonus);
      } else if (param.Type == ItemType.House) {
        this.des4.node.active = false;
        this.des1.node.active = true;
        this.des1.string = "+" + data.addHp;
        this.titleLbl.spriteFrame = this.MainAtlas.getSpriteFrame("text_buyhouse");
        price = param.price - Math.floor(param.price * cc.Mgr.UserDataMgr.HouseBuyBonuse);
      }
      this.des2.string = "+" + data.addBonus;
      this.des3.string = cc.Mgr.global.FormatNum(price);
      this.carhosueDes.active = true;
      this.disdesLbl.node.active = false;
    } else if (param.flag == "Sale") {
      if (param.Type == ItemType.Car || param.Type == ItemType.House) {
        this.titleLbl.spriteFrame = this.MainAtlas.getSpriteFrame("sale_txt");
        if (param.Type == ItemType.Car) {
          this.des4.node.active = true;
          this.des1.node.active = false;
          this.des4.string = "+" + data.addDate * 100 + "%";
        } else {
          this.des1.string = "+" + data.addHp;
          this.des4.node.active = false;
          this.des1.node.active = true;
        }
        this.des2.string = "+" + data.addBonus;
        this.des3.string = Math.floor(price / 2);
        this.carhosueDes.active = true;
        this.disdesLbl.node.active = false;
      } else if (param.Type == ItemType.Mate) {
        var name = cc.Mgr.global.getTranslation("role_" + param.Id);
        this.carhosueDes.active = false;
        this.disdesLbl.node.active = true;
        this.titleLbl.spriteFrame = this.MainAtlas.getSpriteFrame("dis_marry");
        var dd = 1 + Math.floor(Math.random() * 5);
        this.disdesLbl.string = name + "说:" + cc.Mgr.global.getTranslation("Disvorce_" + dd);
      }
    }
    this.price = price;
    this.Type = param.Type;
    this.Id = param.Id;
    this.iconSp.spriteFrame = this.Atlas.getSpriteFrame(param.icon);
    if (param.flag != null) this.flag = param.flag;else this.flag = "";
  },
  ClickBuy: function ClickBuy() {
    if (this.flag == "Buy") {
      if (cc.Mgr.UserDataMgr.Cash < this.price) {
        cc.Mgr.AudioMgr.playSFX("click");
        var param = {};
        param.forWhat = "";
        param.text = "<color=#e77122>你的钱不够啊,买不起</c>";
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
        return;
      }
    }
    if (this.flag != null && this.flag != "") {
      if (this.Type == ItemType.Car || this.Type == ItemType.House) {
        var par = {};
        par.Type = this.Type;
        par.addNum = 0;
        if (this.flag == "Buy") {
          var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(this.Type, this.Id);
          //cc.log("加成属性 ====== 健康 " + data.addHp +"  名声 " + data.addBonus);
          cc.Mgr.UserDataMgr.Reputation += data.addBonus;
          cc.Mgr.UserDataMgr.HpPoint += data.addHp;
          if (cc.Mgr.UserDataMgr.HpPoint > 100) cc.Mgr.UserDataMgr.HpPoint = 100;
          if (cc.Mgr.UserDataMgr.HpPoint >= cc.Mgr.global.HealthLine) {
            cc.Mgr.UserDataMgr.userState = UserState.OK;
            cc.Mgr.UserDataMgr.RecoverYear = 0;
          }
          //cc.log("价格 === " + this.price + " 对应Id " + this.Id);
          cc.Mgr.UserDataMgr.Cash -= this.price;
          par.addNum = 1;
          if (this.Type == ItemType.Car) {
            cc.Mgr.UserDataMgr.DateSuccescRatio += data.addDate;
          }
        } else if (this.flag == "Sale") {
          par.addNum = -1;
          cc.Mgr.UserDataMgr.Cash += Math.floor(this.price / 2);
        }
        par.Id = this.Id;
        par.flag = this.flag;
        cc.Mgr.UserDataMgr.BuySaleCommonItem(par);
        cc.director.GlobalEvent.emit(cc.Mgr.Event.CommonBuySaleSuccess, par);
      } else if (this.Type == ItemType.Mate) {
        if (this.flag == "Sale") {
          if (cc.Mgr.UserDataMgr.DivorceAge == 0) {
            cc.Mgr.UserDataMgr.DivorceAge = cc.Mgr.UserDataMgr.Age;
          }
          var par = {};
          par.flag = this.flag;
          par.Disvorce = true;
          cc.Mgr.UserDataMgr.DisvorceMateById(this.Id);
          cc.director.GlobalEvent.emit(cc.Mgr.Event.CommonBuySaleSuccess, par);
        }
      }
    }
    this.ClosePanel();
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.flag = "";
    this.node.active = false;
  }
});
module.exports = CommonBuyPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENvbW1vbkJ1eVBhbmVsLmpzIl0sIm5hbWVzIjpbIkl0ZW1UeXBlIiwicmVxdWlyZSIsIlVzZXJTdGF0ZSIsIkNvbW1vbkJ1eVBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJNYWluQXRsYXMiLCJTcHJpdGVBdGxhcyIsIkF0bGFzIiwidGl0bGVMYmwiLCJTcHJpdGUiLCJjYXJob3N1ZURlcyIsIk5vZGUiLCJkZXMxIiwiTGFiZWwiLCJkZXMyIiwiZGVzMyIsImRlczQiLCJkaXNkZXNMYmwiLCJpY29uU3AiLCJuYW1lU3AiLCJwcmljZSIsIkludGVnZXIiLCJJZCIsImZsYWciLCJUeXBlIiwiQ2FyIiwidHlwZSIsIlNob3dQYW5lbCIsInBhcmFtIiwiZGF0YSIsIk1nciIsIk1hcERhdGFNZ3IiLCJnZXREYXRhQnlJdGVtVHlwZUFuZElkIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsIm5hbWUiLCJub2RlIiwiYWN0aXZlIiwic3RyaW5nIiwiYWRkRGF0ZSIsIk1hdGgiLCJmbG9vciIsIlVzZXJEYXRhTWdyIiwiQ2FyQnV5Qm9udXMiLCJIb3VzZSIsImFkZEhwIiwiSG91c2VCdXlCb251c2UiLCJhZGRCb251cyIsImdsb2JhbCIsIkZvcm1hdE51bSIsIk1hdGUiLCJnZXRUcmFuc2xhdGlvbiIsImRkIiwicmFuZG9tIiwiaWNvbiIsIkNsaWNrQnV5IiwiQ2FzaCIsIkF1ZGlvTWdyIiwicGxheVNGWCIsImZvcldoYXQiLCJ0ZXh0IiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIk9wZW5Db21tb25UaXAiLCJwYXIiLCJhZGROdW0iLCJSZXB1dGF0aW9uIiwiSHBQb2ludCIsIkhlYWx0aExpbmUiLCJ1c2VyU3RhdGUiLCJPSyIsIlJlY292ZXJZZWFyIiwiRGF0ZVN1Y2Nlc2NSYXRpbyIsIkJ1eVNhbGVDb21tb25JdGVtIiwiQ29tbW9uQnV5U2FsZVN1Y2Nlc3MiLCJEaXZvcmNlQWdlIiwiQWdlIiwiRGlzdm9yY2UiLCJEaXN2b3JjZU1hdGVCeUlkIiwiQ2xvc2VQYW5lbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLFNBQVMsR0FBR0QsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUNwQyxJQUFJRSxjQUFjLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzFCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFNBQVMsRUFBQ0osRUFBRSxDQUFDSyxXQUFXO0lBQ3hCQyxLQUFLLEVBQUNOLEVBQUUsQ0FBQ0ssV0FBVztJQUNwQkUsUUFBUSxFQUFDUCxFQUFFLENBQUNRLE1BQU07SUFDbEJDLFdBQVcsRUFBQ1QsRUFBRSxDQUFDVSxJQUFJO0lBRW5CQyxJQUFJLEVBQUNYLEVBQUUsQ0FBQ1ksS0FBSztJQUNiQyxJQUFJLEVBQUNiLEVBQUUsQ0FBQ1ksS0FBSztJQUNiRSxJQUFJLEVBQUNkLEVBQUUsQ0FBQ1ksS0FBSztJQUNiRyxJQUFJLEVBQUNmLEVBQUUsQ0FBQ1ksS0FBSztJQUViSSxTQUFTLEVBQUNoQixFQUFFLENBQUNZLEtBQUs7SUFDbEJLLE1BQU0sRUFBQ2pCLEVBQUUsQ0FBQ1EsTUFBTTtJQUNoQlUsTUFBTSxFQUFDbEIsRUFBRSxDQUFDUSxNQUFNO0lBQ2hCVyxLQUFLLEVBQUNuQixFQUFFLENBQUNvQixPQUFPO0lBQ2hCQyxFQUFFLEVBQUNyQixFQUFFLENBQUNvQixPQUFPO0lBQ2JFLElBQUksRUFBQyxFQUFFO0lBQ1BDLElBQUksRUFBQztNQUNELFdBQVEzQixRQUFRLENBQUM0QixHQUFHO01BQ3BCQyxJQUFJLEVBQUM3QjtJQUNUO0VBQ0osQ0FBQztFQUVEOEIsU0FBUyxFQUFDLFNBQUFBLFVBQVVDLEtBQUssRUFBRTtJQUN2QixJQUFJQyxJQUFJLEdBQUc1QixF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LEdBQUduRixjQUFjIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBVc2VyU3RhdGUgPSByZXF1aXJlKFwiVXNlclN0YXRlXCIpO1xyXG52YXIgQ29tbW9uQnV5UGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIE1haW5BdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICBBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICB0aXRsZUxibDpjYy5TcHJpdGUsXHJcbiAgICAgICAgY2FyaG9zdWVEZXM6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgZGVzMTpjYy5MYWJlbCxcclxuICAgICAgICBkZXMyOmNjLkxhYmVsLFxyXG4gICAgICAgIGRlczM6Y2MuTGFiZWwsXHJcbiAgICAgICAgZGVzNDpjYy5MYWJlbCxcclxuXHJcbiAgICAgICAgZGlzZGVzTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIGljb25TcDpjYy5TcHJpdGUsXHJcbiAgICAgICAgbmFtZVNwOmNjLlNwcml0ZSxcclxuICAgICAgICBwcmljZTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIElkOmNjLkludGVnZXIsXHJcbiAgICAgICAgZmxhZzpcIlwiLFxyXG4gICAgICAgIFR5cGU6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Okl0ZW1UeXBlLkNhcixcclxuICAgICAgICAgICAgdHlwZTpJdGVtVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKHBhcmFtLlR5cGUsIHBhcmFtLklkKVxyXG4gICAgICAgIHRoaXMubmFtZVNwLnNwcml0ZUZyYW1lID0gdGhpcy5BdGxhcy5nZXRTcHJpdGVGcmFtZShwYXJhbS5uYW1lKVxyXG4gICAgICAgIHZhciBwcmljZSA9IHBhcmFtLnByaWNlO1xyXG4gICAgICAgIGlmKHBhcmFtLmZsYWcgPT0gXCJCdXlcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKHBhcmFtLlR5cGUgPT0gSXRlbVR5cGUuQ2FyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlczQubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXMxLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlczQuc3RyaW5nID0gXCIrXCIgKyAoZGF0YS5hZGREYXRlICogMTAwKSArIFwiJVwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZUxibC5zcHJpdGVGcmFtZSA9IHRoaXMuTWFpbkF0bGFzLmdldFNwcml0ZUZyYW1lKFwidGV4dF9idXljYXJcIik7XHJcbiAgICAgICAgICAgICAgICBwcmljZSA9IHBhcmFtLnByaWNlIC0gTWF0aC5mbG9vcihwYXJhbS5wcmljZSAqIGNjLk1nci5Vc2VyRGF0YU1nci5DYXJCdXlCb251cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihwYXJhbS5UeXBlID09IEl0ZW1UeXBlLkhvdXNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlczQubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzMS5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlczEuc3RyaW5nID0gXCIrXCIgKyBkYXRhLmFkZEhwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZUxibC5zcHJpdGVGcmFtZSA9IHRoaXMuTWFpbkF0bGFzLmdldFNwcml0ZUZyYW1lKFwidGV4dF9idXlob3VzZVwiKTtcclxuICAgICAgICAgICAgICAgIHByaWNlPSBwYXJhbS5wcmljZSAtIE1hdGguZmxvb3IocGFyYW0ucHJpY2UgKiBjYy5NZ3IuVXNlckRhdGFNZ3IuSG91c2VCdXlCb251c2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRlczIuc3RyaW5nID0gXCIrXCIgKyBkYXRhLmFkZEJvbnVzO1xyXG4gICAgICAgICAgICB0aGlzLmRlczMuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0ocHJpY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNhcmhvc3VlRGVzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzZGVzTGJsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYocGFyYW0uZmxhZyA9PSBcIlNhbGVcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKHBhcmFtLlR5cGUgPT0gSXRlbVR5cGUuQ2FyIHx8IHBhcmFtLlR5cGUgPT0gSXRlbVR5cGUuSG91c2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGl0bGVMYmwuc3ByaXRlRnJhbWUgPSB0aGlzLk1haW5BdGxhcy5nZXRTcHJpdGVGcmFtZShcInNhbGVfdHh0XCIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihwYXJhbS5UeXBlID09IEl0ZW1UeXBlLkNhcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlczQubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzMS5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzNC5zdHJpbmcgPSBcIitcIiArIChkYXRhLmFkZERhdGUgKiAxMDApICsgXCIlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXMxLnN0cmluZyA9IFwiK1wiICsgZGF0YS5hZGRIcDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlczQubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlczEubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzMi5zdHJpbmcgPSBcIitcIiArIGRhdGEuYWRkQm9udXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlczMuc3RyaW5nID0gTWF0aC5mbG9vcihwcmljZS8yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FyaG9zdWVEZXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzZGVzTGJsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihwYXJhbS5UeXBlID09IEl0ZW1UeXBlLk1hdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcInJvbGVfXCIrcGFyYW0uSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYXJob3N1ZURlcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzZGVzTGJsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGl0bGVMYmwuc3ByaXRlRnJhbWUgPSB0aGlzLk1haW5BdGxhcy5nZXRTcHJpdGVGcmFtZShcImRpc19tYXJyeVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZCA9IDEgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzZGVzTGJsLnN0cmluZyA9IG5hbWUrXCLor7Q6XCIrY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIkRpc3ZvcmNlX1wiICsgZGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByaWNlID0gcHJpY2U7XHJcbiAgICAgICAgdGhpcy5UeXBlID0gcGFyYW0uVHlwZTtcclxuICAgICAgICB0aGlzLklkID0gcGFyYW0uSWQ7XHJcbiAgICAgICAgdGhpcy5pY29uU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKHBhcmFtLmljb24pO1xyXG4gICAgICAgIGlmKHBhcmFtLmZsYWcgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5mbGFnID0gcGFyYW0uZmxhZztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZmxhZyA9IFwiXCI7XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrQnV5OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5mbGFnID09IFwiQnV5XCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCA8IHRoaXMucHJpY2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwiPGNvbG9yPSNlNzcxMjI+5L2g55qE6ZKx5LiN5aSf5ZWKLOS5sOS4jei1tzwvYz5cIjtcclxuICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLmZsYWcgIT0gbnVsbCAmJiB0aGlzLmZsYWcgIT0gXCJcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuVHlwZSA9PSBJdGVtVHlwZS5DYXIgfHwgdGhpcy5UeXBlID09IEl0ZW1UeXBlLkhvdXNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXIuVHlwZSA9IHRoaXMuVHlwZTtcclxuICAgICAgICAgICAgICAgIHBhci5hZGROdW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5mbGFnID09IFwiQnV5XCIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZCh0aGlzLlR5cGUsIHRoaXMuSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2MubG9nKFwi5Yqg5oiQ5bGe5oCnID09PT09PSDlgaXlurcgXCIgKyBkYXRhLmFkZEhwICtcIiAg5ZCN5aOwIFwiICsgZGF0YS5hZGRCb251cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlcHV0YXRpb24gKz0gZGF0YS5hZGRCb251cztcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludCArPSBkYXRhLmFkZEhwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50ID4gMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludCA9IDEwMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQgPj0gY2MuTWdyLmdsb2JhbC5IZWFsdGhMaW5lKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnVzZXJTdGF0ZSA9IFVzZXJTdGF0ZS5PSztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlY292ZXJZZWFyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jYy5sb2coXCLku7fmoLwgPT09IFwiICsgdGhpcy5wcmljZSArIFwiIOWvueW6lElkIFwiICsgdGhpcy5JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggLT0gdGhpcy5wcmljZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXIuYWRkTnVtID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5UeXBlID09IEl0ZW1UeXBlLkNhcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5EYXRlU3VjY2VzY1JhdGlvICs9IGRhdGEuYWRkRGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuZmxhZyA9PSBcIlNhbGVcIilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXIuYWRkTnVtID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggKz0gTWF0aC5mbG9vcih0aGlzLnByaWNlLzIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyLklkID0gdGhpcy5JZDtcclxuICAgICAgICAgICAgICAgIHBhci5mbGFnID0gdGhpcy5mbGFnO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkJ1eVNhbGVDb21tb25JdGVtKHBhcik7XHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5Db21tb25CdXlTYWxlU3VjY2VzcywgcGFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuVHlwZSA9PSBJdGVtVHlwZS5NYXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmZsYWcgPT0gXCJTYWxlXCIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkRpdm9yY2VBZ2UgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5EaXZvcmNlQWdlID0gY2MuTWdyLlVzZXJEYXRhTWdyLkFnZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhciA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhci5mbGFnID0gdGhpcy5mbGFnO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhci5EaXN2b3JjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkRpc3ZvcmNlTWF0ZUJ5SWQodGhpcy5JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuQ29tbW9uQnV5U2FsZVN1Y2Nlc3MsIHBhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5mbGFnID0gXCJcIjtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tbW9uQnV5UGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CommonTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '34709sQva1EMoBVrzPj89V0', 'CommonTipPanel');
// Scripts/UI/CommonTipPanel.js

"use strict";

var Event = require("Event");
var MateUnLockType = require("MateUnLockType");
var CommonTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    titleLbl: cc.Sprite,
    TipLbl: cc.RichText,
    forWhat: "",
    cost: cc.Integer,
    videoPath: ""
  },
  ShowPanel: function ShowPanel(data) {
    if (data.forWhat != null && data.forWhat != "") this.forWhat = data.forWhat;else this.forWhat = "";

    //this.titleLbl.string = "提示说明";

    this.cost = 0;
    if (this.forWhat == "StockBonus") {
      var companyName = cc.Mgr.global.getTranslation("company_" + data.Id);
      this.TipLbl.string = "<color=#696969>股票市场-" + companyName + "-获得收益</c>" + "<color=#e77122>" + data.bonus + "</c>" + "<color=#696969>元</c>";
    } else if (this.forWhat == "Treat") {
      this.cost = data.needMoney - Math.floor(data.needMoney * cc.Mgr.UserDataMgr.TreatBonus);
      this.TipLbl.string = "花费" + this.cost + "治疗，以恢复健康";
    } else if (this.forWhat == "shareVideo") {
      this.videoPath = data.videoPath;
      this.TipLbl.string = "<color=#696969>" + data.text + "</c>";
    } else {
      this.TipLbl.string = "<color=#696969>" + data.text + "</c>";
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (this.forWhat == "HealthLine") {
      cc.Mgr.UserDataMgr.UnLockMateByInHospital(MateUnLockType.InHospital, cc.Mgr.UserDataMgr.Sex);
    } else if (this.forWhat == "DateLater") {
      if (cc.Mgr.UserDataMgr.tutorialMatePoint == false) cc.director.GlobalEvent.emit(cc.Mgr.Event.DateLater, {});
    }
    this.forWhat = "";
    this.node.active = false;
    //cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenEventTip, {});
  },

  ClickConfirm: function ClickConfirm() {
    if (this.forWhat == "Treat") {
      //计算下所需要的钱 消耗金额=2000*1.18^(当前年龄-20)*（1-当前健康度/100），向上取整
      var needMoney = this.cost; //Math.floor(2000* Math.pow(1.18, cc.Mgr.UserDataMgr.Age-20) *(1-cc.Mgr.UserDataMgr.HpPoint/100));
      if (cc.Mgr.UserDataMgr.Cash < needMoney) {
        this.TipLbl.string = "你的钱不够啊,等有钱了再来吧";
        return;
      }
      cc.Mgr.UserDataMgr.Cash -= needMoney;
      cc.Mgr.UserDataMgr.HpPoint = 100;
      cc.director.GlobalEvent.emit(cc.Mgr.Event.TreatSuccess, {});
    } else if (this.forWhat == "Retire") {
      cc.director.GlobalEvent.emit(cc.Mgr.Event.Retire, {});
    } else if (this.forWhat == "HealthLine") {
      cc.Mgr.UserDataMgr.UnLockMateByInHospital(MateUnLockType.InHospital, cc.Mgr.UserDataMgr.Sex);
    } else if (this.forWhat == "OpenDate") {
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenEnjoy, {});
    } else if (this.forWhat == "Login") {
      cc.Mgr.PlatformController.Login();
    } else if (this.forWhat == "shareVideo") {
      cc.director.GlobalEvent.emit(cc.Mgr.Event.ShareVideo, {
        videoPath: this.videoPath
      });
    }
    this.ClosePanel();
  }
});
module.exports = CommonTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENvbW1vblRpcFBhbmVsLmpzIl0sIm5hbWVzIjpbIkV2ZW50IiwicmVxdWlyZSIsIk1hdGVVbkxvY2tUeXBlIiwiQ29tbW9uVGlwUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsInRpdGxlTGJsIiwiU3ByaXRlIiwiVGlwTGJsIiwiUmljaFRleHQiLCJmb3JXaGF0IiwiY29zdCIsIkludGVnZXIiLCJ2aWRlb1BhdGgiLCJTaG93UGFuZWwiLCJkYXRhIiwiY29tcGFueU5hbWUiLCJNZ3IiLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsIklkIiwic3RyaW5nIiwiYm9udXMiLCJuZWVkTW9uZXkiLCJNYXRoIiwiZmxvb3IiLCJVc2VyRGF0YU1nciIsIlRyZWF0Qm9udXMiLCJ0ZXh0IiwiQ2xvc2VQYW5lbCIsIkF1ZGlvTWdyIiwicGxheVNGWCIsIlVuTG9ja01hdGVCeUluSG9zcGl0YWwiLCJJbkhvc3BpdGFsIiwiU2V4IiwidHV0b3JpYWxNYXRlUG9pbnQiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkRhdGVMYXRlciIsIm5vZGUiLCJhY3RpdmUiLCJDbGlja0NvbmZpcm0iLCJDYXNoIiwiSHBQb2ludCIsIlRyZWF0U3VjY2VzcyIsIlJldGlyZSIsIk9wZW5FbmpveSIsIlBsYXRmb3JtQ29udHJvbGxlciIsIkxvZ2luIiwiU2hhcmVWaWRlbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsS0FBSyxHQUFHQyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQzVCLElBQUlDLGNBQWMsR0FBR0QsT0FBTyxDQUFDLGdCQUFnQixDQUFDO0FBQzlDLElBQUlFLGNBQWMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDMUIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsUUFBUSxFQUFDSixFQUFFLENBQUNLLE1BQU07SUFDbEJDLE1BQU0sRUFBQ04sRUFBRSxDQUFDTyxRQUFRO0lBQ2xCQyxPQUFPLEVBQUMsRUFBRTtJQUNWQyxJQUFJLEVBQUNULEVBQUUsQ0FBQ1UsT0FBTztJQUVmQyxTQUFTLEVBQUU7RUFDZixDQUFDO0VBRURDLFNBQVMsRUFBQyxTQUFBQSxVQUFVQyxJQUFJLEVBQUU7SUFDdEIsSUFBR0EsSUFBSSxDQUFDTCxPQUFPLElBQUksSUFBSSxJQUFJSyxJQUFJLENBQUNMLE9BQU8sSUFBSSxFQUFFLEVBQ3pDLElBQUksQ0FBQ0EsT0FBTyxHQUFHSyxJQUFJLENBQUNMLE9BQU8sQ0FBQyxLQUU1QixJQUFJLENBQUNBLE9BQU8sR0FBRyxFQUFFOztJQUVyQjs7SUFHQSxJQUFJLENBQUNDLElBQUksR0FBRyxDQUFDO0lBQ2IsSUFBRyxJQUFJLENBQUNELE9BQU8sSUFBSSxZQUFZLEVBQy9CO01BQ0ksSUFBSU0sV0FBVyxHQUFHZCxFQUFFLENBQUNlLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDQyxjQUFjLENBQUMsVUFBVSxHQUFFSixJQUFJLENBQUNLLEVBQUUsQ0FBQztNQUNuRSxJQUFJLENBQUNaLE1BQU0sQ0FBQ2EsTUFBTSxHQUFHLHNCQUFzQixHQUFDTCxXQUFXLEdBQUMsV0FBVyxHQUFDLGlCQUFpQixHQUFHRCxJQUFJLENBQUNPLEtBQUssR0FBRSxNQUFNLEdBQUMsc0JBQXNCO0lBQ3JJLENBQUMsTUFDSSxJQUFHLElBQUksQ0FBQ1osT0FBTyxJQUFJLE9BQU8sRUFDL0I7TUFDSSxJQUFJLENBQUNDLElBQUksR0FBR0ksSUFBSSxDQUFDUSxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixJQUFJLENBQUNRLFNBQVMsR0FBR3JCLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDUyxXQUFXLENBQUNDLFVBQVUsQ0FBQztNQUN2RixJQUFJLENBQUNuQixNQUFNLENBQUNhLE1BQU0sR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDVixJQUFJLEdBQUcsVUFBVTtJQUN0RCxDQUFDLE1BQ0ksSUFBRyxJQUFJLENBQUNELE9BQU8sSUFBSSxZQUFZLEVBQUU7TUFDbEMsSUFBSSxDQUFDRyxTQUFTLEdBQUdFLElBQUksQ0FBQ0YsU0FBUztNQUMvQixJQUFJLENBQUNMLE1BQU0sQ0FBQ2EsTUFBTSxHQUFHLGlCQUFpQixHQUFFTixJQUFJLENBQUNhLElBQUksR0FBRSxNQUFNO0lBQzdELENBQUMsTUFFRDtNQUNJLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ2EsTUFBTSxHQUFHLGlCQUFpQixHQUFFTixJQUFJLENBQUNhLElBQUksR0FBRSxNQUFNO0lBQzdEO0VBQ0osQ0FBQztFQUVEQyxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCM0IsRUFBRSxDQUFDZSxHQUFHLENBQUNhLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUVoQyxJQUFHLElBQUksQ0FBQ3JCLE9BQU8sSUFBSSxZQUFZLEVBQy9CO01BQ0lSLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDUyxXQUFXLENBQUNNLHNCQUFzQixDQUFDaEMsY0FBYyxDQUFDaUMsVUFBVSxFQUFFL0IsRUFBRSxDQUFDZSxHQUFHLENBQUNTLFdBQVcsQ0FBQ1EsR0FBRyxDQUFDO0lBQ2hHLENBQUMsTUFDSSxJQUFHLElBQUksQ0FBQ3hCLE9BQU8sSUFBSSxXQUFXLEVBQ25DO01BQ0ksSUFBR1IsRUFBRSxDQUFDZSxHQUFHLENBQUNTLFdBQVcsQ0FBQ1MsaUJBQWlCLElBQUksS0FBSyxFQUM1Q2pDLEVBQUUsQ0FBQ2tDLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUNwQyxFQUFFLENBQUNlLEdBQUcsQ0FBQ25CLEtBQUssQ0FBQ3lDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNoRTtJQUNBLElBQUksQ0FBQzdCLE9BQU8sR0FBRyxFQUFFO0lBQ2pCLElBQUksQ0FBQzhCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7SUFDeEI7RUFDSixDQUFDOztFQUVEQyxZQUFZLEVBQUMsU0FBQUEsYUFBQSxFQUFVO0lBQ25CLElBQUcsSUFBSSxDQUFDaEMsT0FBTyxJQUFJLE9BQU8sRUFDMUI7TUFDSTtNQUNBLElBQUlhLFNBQVMsR0FBRyxJQUFJLENBQUNaLElBQUksQ0FBQyxDQUFDO01BQzNCLElBQUdULEVBQUUsQ0FBQ2UsR0FBRyxDQUFDUyxXQUFXLENBQUNpQixJQUFJLEdBQUdwQixTQUFTLEVBQ3RDO1FBQ0ksSUFBSSxDQUFDZixNQUFNLENBQUNhLE1BQU0sR0FBRyxnQkFBZ0I7UUFDckM7TUFDSjtNQUNBbkIsRUFBRSxDQUFDZSxHQUFHLENBQUNTLFdBQVcsQ0FBQ2lCLElBQUksSUFBSXBCLFNBQVM7TUFDcENyQixFQUFFLENBQUNlLEdBQUcsQ0FBQ1MsV0FBVyxDQUFDa0IsT0FBTyxHQUFHLEdBQUc7TUFDaEMxQyxFQUFFLENBQUNrQyxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDcEMsRUFBRSxDQUFDZSxHQUFHLENBQUNuQixLQUFLLENBQUMrQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDL0QsQ0FBQyxNQUNJLElBQUcsSUFBSSxDQUFDbkMsT0FBTyxJQUFJLFFBQVEsRUFDaEM7TUFDSVIsRUFBRSxDQUFDa0MsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQ3BDLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDbkIsS0FBSyxDQUFDZ0QsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUMsTUFDSSxJQUFHLElBQUksQ0FBQ3BDLE9BQU8sSUFBSSxZQUFZLEVBQ3BDO01BQ0lSLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDUyxXQUFXLENBQUNNLHNCQUFzQixDQUFDaEMsY0FBYyxDQUFDaUMsVUFBVSxFQUFFL0IsRUFBRSxDQUFDZSxHQUFHLENBQUNTLFdBQVcsQ0FBQ1EsR0FBRyxDQUFDO0lBQ2hHLENBQUMsTUFDSSxJQUFHLElBQUksQ0FBQ3hCLE9BQU8sSUFBSSxVQUFVLEVBQ2xDO01BQ0lSLEVBQUUsQ0FBQ2tDLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUNwQyxFQUFFLENBQUNlLEdBQUcsQ0FBQ25CLEtBQUssQ0FBQ2lELFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1RCxDQUFDLE1BQ0ksSUFBRyxJQUFJLENBQUNyQyxPQUFPLElBQUksT0FBTyxFQUMvQjtNQUNJUixFQUFFLENBQUNlLEdBQUcsQ0FBQytCLGtCQUFrQixDQUFDQyxLQUFLLEVBQUU7SUFDckMsQ0FBQyxNQUNJLElBQUksSUFBSSxDQUFDdkMsT0FBTyxJQUFJLFlBQVksRUFBRTtNQUNuQ1IsRUFBRSxDQUFDa0MsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQ3BDLEVBQUUsQ0FBQ2UsR0FBRyxDQUFDbkIsS0FBSyxDQUFDb0QsVUFBVSxFQUFFO1FBQUNyQyxTQUFTLEVBQUUsSUFBSSxDQUFDQTtNQUFTLENBQUMsQ0FBQztJQUN0RjtJQUVBLElBQUksQ0FBQ2dCLFVBQVUsRUFBRTtFQUNyQjtBQUVKLENBQUMsQ0FBQztBQUNGc0IsTUFBTSxDQUFDQyxPQUFPLEdBQUduRCxjQUFjIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXZlbnQgPSByZXF1aXJlKFwiRXZlbnRcIik7XHJcbnZhciBNYXRlVW5Mb2NrVHlwZSA9IHJlcXVpcmUoXCJNYXRlVW5Mb2NrVHlwZVwiKTtcclxudmFyIENvbW1vblRpcFBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICB0aXRsZUxibDpjYy5TcHJpdGUsXHJcbiAgICAgICAgVGlwTGJsOmNjLlJpY2hUZXh0LFxyXG4gICAgICAgIGZvcldoYXQ6XCJcIixcclxuICAgICAgICBjb3N0OmNjLkludGVnZXIsXHJcblxyXG4gICAgICAgIHZpZGVvUGF0aDogXCJcIixcclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYoZGF0YS5mb3JXaGF0ICE9IG51bGwgJiYgZGF0YS5mb3JXaGF0ICE9IFwiXCIpXHJcbiAgICAgICAgICAgIHRoaXMuZm9yV2hhdCA9IGRhdGEuZm9yV2hhdDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZm9yV2hhdCA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8vdGhpcy50aXRsZUxibC5zdHJpbmcgPSBcIuaPkOekuuivtOaYjlwiO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5jb3N0ID0gMDtcclxuICAgICAgICBpZih0aGlzLmZvcldoYXQgPT0gXCJTdG9ja0JvbnVzXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY29tcGFueU5hbWUgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiY29tcGFueV9cIiArZGF0YS5JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwTGJsLnN0cmluZyA9IFwiPGNvbG9yPSM2OTY5Njk+6IKh56Wo5biC5Zy6LVwiK2NvbXBhbnlOYW1lK1wiLeiOt+W+l+aUtuebijwvYz5cIitcIjxjb2xvcj0jZTc3MTIyPlwiICsgZGF0YS5ib251cyArXCI8L2M+XCIrXCI8Y29sb3I9IzY5Njk2OT7lhYM8L2M+XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mb3JXaGF0ID09IFwiVHJlYXRcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29zdCA9IGRhdGEubmVlZE1vbmV5IC0gTWF0aC5mbG9vcihkYXRhLm5lZWRNb25leSAqIGNjLk1nci5Vc2VyRGF0YU1nci5UcmVhdEJvbnVzKTtcclxuICAgICAgICAgICAgdGhpcy5UaXBMYmwuc3RyaW5nID0gXCLoirHotLlcIiArIHRoaXMuY29zdCArIFwi5rK755aX77yM5Lul5oGi5aSN5YGl5bq3XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mb3JXaGF0ID09IFwic2hhcmVWaWRlb1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9QYXRoID0gZGF0YS52aWRlb1BhdGg7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwTGJsLnN0cmluZyA9IFwiPGNvbG9yPSM2OTY5Njk+XCIrIGRhdGEudGV4dCArXCI8L2M+XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwTGJsLnN0cmluZyA9IFwiPGNvbG9yPSM2OTY5Njk+XCIrIGRhdGEudGV4dCArXCI8L2M+XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5mb3JXaGF0ID09IFwiSGVhbHRoTGluZVwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlVuTG9ja01hdGVCeUluSG9zcGl0YWwoTWF0ZVVuTG9ja1R5cGUuSW5Ib3NwaXRhbCwgY2MuTWdyLlVzZXJEYXRhTWdyLlNleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mb3JXaGF0ID09IFwiRGF0ZUxhdGVyXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IudHV0b3JpYWxNYXRlUG9pbnQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5EYXRlTGF0ZXIsIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mb3JXaGF0ID0gXCJcIjtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgLy9jYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuRXZlbnRUaXAsIHt9KTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tDb25maXJtOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5mb3JXaGF0ID09IFwiVHJlYXRcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8v6K6h566X5LiL5omA6ZyA6KaB55qE6ZKxIOa2iOiAl+mHkeminT0yMDAwKjEuMTheKOW9k+WJjeW5tOm+hC0yMCkq77yIMS3lvZPliY3lgaXlurfluqYvMTAw77yJ77yM5ZCR5LiK5Y+W5pW0XHJcbiAgICAgICAgICAgIHZhciBuZWVkTW9uZXkgPSB0aGlzLmNvc3Q7IC8vTWF0aC5mbG9vcigyMDAwKiBNYXRoLnBvdygxLjE4LCBjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlLTIwKSAqKDEtY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQvMTAwKSk7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIDwgbmVlZE1vbmV5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlRpcExibC5zdHJpbmcgPSBcIuS9oOeahOmSseS4jeWkn+WViiznrYnmnInpkrHkuoblho3mnaXlkKdcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCAtPSBuZWVkTW9uZXk7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50ID0gMTAwO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5UcmVhdFN1Y2Nlc3MsIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZvcldoYXQgPT0gXCJSZXRpcmVcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlJldGlyZSwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZm9yV2hhdCA9PSBcIkhlYWx0aExpbmVcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5VbkxvY2tNYXRlQnlJbkhvc3BpdGFsKE1hdGVVbkxvY2tUeXBlLkluSG9zcGl0YWwsIGNjLk1nci5Vc2VyRGF0YU1nci5TZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZm9yV2hhdCA9PSBcIk9wZW5EYXRlXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuRW5qb3ksIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZvcldoYXQgPT0gXCJMb2dpblwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5Mb2dpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZvcldoYXQgPT0gXCJzaGFyZVZpZGVvXCIpIHtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuU2hhcmVWaWRlbywge3ZpZGVvUGF0aDogdGhpcy52aWRlb1BhdGh9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuQ2xvc2VQYW5lbCgpO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1vblRpcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CompanyCreateTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '08151xgK9NNXoJbaEAc321r', 'CompanyCreateTipPanel');
// Scripts/UI/CompanyCreateTipPanel.js

"use strict";

var CompanyCreateTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    IconSp: cc.Sprite,
    NameLbl: cc.Sprite,
    NumLbl: cc.Label,
    DesLbl: cc.RichText,
    Data: null
  },
  ShowPanel: function ShowPanel(data) {
    this.Data = null;
    this.Data = data;
    this.NameLbl.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.NumLbl.string = cc.Mgr.global.CompanyCreateCost;
    var name = cc.Mgr.global.getTranslation("company_" + data.Id);
    this.DesLbl.string = "<color=#696969>创办</c>" + "<color=#e77122>" + name + "</c>" + "<color=#696969>需要花费</c>" + "<color=#e77122>" + cc.Mgr.global.FormatNum(Math.floor(cc.Mgr.global.CompanyCreateCost * 100 * data.stockPrice)) + "</c>" + "<color=#696969>,收益率为</c>" + "<color=#e77122>" + data.bonusRatio * 100 + "%" + "</c>";
  },
  ClickCreate: function ClickCreate() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.Cash < cc.Mgr.global.CompanyCreateCost * 100 * this.Data.stockPrice) {
      var param = {};
      param.forWhat = "";
      param.text = "现金不够";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    if (cc.Mgr.UserDataMgr.FundationAge == 0) {
      cc.Mgr.UserDataMgr.FundationCompanyId = this.Data.Id;
      cc.Mgr.UserDataMgr.FundationAge = cc.Mgr.UserDataMgr.Age;
    }
    cc.Mgr.global.CreateCompanyTimes += 1;
    cc.Mgr.UserDataMgr.Cash -= Math.floor(cc.Mgr.global.CompanyCreateCost * 100 * this.Data.stockPrice);
    var param = {};
    param.Num = cc.Mgr.global.CompanyCreateCost * 100;
    param.price = this.Data.stockPrice;
    param.cost = this.Data.stockCost;
    param.Id = this.Data.Id;
    var data = cc.Mgr.UserDataMgr.CreateCompany(param);
    //通知刷新UI
    cc.Mgr.UserDataMgr.hasCompany = true; //企业只能创办一个
    cc.director.GlobalEvent.emit(cc.Mgr.Event.CreateCompanySuccess, data);
    this.ClosePanel();
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = CompanyCreateTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENvbXBhbnlDcmVhdGVUaXBQYW5lbC5qcyJdLCJuYW1lcyI6WyJDb21wYW55Q3JlYXRlVGlwUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJJY29uU3AiLCJTcHJpdGUiLCJOYW1lTGJsIiwiTnVtTGJsIiwiTGFiZWwiLCJEZXNMYmwiLCJSaWNoVGV4dCIsIkRhdGEiLCJTaG93UGFuZWwiLCJkYXRhIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsIm5hbWUiLCJpY29uIiwic3RyaW5nIiwiTWdyIiwiZ2xvYmFsIiwiQ29tcGFueUNyZWF0ZUNvc3QiLCJnZXRUcmFuc2xhdGlvbiIsIklkIiwiRm9ybWF0TnVtIiwiTWF0aCIsImZsb29yIiwic3RvY2tQcmljZSIsImJvbnVzUmF0aW8iLCJDbGlja0NyZWF0ZSIsIkF1ZGlvTWdyIiwicGxheVNGWCIsIlVzZXJEYXRhTWdyIiwiQ2FzaCIsInBhcmFtIiwiZm9yV2hhdCIsInRleHQiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vblRpcCIsIkZ1bmRhdGlvbkFnZSIsIkZ1bmRhdGlvbkNvbXBhbnlJZCIsIkFnZSIsIkNyZWF0ZUNvbXBhbnlUaW1lcyIsIk51bSIsInByaWNlIiwiY29zdCIsInN0b2NrQ29zdCIsIkNyZWF0ZUNvbXBhbnkiLCJoYXNDb21wYW55IiwiQ3JlYXRlQ29tcGFueVN1Y2Nlc3MiLCJDbG9zZVBhbmVsIiwibm9kZSIsImFjdGl2ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEscUJBQXFCLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ2pDLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLEtBQUssRUFBQ0osRUFBRSxDQUFD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QiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBDb21wYW55Q3JlYXRlVGlwUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIEF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIEljb25TcDpjYy5TcHJpdGUsXHJcbiAgICAgICAgTmFtZUxibDpjYy5TcHJpdGUsXHJcbiAgICAgICAgTnVtTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIERlc0xibDpjYy5SaWNoVGV4dCxcclxuICAgICAgICBEYXRhOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICB0aGlzLkRhdGEgPSBudWxsO1xyXG4gICAgICB0aGlzLkRhdGEgPSBkYXRhOyAgXHJcbiAgICAgIHRoaXMuTmFtZUxibC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5uYW1lKTtcclxuICAgICAgdGhpcy5JY29uU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgIHRoaXMuTnVtTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuQ29tcGFueUNyZWF0ZUNvc3Q7XHJcbiAgICAgIHZhciBuYW1lID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcImNvbXBhbnlfXCIrZGF0YS5JZCk7XHJcbiAgICAgIHRoaXMuRGVzTGJsLnN0cmluZyA9IFwiPGNvbG9yPSM2OTY5Njk+5Yib5YqePC9jPlwiK1wiPGNvbG9yPSNlNzcxMjI+XCIrbmFtZStcIjwvYz5cIiArIFwiPGNvbG9yPSM2OTY5Njk+6ZyA6KaB6Iqx6LS5PC9jPlwiICtcIjxjb2xvcj0jZTc3MTIyPlwiKyBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShNYXRoLmZsb29yKGNjLk1nci5nbG9iYWwuQ29tcGFueUNyZWF0ZUNvc3QgKiAxMDAgKiBkYXRhLnN0b2NrUHJpY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICArXCI8L2M+XCIgK1wiPGNvbG9yPSM2OTY5Njk+LOaUtuebiueOh+S4ujwvYz5cIiArIFwiPGNvbG9yPSNlNzcxMjI+XCIrKGRhdGEuYm9udXNSYXRpbyoxMDApK1wiJVwiICtcIjwvYz5cIjsgIFxyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja0NyZWF0ZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggPCAoY2MuTWdyLmdsb2JhbC5Db21wYW55Q3JlYXRlQ29zdCAqIDEwMCAqIHRoaXMuRGF0YS5zdG9ja1ByaWNlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJcIjtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi546w6YeR5LiN5aSfXCI7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuIDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkZ1bmRhdGlvbkFnZSA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkZ1bmRhdGlvbkNvbXBhbnlJZCA9IHRoaXMuRGF0YS5JZDtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkZ1bmRhdGlvbkFnZSA9IGNjLk1nci5Vc2VyRGF0YU1nci5BZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYy5NZ3IuZ2xvYmFsLkNyZWF0ZUNvbXBhbnlUaW1lcyArPSAxO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIC09IE1hdGguZmxvb3IoY2MuTWdyLmdsb2JhbC5Db21wYW55Q3JlYXRlQ29zdCAqIDEwMCAqIHRoaXMuRGF0YS5zdG9ja1ByaWNlKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5OdW0gPSBjYy5NZ3IuZ2xvYmFsLkNvbXBhbnlDcmVhdGVDb3N0ICogMTAwO1xyXG4gICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5EYXRhLnN0b2NrUHJpY2U7XHJcbiAgICAgICAgcGFyYW0uY29zdCA9IHRoaXMuRGF0YS5zdG9ja0Nvc3Q7XHJcbiAgICAgICAgcGFyYW0uSWQgPSB0aGlzLkRhdGEuSWQ7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQ3JlYXRlQ29tcGFueShwYXJhbSk7XHJcbiAgICAgICAgLy/pgJrnn6XliLfmlrBVSVxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5oYXNDb21wYW55ID0gdHJ1ZTsvL+S8geS4muWPquiDveWIm+WKnuS4gOS4qlxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LkNyZWF0ZUNvbXBhbnlTdWNjZXNzLCBkYXRhKTtcclxuICAgICAgICB0aGlzLkNsb3NlUGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9ZmFsc2U7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBDb21wYW55Q3JlYXRlVGlwUGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CarPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '92575NnT7tEZ4ByGogjuYD/', 'CarPanel');
// Scripts/UI/CarPanel.js

"use strict";

var ItemType = require("ItemType");
var CarPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    carItemPre: cc.Prefab,
    carItemParent: cc.Node,
    hasInit: false
  },
  ShowPanel: function ShowPanel() {
    if (this.hasInit == true) {
      //cc.log("已经初始化过了，不用重复");
      return;
    }
    var dataList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Car);
    for (var i = dataList.length - 1; i >= 0; i--) {
      var data = dataList[i];
      var obj = cc.instantiate(this.carItemPre);
      obj.parent = this.carItemParent;
      obj.active = true;
      obj.getComponent("CarItem").init(data);
    }
    this.hasInit = true;
  }
});
module.exports = CarPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENhclBhbmVsLmpzIl0sIm5hbWVzIjpbIkl0ZW1UeXBlIiwicmVxdWlyZSIsIkNhclBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJjYXJJdGVtUHJlIiwiUHJlZmFiIiwiY2FySXRlbVBhcmVudCIsIk5vZGUiLCJoYXNJbml0IiwiU2hvd1BhbmVsIiwiZGF0YUxpc3QiLCJNZ3IiLCJVc2VyRGF0YU1nciIsImdldE93bkRhdGFMaXN0QnlUeXBlIiwiQ2FyIiwiaSIsImxlbmd0aCIsImRhdGEiLCJvYmoiLCJpbnN0YW50aWF0ZSIsInBhcmVudCIsImFjdGl2ZSIsImdldENvbXBvbmVudCIsImluaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxRQUFRLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3BCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFVBQVUsRUFBQ0osRUFBRSxDQUFDSyxNQUFNO0lBQ3BCQyxhQUFhLEVBQUNOLEVBQUUsQ0FBQ08sSUFBSTtJQUNyQkMsT0FBTyxFQUFDO0VBQ1osQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFZO0lBQ2xCLElBQUcsSUFBSSxDQUFDRCxPQUFPLElBQUksSUFBSSxFQUN2QjtNQUNJO01BQ0E7SUFDSjtJQUVBLElBQUlFLFFBQVEsR0FBR1YsRUFBRSxDQUFDVyxHQUFHLENBQUNDLFdBQVcsQ0FBQ0Msb0JBQW9CLENBQUNoQixRQUFRLENBQUNpQixHQUFHLENBQUM7SUFDcEUsS0FBSyxJQUFJQyxDQUFDLEdBQUdMLFFBQVEsQ0FBQ00sTUFBTSxHQUFHLENBQUMsRUFBRUQsQ0FBQyxJQUFJLENBQUMsRUFBRUEsQ0FBQyxFQUFFLEVBQUU7TUFDM0MsSUFBSUUsSUFBSSxHQUFHUCxRQUFRLENBQUNLLENBQUMsQ0FBQztNQUN0QixJQUFJRyxHQUFHLEdBQUdsQixFQUFFLENBQUNtQixXQUFXLENBQUMsSUFBSSxDQUFDZixVQUFVLENBQUM7TUFDekNjLEdBQUcsQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ2QsYUFBYTtNQUMvQlksR0FBRyxDQUFDRyxNQUFNLEdBQUcsSUFBSTtNQUNqQkgsR0FBRyxDQUFDSSxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUNDLElBQUksQ0FBQ04sSUFBSSxDQUFDO0lBQzFDO0lBQ0EsSUFBSSxDQUFDVCxPQUFPLEdBQUcsSUFBSTtFQUN2QjtBQUNKLENBQUMsQ0FBQztBQUNGZ0IsTUFBTSxDQUFDQyxPQUFPLEdBQUcxQixRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBDYXJQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgY2FySXRlbVByZTpjYy5QcmVmYWIsXHJcbiAgICAgICAgY2FySXRlbVBhcmVudDpjYy5Ob2RlLFxyXG4gICAgICAgIGhhc0luaXQ6ZmFsc2UsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy5oYXNJbml0ID09IHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuW3sue7j+WIneWni+WMlui/h+S6hu+8jOS4jeeUqOmHjeWkjVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRhdGFMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLkNhcik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRhdGFMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YUxpc3RbaV07XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLmNhckl0ZW1QcmUpO1xyXG4gICAgICAgICAgICBvYmoucGFyZW50ID0gdGhpcy5jYXJJdGVtUGFyZW50O1xyXG4gICAgICAgICAgICBvYmouYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkNhckl0ZW1cIikuaW5pdChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYXNJbml0ID0gdHJ1ZTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENhclBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CompanySaleTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '57d83pbqw5Jkr7JTDdihURB', 'CompanySaleTipPanel');
// Scripts/UI/CompanySaleTipPanel.js

"use strict";

var ItemType = require("ItemType");
var TempBonus = require("TempBonus");
var CompanySaleTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    IconSp: cc.Sprite,
    TitleName: cc.Sprite,
    SaleNumLbl: cc.Label,
    EarnLbl: cc.Label,
    Slider: cc.Slider,
    InPutBox: cc.EditBox,
    Progress: cc.ProgressBar,
    SaleNum: 0,
    Data: null
  },
  ShowPanel: function ShowPanel(data) {
    this.Data = data;
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.TitleName.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Company, this.Data.Id);
    var marketPrice = data.stockPrice;
    var cost = data.stockCost;
    this.SaleNum = Math.floor(this.Data.stockNum / 100);
    var money = Math.floor(this.Data.stockNum * (marketPrice - cost));
    if (cc.Mgr.global.TempAdsStockBonus == TempBonus.StockBonus) {
      if (money > 0) money = Math.floor(money * 1.2); //有之前看过广告
    }

    this.EarnLbl.string = cc.Mgr.global.FormatNum(money);
    this.SaleNumLbl.string = this.SaleNum;
    this.InPutBox.string = this.SaleNum;
    this.Slider.progress = 1;
    this.Progress.progress = 1;
  },
  OnSliderChange: function OnSliderChange() {
    this.SaleNum = Math.floor(this.Slider.progress * (this.Data.stockNum / 100));
    this.Progress.progress = this.Slider.progress;
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Company, this.Data.Id);
    var marketPrice = data.stockPrice;
    var cost = data.stockCost;
    var money = Math.floor(this.SaleNum * 100 * (marketPrice - cost));
    if (cc.Mgr.global.TempAdsStockBonus == TempBonus.StockBonus) {
      if (money > 0) money = Math.floor(money * 1.2); //有之前看过广告
    }

    this.EarnLbl.string = cc.Mgr.global.FormatNum(money);
    this.SaleNumLbl.string = this.SaleNum;
    this.InPutBox.string = this.SaleNum;
  },
  OnInputBoxEnd: function OnInputBoxEnd() {
    if (this.InPutBox.string != "") {
      if (Number(this.InPutBox.string) != null) {
        if (Number(this.InPutBox.string) > Math.floor(this.Data.stockNum / 100)) {
          this.InPutBox.string = Math.floor(this.Data.stockNum / 100);
          this.SaleNum = Math.floor(this.Data.stockNum / 100);
          this.Progress.progress = 1;
          this.Slider.progress = 1;
        } else {
          this.SaleNum = Number(this.InPutBox.string);
          this.Slider.progress = Math.floor(this.SaleNum / (this.Data.stockNum / 100));
          this.Progress.progress = this.Slider.progress;
        }
      }
    } else {
      this.InPutBox.string = "0";
      this.SaleNum = 0;
      this.Progress.progress = 0;
      this.Slider.progress = 0;
    }
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Company, this.Data.Id);
    var marketPrice = data.stockPrice;
    var cost = data.stockCost;
    var money = Math.floor(this.SaleNum * 100 * (marketPrice - cost));
    if (cc.Mgr.global.TempAdsStockBonus == TempBonus.StockBonus) {
      if (money > 0) money = Math.floor(money * 1.2); //有之前看过广告
    }

    this.EarnLbl.string = cc.Mgr.global.FormatNum(money);
  },
  ClickSaleBtn: function ClickSaleBtn() {
    if (this.SaleNum <= 0) {
      cc.Mgr.AudioMgr.playSFX("click");
      return;
    }
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Company, this.Data.Id);
    var marketPrice = data.stockPrice;
    var cost = data.stockCost;
    var getMoney = Math.floor(marketPrice * this.SaleNum * 100);
    if (cc.Mgr.global.TempAdsStockBonus == TempBonus.StockBonus) {
      var money = this.SaleNum * (marketPrice - cost);
      if (money > 0) getMoney = Math.floor(getMoney * 1.2); //有之前看过广告
      //cc.Mgr.global.TempAdsBonus = TempBonus.NULL;
    }

    cc.Mgr.UserDataMgr.Cash += getMoney;
    var param = {};
    param.Num = this.SaleNum * 100;
    param.price = marketPrice;
    param.Id = this.Data.Id;
    var data = cc.Mgr.UserDataMgr.SaleStocks(param);
    //通知刷新
    cc.director.GlobalEvent.emit(cc.Mgr.Event.SaleStockSuccess, data);
    this.ClosePanel();
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = CompanySaleTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENvbXBhbnlTYWxlVGlwUGFuZWwuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiVGVtcEJvbnVzIiwiQ29tcGFueVNhbGVUaXBQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiQXRsYXMiLCJTcHJpdGVBdGxhcyIsIkljb25TcCIsIlNwcml0ZSIsIlRpdGxlTmFtZSIsIlNhbGVOdW1MYmwiLCJMYWJlbCIsIkVhcm5MYmwiLCJTbGlkZXIiLCJJblB1dEJveCIsIkVkaXRCb3giLCJQcm9ncmVzcyIsIlByb2dyZXNzQmFyIiwiU2FsZU51bSIsIkRhdGEiLCJTaG93UGFuZWwiLCJkYXRhIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsImljb24iLCJuYW1lIiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJnZXREYXRhQnlJdGVtVHlwZUFuZElkIiwiQ29tcGFueSIsIklkIiwibWFya2V0UHJpY2UiLCJzdG9ja1ByaWNlIiwiY29zdCIsInN0b2NrQ29zdCIsIk1hdGgiLCJmbG9vciIsInN0b2NrTnVtIiwibW9uZXkiLCJnbG9iYWwiLCJUZW1wQWRzU3RvY2tCb251cyIsIlN0b2NrQm9udXMiLCJzdHJpbmciLCJGb3JtYXROdW0iLCJwcm9ncmVzcyIsIk9uU2xpZGVyQ2hhbmdlIiwiT25JbnB1dEJveEVuZCIsIk51bWJlciIsIkNsaWNrU2FsZUJ0biIsIkF1ZGlvTWdyIiwicGxheVNGWCIsImdldE1vbmV5IiwiQ2FzaCIsInBhcmFtIiwiTnVtIiwicHJpY2UiLCJTYWxlU3RvY2tzIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIlNhbGVTdG9ja1N1Y2Nlc3MiLCJDbG9zZVBhbmVsIiwibm9kZSIsImFjdGl2ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFP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QUFVLEVBQUU7RUFDckIsQ0FBQztFQUVEQSxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCN0QsRUFBRSxDQUFDeUIsR0FBRyxDQUFDdUIsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUksQ0FBQ2EsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztFQUM1QjtBQUVKLENBQUMsQ0FBQztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR2xFLG1CQUFtQiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgVGVtcEJvbnVzID0gcmVxdWlyZShcIlRlbXBCb251c1wiKTtcclxudmFyIENvbXBhbnlTYWxlVGlwUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgSWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBUaXRsZU5hbWU6Y2MuU3ByaXRlLFxyXG4gICAgICAgIFNhbGVOdW1MYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgRWFybkxibDpjYy5MYWJlbCxcclxuICAgICAgICBTbGlkZXI6Y2MuU2xpZGVyLFxyXG4gICAgICAgIEluUHV0Qm94OmNjLkVkaXRCb3gsXHJcbiAgICAgICAgUHJvZ3Jlc3M6Y2MuUHJvZ3Jlc3NCYXIsXHJcbiAgICAgICAgU2FsZU51bTowLFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5EYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLkljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICB0aGlzLlRpdGxlTmFtZS5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5uYW1lKTtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5Db21wYW55LHRoaXMuRGF0YS5JZCk7XHJcbiAgICAgICAgdmFyIG1hcmtldFByaWNlID0gZGF0YS5zdG9ja1ByaWNlO1xyXG4gICAgICAgIHZhciBjb3N0ID0gZGF0YS5zdG9ja0Nvc3Q7XHJcbiAgICAgICAgdGhpcy5TYWxlTnVtID0gTWF0aC5mbG9vcih0aGlzLkRhdGEuc3RvY2tOdW0gLyAxMDApO1xyXG4gICAgICAgIHZhciBtb25leSA9IE1hdGguZmxvb3IodGhpcy5EYXRhLnN0b2NrTnVtICogKG1hcmtldFByaWNlIC0gY29zdCkpO1xyXG4gICAgICAgIGlmKGNjLk1nci5nbG9iYWwuVGVtcEFkc1N0b2NrQm9udXMgPT0gVGVtcEJvbnVzLlN0b2NrQm9udXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZihtb25leSA+IDApXHJcbiAgICAgICAgICAgICAgICBtb25leSA9IE1hdGguZmxvb3IobW9uZXkgKiAxLjIpOyAvL+acieS5i+WJjeeci+i/h+W5v+WRilxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLkVhcm5MYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0obW9uZXkpO1xyXG4gICAgICAgIHRoaXMuU2FsZU51bUxibC5zdHJpbmcgPSB0aGlzLlNhbGVOdW07XHJcbiAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSB0aGlzLlNhbGVOdW07XHJcbiAgICAgICAgdGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuUHJvZ3Jlc3MucHJvZ3Jlc3MgPSAxO1xyXG4gICAgfSxcclxuXHJcbiAgICBPblNsaWRlckNoYW5nZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuU2FsZU51bSA9IE1hdGguZmxvb3IodGhpcy5TbGlkZXIucHJvZ3Jlc3MgKiAodGhpcy5EYXRhLnN0b2NrTnVtIC8gMTAwKSk7XHJcbiAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IHRoaXMuU2xpZGVyLnByb2dyZXNzO1xyXG4gICAgICAgIHZhciBkYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuQ29tcGFueSx0aGlzLkRhdGEuSWQpO1xyXG4gICAgICAgIHZhciBtYXJrZXRQcmljZSA9IGRhdGEuc3RvY2tQcmljZTtcclxuICAgICAgICB2YXIgY29zdCA9IGRhdGEuc3RvY2tDb3N0O1xyXG4gICAgICAgIHZhciBtb25leSA9IE1hdGguZmxvb3IodGhpcy5TYWxlTnVtICogMTAwICogKG1hcmtldFByaWNlIC0gY29zdCkpO1xyXG4gICAgICAgIGlmKGNjLk1nci5nbG9iYWwuVGVtcEFkc1N0b2NrQm9udXMgPT0gVGVtcEJvbnVzLlN0b2NrQm9udXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZihtb25leSA+IDApXHJcbiAgICAgICAgICAgICAgICBtb25leSA9IE1hdGguZmxvb3IobW9uZXkgKjEuMik7IC8v5pyJ5LmL5YmN55yL6L+H5bm/5ZGKXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuRWFybkxibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShtb25leSk7XHJcbiAgICAgICAgdGhpcy5TYWxlTnVtTGJsLnN0cmluZyA9IHRoaXMuU2FsZU51bTtcclxuICAgICAgICB0aGlzLkluUHV0Qm94LnN0cmluZyA9IHRoaXMuU2FsZU51bTtcclxuICAgIH0sXHJcblxyXG4gICAgT25JbnB1dEJveEVuZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuSW5QdXRCb3guc3RyaW5nICE9IFwiXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZihOdW1iZXIodGhpcy5JblB1dEJveC5zdHJpbmcpICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKE51bWJlcih0aGlzLkluUHV0Qm94LnN0cmluZykgPiBNYXRoLmZsb29yKHRoaXMuRGF0YS5zdG9ja051bSAvIDEwMCkpIFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuSW5QdXRCb3guc3RyaW5nID0gTWF0aC5mbG9vcih0aGlzLkRhdGEuc3RvY2tOdW0gLyAxMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuU2FsZU51bSA9IE1hdGguZmxvb3IodGhpcy5EYXRhLnN0b2NrTnVtIC8gMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlNsaWRlci5wcm9ncmVzcyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TYWxlTnVtID0gTnVtYmVyKHRoaXMuSW5QdXRCb3guc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlNsaWRlci5wcm9ncmVzcyA9ICBNYXRoLmZsb29yKHRoaXMuU2FsZU51bSAvICh0aGlzLkRhdGEuc3RvY2tOdW0gLyAxMDApKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gdGhpcy5TbGlkZXIucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSBcIjBcIjtcclxuICAgICAgICAgICAgdGhpcy5TYWxlTnVtID0gMDtcclxuICAgICAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuU2xpZGVyLnByb2dyZXNzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5Db21wYW55LHRoaXMuRGF0YS5JZCk7XHJcbiAgICAgICAgdmFyIG1hcmtldFByaWNlID0gZGF0YS5zdG9ja1ByaWNlO1xyXG4gICAgICAgIHZhciBjb3N0ID0gZGF0YS5zdG9ja0Nvc3Q7XHJcbiAgICAgICAgdmFyIG1vbmV5ID0gTWF0aC5mbG9vcih0aGlzLlNhbGVOdW0gKiAxMDAgKiAobWFya2V0UHJpY2UgLSBjb3N0KSk7XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC5UZW1wQWRzU3RvY2tCb251cyA9PSBUZW1wQm9udXMuU3RvY2tCb251cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKG1vbmV5ID4gMClcclxuICAgICAgICAgICAgICAgIG1vbmV5ID0gTWF0aC5mbG9vcihtb25leSAqMS4yKTsgLy/mnInkuYvliY3nnIvov4flub/lkYpcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5FYXJuTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKG1vbmV5KTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tTYWxlQnRuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5TYWxlTnVtIDw9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuQ29tcGFueSx0aGlzLkRhdGEuSWQpO1xyXG4gICAgICAgIHZhciBtYXJrZXRQcmljZSA9IGRhdGEuc3RvY2tQcmljZTtcclxuICAgICAgICB2YXIgY29zdCA9IGRhdGEuc3RvY2tDb3N0O1xyXG4gICAgICAgIHZhciBnZXRNb25leSA9IE1hdGguZmxvb3IobWFya2V0UHJpY2UgKiB0aGlzLlNhbGVOdW0gKiAxMDApO1xyXG4gICAgICAgIGlmKGNjLk1nci5nbG9iYWwuVGVtcEFkc1N0b2NrQm9udXMgPT0gVGVtcEJvbnVzLlN0b2NrQm9udXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbW9uZXkgPSB0aGlzLlNhbGVOdW0gKiAobWFya2V0UHJpY2UgLSBjb3N0KTtcclxuICAgICAgICAgICAgaWYobW9uZXkgPiAwKVxyXG4gICAgICAgICAgICAgICAgZ2V0TW9uZXkgPSBNYXRoLmZsb29yKGdldE1vbmV5ICoxLjIpOyAvL+acieS5i+WJjeeci+i/h+W5v+WRilxyXG4gICAgICAgICAgICAvL2NjLk1nci5nbG9iYWwuVGVtcEFkc0JvbnVzID0gVGVtcEJvbnVzLk5VTEw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoICs9IGdldE1vbmV5O1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLk51bSA9IHRoaXMuU2FsZU51bSAqIDEwMDtcclxuICAgICAgICBwYXJhbS5wcmljZSA9IG1hcmtldFByaWNlO1xyXG4gICAgICAgIHBhcmFtLklkID0gdGhpcy5EYXRhLklkO1xyXG4gICAgICAgIHZhciBkYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLlNhbGVTdG9ja3MocGFyYW0pO1xyXG4gICAgICAgIC8v6YCa55+l5Yi35pawXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuU2FsZVN0b2NrU3VjY2VzcywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcGFueVNhbGVUaXBQYW5lbDsiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/EnjoyPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '6589609fM1OeIJ/a8i4TPj5', 'EnjoyPanel');
// Scripts/UI/EnjoyPanel.js

"use strict";

var JoyPanel = require("JoyPanel");
var HousePanel = require("HousePanel");
var TreatPanel = require("TreatPanel");
var CarPanel = require("CarPanel");
var EnjoyPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    MainAtlas: cc.SpriteAtlas,
    TipNameSp: cc.Sprite,
    joyPanel: JoyPanel,
    housePanel: HousePanel,
    carPanel: CarPanel
    //treatPanel:TreatPanel,
  },

  ShowPanel: function ShowPanel() {
    //this.OpenJoyPanel();
  },
  OpenJoyPanel: function OpenJoyPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.joyPanel.node.active = true;
    this.housePanel.node.active = false;
    this.carPanel.node.active = false;
    this.TipNameSp.spriteFrame = this.MainAtlas.getSpriteFrame("funny");
    //this.treatPanel.node.active = false;
  },

  OpenHousePanel: function OpenHousePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.joyPanel.node.active = false;
    this.housePanel.node.active = true;
    this.carPanel.node.active = false;
    //this.treatPanel.node.active = false;
    this.TipNameSp.spriteFrame = this.MainAtlas.getSpriteFrame("house");
    this.housePanel.ShowPanel();
  },
  OpenCarPanel: function OpenCarPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.joyPanel.node.active = false;
    this.housePanel.node.active = false;
    this.carPanel.node.active = true;
    //this.treatPanel.node.active = false;
    this.TipNameSp.spriteFrame = this.MainAtlas.getSpriteFrame("text_car");
    this.carPanel.ShowPanel();
  },
  OpenTreatPanel: function OpenTreatPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.joyPanel.node.active = false;
    this.housePanel.node.active = false;
    this.carPanel.node.active = false;
    //this.treatPanel.node.active = true;
  },

  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = EnjoyPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEVuam95UGFuZWwuanMiXSwibmFtZXMiOlsiSm95UGFuZWwiLCJyZXF1aXJlIiwiSG91c2VQYW5lbCIsIlRyZWF0UGFuZWwiLCJDYXJQYW5lbCIsIkVuam95UGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIk1haW5BdGxhcyIsIlNwcml0ZUF0bGFzIiwiVGlwTmFtZVNwIiwiU3ByaXRlIiwiam95UGFuZWwiLCJob3VzZVBhbmVsIiwiY2FyUGFuZWwiLCJTaG93UGFuZWwiLCJPcGVuSm95UGFuZWwiLCJNZ3IiLCJBdWRpb01nciIsInBsYXlTRlgiLCJub2RlIiwiYWN0aXZlIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsIk9wZW5Ib3VzZVBhbmVsIiwiT3BlbkNhclBhbmVsIiwiT3BlblRyZWF0UGFuZWwiLCJDbG9zZVBhbmVsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsVUFBVSxHQUFHRCxPQUFPLENBQUMsWUFBWSxDQUFDO0FBQ3RDLElBQUlFLFVBQVUsR0FBR0YsT0FBTyxDQUFDLFlBQVksQ0FBQztBQUN0QyxJQUFJRyxRQUFRLEdBQUdILE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFFbEMsSUFBSUksVUFBVSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN0QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxTQUFTLEVBQUNKLEVBQUUsQ0FBQ0ssV0FBVztJQUN4QkMsU0FBUyxFQUFDTixFQUFFLENBQUNPLE1BQU07SUFDbkJDLFFBQVEsRUFBQ2QsUUFBUTtJQUNqQmUsVUFBVSxFQUFDYixVQUFVO0lBQ3JCYyxRQUFRLEVBQUNaO0lBQ1Q7RUFDSixDQUFDOztFQUVEYSxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFVO0lBQ2hCO0VBQUEsQ0FDSDtFQUVEQyxZQUFZLEVBQUMsU0FBQUEsYUFBQSxFQUFZO0lBQ3JCWixFQUFFLENBQUNhLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJO0lBQ2hDLElBQUksQ0FBQ1IsVUFBVSxDQUFDTyxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0lBQ25DLElBQUksQ0FBQ1AsUUFBUSxDQUFDTSxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0lBQ2pDLElBQUksQ0FBQ1gsU0FBUyxDQUFDWSxXQUFXLEdBQUcsSUFBSSxDQUFDZCxTQUFTLENBQUNlLGNBQWMsQ0FBQyxPQUFPLENBQUM7SUFDbkU7RUFDSixDQUFDOztFQUVEQyxjQUFjLEVBQUMsU0FBQUEsZUFBQSxFQUFZO0lBQ3ZCcEIsRUFBRSxDQUFDYSxHQUFHLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJLENBQUNQLFFBQVEsQ0FBQ1EsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztJQUNqQyxJQUFJLENBQUNSLFVBQVUsQ0FBQ08sSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSTtJQUNsQyxJQUFJLENBQUNQLFFBQVEsQ0FBQ00sSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztJQUNqQztJQUNBLElBQUksQ0FBQ1gsU0FBUyxDQUFDWSxXQUFXLEdBQUcsSUFBSSxDQUFDZCxTQUFTLENBQUNlLGNBQWMsQ0FBQyxPQUFPLENBQUM7SUFDbkUsSUFBSSxDQUFDVixVQUFVLENBQUNFLFNBQVMsRUFBRTtFQUMvQixDQUFDO0VBRURVLFlBQVksRUFBQyxTQUFBQSxhQUFBLEVBQVk7SUFDckJyQixFQUFFLENBQUNhLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0lBQ2pDLElBQUksQ0FBQ1IsVUFBVSxDQUFDTyxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0lBQ25DLElBQUksQ0FBQ1AsUUFBUSxDQUFDTSxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJO0lBQ2hDO0lBQ0EsSUFBSSxDQUFDWCxTQUFTLENBQUNZLFdBQVcsR0FBRyxJQUFJLENBQUNkLFNBQVMsQ0FBQ2UsY0FBYyxDQUFDLFVBQVUsQ0FBQztJQUN0RSxJQUFJLENBQUNULFFBQVEsQ0FBQ0MsU0FBUyxFQUFFO0VBQzdCLENBQUM7RUFFRFcsY0FBYyxFQUFDLFNBQUFBLGVBQUEsRUFBWTtJQUN2QnRCLEVBQUUsQ0FBQ2EsR0FBRyxDQUFDQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDUCxRQUFRLENBQUNRLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7SUFDakMsSUFBSSxDQUFDUixVQUFVLENBQUNPLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7SUFDbkMsSUFBSSxDQUFDUCxRQUFRLENBQUNNLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7SUFDakM7RUFDSixDQUFDOztFQUVETSxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCdkIsRUFBRSxDQUFDYSxHQUFHLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7RUFDNUI7QUFFSixDQUFDLENBQUM7QUFDRk8sTUFBTSxDQUFDQyxPQUFPLEdBQUcxQixVQUFVIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSm95UGFuZWwgPSByZXF1aXJlKFwiSm95UGFuZWxcIik7XHJcbnZhciBIb3VzZVBhbmVsID0gcmVxdWlyZShcIkhvdXNlUGFuZWxcIik7XHJcbnZhciBUcmVhdFBhbmVsID0gcmVxdWlyZShcIlRyZWF0UGFuZWxcIik7XHJcbnZhciBDYXJQYW5lbCA9IHJlcXVpcmUoXCJDYXJQYW5lbFwiKTtcclxuXHJcbnZhciBFbmpveVBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBNYWluQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgVGlwTmFtZVNwOmNjLlNwcml0ZSxcclxuICAgICAgICBqb3lQYW5lbDpKb3lQYW5lbCxcclxuICAgICAgICBob3VzZVBhbmVsOkhvdXNlUGFuZWwsXHJcbiAgICAgICAgY2FyUGFuZWw6Q2FyUGFuZWwsXHJcbiAgICAgICAgLy90cmVhdFBhbmVsOlRyZWF0UGFuZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vdGhpcy5PcGVuSm95UGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgT3BlbkpveVBhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMuam95UGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaG91c2VQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FyUGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLlRpcE5hbWVTcC5zcHJpdGVGcmFtZSA9IHRoaXMuTWFpbkF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZnVubnlcIik7XHJcbiAgICAgICAgLy90aGlzLnRyZWF0UGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgT3BlbkhvdXNlUGFuZWw6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5qb3lQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaG91c2VQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYXJQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vdGhpcy50cmVhdFBhbmVsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5UaXBOYW1lU3Auc3ByaXRlRnJhbWUgPSB0aGlzLk1haW5BdGxhcy5nZXRTcHJpdGVGcmFtZShcImhvdXNlXCIpO1xyXG4gICAgICAgIHRoaXMuaG91c2VQYW5lbC5TaG93UGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgT3BlbkNhclBhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMuam95UGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhvdXNlUGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhclBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAvL3RoaXMudHJlYXRQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuVGlwTmFtZVNwLnNwcml0ZUZyYW1lID0gdGhpcy5NYWluQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJ0ZXh0X2NhclwiKTtcclxuICAgICAgICB0aGlzLmNhclBhbmVsLlNob3dQYW5lbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBPcGVuVHJlYXRQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLmpveVBhbmVsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ob3VzZVBhbmVsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYXJQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vdGhpcy50cmVhdFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEVuam95UGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CompanyItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9e61c2yr0NJ2abO1EeVmALW', 'CompanyItem');
// Scripts/UI/CompanyItem.js

"use strict";

var ItemType = require("ItemType");
var UserState = require("UserState");
var CompanyItem = cc.Class({
  "extends": cc.Component,
  properties: {
    Id: cc.Integer,
    stockNum: cc.Integer,
    LimitYear: cc.Integer,
    Atlas: cc.SpriteAtlas,
    IconSp: cc.Sprite,
    nameLbl: cc.Sprite,
    priceLbl: cc.Label,
    costLbl: cc.Label,
    numLbl: cc.Label,
    ratioLbl: cc.Label,
    InLockLbl: cc.Label,
    CreateBtn: cc.Node,
    BuySaleBtns: cc.Node,
    canGetProfit: false,
    bankRupt: false,
    //是否已经破产

    Data: null
  },
  init: function init(data) {
    this.Data = null;
    this.Data = data;
    this.bankRupt = false;
    this.LimitYear = data.LimitYear - 1; //限制交易年限
    this.stockNum = 0;
    this.ratioLbl.string = (data.bonusRatio * 100).toString() + "%";
    this.Id = data.Id;
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.nameLbl.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.costLbl.string = data.stockCost;
    this.priceLbl.string = data.stockPrice;
    this.numLbl.string = Math.floor(data.stockNum / 100);
  },
  refreshPrice: function refreshPrice() {
    var mapdata = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Company, this.Data.Id);
    var proList = mapdata.proList;
    var unList = mapdata.unList;
    var seed = Math.random();
    var stockPrice = this.Data.stockPrice;
    ////cc.log(seed + "   ++++++++++++++++++++++++++++++++++++++++++  " + proList[0].weight);

    if (this.bankRupt == true) {
      stockPrice = mapdata.inPrice;
      this.bankRupt = false;
      this.InLockLbl.node.active = false;
      this.CreateBtn.active = true;
      this.BuySaleBtns.active = false;
    } else {
      if (this.stockNum > 0)
        //只有股票 持有量大于0时才可用 计算该股票的 上涨概率加成
        {
          //cc.log("拥有这家公司时候 --刷第一个比例");
          seed += cc.Mgr.UserDataMgr.StockUpBonus / 100;
          if (seed < proList[0].weight)
            //跌
            {
              var iseed = Math.random() * (proList[0].upRatio - proList[0].lowRatio) + (1 - proList[0].upRatio);
              stockPrice = stockPrice - this.Data.stockPrice * iseed;
            } else
            //涨
            {
              var iseed = Math.random() * (proList[1].upRatio - proList[1].lowRatio) + (proList[1].lowRatio - 1);
              stockPrice = stockPrice + this.Data.stockPrice * iseed;
            }
        } else {
        //cc.log("没有这家公司时候 --刷第二个比例");
        if (seed < unList[0].weight)
          //跌
          {
            var iseed = Math.random() * (unList[0].upRatio - unList[0].lowRatio) + (1 - unList[0].upRatio);
            stockPrice = stockPrice - this.Data.stockPrice * iseed;
          } else
          //涨
          {
            var iseed = Math.random() * (unList[1].upRatio - unList[1].lowRatio) + (unList[1].lowRatio - 1);
            stockPrice = stockPrice + this.Data.stockPrice * iseed;
          }
      }
    }
    this.Data.stockPrice = Math.floor(stockPrice * 100) / 100;
    this.priceLbl.string = this.Data.stockPrice;
    this.costLbl.string = this.Data.stockCost;

    //有公司破产了
    if (this.Data.stockPrice <= this.Data.bankruptPrice) {
      this.bankRupt = true;
      this.InLockLbl.node.active = true;
      this.CreateBtn.active = false;
      this.BuySaleBtns.active = false;
      this.canGetProfit = false;
      cc.Mgr.UserDataMgr.CanGetStockProfit = false;
      this.InLockLbl.string = "该行业一片萧条";
      this.costLbl.string = "0";
      this.numLbl.string = "0";
      this.LimitYear = this.Data.LimitYear - 1;
      if (this.stockNum > 0) {
        if (cc.Mgr.UserDataMgr.BankruptAge == 0) {
          cc.Mgr.UserDataMgr.BankruptAge = cc.Mgr.UserDataMgr.Age;
        }
        cc.Mgr.UserDataMgr.Cash += Math.floor(this.Data.stockPrice * 0.5 * this.stockNum); //折半出售
        var param = {};
        param.Num = this.stockNum;
        param.price = this.stockPrice;
        param.Id = this.Data.Id;
        var reData = cc.Mgr.UserDataMgr.SaleStocks(param);
        this.stockNum = reData.stockNum;
        var param = {};
        param.forWhat = "";
        var comname = cc.Mgr.global.getTranslation("company_" + this.data.Id);
        param.text = "您创办的[" + "<color=#e77122>" + comname + "</c>" + "]由于经营不善,已破产处理,公司股票将折半价抛售";
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      }
    } else {
      this.bankRupt = false;
      if (this.stockNum > 0 && this.LimitYear > 0) {
        if (this.LimitYear > 0) {
          this.LimitYear -= 1;
          this.InLockLbl.string = "创业期" + this.LimitYear + "年";
        }
        this.canGetProfit = false;
      }
      if (this.stockNum <= 0 && this.LimitYear <= 0) {
        this.InLockLbl.node.active = false;
        this.BuySaleBtns.active = false;
        this.CreateBtn.active = true;
        this.canGetProfit = false;
      } else if (this.LimitYear <= 0 && this.stockNum > 0) {
        this.InLockLbl.node.active = false;
        this.BuySaleBtns.active = true;
        this.canGetProfit = true;
      }
      var param = {};
      param.stockCost = this.Data.stockCost;
      param.stockPrice = this.Data.stockPrice;
      cc.Mgr.UserDataMgr.RefreshStockData(this.Id, param);
    }
  },
  RefreshUIShowAfter: function RefreshUIShowAfter() {
    var num = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Company, this.Id).stockNum;
    this.numLbl.string = Math.floor(num / 100);
  },
  RefreshUIShow: function RefreshUIShow(data) {
    this.stockNum = data.stockNum;
    this.priceLbl.string = data.stockPrice.toString();
    this.costLbl.string = data.stockCost.toString();
    this.numLbl.string = Math.floor(data.stockNum / 100);
    if (data.stockNum > 0 && this.LimitYear <= 0) {
      this.InLockLbl.node.active = false;
      this.CreateBtn.active = false;
      this.BuySaleBtns.active = true;
      this.canGetProfit = true;
    } else if (data.stockNum > 0 && this.LimitYear > 0) {
      this.InLockLbl.node.active = true;
      this.CreateBtn.active = false;
      this.BuySaleBtns.active = false;
      this.canGetProfit = false;
      this.InLockLbl.string = "创业期" + this.LimitYear + "年";
    } else if (data.stockNum <= 0) {
      this.InLockLbl.node.active = false;
      this.CreateBtn.active = true;
      this.BuySaleBtns.active = false;
      this.canGetProfit = false;
      //出售完了 需要重新创办
      this.LimitYear = this.Data.LimitYear - 1;
    }
  },
  //创办公司
  OpenCompanyCreateTip: function OpenCompanyCreateTip() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.userState == UserState.NotOK) {
      var param = {};
      param.text = cc.Mgr.global.getTranslation("InHealDownLine");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    if (cc.Mgr.UserDataMgr.hasCompany == true) {
      var param = {};
      param.forWhat = "";
      param.text = "<color=#e77122>您已经创办一家公司</c>";
      //cc.log("===提醒下已经有一家公司在名下===");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCompanyCreate, this.Data);
  },
  //出售股票
  OpenStuckSaleTip: function OpenStuckSaleTip() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.userState == UserState.NotOK) {
      var param = {};
      param.text = cc.Mgr.global.getTranslation("InHealDownLine");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenStuckSaleTip, this.Data);
  },
  //购入股票
  OpenStuckBuyTip: function OpenStuckBuyTip() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.userState == UserState.NotOK) {
      var param = {};
      param.text = cc.Mgr.global.getTranslation("InHealDownLine");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenStuckBuyTip, this.Data);
  }
});
module.exports = CompanyItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENvbXBhbnlJdGVtLmpzIl0sIm5hbWVzIjpbIkl0ZW1UeXBlIiwicmVxdWlyZSIsIlVzZXJTdGF0ZSIsIkNvbXBhbnlJdGVtIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJJZCIsIkludGVnZXIiLCJzdG9ja051bSIsIkxpbWl0WWVhciIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJJY29uU3AiLCJTcHJpdGUiLCJuYW1lTGJsIiwicHJpY2VMYmwiLCJMYWJlbCIsImNvc3RMYmwiLCJudW1MYmwiLCJyYXRpb0xibCIsIkluTG9ja0xibCIsIkNyZWF0ZUJ0biIsIk5vZGUiLCJCdXlTYWxlQnRucyIsImNhbkdldFByb2ZpdCIsImJhbmtSdXB0IiwiRGF0YSIsImluaXQiLCJkYXRhIiwic3RyaW5nIiwiYm9udXNSYXRpbyIsInRvU3RyaW5nIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsImljb24iLCJuYW1lIiwic3RvY2tDb3N0Iiwic3RvY2tQcmljZSIsIk1hdGgiLCJmbG9vciIsInJlZnJlc2hQcmljZSIsIm1hcGRhdGEiLCJNZ3IiLCJNYXBEYXRhTWdyIiwiZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZCIsIkNvbXBhbnkiLCJwcm9MaXN0IiwidW5MaXN0Iiwic2VlZCIsInJhbmRvbSIsImluUHJpY2UiLCJub2RlIiwiYWN0aXZlIiwiVXNlckRhdGFNZ3IiLCJTdG9ja1VwQm9udXMiLCJ3ZWlnaHQiLCJpc2VlZCIsInVwUmF0aW8iLCJsb3dSYXRpbyIsImJhbmtydXB0UHJpY2UiLCJDYW5HZXRTdG9ja1Byb2ZpdCIsIkJhbmtydXB0QWdlIiwiQWdlIiwiQ2FzaCIsInBhcmFtIiwiTnVtIiwicHJpY2UiLCJyZURhdGEiLCJTYWxlU3RvY2tzIiwiZm9yV2hhdCIsImNvbW5hbWUiLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsInRleHQiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vblRpcCIsIlJlZnJlc2hTdG9ja0RhdGEiLCJSZWZyZXNoVUlTaG93QWZ0ZXIiLCJudW0iLCJSZWZyZXNoVUlTaG93IiwiT3BlbkNvbXBhbnlDcmVhdGVUaXAiLCJBdWRpb01nciIsInBsYXlTRlgiLCJ1c2VyU3RhdGUiLCJOb3RPSyIsImhhc0NvbXBhbnkiLCJPcGVuQ29tcGFueUNyZWF0ZSIsIk9wZW5TdHVja1NhbGVUaXAiLCJPcGVuU3R1Y2tCdXlUaXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxTQUFTLEdBQUdELE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDcEMsSUFBSUUsV0FBVyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN2QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxFQUFFLEVBQUNKLEVBQUUsQ0FBQ0ssT0FBTztJQUNiQyxRQUFRLEVBQUNOLEVBQUUsQ0FBQ0ssT0FBTztJQUNuQkUsU0FBUyxFQUFDUCxFQUFFLENBQUNLLE9BQU87SUFFcEJHLEtBQUssRUFBQ1IsRUFBRSxDQUFDUyxXQUFXO0lBQ3BCQyxNQUFNLEVBQUNWLEVBQUUsQ0FBQ1csTUFBTTtJQUNoQkMsT0FBTyxFQUFDWixFQUFFLENBQUNXLE1BQU07SUFDakJFLFFBQVEsRUFBQ2IsRUFBRSxDQUFDYyxLQUFLO0lBQ2pCQyxPQUFPLEVBQUNmLEVBQUUsQ0FBQ2MsS0FBSztJQUNoQkUsTUFBTSxFQUFDaEIsRUFBRSxDQUFDYyxLQUFLO0lBRWZHLFFBQVEsRUFBQ2pCLEVBQUUsQ0FBQ2MsS0FBSztJQUVqQkksU0FBUyxFQUFDbEIsRUFBRSxDQUFDYyxLQUFLO0lBQ2xCSyxTQUFTLEVBQUNuQixFQUFFLENBQUNvQixJQUFJO0lBQ2pCQyxXQUFXLEVBQUNyQixFQUFFLENBQUNvQixJQUFJO0lBRW5CRSxZQUFZLEVBQUMsS0FBSztJQUVsQkMsUUFBUSxFQUFDLEtBQUs7SUFBRTs7SUFFaEJDLElBQUksRUFBQztFQUNULENBQUM7RUFFREMsSUFBSSxFQUFDLFNBQUFBLEtBQVVDLElBQUksRUFBRTtJQUNqQixJQUFJLENBQUNGLElBQUksR0FBRyxJQUFJO0lBQ2hCLElBQUksQ0FBQ0EsSUFBSSxHQUFHRSxJQUFJO0lBQ2hCLElBQUksQ0FBQ0gsUUFBUSxHQUFHLEtBQUs7SUFDckIsSUFBSSxDQUFDaEIsU0FBUyxHQUFHbUIsSUFBSSxDQUFDbkIsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3JDLElBQUksQ0FBQ0QsUUFBUSxHQUFHLENBQUM7SUFDakIsSUFBSSxDQUFDVyxRQUFRLENBQUNVLE1BQU0sR0FBRyxDQUFDRCxJQUFJLENBQUNFLFVBQVUsR0FBRyxHQUFHLEVBQUVDLFFBQVEsRUFBRSxHQUFHLEdBQUc7SUFDL0QsSUFBSSxDQUFDekIsRUFBRSxHQUFHc0IsSUFBSSxDQUFDdEIsRUFBRTtJQUNqQixJQUFJLENBQUNNLE1BQU0sQ0FBQ29CLFdBQVcsR0FBRyxJQUFJLENBQUN0QixLQUFLLENBQUN1QixjQUFjLENBQUNMLElBQUksQ0FBQ00sSUFBSSxDQUFDO0lBQzlELElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ2tCLFdBQVcsR0FBRyxJQUFJLENBQUN0QixLQUFLLENBQUN1QixjQUFjLENBQUNMLElBQUksQ0FBQ08sSUFBSSxDQUFDO0lBQy9ELElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ1ksTUFBTSxHQUFHRCxJQUFJLENBQUNRLFNBQVM7SUFDcEMsSUFBSSxDQUFDckIsUUFBUSxDQUFDYyxNQUFNLEdBQUdELElBQUksQ0FBQ1MsVUFBVTtJQUN0QyxJQUFJLENBQUNuQixNQUFNLENBQUNXLE1BQU0sR0FBR1MsSUFBSSxDQUFDQyxLQUFLLENBQUNYLElBQUksQ0FBQ3BCLFFBQVEsR0FBRyxHQUFHLENBQUM7RUFDeEQsQ0FBQztFQUVEZ0MsWUFBWSxFQUFDLFNBQUFBLGFBQUEsRUFBVTtJQUNuQixJQUFJQyxPQUFPLEdBQUd2QyxFQUFFLENBQUN3QyxHQUFHLENBQUNDLFVBQVUsQ0FBQ0Msc0JBQXNCLENBQUM5QyxRQUFRLENBQUMrQyxPQUFPLEVBQUUsSUFBSSxDQUFDbkIsSUFBSSxDQUFDcEIsRUFBRSxDQUFDO0lBQ3RGLElBQUl3QyxPQUFPLEdBQUdMLE9BQU8sQ0FBQ0ssT0FBTztJQUM3QixJQUFJQyxNQUFNLEdBQUdOLE9BQU8sQ0FBQ00sTUFBTTtJQUMzQixJQUFJQyxJQUFJLEdBQUdWLElBQUksQ0FBQ1csTUFBTSxFQUFFO0lBQ3hCLElBQUlaLFVBQVUsR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ1csVUFBVTtJQUNyQzs7SUFFQSxJQUFHLElBQUksQ0FBQ1osUUFBUSxJQUFJLElBQUksRUFDeEI7TUFDSVksVUFBVSxHQUFHSSxPQUFPLENBQUNTLE9BQU87TUFDNUIsSUFBSSxDQUFDekIsUUFBUSxHQUFHLEtBQUs7TUFDckIsSUFBSSxDQUFDTCxTQUFTLENBQUMrQixJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO01BQ2xDLElBQUksQ0FBQy9CLFNBQVMsQ0FBQytCLE1BQU0sR0FBRyxJQUFJO01BQzVCLElBQUksQ0FBQzdCLFdBQVcsQ0FBQzZCLE1BQU0sR0FBRyxLQUFLO0lBQ25DLENBQUMsTUFFRDtNQUNJLElBQUcsSUFBSSxDQUFDNUMsUUFBUSxHQUFHLENBQUM7UUFBRTtRQUN0QjtVQUNJO1VBQ0F3QyxJQUFJLElBQUk5QyxFQUFFLENBQUN3QyxHQUFHLENBQUNXLFdBQVcsQ0FBQ0MsWUFBWSxHQUFHLEdBQUc7VUFFN0MsSUFBR04sSUFBSSxHQUFHRixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNTLE1BQU07WUFBRTtZQUM3QjtjQUNJLElBQUlDLEtBQUssR0FBR2xCLElBQUksQ0FBQ1csTUFBTSxFQUFFLElBQUlILE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQ1csT0FBTyxHQUFHWCxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNZLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBQ1osT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDVyxPQUFPLENBQUM7Y0FDL0ZwQixVQUFVLEdBQUdBLFVBQVUsR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ1csVUFBVSxHQUFHbUIsS0FBSztZQUMxRCxDQUFDO1lBQ0k7WUFDTDtjQUNJLElBQUlBLEtBQUssR0FBR2xCLElBQUksQ0FBQ1csTUFBTSxFQUFFLElBQUlILE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQ1csT0FBTyxHQUFHWCxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNZLFFBQVEsQ0FBQyxJQUFJWixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNZLFFBQVEsR0FBRyxDQUFDLENBQUM7Y0FDbEdyQixVQUFVLEdBQUdBLFVBQVUsR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ1csVUFBVSxHQUFHbUIsS0FBSztZQUMxRDtRQUNKLENBQUMsTUFFRDtRQUNLO1FBQ0QsSUFBR1IsSUFBSSxHQUFHRCxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUNRLE1BQU07VUFBRTtVQUM1QjtZQUNJLElBQUlDLEtBQUssR0FBR2xCLElBQUksQ0FBQ1csTUFBTSxFQUFFLElBQUlGLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ1UsT0FBTyxHQUFHVixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUNXLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBR1gsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDVSxPQUFPLENBQUM7WUFDOUZwQixVQUFVLEdBQUdBLFVBQVUsR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ1csVUFBVSxHQUFHbUIsS0FBSztVQUMxRCxDQUFDO1VBQ0k7VUFDTDtZQUNJLElBQUlBLEtBQUssR0FBR2xCLElBQUksQ0FBQ1csTUFBTSxFQUFFLElBQUlGLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ1UsT0FBTyxHQUFHVixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUNXLFFBQVEsQ0FBQyxJQUFJWCxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUNXLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDL0ZyQixVQUFVLEdBQUdBLFVBQVUsR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ1csVUFBVSxHQUFHbUIsS0FBSztVQUMxRDtNQUNKO0lBQ0o7SUFHQSxJQUFJLENBQUM5QixJQUFJLENBQUNXLFVBQVUsR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUNGLFVBQVUsR0FBRyxHQUFHLENBQUMsR0FBQyxHQUFHO0lBQ3ZELElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ2MsTUFBTSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDVyxVQUFVO0lBQzNDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ1ksTUFBTSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDVSxTQUFTOztJQUV6QztJQUNBLElBQUcsSUFBSSxDQUFDVixJQUFJLENBQUNXLFVBQVUsSUFBSSxJQUFJLENBQUNYLElBQUksQ0FBQ2lDLGFBQWEsRUFDbEQ7TUFDSSxJQUFJLENBQUNsQyxRQUFRLEdBQUcsSUFBSTtNQUNwQixJQUFJLENBQUNMLFNBQVMsQ0FBQytCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUk7TUFDakMsSUFBSSxDQUFDL0IsU0FBUyxDQUFDK0IsTUFBTSxHQUFHLEtBQUs7TUFDN0IsSUFBSSxDQUFDN0IsV0FBVyxDQUFDNkIsTUFBTSxHQUFHLEtBQUs7TUFDL0IsSUFBSSxDQUFDNUIsWUFBWSxHQUFHLEtBQUs7TUFDekJ0QixFQUFFLENBQUN3QyxHQUFHLENBQUNXLFdBQVcsQ0FBQ08saUJBQWlCLEdBQUcsS0FBSztNQUM1QyxJQUFJLENBQUN4QyxTQUFTLENBQUNTLE1BQU0sR0FBRyxTQUFTO01BQ2pDLElBQUksQ0FBQ1osT0FBTyxDQUFDWSxNQUFNLEdBQUcsR0FBRztNQUN6QixJQUFJLENBQUNYLE1BQU0sQ0FBQ1csTUFBTSxHQUFHLEdBQUc7TUFDeEIsSUFBSSxDQUFDcEIsU0FBUyxHQUFHLElBQUksQ0FBQ2lCLElBQUksQ0FBQ2pCLFNBQVMsR0FBRyxDQUFDO01BRXhDLElBQUcsSUFBSSxDQUFDRCxRQUFRLEdBQUcsQ0FBQyxFQUNwQjtRQUNJLElBQUdOLEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQ1csV0FBVyxDQUFDUSxXQUFXLElBQUksQ0FBQyxFQUN0QztVQUNJM0QsRUFBRSxDQUFDd0MsR0FBRyxDQUFDVyxXQUFXLENBQUNRLFdBQVcsR0FBRzNELEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQ1csV0FBVyxDQUFDUyxHQUFHO1FBQzNEO1FBQ0E1RCxFQUFFLENBQUN3QyxHQUFHLENBQUNXLFdBQVcsQ0FBQ1UsSUFBSSxJQUFJekIsSUFBSSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDYixJQUFJLENBQUNXLFVBQVUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDN0IsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNuRixJQUFJd0QsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNkQSxLQUFLLENBQUNDLEdBQUcsR0FBRyxJQUFJLENBQUN6RCxRQUFRO1FBQ3pCd0QsS0FBSyxDQUFDRSxLQUFLLEdBQUcsSUFBSSxDQUFDN0IsVUFBVTtRQUM3QjJCLEtBQUssQ0FBQzFELEVBQUUsR0FBRyxJQUFJLENBQUNvQixJQUFJLENBQUNwQixFQUFFO1FBQ3ZCLElBQUk2RCxNQUFNLEdBQUdqRSxFQUFFLENBQUN3QyxHQUFHLENBQUNXLFdBQVcsQ0FBQ2UsVUFBVSxDQUFDSixLQUFLLENBQUM7UUFDakQsSUFBSSxDQUFDeEQsUUFBUSxHQUFHMkQsTUFBTSxDQUFDM0QsUUFBUTtRQUMvQixJQUFJd0QsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNkQSxLQUFLLENBQUNLLE9BQU8sR0FBRyxFQUFFO1FBQ2xCLElBQUlDLE9BQU8sR0FBR3BFLEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQzZCLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDLFVBQVUsR0FBRSxJQUFJLENBQUM1QyxJQUFJLENBQUN0QixFQUFFLENBQUM7UUFDcEUwRCxLQUFLLENBQUNTLElBQUksR0FBRyxPQUFPLEdBQUMsaUJBQWlCLEdBQUNILE9BQU8sR0FBQyxNQUFNLEdBQUMsMEJBQTBCO1FBQ2hGcEUsRUFBRSxDQUFDd0UsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQzFFLEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQ21DLEtBQUssQ0FBQ0MsYUFBYSxFQUFHZCxLQUFLLENBQUM7TUFDcEU7SUFDSixDQUFDLE1BRUQ7TUFDSSxJQUFJLENBQUN2QyxRQUFRLEdBQUcsS0FBSztNQUNyQixJQUFHLElBQUksQ0FBQ2pCLFFBQVEsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxFQUMxQztRQUNJLElBQUcsSUFBSSxDQUFDQSxTQUFTLEdBQUcsQ0FBQyxFQUNyQjtVQUNJLElBQUksQ0FBQ0EsU0FBUyxJQUFJLENBQUM7VUFDbkIsSUFBSSxDQUFDVyxTQUFTLENBQUNTLE1BQU0sR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDcEIsU0FBUyxHQUFHLEdBQUc7UUFDeEQ7UUFDQSxJQUFJLENBQUNlLFlBQVksR0FBRyxLQUFLO01BQzdCO01BRUEsSUFBRyxJQUFJLENBQUNoQixRQUFRLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQ0MsU0FBUyxJQUFJLENBQUMsRUFDNUM7UUFDSSxJQUFJLENBQUNXLFNBQVMsQ0FBQytCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDbEMsSUFBSSxDQUFDN0IsV0FBVyxDQUFDNkIsTUFBTSxHQUFHLEtBQUs7UUFDL0IsSUFBSSxDQUFDL0IsU0FBUyxDQUFDK0IsTUFBTSxHQUFHLElBQUk7UUFDNUIsSUFBSSxDQUFDNUIsWUFBWSxHQUFHLEtBQUs7TUFDN0IsQ0FBQyxNQUNJLElBQUcsSUFBSSxDQUFDZixTQUFTLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQ0QsUUFBUSxHQUFHLENBQUMsRUFDaEQ7UUFDSSxJQUFJLENBQUNZLFNBQVMsQ0FBQytCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDbEMsSUFBSSxDQUFDN0IsV0FBVyxDQUFDNkIsTUFBTSxHQUFHLElBQUk7UUFDOUIsSUFBSSxDQUFDNUIsWUFBWSxHQUFHLElBQUk7TUFDNUI7TUFFQSxJQUFJd0MsS0FBSyxHQUFHLENBQUMsQ0FBQztNQUNkQSxLQUFLLENBQUM1QixTQUFTLEdBQUcsSUFBSSxDQUFDVixJQUFJLENBQUNVLFNBQVM7TUFDckM0QixLQUFLLENBQUMzQixVQUFVLEdBQUcsSUFBSSxDQUFDWCxJQUFJLENBQUNXLFVBQVU7TUFDdkNuQyxFQUFFLENBQUN3QyxHQUFHLENBQUNXLFdBQVcsQ0FBQzBCLGdCQUFnQixDQUFDLElBQUksQ0FBQ3pFLEVBQUUsRUFBRTBELEtBQUssQ0FBQztJQUN2RDtFQUNKLENBQUM7RUFFRGdCLGtCQUFrQixFQUFDLFNBQUFBLG1CQUFBLEVBQVU7SUFDekIsSUFBSUMsR0FBRyxHQUFHL0UsRUFBRSxDQUFDd0MsR0FBRyxDQUFDVyxXQUFXLENBQUNULHNCQUFzQixDQUFDOUMsUUFBUSxDQUFDK0MsT0FBTyxFQUFFLElBQUksQ0FBQ3ZDLEVBQUUsQ0FBQyxDQUFDRSxRQUFRO0lBQ3ZGLElBQUksQ0FBQ1UsTUFBTSxDQUFDVyxNQUFNLEdBQUdTLElBQUksQ0FBQ0MsS0FBSyxDQUFDMEMsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUM5QyxDQUFDO0VBRURDLGFBQWEsRUFBQyxTQUFBQSxjQUFTdEQsSUFBSSxFQUFDO0lBQ3hCLElBQUksQ0FBQ3BCLFFBQVEsR0FBR29CLElBQUksQ0FBQ3BCLFFBQVE7SUFFN0IsSUFBSSxDQUFDTyxRQUFRLENBQUNjLE1BQU0sR0FBR0QsSUFBSSxDQUFDUyxVQUFVLENBQUNOLFFBQVEsRUFBRTtJQUNqRCxJQUFJLENBQUNkLE9BQU8sQ0FBQ1ksTUFBTSxHQUFHRCxJQUFJLENBQUNRLFNBQVMsQ0FBQ0wsUUFBUSxFQUFFO0lBQy9DLElBQUksQ0FBQ2IsTUFBTSxDQUFDVyxNQUFNLEdBQUdTLElBQUksQ0FBQ0MsS0FBSyxDQUFDWCxJQUFJLENBQUNwQixRQUFRLEdBQUcsR0FBRyxDQUFDO0lBQ3BELElBQUdvQixJQUFJLENBQUNwQixRQUFRLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ0MsU0FBUyxJQUFJLENBQUMsRUFDM0M7TUFDSSxJQUFJLENBQUNXLFNBQVMsQ0FBQytCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7TUFDbEMsSUFBSSxDQUFDL0IsU0FBUyxDQUFDK0IsTUFBTSxHQUFHLEtBQUs7TUFDN0IsSUFBSSxDQUFDN0IsV0FBVyxDQUFDNkIsTUFBTSxHQUFHLElBQUk7TUFDOUIsSUFBSSxDQUFDNUIsWUFBWSxHQUFHLElBQUk7SUFDNUIsQ0FBQyxNQUNJLElBQUdJLElBQUksQ0FBQ3BCLFFBQVEsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxFQUMvQztNQUNJLElBQUksQ0FBQ1csU0FBUyxDQUFDK0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSTtNQUNqQyxJQUFJLENBQUMvQixTQUFTLENBQUMrQixNQUFNLEdBQUcsS0FBSztNQUM3QixJQUFJLENBQUM3QixXQUFXLENBQUM2QixNQUFNLEdBQUcsS0FBSztNQUMvQixJQUFJLENBQUM1QixZQUFZLEdBQUcsS0FBSztNQUN6QixJQUFJLENBQUNKLFNBQVMsQ0FBQ1MsTUFBTSxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUNwQixTQUFTLEdBQUcsR0FBRztJQUN4RCxDQUFDLE1BQ0ksSUFBR21CLElBQUksQ0FBQ3BCLFFBQVEsSUFBSSxDQUFDLEVBQzFCO01BQ0ksSUFBSSxDQUFDWSxTQUFTLENBQUMrQixJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO01BQ2xDLElBQUksQ0FBQy9CLFNBQVMsQ0FBQytCLE1BQU0sR0FBRyxJQUFJO01BQzVCLElBQUksQ0FBQzdCLFdBQVcsQ0FBQzZCLE1BQU0sR0FBRyxLQUFLO01BQy9CLElBQUksQ0FBQzVCLFlBQVksR0FBRyxLQUFLO01BQ3pCO01BQ0EsSUFBSSxDQUFDZixTQUFTLEdBQUcsSUFBSSxDQUFDaUIsSUFBSSxDQUFDakIsU0FBUyxHQUFHLENBQUM7SUFDNUM7RUFDSixDQUFDO0VBQ0Q7RUFDQTBFLG9CQUFvQixFQUFDLFNBQUFBLHFCQUFBLEVBQVU7SUFDM0JqRixFQUFFLENBQUN3QyxHQUFHLENBQUMwQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFFaEMsSUFBR25GLEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQ1csV0FBVyxDQUFDaUMsU0FBUyxJQUFJdEYsU0FBUyxDQUFDdUYsS0FBSyxFQUNsRDtNQUNJLElBQUl2QixLQUFLLEdBQUcsQ0FBQyxDQUFDO01BQ2RBLEtBQUssQ0FBQ1MsSUFBSSxHQUFHdkUsRUFBRSxDQUFDd0MsR0FBRyxDQUFDNkIsTUFBTSxDQUFDQyxjQUFjLENBQUMsZ0JBQWdCLENBQUM7TUFDM0R0RSxFQUFFLENBQUN3RSxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDMUUsRUFBRSxDQUFDd0MsR0FBRyxDQUFDbUMsS0FBSyxDQUFDQyxhQUFhLEVBQUVkLEtBQUssQ0FBQztNQUMvRDtJQUNKO0lBRUEsSUFBRzlELEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQ1csV0FBVyxDQUFDbUMsVUFBVSxJQUFJLElBQUksRUFDeEM7TUFDSSxJQUFJeEIsS0FBSyxHQUFHLENBQUMsQ0FBQztNQUNkQSxLQUFLLENBQUNLLE9BQU8sR0FBRyxFQUFFO01BQ2xCTCxLQUFLLENBQUNTLElBQUksR0FBRyw4QkFBOEI7TUFDM0M7TUFDQXZFLEVBQUUsQ0FBQ3dFLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUMxRSxFQUFFLENBQUN3QyxHQUFHLENBQUNtQyxLQUFLLENBQUNDLGFBQWEsRUFBRWQsS0FBSyxDQUFDO01BQy9EO0lBQ0o7SUFDQTlELEVBQUUsQ0FBQ3dFLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUMxRSxFQUFFLENBQUN3QyxHQUFHLENBQUNtQyxLQUFLLENBQUNZLGlCQUFpQixFQUFFLElBQUksQ0FBQy9ELElBQUksQ0FBQztFQUMzRSxDQUFDO0VBQ0Q7RUFDQWdFLGdCQUFnQixFQUFDLFNBQUFBLGlCQUFBLEVBQVU7SUFDdkJ4RixFQUFFLENBQUN3QyxHQUFHLENBQUMwQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFFaEMsSUFBR25GLEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQ1csV0FBVyxDQUFDaUMsU0FBUyxJQUFJdEYsU0FBUyxDQUFDdUYsS0FBSyxFQUNsRDtNQUNJLElBQUl2QixLQUFLLEdBQUcsQ0FBQyxDQUFDO01BQ2RBLEtBQUssQ0FBQ1MsSUFBSSxHQUFHdkUsRUFBRSxDQUFDd0MsR0FBRyxDQUFDNkIsTUFBTSxDQUFDQyxjQUFjLENBQUMsZ0JBQWdCLENBQUM7TUFDM0R0RSxFQUFFLENBQUN3RSxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDMUUsRUFBRSxDQUFDd0MsR0FBRyxDQUFDbUMsS0FBSyxDQUFDQyxhQUFhLEVBQUVkLEtBQUssQ0FBQztNQUMvRDtJQUNKO0lBRUE5RCxFQUFFLENBQUN3RSxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDMUUsRUFBRSxDQUFDd0MsR0FBRyxDQUFDbUMsS0FBSyxDQUFDYSxnQkFBZ0IsRUFBRSxJQUFJLENBQUNoRSxJQUFJLENBQUM7RUFDMUUsQ0FBQztFQUNEO0VBQ0FpRSxlQUFlLEVBQUMsU0FBQUEsZ0JBQUEsRUFBVTtJQUN0QnpGLEVBQUUsQ0FBQ3dDLEdBQUcsQ0FBQzBDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUVoQyxJQUFHbkYsRUFBRSxDQUFDd0MsR0FBRyxDQUFDVyxXQUFXLENBQUNpQyxTQUFTLElBQUl0RixTQUFTLENBQUN1RixLQUFLLEVBQ2xEO01BQ0ksSUFBSXZCLEtBQUssR0FBRyxDQUFDLENBQUM7TUFDZEEsS0FBSyxDQUFDUyxJQUFJLEdBQUd2RSxFQUFFLENBQUN3QyxHQUFHLENBQUM2QixNQUFNLENBQUNDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQztNQUMzRHRFLEVBQUUsQ0FBQ3dFLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUMxRSxFQUFFLENBQUN3QyxHQUFHLENBQUNtQyxLQUFLLENBQUNDLGFBQWEsRUFBRWQsS0FBSyxDQUFDO01BQy9EO0lBQ0o7SUFFQTlELEVBQUUsQ0FBQ3dFLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUMxRSxFQUFFLENBQUN3QyxHQUFHLENBQUNtQyxLQUFLLENBQUNjLGVBQWUsRUFBRSxJQUFJLENBQUNqRSxJQUFJLENBQUM7RUFDekU7QUFFSixDQUFDLENBQUM7QUFDRmtFLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHNUYsV0FBVyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgVXNlclN0YXRlID0gcmVxdWlyZShcIlVzZXJTdGF0ZVwiKTtcclxudmFyIENvbXBhbnlJdGVtID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIHN0b2NrTnVtOmNjLkludGVnZXIsXHJcbiAgICAgICAgTGltaXRZZWFyOmNjLkludGVnZXIsXHJcblxyXG4gICAgICAgIEF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIEljb25TcDpjYy5TcHJpdGUsXHJcbiAgICAgICAgbmFtZUxibDpjYy5TcHJpdGUsXHJcbiAgICAgICAgcHJpY2VMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgY29zdExibDpjYy5MYWJlbCxcclxuICAgICAgICBudW1MYmw6Y2MuTGFiZWwsXHJcblxyXG4gICAgICAgIHJhdGlvTGJsOmNjLkxhYmVsLFxyXG5cclxuICAgICAgICBJbkxvY2tMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgQ3JlYXRlQnRuOmNjLk5vZGUsXHJcbiAgICAgICAgQnV5U2FsZUJ0bnM6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgY2FuR2V0UHJvZml0OmZhbHNlLFxyXG5cclxuICAgICAgICBiYW5rUnVwdDpmYWxzZSwgLy/mmK/lkKblt7Lnu4/noLTkuqdcclxuXHJcbiAgICAgICAgRGF0YTpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OmZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5EYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuYmFua1J1cHQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLkxpbWl0WWVhciA9IGRhdGEuTGltaXRZZWFyIC0gMTsgLy/pmZDliLbkuqTmmJPlubTpmZBcclxuICAgICAgICB0aGlzLnN0b2NrTnVtID0gMDtcclxuICAgICAgICB0aGlzLnJhdGlvTGJsLnN0cmluZyA9IChkYXRhLmJvbnVzUmF0aW8gKiAxMDApLnRvU3RyaW5nKCkgKyBcIiVcIjtcclxuICAgICAgICB0aGlzLklkID0gZGF0YS5JZDtcclxuICAgICAgICB0aGlzLkljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICB0aGlzLm5hbWVMYmwuc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEubmFtZSk7XHJcbiAgICAgICAgdGhpcy5jb3N0TGJsLnN0cmluZyA9IGRhdGEuc3RvY2tDb3N0O1xyXG4gICAgICAgIHRoaXMucHJpY2VMYmwuc3RyaW5nID0gZGF0YS5zdG9ja1ByaWNlO1xyXG4gICAgICAgIHRoaXMubnVtTGJsLnN0cmluZyA9IE1hdGguZmxvb3IoZGF0YS5zdG9ja051bSAvIDEwMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlZnJlc2hQcmljZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBtYXBkYXRhID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5Db21wYW55LCB0aGlzLkRhdGEuSWQpO1xyXG4gICAgICAgIHZhciBwcm9MaXN0ID0gbWFwZGF0YS5wcm9MaXN0O1xyXG4gICAgICAgIHZhciB1bkxpc3QgPSBtYXBkYXRhLnVuTGlzdDtcclxuICAgICAgICB2YXIgc2VlZCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgdmFyIHN0b2NrUHJpY2UgPSB0aGlzLkRhdGEuc3RvY2tQcmljZTtcclxuICAgICAgICAvLy8vY2MubG9nKHNlZWQgKyBcIiAgICsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyAgXCIgKyBwcm9MaXN0WzBdLndlaWdodCk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuYmFua1J1cHQgPT0gdHJ1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0b2NrUHJpY2UgPSBtYXBkYXRhLmluUHJpY2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmFua1J1cHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5JbkxvY2tMYmwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5DcmVhdGVCdG4uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5CdXlTYWxlQnRucy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zdG9ja051bSA+IDApIC8v5Y+q5pyJ6IKh56WoIOaMgeaciemHj+Wkp+S6jjDml7bmiY3lj6/nlKgg6K6h566X6K+l6IKh56Wo55qEIOS4iua2qOamgueOh+WKoOaIkFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIuaLpeaciei/meWutuWFrOWPuOaXtuWAmSAtLeWIt+esrOS4gOS4quavlOS+i1wiKTtcclxuICAgICAgICAgICAgICAgIHNlZWQgKz0gY2MuTWdyLlVzZXJEYXRhTWdyLlN0b2NrVXBCb251cyAvIDEwMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzZWVkIDwgcHJvTGlzdFswXS53ZWlnaHQpIC8v6LeMXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzZWVkID0gTWF0aC5yYW5kb20oKSAqIChwcm9MaXN0WzBdLnVwUmF0aW8gLSBwcm9MaXN0WzBdLmxvd1JhdGlvKSArICgxLXByb0xpc3RbMF0udXBSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvY2tQcmljZSA9IHN0b2NrUHJpY2UgLSB0aGlzLkRhdGEuc3RvY2tQcmljZSAqIGlzZWVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSAvL+a2qFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc2VlZCA9IE1hdGgucmFuZG9tKCkgKiAocHJvTGlzdFsxXS51cFJhdGlvIC0gcHJvTGlzdFsxXS5sb3dSYXRpbykgKyAocHJvTGlzdFsxXS5sb3dSYXRpbyAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b2NrUHJpY2UgPSBzdG9ja1ByaWNlICsgdGhpcy5EYXRhLnN0b2NrUHJpY2UgKiBpc2VlZDtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgLy9jYy5sb2coXCLmsqHmnInov5nlrrblhazlj7jml7blgJkgLS3liLfnrKzkuozkuKrmr5TkvotcIik7XHJcbiAgICAgICAgICAgICAgICBpZihzZWVkIDwgdW5MaXN0WzBdLndlaWdodCkgLy/ot4xcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNlZWQgPSBNYXRoLnJhbmRvbSgpICogKHVuTGlzdFswXS51cFJhdGlvIC0gdW5MaXN0WzBdLmxvd1JhdGlvKSArICgxIC0gdW5MaXN0WzBdLnVwUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b2NrUHJpY2UgPSBzdG9ja1ByaWNlIC0gdGhpcy5EYXRhLnN0b2NrUHJpY2UgKiBpc2VlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgLy/mtqhcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNlZWQgPSBNYXRoLnJhbmRvbSgpICogKHVuTGlzdFsxXS51cFJhdGlvIC0gdW5MaXN0WzFdLmxvd1JhdGlvKSArICh1bkxpc3RbMV0ubG93UmF0aW8gLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBzdG9ja1ByaWNlID0gc3RvY2tQcmljZSArIHRoaXMuRGF0YS5zdG9ja1ByaWNlICogaXNlZWQ7XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLkRhdGEuc3RvY2tQcmljZSA9IE1hdGguZmxvb3Ioc3RvY2tQcmljZSAqIDEwMCkvMTAwO1xyXG4gICAgICAgIHRoaXMucHJpY2VMYmwuc3RyaW5nID0gdGhpcy5EYXRhLnN0b2NrUHJpY2U7XHJcbiAgICAgICAgdGhpcy5jb3N0TGJsLnN0cmluZyA9IHRoaXMuRGF0YS5zdG9ja0Nvc3Q7XHJcblxyXG4gICAgICAgIC8v5pyJ5YWs5Y+456C05Lqn5LqGXHJcbiAgICAgICAgaWYodGhpcy5EYXRhLnN0b2NrUHJpY2UgPD0gdGhpcy5EYXRhLmJhbmtydXB0UHJpY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJhbmtSdXB0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5JbkxvY2tMYmwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUJ0bi5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5CdXlTYWxlQnRucy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jYW5HZXRQcm9maXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhbkdldFN0b2NrUHJvZml0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuSW5Mb2NrTGJsLnN0cmluZyA9IFwi6K+l6KGM5Lia5LiA54mH6JCn5p2hXCI7XHJcbiAgICAgICAgICAgIHRoaXMuY29zdExibC5zdHJpbmcgPSBcIjBcIjtcclxuICAgICAgICAgICAgdGhpcy5udW1MYmwuc3RyaW5nID0gXCIwXCI7XHJcbiAgICAgICAgICAgIHRoaXMuTGltaXRZZWFyID0gdGhpcy5EYXRhLkxpbWl0WWVhciAtIDE7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnN0b2NrTnVtID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkJhbmtydXB0QWdlID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkJhbmtydXB0QWdlID0gY2MuTWdyLlVzZXJEYXRhTWdyLkFnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoICs9IE1hdGguZmxvb3IodGhpcy5EYXRhLnN0b2NrUHJpY2UgKiAwLjUgKiB0aGlzLnN0b2NrTnVtKTsgLy/mipjljYrlh7rllK5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW0uTnVtID0gdGhpcy5zdG9ja051bTtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5zdG9ja1ByaWNlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW0uSWQgPSB0aGlzLkRhdGEuSWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVEYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLlNhbGVTdG9ja3MocGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9ja051bSA9IHJlRGF0YS5zdG9ja051bTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tbmFtZSA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJjb21wYW55X1wiICt0aGlzLmRhdGEuSWQpO1xyXG4gICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5oKo5Yib5Yqe55qEW1wiK1wiPGNvbG9yPSNlNzcxMjI+XCIrY29tbmFtZStcIjwvYz5cIitcIl3nlLHkuo7nu4/okKXkuI3lloQs5bey56C05Lqn5aSE55CGLOWFrOWPuOiCoeelqOWwhuaKmOWNiuS7t+aKm+WUrlwiO1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCAsIHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJhbmtSdXB0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RvY2tOdW0gPiAwICYmIHRoaXMuTGltaXRZZWFyID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5MaW1pdFllYXIgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuTGltaXRZZWFyIC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5JbkxvY2tMYmwuc3RyaW5nID0gXCLliJvkuJrmnJ9cIiArIHRoaXMuTGltaXRZZWFyICsgXCLlubRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuR2V0UHJvZml0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RvY2tOdW0gPD0gMCAmJiB0aGlzLkxpbWl0WWVhciA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkluTG9ja0xibC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5CdXlTYWxlQnRucy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuQ3JlYXRlQnRuLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbkdldFByb2ZpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5MaW1pdFllYXIgPD0gMCAmJiB0aGlzLnN0b2NrTnVtID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5JbkxvY2tMYmwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuQnV5U2FsZUJ0bnMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuR2V0UHJvZml0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLnN0b2NrQ29zdCA9IHRoaXMuRGF0YS5zdG9ja0Nvc3Q7XHJcbiAgICAgICAgICAgIHBhcmFtLnN0b2NrUHJpY2UgPSB0aGlzLkRhdGEuc3RvY2tQcmljZTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hTdG9ja0RhdGEodGhpcy5JZCwgcGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaFVJU2hvd0FmdGVyOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG51bSA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNvbXBhbnksIHRoaXMuSWQpLnN0b2NrTnVtO1xyXG4gICAgICAgIHRoaXMubnVtTGJsLnN0cmluZyA9IE1hdGguZmxvb3IobnVtIC8gMTAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaFVJU2hvdzpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLnN0b2NrTnVtID0gZGF0YS5zdG9ja051bTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmljZUxibC5zdHJpbmcgPSBkYXRhLnN0b2NrUHJpY2UudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNvc3RMYmwuc3RyaW5nID0gZGF0YS5zdG9ja0Nvc3QudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLm51bUxibC5zdHJpbmcgPSBNYXRoLmZsb29yKGRhdGEuc3RvY2tOdW0gLyAxMDApO1xyXG4gICAgICAgIGlmKGRhdGEuc3RvY2tOdW0gPiAwICYmIHRoaXMuTGltaXRZZWFyIDw9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkluTG9ja0xibC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUJ0bi5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5CdXlTYWxlQnRucy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNhbkdldFByb2ZpdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZGF0YS5zdG9ja051bSA+IDAgJiYgdGhpcy5MaW1pdFllYXIgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5JbkxvY2tMYmwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUJ0bi5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5CdXlTYWxlQnRucy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jYW5HZXRQcm9maXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5JbkxvY2tMYmwuc3RyaW5nID0gXCLliJvkuJrmnJ9cIiArIHRoaXMuTGltaXRZZWFyICsgXCLlubRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihkYXRhLnN0b2NrTnVtIDw9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkluTG9ja0xibC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUJ0bi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkJ1eVNhbGVCdG5zLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNhbkdldFByb2ZpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL+WHuuWUruWujOS6hiDpnIDopoHph43mlrDliJvlip5cclxuICAgICAgICAgICAgdGhpcy5MaW1pdFllYXIgPSB0aGlzLkRhdGEuTGltaXRZZWFyIC0gMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy/liJvlip7lhazlj7hcclxuICAgIE9wZW5Db21wYW55Q3JlYXRlVGlwOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLnVzZXJTdGF0ZSA9PSBVc2VyU3RhdGUuTm90T0spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJJbkhlYWxEb3duTGluZVwiKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuaGFzQ29tcGFueSA9PSB0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIlwiO1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCI8Y29sb3I9I2U3NzEyMj7mgqjlt7Lnu4/liJvlip7kuIDlrrblhazlj7g8L2M+XCI7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwiPT095o+Q6YaS5LiL5bey57uP5pyJ5LiA5a625YWs5Y+45Zyo5ZCN5LiLPT09XCIpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbXBhbnlDcmVhdGUsIHRoaXMuRGF0YSk7XHJcbiAgICB9LFxyXG4gICAgLy/lh7rllK7ogqHnpahcclxuICAgIE9wZW5TdHVja1NhbGVUaXA6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG5cclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IudXNlclN0YXRlID09IFVzZXJTdGF0ZS5Ob3RPSylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIkluSGVhbERvd25MaW5lXCIpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5TdHVja1NhbGVUaXAsIHRoaXMuRGF0YSk7XHJcbiAgICB9LFxyXG4gICAgLy/otK3lhaXogqHnpahcclxuICAgIE9wZW5TdHVja0J1eVRpcDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcblxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci51c2VyU3RhdGUgPT0gVXNlclN0YXRlLk5vdE9LKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiSW5IZWFsRG93bkxpbmVcIik7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlblN0dWNrQnV5VGlwLCB0aGlzLkRhdGEpO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhbnlJdGVtO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/CompanyBuyTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd4cf1ZNYClHfZlhOyWm3IZa', 'CompanyBuyTipPanel');
// Scripts/UI/CompanyBuyTipPanel.js

"use strict";

var CompanyBuyTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    IconSp: cc.Sprite,
    TitleName: cc.Sprite,
    BuyNumLbl: cc.Label,
    DesLbl: cc.Label,
    Slider: cc.Slider,
    InPutBox: cc.EditBox,
    Progress: cc.ProgressBar,
    BuyNum: 0,
    Data: null
  },
  ShowPanel: function ShowPanel(data) {
    this.Data = data;
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.TitleName.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.BuyNum = Math.floor(cc.Mgr.UserDataMgr.Cash / (this.Data.stockPrice * 100));
    var money = Math.floor(this.BuyNum * 100 * this.Data.stockPrice);
    this.DesLbl.string = cc.Mgr.global.FormatNum(money);
    this.BuyNumLbl.string = this.BuyNum;
    this.InPutBox.string = this.BuyNum;
    this.Slider.progress = 1;
    this.Progress.progress = 1;
  },
  ClickBuyBtn: function ClickBuyBtn() {
    if (this.BuyNum <= 0) {
      cc.Mgr.AudioMgr.playSFX("click");
      return;
    }
    cc.Mgr.UserDataMgr.Cash -= Math.floor(this.Data.stockPrice * (this.BuyNum * 100));
    var param = {};
    param.Num = this.BuyNum * 100;
    param.price = this.Data.stockPrice;
    param.Id = this.Data.Id;
    var data = cc.Mgr.UserDataMgr.BuyStocks(param);
    //通知刷新现金
    cc.director.GlobalEvent.emit(cc.Mgr.Event.BuyStockSuccess, data);
    this.ClosePanel();
  },
  OnSliderChange: function OnSliderChange() {
    this.BuyNum = Math.floor(this.Slider.progress * cc.Mgr.UserDataMgr.Cash / (this.Data.stockPrice * 100));
    this.Progress.progress = this.Slider.progress;
    this.DesLbl.string = cc.Mgr.global.FormatNum(Math.floor(this.BuyNum * this.Data.stockPrice * 100));
    this.BuyNumLbl.string = this.BuyNum;
    this.InPutBox.string = this.BuyNum;
  },
  OnInputBoxEnd: function OnInputBoxEnd() {
    var MaxNum = Math.floor(cc.Mgr.UserDataMgr.Cash / (this.Data.stockPrice * 100));
    if (this.InPutBox.string != "") {
      if (Number(this.InPutBox.string) != null) {
        if (Number(this.InPutBox.string) > MaxNum) {
          this.InPutBox.string = MaxNum;
          this.BuyNum = MaxNum;
          this.Progress.progress = 1;
          this.Slider.progress = 1;
        } else {
          this.BuyNum = Number(this.InPutBox.string);
          this.Slider.progress = this.BuyNum / MaxNum;
          this.Progress.progress = this.Slider.progress;
        }
      }
    } else {
      this.InPutBox.string = "0";
      this.BuyNum = 0;
      this.Progress.progress = 0;
      this.Slider.progress = 0;
    }
    this.DesLbl.string = cc.Mgr.global.FormatNum(Math.floor(this.BuyNum * this.Data.stockPrice * 100));
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = CompanyBuyTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXENvbXBhbnlCdXlUaXBQYW5lbC5qcyJdLCJuYW1lcyI6WyJDb21wYW55QnV5VGlwUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJJY29uU3AiLCJTcHJpdGUiLCJUaXRsZU5hbWUiLCJCdXlOdW1MYmwiLCJMYWJlbCIsIkRlc0xibCIsIlNsaWRlciIsIkluUHV0Qm94IiwiRWRpdEJveCIsIlByb2dyZXNzIiwiUHJvZ3Jlc3NCYXIiLCJCdXlOdW0iLCJEYXRhIiwiU2hvd1BhbmVsIiwiZGF0YSIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJpY29uIiwibmFtZSIsIk1hdGgiLCJmbG9vciIsIk1nciIsIlVzZXJEYXRhTWdyIiwiQ2FzaCIsInN0b2NrUHJpY2UiLCJtb25leSIsInN0cmluZyIsImdsb2JhbCIsIkZvcm1hdE51bSIsInByb2dyZXNzIiwiQ2xpY2tCdXlCdG4iLCJBdWRpb01nciIsInBsYXlTRlgiLCJwYXJhbSIsIk51bSIsInByaWNlIiwiSWQiLCJCdXlTdG9ja3MiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiQnV5U3RvY2tTdWNjZXNzIiwiQ2xvc2VQYW5lbCIsIk9uU2xpZGVyQ2hhbmdlIiwiT25JbnB1dEJveEVuZCIsIk1heE51bSIsIk51bWJlciIsIm5vZGUiLCJhY3RpdmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLGtCQUFrQixHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUM5QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxLQUFLLEVBQUNKLEVBQUUsQ0FBQ0ssV0FBVztJQUNwQkMsTUFBTSxFQUFDTixFQUFFLENBQUNPLE1BQU07SUFDaEJDLFNBQVMsRUFBQ1IsRUFBRSxD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LENBQUNnQixJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0VBQzVCO0FBRUosQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHMUQsa0JBQWtCIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIENvbXBhbnlCdXlUaXBQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgSWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBUaXRsZU5hbWU6Y2MuU3ByaXRlLFxyXG4gICAgICAgIEJ1eU51bUxibDpjYy5MYWJlbCxcclxuICAgICAgICBEZXNMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgU2xpZGVyOmNjLlNsaWRlcixcclxuICAgICAgICBJblB1dEJveDpjYy5FZGl0Qm94LFxyXG4gICAgICAgIFByb2dyZXNzOmNjLlByb2dyZXNzQmFyLFxyXG4gICAgICAgIEJ1eU51bTowLFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBcdHRoaXMuRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5JY29uU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgdGhpcy5UaXRsZU5hbWUuc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEubmFtZSk7XHJcbiAgICAgICAgdGhpcy5CdXlOdW0gPSBNYXRoLmZsb29yKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIC8gKHRoaXMuRGF0YS5zdG9ja1ByaWNlICogMTAwKSk7XHJcbiAgICAgICAgdmFyIG1vbmV5ID0gTWF0aC5mbG9vcih0aGlzLkJ1eU51bSAqIDEwMCAqIHRoaXMuRGF0YS5zdG9ja1ByaWNlKTtcclxuICAgICAgICB0aGlzLkRlc0xibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShtb25leSk7XHJcbiAgICAgICAgdGhpcy5CdXlOdW1MYmwuc3RyaW5nID0gdGhpcy5CdXlOdW07XHJcbiAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSB0aGlzLkJ1eU51bTtcclxuICAgICAgICB0aGlzLlNsaWRlci5wcm9ncmVzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IDE7XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrQnV5QnRuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5CdXlOdW0gPD0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggLT0gTWF0aC5mbG9vcih0aGlzLkRhdGEuc3RvY2tQcmljZSAqICh0aGlzLkJ1eU51bSAqIDEwMCkpO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLk51bSA9IHRoaXMuQnV5TnVtICogMTAwO1xyXG4gICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5EYXRhLnN0b2NrUHJpY2U7XHJcbiAgICAgICAgcGFyYW0uSWQgPSB0aGlzLkRhdGEuSWQ7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQnV5U3RvY2tzKHBhcmFtKTtcclxuICAgICAgICAvL+mAmuefpeWIt+aWsOeOsOmHkVxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LkJ1eVN0b2NrU3VjY2VzcywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIE9uU2xpZGVyQ2hhbmdlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5CdXlOdW0gPSBNYXRoLmZsb29yKHRoaXMuU2xpZGVyLnByb2dyZXNzICogY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggLyAodGhpcy5EYXRhLnN0b2NrUHJpY2UgKiAxMDApKTtcclxuICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gdGhpcy5TbGlkZXIucHJvZ3Jlc3M7XHJcbiAgICAgICAgdGhpcy5EZXNMYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0oTWF0aC5mbG9vcih0aGlzLkJ1eU51bSAqIHRoaXMuRGF0YS5zdG9ja1ByaWNlICogMTAwKSk7XHJcbiAgICAgICAgdGhpcy5CdXlOdW1MYmwuc3RyaW5nID0gdGhpcy5CdXlOdW07XHJcbiAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSB0aGlzLkJ1eU51bTtcclxuICAgIH0sXHJcblxyXG4gICAgT25JbnB1dEJveEVuZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBNYXhOdW0gPSBNYXRoLmZsb29yKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIC8gKHRoaXMuRGF0YS5zdG9ja1ByaWNlICogMTAwKSk7XHJcbiAgICAgICAgaWYodGhpcy5JblB1dEJveC5zdHJpbmcgIT0gXCJcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKE51bWJlcih0aGlzLkluUHV0Qm94LnN0cmluZykgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoTnVtYmVyKHRoaXMuSW5QdXRCb3guc3RyaW5nKSA+IE1heE51bSkgXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSBNYXhOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5CdXlOdW0gPSBNYXhOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQnV5TnVtID0gTnVtYmVyKHRoaXMuSW5QdXRCb3guc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlNsaWRlci5wcm9ncmVzcyA9ICB0aGlzLkJ1eU51bSAvIE1heE51bTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gdGhpcy5TbGlkZXIucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSBcIjBcIjtcclxuICAgICAgICAgICAgdGhpcy5CdXlOdW0gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLkRlc0xibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShNYXRoLmZsb29yKHRoaXMuQnV5TnVtICogdGhpcy5EYXRhLnN0b2NrUHJpY2UgKiAxMDApKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuICAgXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhbnlCdXlUaXBQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/GoodsItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2a11a6P8iFNOZlvuPpRuIxV', 'GoodsItem');
// Scripts/UI/GoodsItem.js

"use strict";

var Event = require("Event");
var UserState = require("UserState");
var GoodsItem = cc.Class({
  "extends": cc.Component,
  properties: {
    //UI
    Atlas: cc.SpriteAtlas,
    IconSp: cc.Sprite,
    NameLbl: cc.Sprite,
    PriceLbl: cc.Label,
    State: 1,
    //状态
    //Data
    Id: cc.Integer,
    price: cc.Integer,
    Data: null
  },
  init: function init(data) {
    this.Data = data;
    this.Id = data.Id;
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.NameLbl.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.priceId = 0; //所在的价格区间
    this.refreshPrice();
  },
  refreshLowPrice: function refreshLowPrice() {
    var priceList = this.Data.priceList;
    var price = priceList[0].lowprice;
    this.priceId = 0;
    var d = Math.random();
    price = priceList[0].lowprice + d * (priceList[0].highprice - priceList[0].lowprice);
    this.price = Math.floor(price);
    this.Data.price = this.price;
    cc.Mgr.UserDataMgr.RefreshGoodsMarKetPrice(this.Id, this.price);
    this.PriceLbl.string = this.price.toString();
    var param = {};
    this.State = 0;
    param.State = 0; //-2表示暴跌 -1表示跌了  0 表示稳定  1有所增长 2表示暴涨
    param.Id = this.Id;
    param.icon = this.Data.icon;
    param.name = this.Data.name;
    param.price = this.price;
    return param;
  },
  refreshMidPrice: function refreshMidPrice() {
    var priceList = this.Data.priceList;
    var price = priceList[0].lowprice;
    this.priceId = 1;
    var d = Math.random();
    price = priceList[1].lowprice + d * (priceList[1].highprice - priceList[1].lowprice);
    this.price = Math.floor(price);
    this.Data.price = this.price;
    cc.Mgr.UserDataMgr.RefreshGoodsMarKetPrice(this.Id, this.price);
    this.PriceLbl.string = this.price.toString();
    var param = {};
    this.State = 1;
    param.State = 1; //-2表示暴跌 -1表示跌了  0 表示稳定  1有所增长 2表示暴涨
    param.Id = this.Id;
    param.icon = this.Data.icon;
    param.name = this.Data.name;
    param.price = this.price;
    return param;
  },
  refreshUpPrice: function refreshUpPrice() {
    var priceList = this.Data.priceList;
    var price = priceList[0].lowprice;
    /*
    var seed = 0.99999;
    if(seed < priceList[0].probability)
    {
        change = 0; //-this.priceId;
        this.priceId = 0;
        var d = Math.random();
        price = priceList[0].lowprice + d*(priceList[0].highprice - priceList[0].lowprice);
    }
    else if(seed <= priceList[0].probability + priceList[1].probability)
    {
        change = 1; //-this.priceId;
        this.priceId = 1;
        var d = Math.random();
        price = priceList[1].lowprice + d*(priceList[1].highprice - priceList[1].lowprice);
    }
    else
    {
        change = 2;//-this.priceId;
        this.priceId = 2;
        var d = Math.random();
        price = priceList[2].lowprice + (priceList[2].highprice - priceList[2].lowprice);
    }
    */
    this.priceId = 2;
    var d = Math.random();
    price = priceList[2].lowprice + d * (priceList[2].highprice - priceList[2].lowprice);
    this.State = 2;
    this.price = Math.floor(price);
    this.Data.price = this.price;
    cc.Mgr.UserDataMgr.RefreshGoodsMarKetPrice(this.Id, this.price);
    this.PriceLbl.string = this.price.toString();
    var param = {};
    param.State = 2; //-2表示暴跌 -1表示跌了  0 表示稳定  1有所增长 2表示暴涨
    param.Id = this.Id;
    param.icon = this.Data.icon;
    param.name = this.Data.name;
    param.price = this.price;
    return param;
  },
  //刷新价格信息
  refreshPrice: function refreshPrice() {
    var priceList = this.Data.priceList;
    var price = priceList[0].lowprice;
    var change = 0;
    var seed = Math.random();
    if (seed < priceList[0].probability) {
      change = 0; //-this.priceId;
      this.priceId = 0;
      var d = Math.random();
      price = priceList[0].lowprice + d * (priceList[0].highprice - priceList[0].lowprice);
    } else if (seed <= priceList[0].probability + priceList[1].probability) {
      change = 1; //-this.priceId;
      this.priceId = 1;
      var d = Math.random();
      price = priceList[1].lowprice + d * (priceList[1].highprice - priceList[1].lowprice);
    } else {
      change = 2; //-this.priceId;
      this.priceId = 2;
      var d = Math.random();
      price = priceList[2].lowprice + d * (priceList[2].highprice - priceList[2].lowprice);
    }
    this.State = change;
    this.price = Math.floor(price);
    this.Data.price = this.price;
    cc.Mgr.UserDataMgr.RefreshGoodsMarKetPrice(this.Id, this.price);
    this.PriceLbl.string = this.price.toString();
    var param = {};
    param.State = change; //-2表示暴跌 -1表示跌了  0 表示稳定  1有所增长 2表示暴涨
    param.Id = this.Id;
    param.icon = this.Data.icon;
    param.name = this.Data.name;
    param.price = this.price;
    return param;
  },
  OpenBuyTipPanel: function OpenBuyTipPanel() {
    cc.Mgr.AudioMgr.playSFX("goods_" + this.Id);
    if (cc.Mgr.UserDataMgr.userState == UserState.NotOK) {
      var param = {};
      param.text = "您还处在恢复阶段，目前不能交易";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    //cc.log("打开购买窗口 = " + this.Data.name);
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenBuyTip, this.Data);
  }
});
module.exports = GoodsItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEdvb2RzSXRlbS5qcyJdLCJuYW1lcyI6WyJFdmVudCIsInJlcXVpcmUiLCJVc2VyU3RhdGUiLCJHb29kc0l0ZW0iLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJJY29uU3AiLCJTcHJpdGUiLCJOYW1lTGJsIiwiUHJpY2VMYmwiLCJMYWJlbCIsIlN0YXRlIiwiSWQiLCJJbnRlZ2VyIiwicHJpY2UiLCJEYXRhIiwiaW5pdCIsImRhdGEiLCJzcHJpdGVGcmFtZSIsImdldFNwcml0ZUZyYW1lIiwiaWNvbiIsIm5hbWUiLCJwcmljZUlkIiwicmVmcmVzaFByaWNlIiwicmVmcmVzaExvd1ByaWNlIiwicHJpY2VMaXN0IiwibG93cHJpY2UiLCJkIiwiTWF0aCIsInJhbmRvbSIsImhpZ2hwcmljZSIsImZsb29yIiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJSZWZyZXNoR29vZHNNYXJLZXRQcmljZSIsInN0cmluZyIsInRvU3RyaW5nIiwicGFyYW0iLCJyZWZyZXNoTWlkUHJpY2UiLCJyZWZyZXNoVXBQcmljZSIsImNoYW5nZSIsInNlZWQiLCJwcm9iYWJpbGl0eSIsIk9wZW5CdXlUaXBQYW5lbCIsIkF1ZGlvTWdyIiwicGxheVNGWCIsInVzZXJTdGF0ZSIsIk5vdE9LIiwidGV4dCIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiT3BlbkNvbW1vblRpcCIsIk9wZW5CdXlUaXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLEtBQUssR0FBR0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUM1QixJQUFJQyxTQUFTLEdBQUdELE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDcEMsSUFBSUUsU0FBUyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNyQixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJD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QzNCZ0IsS0FBSyxDQUFDdkIsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSztJQUN4QixPQUFPdUIsS0FBSztFQUNoQixDQUFDO0VBRURNLGVBQWUsRUFBQyxTQUFBQSxnQkFBQSxFQUFVO0lBQ3RCM0MsRUFBRSxDQUFDZ0MsR0FBRyxDQUFDWSxRQUFRLENBQUNDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDakMsRUFBRSxDQUFDO0lBQzNDLElBQUdaLEVBQUUsQ0FBQ2dDLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDYSxTQUFTLElBQUloRCxTQUFTLENBQUNpRCxLQUFLLEVBQ2xEO01BQ0ksSUFBSVYsS0FBSyxHQUFHLENBQUMsQ0FBQztNQUNkQSxLQUFLLENBQUNXLElBQUksR0FBRyxpQkFBaUI7TUFDOUJoRCxFQUFFLENBQUNpRCxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDbkQsRUFBRSxDQUFDZ0MsR0FBRyxDQUFDcEMsS0FBSyxDQUFDd0QsYUFBYSxFQUFFZixLQUFLLENBQUM7TUFDL0Q7SUFDSjtJQUNBO0lBQ0FyQyxFQUFFLENBQUNpRCxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDbkQsRUFBRSxDQUFDZ0MsR0FBRyxDQUFDcEMsS0FBSyxDQUFDeUQsVUFBVSxFQUFFLElBQUksQ0FBQ3RDLElBQUksQ0FBQztFQUNwRTtBQUNKLENBQUMsQ0FBQztBQUNGdUMsTUFBTSxDQUFDQyxPQUFPLEdBQUd4RCxTQUFTIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXZlbnQgPSByZXF1aXJlKFwiRXZlbnRcIik7XHJcbnZhciBVc2VyU3RhdGUgPSByZXF1aXJlKFwiVXNlclN0YXRlXCIpO1xyXG52YXIgR29vZHNJdGVtID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvL1VJXHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgSWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBOYW1lTGJsOmNjLlNwcml0ZSxcclxuICAgICAgICBQcmljZUxibDpjYy5MYWJlbCxcclxuICAgICAgICBTdGF0ZToxLCAvL+eKtuaAgVxyXG4gICAgICAgIC8vRGF0YVxyXG4gICAgICAgIElkOmNjLkludGVnZXIsXHJcbiAgICAgICAgcHJpY2U6Y2MuSW50ZWdlcixcclxuICAgICAgICBEYXRhOm51bGwsXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0OmZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5EYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLklkID0gZGF0YS5JZDtcclxuICAgICAgICB0aGlzLkljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICB0aGlzLk5hbWVMYmwuc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEubmFtZSk7XHJcbiAgICAgICAgdGhpcy5wcmljZUlkID0gMDsgLy/miYDlnKjnmoTku7fmoLzljLrpl7RcclxuICAgICAgICB0aGlzLnJlZnJlc2hQcmljZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWZyZXNoTG93UHJpY2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcHJpY2VMaXN0ID0gdGhpcy5EYXRhLnByaWNlTGlzdDtcclxuICAgICAgICB2YXIgcHJpY2UgPSBwcmljZUxpc3RbMF0ubG93cHJpY2U7XHJcbiAgICAgICAgdGhpcy5wcmljZUlkID0gMDtcclxuICAgICAgICB2YXIgZCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgcHJpY2UgPSBwcmljZUxpc3RbMF0ubG93cHJpY2UgKyBkKihwcmljZUxpc3RbMF0uaGlnaHByaWNlIC0gcHJpY2VMaXN0WzBdLmxvd3ByaWNlKTtcclxuICAgICAgICB0aGlzLnByaWNlID0gTWF0aC5mbG9vcihwcmljZSk7XHJcbiAgICAgICAgdGhpcy5EYXRhLnByaWNlID0gdGhpcy5wcmljZTtcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaEdvb2RzTWFyS2V0UHJpY2UodGhpcy5JZCwgdGhpcy5wcmljZSk7XHJcbiAgICAgICAgdGhpcy5QcmljZUxibC5zdHJpbmcgPSB0aGlzLnByaWNlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgdGhpcy5TdGF0ZSA9IDA7XHJcbiAgICAgICAgcGFyYW0uU3RhdGUgPSAwOyAvLy0y6KGo56S65pq06LeMIC0x6KGo56S66LeM5LqGICAwIOihqOekuueos+WumiAgMeacieaJgOWinumVvyAy6KGo56S65pq05raoXHJcbiAgICAgICAgcGFyYW0uSWQgPSB0aGlzLklkO1xyXG4gICAgICAgIHBhcmFtLmljb24gPSB0aGlzLkRhdGEuaWNvbjtcclxuICAgICAgICBwYXJhbS5uYW1lID0gdGhpcy5EYXRhLm5hbWU7XHJcbiAgICAgICAgcGFyYW0ucHJpY2UgPSB0aGlzLnByaWNlO1xyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVmcmVzaE1pZFByaWNlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHByaWNlTGlzdCA9IHRoaXMuRGF0YS5wcmljZUxpc3Q7XHJcbiAgICAgICAgdmFyIHByaWNlID0gcHJpY2VMaXN0WzBdLmxvd3ByaWNlO1xyXG4gICAgICAgIHRoaXMucHJpY2VJZCA9IDE7XHJcbiAgICAgICAgdmFyIGQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIHByaWNlID0gcHJpY2VMaXN0WzFdLmxvd3ByaWNlICsgZCoocHJpY2VMaXN0WzFdLmhpZ2hwcmljZSAtIHByaWNlTGlzdFsxXS5sb3dwcmljZSk7XHJcbiAgICAgICAgdGhpcy5wcmljZSA9IE1hdGguZmxvb3IocHJpY2UpO1xyXG4gICAgICAgIHRoaXMuRGF0YS5wcmljZSA9IHRoaXMucHJpY2U7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hHb29kc01hcktldFByaWNlKHRoaXMuSWQsIHRoaXMucHJpY2UpO1xyXG4gICAgICAgIHRoaXMuUHJpY2VMYmwuc3RyaW5nID0gdGhpcy5wcmljZS50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHRoaXMuU3RhdGUgPSAxO1xyXG4gICAgICAgIHBhcmFtLlN0YXRlID0gMTsgLy8tMuihqOekuuaatOi3jCAtMeihqOekuui3jOS6hiAgMCDooajnpLrnqLPlrpogIDHmnInmiYDlop7plb8gMuihqOekuuaatOa2qFxyXG4gICAgICAgIHBhcmFtLklkID0gdGhpcy5JZDtcclxuICAgICAgICBwYXJhbS5pY29uID0gdGhpcy5EYXRhLmljb247XHJcbiAgICAgICAgcGFyYW0ubmFtZSA9IHRoaXMuRGF0YS5uYW1lO1xyXG4gICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5wcmljZTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9LFxyXG5cclxuICAgIHJlZnJlc2hVcFByaWNlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHByaWNlTGlzdCA9IHRoaXMuRGF0YS5wcmljZUxpc3Q7XHJcbiAgICAgICAgdmFyIHByaWNlID0gcHJpY2VMaXN0WzBdLmxvd3ByaWNlO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIHNlZWQgPSAwLjk5OTk5O1xyXG4gICAgICAgIGlmKHNlZWQgPCBwcmljZUxpc3RbMF0ucHJvYmFiaWxpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGFuZ2UgPSAwOyAvLy10aGlzLnByaWNlSWQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJpY2VJZCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgcHJpY2UgPSBwcmljZUxpc3RbMF0ubG93cHJpY2UgKyBkKihwcmljZUxpc3RbMF0uaGlnaHByaWNlIC0gcHJpY2VMaXN0WzBdLmxvd3ByaWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihzZWVkIDw9IHByaWNlTGlzdFswXS5wcm9iYWJpbGl0eSArIHByaWNlTGlzdFsxXS5wcm9iYWJpbGl0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoYW5nZSA9IDE7IC8vLXRoaXMucHJpY2VJZDtcclxuICAgICAgICAgICAgdGhpcy5wcmljZUlkID0gMTtcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBwcmljZSA9IHByaWNlTGlzdFsxXS5sb3dwcmljZSArIGQqKHByaWNlTGlzdFsxXS5oaWdocHJpY2UgLSBwcmljZUxpc3RbMV0ubG93cHJpY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGFuZ2UgPSAyOy8vLXRoaXMucHJpY2VJZDtcclxuICAgICAgICAgICAgdGhpcy5wcmljZUlkID0gMjtcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBwcmljZSA9IHByaWNlTGlzdFsyXS5sb3dwcmljZSArIChwcmljZUxpc3RbMl0uaGlnaHByaWNlIC0gcHJpY2VMaXN0WzJdLmxvd3ByaWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByaWNlSWQgPSAyO1xyXG4gICAgICAgIHZhciBkID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBwcmljZSA9IHByaWNlTGlzdFsyXS5sb3dwcmljZSArIGQqKHByaWNlTGlzdFsyXS5oaWdocHJpY2UgLSBwcmljZUxpc3RbMl0ubG93cHJpY2UpO1xyXG4gICAgICAgIHRoaXMuU3RhdGUgPSAyO1xyXG4gICAgICAgIHRoaXMucHJpY2UgPSBNYXRoLmZsb29yKHByaWNlKTtcclxuICAgICAgICB0aGlzLkRhdGEucHJpY2UgPSB0aGlzLnByaWNlO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoR29vZHNNYXJLZXRQcmljZSh0aGlzLklkLCB0aGlzLnByaWNlKTtcclxuICAgICAgICB0aGlzLlByaWNlTGJsLnN0cmluZyA9IHRoaXMucHJpY2UudG9TdHJpbmcoKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5TdGF0ZSA9IDI7IC8vLTLooajnpLrmmrTot4wgLTHooajnpLrot4zkuoYgIDAg6KGo56S656iz5a6aICAx5pyJ5omA5aKe6ZW/IDLooajnpLrmmrTmtqhcclxuICAgICAgICBwYXJhbS5JZCA9IHRoaXMuSWQ7XHJcbiAgICAgICAgcGFyYW0uaWNvbiA9IHRoaXMuRGF0YS5pY29uO1xyXG4gICAgICAgIHBhcmFtLm5hbWUgPSB0aGlzLkRhdGEubmFtZTtcclxuICAgICAgICBwYXJhbS5wcmljZSA9IHRoaXMucHJpY2U7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtOyBcclxuICAgIH0sXHJcblxyXG4gICAgLy/liLfmlrDku7fmoLzkv6Hmga9cclxuICAgIHJlZnJlc2hQcmljZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwcmljZUxpc3QgPSB0aGlzLkRhdGEucHJpY2VMaXN0O1xyXG4gICAgICAgIHZhciBwcmljZSA9IHByaWNlTGlzdFswXS5sb3dwcmljZTtcclxuICAgICAgICB2YXIgY2hhbmdlID0gMDtcclxuXHJcbiAgICAgICAgdmFyIHNlZWQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIGlmKHNlZWQgPCBwcmljZUxpc3RbMF0ucHJvYmFiaWxpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGFuZ2UgPSAwOyAvLy10aGlzLnByaWNlSWQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJpY2VJZCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgcHJpY2UgPSBwcmljZUxpc3RbMF0ubG93cHJpY2UgKyBkKihwcmljZUxpc3RbMF0uaGlnaHByaWNlIC0gcHJpY2VMaXN0WzBdLmxvd3ByaWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihzZWVkIDw9IHByaWNlTGlzdFswXS5wcm9iYWJpbGl0eSArIHByaWNlTGlzdFsxXS5wcm9iYWJpbGl0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoYW5nZSA9IDE7IC8vLXRoaXMucHJpY2VJZDtcclxuICAgICAgICAgICAgdGhpcy5wcmljZUlkID0gMTtcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBwcmljZSA9IHByaWNlTGlzdFsxXS5sb3dwcmljZSArIGQqKHByaWNlTGlzdFsxXS5oaWdocHJpY2UgLSBwcmljZUxpc3RbMV0ubG93cHJpY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGFuZ2UgPSAyOy8vLXRoaXMucHJpY2VJZDtcclxuICAgICAgICAgICAgdGhpcy5wcmljZUlkID0gMjtcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBwcmljZSA9IHByaWNlTGlzdFsyXS5sb3dwcmljZSArIGQqKHByaWNlTGlzdFsyXS5oaWdocHJpY2UgLSBwcmljZUxpc3RbMl0ubG93cHJpY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLlN0YXRlID0gY2hhbmdlO1xyXG4gICAgICAgIHRoaXMucHJpY2UgPSBNYXRoLmZsb29yKHByaWNlKTtcclxuICAgICAgICB0aGlzLkRhdGEucHJpY2UgPSB0aGlzLnByaWNlO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoR29vZHNNYXJLZXRQcmljZSh0aGlzLklkLCB0aGlzLnByaWNlKTtcclxuICAgICAgICB0aGlzLlByaWNlTGJsLnN0cmluZyA9IHRoaXMucHJpY2UudG9TdHJpbmcoKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5TdGF0ZSA9IGNoYW5nZTsgLy8tMuihqOekuuaatOi3jCAtMeihqOekuui3jOS6hiAgMCDooajnpLrnqLPlrpogIDHmnInmiYDlop7plb8gMuihqOekuuaatOa2qFxyXG4gICAgICAgIHBhcmFtLklkID0gdGhpcy5JZDtcclxuICAgICAgICBwYXJhbS5pY29uID0gdGhpcy5EYXRhLmljb247XHJcbiAgICAgICAgcGFyYW0ubmFtZSA9IHRoaXMuRGF0YS5uYW1lO1xyXG4gICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5wcmljZTtcclxuICAgICAgICByZXR1cm4gcGFyYW07IFxyXG4gICAgfSxcclxuXHJcbiAgICBPcGVuQnV5VGlwUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImdvb2RzX1wiICsgdGhpcy5JZCk7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLnVzZXJTdGF0ZSA9PSBVc2VyU3RhdGUuTm90T0spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5oKo6L+Y5aSE5Zyo5oGi5aSN6Zi25q6177yM55uu5YmN5LiN6IO95Lqk5piTXCI7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NjLmxvZyhcIuaJk+W8gOi0reS5sOeql+WPoyA9IFwiICsgdGhpcy5EYXRhLm5hbWUpO1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5CdXlUaXAsIHRoaXMuRGF0YSk7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBHb29kc0l0ZW07XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/HonorItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3a387GurgBME4n57ivPSuax', 'HonorItem');
// Scripts/UI/HonorItem.js

"use strict";

var HonorItem = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    icon: cc.Sprite,
    nameLbl: cc.Label,
    Data: null
  },
  ShowData: function ShowData(data) {
    this.Data = data;
    this.icon.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    if (data.hasFinish) this.icon.setState(0);else this.icon.setState(1);
    this.nameLbl.string = data.name;
  },
  ClickOpenTip: function ClickOpenTip() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.text = cc.Mgr.global.getTranslation("Cj_" + this.Data.desId);
    cc.director.GlobalEvent.emit(cc.Mgr.Event.AchieveTip, param);
  }
});
module.exports = HonorItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEhvbm9ySXRlbS5qcyJdLCJuYW1lcyI6WyJIb25vckl0ZW0iLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJpY29uIiwiU3ByaXRlIiwibmFtZUxibCIsIkxhYmVsIiwiRGF0YSIsIlNob3dEYXRhIiwiZGF0YSIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJoYXNGaW5pc2giLCJzZXRTdGF0ZSIsInN0cmluZyIsIm5hbWUiLCJDbGlja09wZW5UaXAiLCJNZ3IiLCJBdWRpb01nciIsInBsYXlTRlgiLCJwYXJhbSIsInRleHQiLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsImRlc0lkIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIkFjaGlldmVUaXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLFNBQVMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDckIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsS0FBSyxFQUFDSixFQUFFLENBQUNLLFdBQVc7SUFDcEJDLElBQUksRUFBQ04sRUFBRSxDQUFDTyxNQUFNO0lBQ2RDLE9BQU8sRUFBQ1IsRUFBRSxDQUFDUyxLQUFLO0lBQ2hCQyxJQUFJLEVBQUM7RUFDVCxDQUFDO0VBRURDLFFBQVEsRUFBQyxTQUFBQSxTQUFVQyxJQUFJLEVBQUU7SUFDckIsSUFBSSxDQUFDRixJQUFJLEdBQUdFLElBQUk7SUFDaEIsSUFBSSxDQUFDTixJQUFJLENBQUNPLFdBQVcsR0FBRyxJQUFJLENBQUNULEtBQUssQ0FBQ1UsY0FBYyxDQUFDRixJQUFJLENBQUNOLElBQUksQ0FBQztJQUM1RCxJQUFHTSxJQUFJLENBQUNHLFNBQVMsRUFDYixJQUFJLENBQUNULElBQUksQ0FBQ1UsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBRXRCLElBQUksQ0FBQ1YsSUFBSSxDQUFDVSxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLElBQUksQ0FBQ1IsT0FBTyxDQUFDUyxNQUFNLEdBQUdMLElBQUksQ0FBQ00sSUFBSTtFQUNuQyxDQUFDO0VBRURDLFlBQVksRUFBQyxTQUFBQSxhQUFBLEVBQVU7SUFDbkJuQixFQUFFLENBQUNvQixHQUFHLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2RBLEtBQUssQ0FBQ0MsSUFBSSxHQUFHeEIsRUFBRSxDQUFDb0IsR0FBRyxDQUFDSyxNQUFNLENBQUNDLGNBQWMsQ0FBQyxLQUFLLEdBQUMsSUFBSSxDQUFDaEIsSUFBSSxDQUFDaUIsS0FBSyxDQUFDO0lBQ2hFM0IsRUFBRSxDQUFDNEIsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQzlCLEVBQUUsQ0FBQ29CLEdBQUcsQ0FBQ1csS0FBSyxDQUFDQyxVQUFVLEVBQUVULEtBQUssQ0FBQztFQUNoRTtBQUVKLENBQUMsQ0FBQztBQUNGVSxNQUFNLENBQUNDLE9BQU8sR0FBR25DLFNBQVMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgSG9ub3JJdGVtID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICBpY29uOmNjLlNwcml0ZSxcclxuICAgICAgICBuYW1lTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgU2hvd0RhdGE6ZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuaWNvbi5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICBpZihkYXRhLmhhc0ZpbmlzaClcclxuICAgICAgICAgICAgdGhpcy5pY29uLnNldFN0YXRlKDApO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5pY29uLnNldFN0YXRlKDEpO1xyXG4gICAgICAgIHRoaXMubmFtZUxibC5zdHJpbmcgPSBkYXRhLm5hbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrT3BlblRpcDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJDal9cIit0aGlzLkRhdGEuZGVzSWQpO1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LkFjaGlldmVUaXAsIHBhcmFtKTtcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBIb25vckl0ZW07XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/EventResultPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e12bbpvZJlERLKL1hpHue1M', 'EventResultPanel');
// Scripts/UI/EventResultPanel.js

"use strict";

var EventResultPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    DesLbl: cc.Label,
    CostLbl: cc.Label,
    CostObj: cc.Node
  },
  ShowPanel: function ShowPanel(data) {
    this.DesLbl.string = data.text;
    this.CostLbl.string = data.des;
    this.CostObj.active = true;
    if (data.des == null || data.des == "") {
      this.CostObj.active = false;
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEV2ZW50UmVzdWx0UGFuZWwuanMiXSwibmFtZXMiOlsiRXZlbnRSZXN1bHRQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiRGVzTGJsIiwiTGFiZWwiLCJDb3N0TGJsIiwiQ29zdE9iaiIsIk5vZGUiLCJTaG93UGFuZWwiLCJkYXRhIiwic3RyaW5nIiwidGV4dCIsImRlcyIsImFjdGl2ZSIsIkNsb3NlUGFuZWwiLCJNZ3IiLCJBdWRpb01nciIsInBsYXlTRlgiLCJub2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLGdCQUFnQixHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUM1QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxNQUFNLEVBQUNKLEVBQUUsQ0FBQ0ssS0FBSztJQUNmQyxPQUFPLEVBQUNOLEVBQUUsQ0FBQ0ssS0FBSztJQUNoQkUsT0FBTyxFQUFDUCxFQUFFLENBQUNRO0VBQ2YsQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBU0MsSUFBSSxFQUFDO0lBQ3BCLElBQUksQ0FBQ04sTUFBTSxDQUFDTyxNQUFNLEdBQUdELElBQUksQ0FBQ0UsSUFBSTtJQUM5QixJQUFJLENBQUNOLE9BQU8sQ0FBQ0ssTUFBTSxHQUFHRCxJQUFJLENBQUNHLEdBQUc7SUFDOUIsSUFBSSxDQUFDTixPQUFPLENBQUNPLE1BQU0sR0FBRyxJQUFJO0lBQzFCLElBQUdKLElBQUksQ0FBQ0csR0FBRyxJQUFJLElBQUksSUFBSUgsSUFBSSxDQUFDRyxHQUFHLElBQUksRUFBRSxFQUNyQztNQUNJLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxNQUFNLEdBQUcsS0FBSztJQUMvQjtFQUNKLENBQUM7RUFFREMsVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFDWDtJQUNJZixFQUFFLENBQUNnQixHQUFHLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJLENBQUNDLElBQUksQ0FBQ0wsTUFBTSxHQUFHLEtBQUs7RUFDNUI7QUFDSixDQUFDLENBQUMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgRXZlbnRSZXN1bHRQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgRGVzTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIENvc3RMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgQ29zdE9iajpjYy5Ob2RlLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgdGhpcy5EZXNMYmwuc3RyaW5nID0gZGF0YS50ZXh0O1xyXG4gICAgICAgIHRoaXMuQ29zdExibC5zdHJpbmcgPSBkYXRhLmRlcztcclxuICAgICAgICB0aGlzLkNvc3RPYmouYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBpZihkYXRhLmRlcyA9PSBudWxsIHx8IGRhdGEuZGVzID09IFwiXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkNvc3RPYmouYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbn0pO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/EventPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e67e8p1OxxG7oSy9F6+K1UZ', 'EventPanel');
// Scripts/UI/EventPanel.js

"use strict";

var ItemType = require("ItemType");
var RewardType = require("RewardType");
var UserState = require("UserState");
var EventPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    desLbl: cc.Label,
    btnLbl: [cc.Label],
    btnTip: [cc.Node],
    btnDesLbl: [cc.Label],
    Data: null
  },
  ShowPanel: function ShowPanel(Id) {
    //cc.log("根据事件来处理问题  Id = " + Id);
    var data = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.EventData, Id);
    this.Data = data;
    this.desLbl.string = cc.Mgr.global.getTranslation("event_" + data.desId);
    for (var i = 0; i < 2; i++) {
      this.btnLbl[i].string = cc.Mgr.global.getTranslation("event_" + data.cost[i].desId);
      this.btnTip[i].active = true;
      if (data.cost[i].costType == RewardType.NULL) {
        this.btnTip[i].active = false;
      } else if (data.cost[i].costType == RewardType.Cash) {
        var costNum = Math.floor(data.cost[i].costNum * (1 - cc.Mgr.UserDataMgr.EventCostBonus));
        this.btnDesLbl[i].string = "花费现金:" + costNum;
      } else if (data.cost[i].costType == RewardType.HP) {
        this.btnDesLbl[i].string = "消耗体力:" + data.cost[i].costNum;
      } else if (data.cost[i].costType == RewardType.Reputation) {
        this.btnDesLbl[i].string = "名声损失:" + data.cost[i].costNum;
      }
    }
  },
  ClickConfirmY: function ClickConfirmY() {
    var param = {};
    param.text = "";
    param.des = "";
    param.forWhat = "Event_No";
    if (cc.Mgr.UserDataMgr.userState == UserState.OK) {
      if (this.Data.cost[0].costType == RewardType.NULL) {
        param.forWhat = "Event_Yes";
      } else if (this.Data.cost[0].costType == RewardType.Cash) {
        if (cc.Mgr.UserDataMgr.Cash >= this.Data.cost[0].costNum) {
          param.forWhat = "Event_Yes";
          cc.Mgr.UserDataMgr.Cash -= this.Data.cost[0].costNum;
        } else {
          param.text = "钱不够,无法参与";
          param.forWhat = "Event_No";
        }
      } else if (this.Data.cost[0].costType == RewardType.HP) {
        if (cc.Mgr.UserDataMgr.HpPoint >= this.Data.cost[0].costNum) {
          param.forWhat = "Event_Yes";
          cc.Mgr.UserDataMgr.HpPoint -= this.Data.cost[0].costNum;
        } else {
          param.text = "你的健康状态已无法支持你进入本次活动";
          param.forWhat = "Event_No";
        }
      } else if (this.Data.cost[0].costType == RewardType.Reputation) {
        if (cc.Mgr.UserDataMgr.Reputation >= this.Data.cost[0].costNum) {
          param.forWhat = "Event_Yes";
          cc.Mgr.UserDataMgr.Reputation -= this.Data.cost[0].costNum;
        } else {
          param.text = "你的名声已无法支持你进入本次活动";
          param.forWhat = "Event_No";
        }
      }
    } else {
      param.text = "尚在治疗过程中,停止一切活动";
      param.forWhat = "Event_No";
    }
    if (param.forWhat != "Event_No") {
      param.forWhat = "Event_Yes";
      var result = null;
      var seed = Math.random();
      if (seed > 0.5) {
        result = this.Data.YResults[1];
        param.text = cc.Mgr.global.getTranslation("event_" + result.desId);
      } else {
        result = this.Data.YResults[0];
        param.text = cc.Mgr.global.getTranslation("event_" + result.desId);
      }
      if (result != null) {
        param.Pdata = cc.Mgr.UserDataMgr.GetOrCostDataByRewardType(result.rewardType, result.rewardNum, result.rewardId);
        var des = this.GetEventReward(result.rewardType, result.rewardId);
        if (des != "") {
          if (result.rewardNum > 0 && result.rewardType == RewardType.Goods) {
            if (param.Pdata.Id == -1) {
              param.des = des + "+" + result.rewardNum;
              param.text = "仓库已满，无法获得"; //"+" + result.rewardNum;
            } else {
              param.des = des + "+" + result.rewardNum;
              param.text = param.text + "\n"; //"+" + result.rewardNum;
            }
          } else if (result.rewardNum > 0 && (result.rewardType == RewardType.Stock || result.rewardType == RewardType.StockPrice)) {
            if (param.Pdata.companyId == -1) {
              if (this.Data.cost[0].costType == RewardType.Cash) cc.Mgr.UserDataMgr.Cash += this.Data.cost[0].costNum;
              param.des = des + "+" + result.rewardNum;
              param.text = "该公司尚未创立,奖励无法获得,花费现金返回"; //"+" + result.rewardNum;
            } else {
              param.des = des + "+" + result.rewardNum;
              param.text = param.text + "\n"; //"+" + result.rewardNum;
            }
          } else {
            if (result.rewardNum > 0) param.des = des + "+" + result.rewardNum;else param.des = des + result.rewardNum;
            param.text = param.text + "\n"; //+ result.rewardNum;
          }
        }
      }
    } else {}
    //cc.log("___________________________" + param.forWhat);
    //cc.log(" ====事件最终描述 ============= " + param.text);
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenEventResult, param);
    this.ClosePanel();
  },
  ClickConfirmN: function ClickConfirmN() {
    var param = {};
    param.forWhat = "Event_No";
    param.text = "";
    param.des = "";
    if (cc.Mgr.UserDataMgr.userState == UserState.OK) {
      if (this.Data.cost[1].costType == RewardType.NULL) {
        param.forWhat = "Event_Yes";
      } else if (this.Data.cost[1].costType == RewardType.Cash) {
        if (cc.Mgr.UserDataMgr.Cash >= this.Data.cost[1].costNum) {
          param.forWhat = "Event_Yes";
          cc.Mgr.UserDataMgr.Cash -= this.Data.cost[1].costNum;
        } else {
          param.text = "钱不够,无法参与";
          param.forWhat = "Event_No";
        }
      } else if (this.Data.cost[1].costType == RewardType.HP) {
        if (cc.Mgr.UserDataMgr.HpPoint >= this.Data.cost[1].costNum) {
          param.forWhat = "Event_Yes";
          cc.Mgr.UserDataMgr.HpPoint -= this.Data.cost[1].costNum;
        } else {
          param.text = "你的健康状态已无法支持你进入本次活动";
          param.forWhat = "Event_No";
        }
      } else if (this.Data.cost[1].costType == RewardType.Reputation) {
        if (cc.Mgr.UserDataMgr.Reputation >= this.Data.cost[1].costNum) {
          param.forWhat = "Event_Yes";
          cc.Mgr.UserDataMgr.Reputation -= this.Data.cost[1].costNum;
        } else {
          param.text = "你的名声已无法支持你进入本次活动";
          param.forWhat = "Event_No";
        }
      }
    } else {
      param.text = "尚在治疗过程中,停止一切活动";
      param.forWhat = "Event_No";
    }
    if (param.forWhat != "Event_No") {
      param.forWhat = "Event_Yes";
      var seed = Math.random();
      var result = null;
      if (seed > 0.5) {
        result = this.Data.NResults[1];
        param.text = cc.Mgr.global.getTranslation("event_" + result.desId);
      } else {
        result = this.Data.NResults[0];
        param.text = cc.Mgr.global.getTranslation("event_" + result.desId);
      }
      if (result != null) {
        param.Pdata = cc.Mgr.UserDataMgr.GetOrCostDataByRewardType(result.rewardType, result.rewardNum, result.rewardId);
        var des = this.GetEventReward(result.rewardType, result.rewardId);
        if (des != "") {
          if (result.rewardNum > 0 && result.rewardType == RewardType.Goods) {
            if (param.Pdata.Id == -1) {
              param.des = des + "+" + result.rewardNum;
              param.text = "仓库已满，无法获得"; //"+" + result.rewardNum;
            } else {
              param.des = des + "+" + result.rewardNum;
              param.text = param.text + "\n"; //"+" + result.rewardNum;
            }
          } else if (result.rewardNum > 0 && (result.rewardType == RewardType.Stock || result.rewardType == RewardType.StockPrice)) {
            if (param.Pdata.companyId == -1) {
              if (this.Data.cost[0].costType == RewardType.Cash) cc.Mgr.UserDataMgr.Cash += this.Data.cost[0].costNum;
              param.des = des + "+" + result.rewardNum;
              param.text = "该公司尚未创立,奖励无法获得,花费现金返回"; //"+" + result.rewardNum;
            } else {
              param.des = des + "+" + result.rewardNum;
              param.text = param.text + "\n"; //"+" + result.rewardNum;
            }
          } else {
            if (result.rewardNum > 0) param.des = des + "+" + result.rewardNum;else param.des = des + result.rewardNum;
            param.text = param.text + "\n"; //+ result.rewardNum;
          }
        }
      }
    } else {}
    //cc.log("事件最终描述 ============= " + param.text);
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenEventResult, param);
    this.ClosePanel();
  },
  GetEventReward: function GetEventReward(rewardType, rewardId) {
    var des = "";
    switch (rewardType) {
      case RewardType.NULL:
        des = "";
        break;
      case RewardType.Cash:
        des = "现金";
        break;
      case RewardType.Car:
        des = "汽车";
        break;
      case RewardType.House:
        des = "房子";
        break;
      case RewardType.HP:
        des = "健康值";
        break;
      case RewardType.Goods:
        des = "商品";
        break;
      case RewardType.Reputation:
        des = "名声";
        break;
      case RewardType.Stock:
        var companyName = cc.Mgr.global.getTranslation("company_" + rewardId);
        des = companyName + "股票";
        break;
      case RewardType.StockPrice:
        var companyName = cc.Mgr.global.getTranslation("company_" + rewardId);
        des = companyName + "股票价格";
        break;
    }
    return des;
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = EventPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEV2ZW50UGFuZWwuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiUmV3YXJkVHlwZSIsIlVzZXJTdGF0ZSIsIkV2ZW50UGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImRlc0xibCIsIkxhYmVsIiwiYnRuTGJsIiwiYnRuVGlwIiwiTm9kZSIsImJ0bkRlc0xibCIsIkRhdGEiLCJTaG93UGFuZWwiLCJJZCIsImRhdGEiLCJNZ3IiLCJNYXBEYXRhTWdyIiwiZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZCIsIkV2ZW50RGF0YSIsInN0cmluZyIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwiZGVzSWQiLCJpIiwiY29zdCIsImFjdGl2ZSIsImNvc3RUeXBlIiwiTlVMTCIsIkNhc2giLCJjb3N0TnVtIiwiTWF0aCIsImZsb29yIiwiVXNlckRhdGFNZ3IiLCJFdmVudENvc3RCb251cyIsIkhQIiwiUmVwdXRhdGlvbiIsIkNsaWNrQ29uZmlybVkiLCJwYXJhbSIsInRleHQiLCJkZXMiLCJmb3JXaGF0IiwidXNlclN0YXRlIiwiT0siLCJIcFBvaW50IiwicmVzdWx0Iiwic2VlZCIsInJhbmRvbSIsIllSZXN1bHRzIiwiUGRhdGEiLCJHZXRPckNvc3REYXRhQnlSZXdhcmRUeXBlIiwicmV3YXJkVHlwZSIsInJld2FyZE51bSIsInJld2FyZElkIiwiR2V0RXZlbnRSZXdhcmQiLCJHb29kcyIsIlN0b2NrIiwiU3RvY2tQcmljZSIsImNvbXBhbnlJZCIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiRXZlbnQiLCJPcGVuRXZlbnRSZXN1bHQiLCJDbG9zZVBhbmVsIiwiQ2xpY2tDb25maXJtTiIsIk5SZXN1bHRzIiwiQ2FyIiwiSG91c2UiLCJjb21wYW55TmFtZSIsIkF1ZGlvTWdyIiwicGxheVNGWCIsIm5vZGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7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LENBQUMwRCxVQUFVO1FBQ3RCLElBQUlZLFdBQVcsR0FBR25FLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDSyxNQUFNLENBQUNDLGNBQWMsQ0FBQyxVQUFVLEdBQUcrQixRQUFRLENBQUM7UUFDckViLEdBQUcsR0FBRzZCLFdBQVcsR0FBRyxNQUFNO1FBQzFCO0lBQU07SUFFZCxPQUFPN0IsR0FBRztFQUNkLENBQUM7RUFFRHdCLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQVU7SUFDakI5RCxFQUFFLENBQUNjLEdBQUcsQ0FBQ3NELFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJLENBQUNDLElBQUksQ0FBQzlDLE1BQU0sR0FBRyxLQUFLO0VBQzVCO0FBQ0osQ0FBQyxDQUFDO0FBQ0YrQyxNQUFNLENBQUNDLE9BQU8sR0FBR3pFLFVBQVUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIFJld2FyZFR5cGUgPSByZXF1aXJlKFwiUmV3YXJkVHlwZVwiKTtcclxudmFyIFVzZXJTdGF0ZSA9IHJlcXVpcmUoXCJVc2VyU3RhdGVcIik7XHJcbnZhciBFdmVudFBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGRlc0xibDpjYy5MYWJlbCxcclxuXHJcbiAgICAgICAgYnRuTGJsOltjYy5MYWJlbF0sXHJcblxyXG4gICAgICAgIGJ0blRpcDpbY2MuTm9kZV0sXHJcbiAgICAgICAgYnRuRGVzTGJsOltjYy5MYWJlbF0sXHJcbiAgICAgICAgRGF0YTpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24gKElkKSB7XHJcbiAgICAgICAgLy9jYy5sb2coXCLmoLnmja7kuovku7bmnaXlpITnkIbpl67popggIElkID0gXCIgKyBJZCk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkV2ZW50RGF0YSwgSWQpO1xyXG4gICAgICAgIHRoaXMuRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5kZXNMYmwuc3RyaW5nICA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJldmVudF9cIitkYXRhLmRlc0lkKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5idG5MYmxbaV0uc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcImV2ZW50X1wiK2RhdGEuY29zdFtpXS5kZXNJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuVGlwW2ldLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKGRhdGEuY29zdFtpXS5jb3N0VHlwZSA9PSBSZXdhcmRUeXBlLk5VTEwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnRuVGlwW2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZGF0YS5jb3N0W2ldLmNvc3RUeXBlID09IFJld2FyZFR5cGUuQ2FzaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvc3ROdW0gPSBNYXRoLmZsb29yKGRhdGEuY29zdFtpXS5jb3N0TnVtICogKDEtY2MuTWdyLlVzZXJEYXRhTWdyLkV2ZW50Q29zdEJvbnVzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ0bkRlc0xibFtpXS5zdHJpbmcgPSBcIuiKsei0ueeOsOmHkTpcIitjb3N0TnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZGF0YS5jb3N0W2ldLmNvc3RUeXBlID09IFJld2FyZFR5cGUuSFApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnRuRGVzTGJsW2ldLnN0cmluZyA9IFwi5raI6ICX5L2T5YqbOlwiK2RhdGEuY29zdFtpXS5jb3N0TnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZGF0YS5jb3N0W2ldLmNvc3RUeXBlID09IFJld2FyZFR5cGUuUmVwdXRhdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idG5EZXNMYmxbaV0uc3RyaW5nID0gXCLlkI3lo7DmjZ/lpLE6XCIrZGF0YS5jb3N0W2ldLmNvc3ROdW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrQ29uZmlybVk6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS50ZXh0ID0gXCJcIjtcclxuICAgICAgICBwYXJhbS5kZXMgPSBcIlwiO1xyXG4gICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X05vXCI7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLnVzZXJTdGF0ZSA9PSBVc2VyU3RhdGUuT0spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZih0aGlzLkRhdGEuY29zdFswXS5jb3N0VHlwZSA9PSBSZXdhcmRUeXBlLk5VTEwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X1llc1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5EYXRhLmNvc3RbMF0uY29zdFR5cGUgPT0gUmV3YXJkVHlwZS5DYXNoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCA+PSB0aGlzLkRhdGEuY29zdFswXS5jb3N0TnVtKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X1llc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIC09IHRoaXMuRGF0YS5jb3N0WzBdLmNvc3ROdW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi6ZKx5LiN5aSfLOaXoOazleWPguS4jlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X05vXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLkRhdGEuY29zdFswXS5jb3N0VHlwZSA9PSBSZXdhcmRUeXBlLkhQKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludCA+PSB0aGlzLkRhdGEuY29zdFswXS5jb3N0TnVtKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X1llc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50IC09IHRoaXMuRGF0YS5jb3N0WzBdLmNvc3ROdW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5L2g55qE5YGl5bq354q25oCB5bey5peg5rOV5pSv5oyB5L2g6L+b5YWl5pys5qyh5rS75YqoXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfTm9cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuRGF0YS5jb3N0WzBdLmNvc3RUeXBlID09IFJld2FyZFR5cGUuUmVwdXRhdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLlJlcHV0YXRpb24gPj0gdGhpcy5EYXRhLmNvc3RbMF0uY29zdE51bSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJFdmVudF9ZZXNcIjtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVwdXRhdGlvbiAtPSB0aGlzLkRhdGEuY29zdFswXS5jb3N0TnVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBcIuS9oOeahOWQjeWjsOW3suaXoOazleaUr+aMgeS9oOi/m+WFpeacrOasoea0u+WKqFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X05vXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5bCa5Zyo5rK755aX6L+H56iL5LitLOWBnOatouS4gOWIh+a0u+WKqFwiO1xyXG4gICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJFdmVudF9Ob1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYXJhbS5mb3JXaGF0ICE9IFwiRXZlbnRfTm9cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X1llc1wiO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHNlZWQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBpZihzZWVkID4gMC41KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLkRhdGEuWVJlc3VsdHNbMV07XHJcbiAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcImV2ZW50X1wiK3Jlc3VsdC5kZXNJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLkRhdGEuWVJlc3VsdHNbMF07XHJcbiAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcImV2ZW50X1wiK3Jlc3VsdC5kZXNJZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHJlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5QZGF0YSA9IGNjLk1nci5Vc2VyRGF0YU1nci5HZXRPckNvc3REYXRhQnlSZXdhcmRUeXBlKHJlc3VsdC5yZXdhcmRUeXBlLCByZXN1bHQucmV3YXJkTnVtLCByZXN1bHQucmV3YXJkSWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcyA9IHRoaXMuR2V0RXZlbnRSZXdhcmQocmVzdWx0LnJld2FyZFR5cGUsIHJlc3VsdC5yZXdhcmRJZCk7XHJcbiAgICAgICAgICAgICAgICBpZihkZXMgIT0gXCJcIilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQucmV3YXJkTnVtID4gMCAmJiByZXN1bHQucmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLkdvb2RzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyYW0uUGRhdGEuSWQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmRlcyA9IGRlcyArIFwiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBcIuS7k+W6k+W3sua7oe+8jOaXoOazleiOt+W+l1wiOy8vXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uZGVzID0gZGVzICsgXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IHBhcmFtLnRleHQgKyBcIlxcblwiOy8vXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihyZXN1bHQucmV3YXJkTnVtID4gMCAmJiAocmVzdWx0LnJld2FyZFR5cGUgPT0gUmV3YXJkVHlwZS5TdG9jayB8fCByZXN1bHQucmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLlN0b2NrUHJpY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyYW0uUGRhdGEuY29tcGFueUlkID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLkRhdGEuY29zdFswXS5jb3N0VHlwZSA9PSBSZXdhcmRUeXBlLkNhc2gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggKz0gdGhpcy5EYXRhLmNvc3RbMF0uY29zdE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uZGVzID0gZGVzICsgXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi6K+l5YWs5Y+45bCa5pyq5Yib56uLLOWlluWKseaXoOazleiOt+W+lyzoirHotLnnjrDph5Hov5Tlm55cIjsvL1wiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmRlcyA9IGRlcyArIFwiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBwYXJhbS50ZXh0ICsgXCJcXG5cIjsvL1wiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQucmV3YXJkTnVtID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmRlcyA9IGRlcyArIFwiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uZGVzID0gZGVzICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IHBhcmFtLnRleHQgKyBcIlxcblwiIDsvLysgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NjLmxvZyhcIl9fX19fX19fX19fX19fX19fX19fX19fX19fX1wiICsgcGFyYW0uZm9yV2hhdCk7XHJcbiAgICAgICAgLy9jYy5sb2coXCIgPT09PeS6i+S7tuacgOe7iOaPj+i/sCA9PT09PT09PT09PT09IFwiICsgcGFyYW0udGV4dCk7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkV2ZW50UmVzdWx0ICwgcGFyYW0pO1xyXG5cclxuICAgICAgICB0aGlzLkNsb3NlUGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tDb25maXJtTjpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIkV2ZW50X05vXCI7XHJcbiAgICAgICAgcGFyYW0udGV4dCA9IFwiXCI7XHJcbiAgICAgICAgcGFyYW0uZGVzID0gXCJcIjtcclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IudXNlclN0YXRlID09IFVzZXJTdGF0ZS5PSylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuRGF0YS5jb3N0WzFdLmNvc3RUeXBlID09IFJld2FyZFR5cGUuTlVMTClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfWWVzXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLkRhdGEuY29zdFsxXS5jb3N0VHlwZSA9PSBSZXdhcmRUeXBlLkNhc2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoID49IHRoaXMuRGF0YS5jb3N0WzFdLmNvc3ROdW0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfWWVzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggLT0gdGhpcy5EYXRhLmNvc3RbMV0uY29zdE51bTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLpkrHkuI3lpJ8s5peg5rOV5Y+C5LiOXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfTm9cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuRGF0YS5jb3N0WzFdLmNvc3RUeXBlID09IFJld2FyZFR5cGUuSFApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50ID49IHRoaXMuRGF0YS5jb3N0WzFdLmNvc3ROdW0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfWWVzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQgLT0gdGhpcy5EYXRhLmNvc3RbMV0uY29zdE51bTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLkvaDnmoTlgaXlurfnirbmgIHlt7Lml6Dms5XmlK/mjIHkvaDov5vlhaXmnKzmrKHmtLvliqhcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJFdmVudF9Ob1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLkRhdGEuY29zdFsxXS5jb3N0VHlwZSA9PSBSZXdhcmRUeXBlLlJlcHV0YXRpb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5SZXB1dGF0aW9uID49IHRoaXMuRGF0YS5jb3N0WzFdLmNvc3ROdW0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfWWVzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlcHV0YXRpb24gLT0gdGhpcy5EYXRhLmNvc3RbMV0uY29zdE51bTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLkvaDnmoTlkI3lo7Dlt7Lml6Dms5XmlK/mjIHkvaDov5vlhaXmnKzmrKHmtLvliqhcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJFdmVudF9Ob1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBcIuWwmuWcqOayu+eWl+i/h+eoi+S4rSzlgZzmraLkuIDliIfmtLvliqhcIjtcclxuICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfTm9cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHBhcmFtLmZvcldoYXQgIT0gXCJFdmVudF9Ob1wiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiRXZlbnRfWWVzXCI7XHJcbiAgICAgICAgICAgIHZhciBzZWVkID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmKHNlZWQgPiAwLjUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuRGF0YS5OUmVzdWx0c1sxXTtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiZXZlbnRfXCIrcmVzdWx0LmRlc0lkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuRGF0YS5OUmVzdWx0c1swXTtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiZXZlbnRfXCIrcmVzdWx0LmRlc0lkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYocmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtLlBkYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLkdldE9yQ29zdERhdGFCeVJld2FyZFR5cGUocmVzdWx0LnJld2FyZFR5cGUsIHJlc3VsdC5yZXdhcmROdW0sIHJlc3VsdC5yZXdhcmRJZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVzID0gdGhpcy5HZXRFdmVudFJld2FyZChyZXN1bHQucmV3YXJkVHlwZSwgcmVzdWx0LnJld2FyZElkKTtcclxuICAgICAgICAgICAgICAgIGlmKGRlcyAhPSBcIlwiKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5yZXdhcmROdW0gPiAwICYmIHJlc3VsdC5yZXdhcmRUeXBlID09IFJld2FyZFR5cGUuR29vZHMgKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyYW0uUGRhdGEuSWQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmRlcyA9IGRlcyArIFwiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBcIuS7k+W6k+W3sua7oe+8jOaXoOazleiOt+W+l1wiOy8vXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uZGVzID0gZGVzICsgXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IHBhcmFtLnRleHQgKyBcIlxcblwiOy8vXCIrXCIgKyByZXN1bHQucmV3YXJkTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihyZXN1bHQucmV3YXJkTnVtID4gMCAmJiAocmVzdWx0LnJld2FyZFR5cGUgPT0gUmV3YXJkVHlwZS5TdG9jayB8fCByZXN1bHQucmV3YXJkVHlwZSA9PSBSZXdhcmRUeXBlLlN0b2NrUHJpY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyYW0uUGRhdGEuY29tcGFueUlkID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5EYXRhLmNvc3RbMF0uY29zdFR5cGUgPT0gUmV3YXJkVHlwZS5DYXNoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoICs9IHRoaXMuRGF0YS5jb3N0WzBdLmNvc3ROdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmRlcyA9IGRlcyArIFwiK1wiICsgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBcIuivpeWFrOWPuOWwmuacquWIm+eriyzlpZblirHml6Dms5Xojrflvpcs6Iqx6LS5546w6YeR6L+U5ZueXCI7Ly9cIitcIiArIHJlc3VsdC5yZXdhcmROdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5kZXMgPSBkZXMgKyBcIitcIiArIHJlc3VsdC5yZXdhcmROdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gcGFyYW0udGV4dCArIFwiXFxuXCI7Ly9cIitcIiArIHJlc3VsdC5yZXdhcmROdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnJld2FyZE51bSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5kZXMgPSBkZXMgKyBcIitcIiArIHJlc3VsdC5yZXdhcmROdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLmRlcyA9IGRlcyArIHJlc3VsdC5yZXdhcmROdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBwYXJhbS50ZXh0ICsgXCJcXG5cIjsvLysgcmVzdWx0LnJld2FyZE51bTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY2MubG9nKFwi5LqL5Lu25pyA57uI5o+P6L+wID09PT09PT09PT09PT0gXCIgKyBwYXJhbS50ZXh0KTtcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuRXZlbnRSZXN1bHQgLCBwYXJhbSk7XHJcbiAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIEdldEV2ZW50UmV3YXJkOmZ1bmN0aW9uKHJld2FyZFR5cGUsIHJld2FyZElkKXtcclxuICAgICAgICB2YXIgZGVzID0gXCJcIjtcclxuICAgICAgICBzd2l0Y2ggKHJld2FyZFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBSZXdhcmRUeXBlLk5VTEw6XHJcbiAgICAgICAgICAgICAgICBkZXMgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmV3YXJkVHlwZS5DYXNoOlxyXG4gICAgICAgICAgICAgICAgZGVzID0gXCLnjrDph5FcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJld2FyZFR5cGUuQ2FyOlxyXG4gICAgICAgICAgICAgICAgZGVzID0gXCLmsb3ovaZcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJld2FyZFR5cGUuSG91c2U6XHJcbiAgICAgICAgICAgICAgICBkZXMgPSBcIuaIv+WtkFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmV3YXJkVHlwZS5IUDpcclxuICAgICAgICAgICAgICAgIGRlcyA9IFwi5YGl5bq35YC8XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXdhcmRUeXBlLkdvb2RzOlxyXG4gICAgICAgICAgICAgICAgZGVzID0gXCLllYblk4FcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJld2FyZFR5cGUuUmVwdXRhdGlvbjpcclxuICAgICAgICAgICAgICAgIGRlcyA9IFwi5ZCN5aOwXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXdhcmRUeXBlLlN0b2NrOlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhbnlOYW1lID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcImNvbXBhbnlfXCIgKyByZXdhcmRJZCk7XHJcbiAgICAgICAgICAgICAgICBkZXMgPSBjb21wYW55TmFtZSArIFwi6IKh56WoXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXdhcmRUeXBlLlN0b2NrUHJpY2U6XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFueU5hbWUgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiY29tcGFueV9cIiArIHJld2FyZElkKTtcclxuICAgICAgICAgICAgICAgIGRlcyA9IGNvbXBhbnlOYW1lICsgXCLogqHnpajku7fmoLxcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/HouseItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2ea48WqAlpBZLuQaiP7A4LU', 'HouseItem');
// Scripts/UI/HouseItem.js

"use strict";

var ItemType = require("ItemType");
var HouseItem = cc.Class({
  "extends": cc.Component,
  properties: {
    nameLbl: cc.Label,
    icon: cc.Sprite,
    Atlas: cc.SpriteAtlas,
    Data: null
  },
  init: function init(data) {
    this.icon.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.Data = data;
  },
  ClickBuy: function ClickBuy() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.name = this.Data.name;
    param.Id = this.Data.Id;
    param.icon = this.Data.icon;
    param.Type = ItemType.House;
    param.price = this.Data.price;
    param.flag = "Buy";
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonBuy, param);
  }
});
module.exports = HouseItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEhvdXNlSXRlbS5qcyJdLCJuYW1lcyI6WyJJdGVtVHlwZSIsInJlcXVpcmUiLCJIb3VzZUl0ZW0iLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIm5hbWVMYmwiLCJMYWJlbCIsImljb24iLCJTcHJpdGUiLCJBdGxhcyIsIlNwcml0ZUF0bGFzIiwiRGF0YSIsImluaXQiLCJkYXRhIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsIkNsaWNrQnV5IiwiTWdyIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwicGFyYW0iLCJuYW1lIiwiSWQiLCJUeXBlIiwiSG91c2UiLCJwcmljZSIsImZsYWciLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vbkJ1eSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLFNBQVMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDckIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDVEMsT0FBTyxFQUFDSixFQUFFLENBQUNLLEtBQUs7SUFDaEJDLElBQUksRUFBQ04sRUFBRSxDQUFDTyxNQUFNO0lBQ2RDLEtBQUssRUFBQ1IsRUFBRSxDQUFDUyxXQUFXO0lBQ3BCQyxJQUFJLEVBQUM7RUFDUixDQUFDO0VBRURDLElBQUksRUFBQyxTQUFBQSxLQUFVQyxJQUFJLEVBQUU7SUFDakIsSUFBSSxDQUFDTixJQUFJLENBQUNPLFdBQVcsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ00sY0FBYyxDQUFDRixJQUFJLENBQUNOLElBQUksQ0FBQztJQUM1RCxJQUFJLENBQUNJLElBQUksR0FBR0UsSUFBSTtFQUNwQixDQUFDO0VBRURHLFFBQVEsRUFBQyxTQUFBQSxTQUFBLEVBQVU7SUFDZmYsRUFBRSxDQUFDZ0IsR0FBRyxDQUFDQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkQSxLQUFLLENBQUNDLElBQUksR0FBRyxJQUFJLENBQUNWLElBQUksQ0FBQ1UsSUFBSTtJQUMzQkQsS0FBSyxDQUFDRSxFQUFFLEdBQUcsSUFBSSxDQUFDWCxJQUFJLENBQUNXLEVBQUU7SUFDdkJGLEtBQUssQ0FBQ2IsSUFBSSxHQUFHLElBQUksQ0FBQ0ksSUFBSSxDQUFDSixJQUFJO0lBQzNCYSxLQUFLLENBQUNHLElBQUksR0FBR3pCLFFBQVEsQ0FBQzBCLEtBQUs7SUFDM0JKLEtBQUssQ0FBQ0ssS0FBSyxHQUFHLElBQUksQ0FBQ2QsSUFBSSxDQUFDYyxLQUFLO0lBQzdCTCxLQUFLLENBQUNNLElBQUksR0FBRyxLQUFLO0lBQ2xCekIsRUFBRSxDQUFDMEIsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQzVCLEVBQUUsQ0FBQ2dCLEdBQUcsQ0FBQ2EsS0FBSyxDQUFDQyxhQUFhLEVBQUVYLEtBQUssQ0FBQztFQUNuRTtBQUNKLENBQUMsQ0FBQztBQUNGWSxNQUFNLENBQUNDLE9BQU8sR0FBR2pDLFNBQVMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIEhvdXNlSXRlbSA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICBuYW1lTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgaWNvbjpjYy5TcHJpdGUsXHJcbiAgICAgICBBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgIERhdGE6bnVsbCwgXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6ZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmljb24uc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgdGhpcy5EYXRhID0gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tCdXk6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLm5hbWUgPSB0aGlzLkRhdGEubmFtZTtcclxuICAgICAgICBwYXJhbS5JZCA9IHRoaXMuRGF0YS5JZDtcclxuICAgICAgICBwYXJhbS5pY29uID0gdGhpcy5EYXRhLmljb247XHJcbiAgICAgICAgcGFyYW0uVHlwZSA9IEl0ZW1UeXBlLkhvdXNlO1xyXG4gICAgICAgIHBhcmFtLnByaWNlID0gdGhpcy5EYXRhLnByaWNlO1xyXG4gICAgICAgIHBhcmFtLmZsYWcgPSBcIkJ1eVwiO1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25CdXksIHBhcmFtKTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEhvdXNlSXRlbTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/HistoryPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '19978Asv5VHRJ2aT2QlyfZs', 'HistoryPanel');
// Scripts/UI/HistoryPanel.js

"use strict";

var HistoryPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    nameLbl: cc.Label,
    personNum: cc.Label,
    assetHigh: cc.Label,
    retireAsset: cc.Label,
    Million: cc.Label,
    TenMillion: cc.Label,
    HundredMillion: cc.Label
  },
  ShowPanel: function ShowPanel() {
    this.nameLbl.string = cc.Mgr.UserDataMgr.playerName;
    this.personNum.string = cc.Mgr.UserDataMgr.playTimes;
    var param = this.getRecordData();
    this.assetHigh.string = param.highAsset;
    this.retireAsset.string = param.as;
    this.Million.string = param.milltimes;
    this.TenMillion.string = param.thousend;
    this.HundredMillion.string = param.hundredmill;
  },
  getRecordData: function getRecordData() {
    //cc.log(JSON.stringify(cc.Mgr.UserDataMgr.RecordList))
    var list = cc.Mgr.UserDataMgr.RecordList;
    var allasset = 0;
    var milltimes = 0;
    var thousend = 0;
    var hundredmill = 0;
    var highAsset = list[0].highAssets;
    for (var i = 0; i < list.length; i++) {
      allasset += list[i].assets;
      if (list[i].highAssets > highAsset) {
        highAsset = list[i].highAssets;
      }
      if (list[i].level == 1) {
        milltimes += 1;
      } else if (list[i].level == 2) {
        thousend += 1;
      } else if (list[i].level == 3) {
        hundredmill += 1;
      }
    }
    var as = Math.floor(allasset / list.length);
    var param = {};
    param.as = as;
    param.milltimes = milltimes;
    param.thousend = thousend;
    param.hundredmill = hundredmill;
    param.highAsset = highAsset;
    return param;
  },
  ChangeName: function ChangeName() {
    //cc.log("===========");
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = HistoryPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEhpc3RvcnlQYW5lbC5qcyJdLCJuYW1lcyI6WyJIaXN0b3J5UGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIm5hbWVMYmwiLCJMYWJlbCIsInBlcnNvbk51bSIsImFzc2V0SGlnaCIsInJldGlyZUFzc2V0IiwiTWlsbGlvbiIsIlRlbk1pbGxpb24iLCJIdW5kcmVkTWlsbGlvbiIsIlNob3dQYW5lbCIsInN0cmluZyIsIk1nciIsIlVzZXJEYXRhTWdyIiwicGxheWVyTmFtZSIsInBsYXlUaW1lcyIsInBhcmFtIiwiZ2V0UmVjb3JkRGF0YSIsImhpZ2hBc3NldCIsImFzIiwibWlsbHRpbWVzIiwidGhvdXNlbmQiLCJodW5kcmVkbWlsbCIsImxpc3QiLCJSZWNvcmRMaXN0IiwiYWxsYXNzZXQiLCJoaWdoQXNzZXRzIiwiaSIsImxlbmd0aCIsImFzc2V0cyIsImxldmVsIiwiTWF0aCIsImZsb29yIiwiQ2hhbmdlTmFtZSIsIkNsb3NlUGFuZWwiLCJBdWRpb01nciIsInBsYXlTRlgiLCJub2RlIiwiYWN0aXZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxZQUFZLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLE9BQU8sRUFBQ0osRUFBRSxDQUFDSyxLQUFLO0lBQ2hCQyxTQUFTLEVBQUNOLEVBQUUsQ0FBQ0ssS0FBSztJQUNsQkUsU0FBUyxFQUFDUCxFQUFFLENBQUNLLEtBQUs7SUFDbEJHLFdBQVcsRUFBQ1IsRUFBRSxDQUFDSyxLQUFLO0lBQ3BCSSxPQUFPLEVBQUNULEVBQUUsQ0FBQ0ssS0FBSztJQUNoQkssVUFBVSxFQUFDVixFQUFFLENBQUNLLEtBQUs7SUFDbkJNLGNBQWMsRUFBQ1gsRUFBRSxDQUFDSztFQUN0QixDQUFDO0VB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Q0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHM0MsWUFBWSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBIaXN0b3J5UGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIG5hbWVMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgcGVyc29uTnVtOmNjLkxhYmVsLFxyXG4gICAgICAgIGFzc2V0SGlnaDpjYy5MYWJlbCxcclxuICAgICAgICByZXRpcmVBc3NldDpjYy5MYWJlbCxcclxuICAgICAgICBNaWxsaW9uOmNjLkxhYmVsLFxyXG4gICAgICAgIFRlbk1pbGxpb246Y2MuTGFiZWwsXHJcbiAgICAgICAgSHVuZHJlZE1pbGxpb246Y2MuTGFiZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lTGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5wbGF5ZXJOYW1lO1xyXG4gICAgICAgIHRoaXMucGVyc29uTnVtLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5wbGF5VGltZXM7XHJcblxyXG4gICAgICAgIHZhciBwYXJhbSA9IHRoaXMuZ2V0UmVjb3JkRGF0YSgpO1xyXG4gICAgICAgIHRoaXMuYXNzZXRIaWdoLnN0cmluZyA9IHBhcmFtLmhpZ2hBc3NldDtcclxuICAgICAgICB0aGlzLnJldGlyZUFzc2V0LnN0cmluZyA9IHBhcmFtLmFzO1xyXG4gICAgICAgIHRoaXMuTWlsbGlvbi5zdHJpbmcgPSBwYXJhbS5taWxsdGltZXM7XHJcbiAgICAgICAgdGhpcy5UZW5NaWxsaW9uLnN0cmluZyA9IHBhcmFtLnRob3VzZW5kO1xyXG4gICAgICAgIHRoaXMuSHVuZHJlZE1pbGxpb24uc3RyaW5nID0gcGFyYW0uaHVuZHJlZG1pbGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlY29yZERhdGE6ZnVuY3Rpb24oKXtcclxuICAgICAgICAvL2NjLmxvZyhKU09OLnN0cmluZ2lmeShjYy5NZ3IuVXNlckRhdGFNZ3IuUmVjb3JkTGlzdCkpXHJcbiAgICAgICAgdmFyIGxpc3QgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVjb3JkTGlzdDtcclxuICAgICAgICB2YXIgYWxsYXNzZXQgPSAwO1xyXG4gICAgICAgIHZhciBtaWxsdGltZXMgPSAwO1xyXG4gICAgICAgIHZhciB0aG91c2VuZCA9IDA7XHJcbiAgICAgICAgdmFyIGh1bmRyZWRtaWxsID0gMDtcclxuICAgICAgICB2YXIgaGlnaEFzc2V0ID0gbGlzdFswXS5oaWdoQXNzZXRzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhbGxhc3NldCArPSBsaXN0W2ldLmFzc2V0cztcclxuICAgICAgICAgICAgaWYobGlzdFtpXS5oaWdoQXNzZXRzID4gaGlnaEFzc2V0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoaWdoQXNzZXQgPSBsaXN0W2ldLmhpZ2hBc3NldHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYobGlzdFtpXS5sZXZlbCA9PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtaWxsdGltZXMgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGxpc3RbaV0ubGV2ZWwgPT0gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhvdXNlbmQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGxpc3RbaV0ubGV2ZWwgPT0gMylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaHVuZHJlZG1pbGwgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFzID0gTWF0aC5mbG9vcihhbGxhc3NldCAvIGxpc3QubGVuZ3RoKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5hcyA9IGFzO1xyXG4gICAgICAgIHBhcmFtLm1pbGx0aW1lcyA9IG1pbGx0aW1lcztcclxuICAgICAgICBwYXJhbS50aG91c2VuZCA9IHRob3VzZW5kO1xyXG4gICAgICAgIHBhcmFtLmh1bmRyZWRtaWxsID0gaHVuZHJlZG1pbGw7XHJcbiAgICAgICAgcGFyYW0uaGlnaEFzc2V0ID0gaGlnaEFzc2V0O1xyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2hhbmdlTmFtZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vY2MubG9nKFwiPT09PT09PT09PT1cIik7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5UGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/HonorPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b1e0dyy5PlDzoGSqpu21Es4', 'HonorPanel');
// Scripts/UI/HonorPanel.js

"use strict";

var HonorPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    itemParent: cc.Node,
    itemPre: cc.Prefab
  },
  InitPanel: function InitPanel() {
    var DataList = cc.Mgr.UserDataMgr.AchievementList;
    for (var i = 0; i <= DataList.length - 1; i++) {
      var data = DataList[i];
      var obj = cc.instantiate(this.itemPre);
      obj.parent = this.itemParent;
      obj.active = true;
      obj.getComponent("HonorItem").ShowData(data);
    }
  },
  RefreshPanel: function RefreshPanel() {
    var DataList = cc.Mgr.UserDataMgr.AchievementList;
    var children = this.itemParent.children;
    for (var i = 0; i <= children.length - 1; i++) {
      var data = DataList[i];
      var sc = children[i].getComponent("HonorItem");
      if (sc != null) {
        sc.ShowData(DataList[i]);
      }
    }
  },
  ShowPanel: function ShowPanel() {
    var children = this.itemParent.children;
    if (children.length == 0) {
      this.InitPanel();
    } else {
      this.RefreshPanel();
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = HonorPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEhvbm9yUGFuZWwuanMiXSwibmFtZXMiOlsiSG9ub3JQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiaXRlbVBhcmVudCIsIk5vZGUiLCJpdGVtUHJlIiwiUHJlZmFiIiwiSW5pdFBhbmVsIiwiRGF0YUxpc3QiLCJNZ3IiLCJVc2VyRGF0YU1nciIsIkFjaGlldmVtZW50TGlzdCIsImkiLCJsZW5ndGgiLCJkYXRhIiwib2JqIiwiaW5zdGFudGlhdGUiLCJwYXJlbnQiLCJhY3RpdmUiLCJnZXRDb21wb25lbnQiLCJTaG93RGF0YSIsIlJlZnJlc2hQYW5lbCIsImNoaWxkcmVuIiwic2MiLCJTaG93UGFuZWwiLCJDbG9zZVBhbmVsIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibm9kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsVUFBVSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN0QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxVQUFVLEVBQUNKLEVBQUUsQ0FBQ0ssSUFBSTtJQUNsQkMsT0FBTyxFQUFDTixFQUFFLENBQUNPO0VBQ2YsQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFVO0lBQ25CLElBQUlDLFFBQVEsR0FBR1QsRUFBRSxDQUFDVSxHQUFHLENBQUNDLFdBQVcsQ0FBQ0MsZUFBZTtJQUNqRCxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsSUFBSUosUUFBUSxDQUFDSyxNQUFNLEdBQUcsQ0FBQyxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUM5QyxJQUFJRSxJQUFJLEdBQUdOLFFBQVEsQ0FBQ0ksQ0FBQyxDQUFDO01BQ2hCLElBQUlHLEdBQUcsR0FBR2hCLEVBQUUsQ0FBQ2lCLFdBQVcsQ0FBQyxJQUFJLENBQUNYLE9BQU8sQ0FBQztNQUN0Q1UsR0FBRyxDQUFDRSxNQUFNLEdBQUcsSUFBSSxDQUFDZCxVQUFVO01BQzVCWSxHQUFHLENBQUNHLE1BQU0sR0FBRyxJQUFJO01BQ2pCSCxHQUFHLENBQUNJLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQ0MsUUFBUSxDQUFDTixJQUFJLENBQUM7SUFDbkQ7RUFDRCxDQUFDO0VBRURPLFlBQVksRUFBQyxTQUFBQSxhQUFBLEVBQVU7SUFDdEIsSUFBSWIsUUFBUSxHQUFHVCxFQUFFLENBQUNVLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDQyxlQUFlO0lBQ2pELElBQUlXLFFBQVEsR0FBRyxJQUFJLENBQUNuQixVQUFVLENBQUNtQixRQUFRO0lBQ3ZDLEtBQUssSUFBSVYsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxJQUFJVSxRQUFRLENBQUNULE1BQU0sR0FBRSxDQUFDLEVBQUVELENBQUMsRUFBRSxFQUFFO01BQzdDLElBQUlFLElBQUksR0FBR04sUUFBUSxDQUFDSSxDQUFDLENBQUM7TUFDdEIsSUFBSVcsRUFBRSxHQUFHRCxRQUFRLENBQUNWLENBQUMsQ0FBQyxDQUFDTyxZQUFZLENBQUMsV0FBVyxDQUFDO01BQzlDLElBQUdJLEVBQUUsSUFBSSxJQUFJLEVBQ2I7UUFDQ0EsRUFBRSxDQUFDSCxRQUFRLENBQUNaLFFBQVEsQ0FBQ0ksQ0FBQyxDQUFDLENBQUM7TUFDekI7SUFDRDtFQUNELENBQUM7RUFFRFksU0FBUyxFQUFDLFNBQUFBLFVBQUEsRUFBWTtJQUNyQixJQUFJRixRQUFRLEdBQUcsSUFBSSxDQUFDbkIsVUFBVSxDQUFDbUIsUUFBUTtJQUN2QyxJQUFHQSxRQUFRLENBQUNULE1BQU0sSUFBSSxDQUFDLEVBQ3ZCO01BQ0MsSUFBSSxDQUFDTixTQUFTLEVBQUU7SUFDakIsQ0FBQyxNQUVEO01BQ0MsSUFBSSxDQUFDYyxZQUFZLEVBQUU7SUFDcEI7RUFDRCxDQUFDO0VBRURJLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQVU7SUFDakIxQixFQUFFLENBQUNVLEdBQUcsQ0FBQ2lCLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNuQyxJQUFJLENBQUNDLElBQUksQ0FBQ1YsTUFBTSxHQUFHLEtBQUs7RUFDekI7QUFHSixDQUFDLENBQUM7QUFDRlcsTUFBTSxDQUFDQyxPQUFPLEdBQUdoQyxVQUFVIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIEhvbm9yUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGl0ZW1QYXJlbnQ6Y2MuTm9kZSxcclxuICAgICAgICBpdGVtUHJlOmNjLlByZWZhYixcclxuICAgIH0sXHJcblxyXG4gICAgSW5pdFBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICBcdHZhciBEYXRhTGlzdCA9IGNjLk1nci5Vc2VyRGF0YU1nci5BY2hpZXZlbWVudExpc3Q7XHJcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDw9IERhdGFMaXN0Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgXHRcdHZhciBkYXRhID0gRGF0YUxpc3RbaV07XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLml0ZW1QcmUpO1xyXG4gICAgICAgICAgICBvYmoucGFyZW50ID0gdGhpcy5pdGVtUGFyZW50O1xyXG4gICAgICAgICAgICBvYmouYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkhvbm9ySXRlbVwiKS5TaG93RGF0YShkYXRhKTtcclxuICAgIFx0fVxyXG4gICAgfSxcclxuXHJcbiAgICBSZWZyZXNoUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgIFx0dmFyIERhdGFMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLkFjaGlldmVtZW50TGlzdDtcclxuICAgIFx0dmFyIGNoaWxkcmVuID0gdGhpcy5pdGVtUGFyZW50LmNoaWxkcmVuO1xyXG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8PSBjaGlsZHJlbi5sZW5ndGggLTE7IGkrKykge1xyXG4gICAgXHRcdHZhciBkYXRhID0gRGF0YUxpc3RbaV07XHJcbiAgICBcdFx0dmFyIHNjID0gY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiSG9ub3JJdGVtXCIpO1xyXG4gICBcdFx0XHRpZihzYyAhPSBudWxsKVxyXG4gICBcdFx0XHR7XHJcbiAgIFx0XHRcdFx0c2MuU2hvd0RhdGEoRGF0YUxpc3RbaV0pO1xyXG4gICBcdFx0XHR9XHJcbiAgICBcdH1cclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgIFx0dmFyIGNoaWxkcmVuID0gdGhpcy5pdGVtUGFyZW50LmNoaWxkcmVuO1xyXG4gICAgXHRpZihjaGlsZHJlbi5sZW5ndGggPT0gMClcclxuICAgIFx0e1xyXG4gICAgXHRcdHRoaXMuSW5pdFBhbmVsKCk7XHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZVxyXG4gICAgXHR7XHJcbiAgICBcdFx0dGhpcy5SZWZyZXNoUGFuZWwoKTtcclxuICAgIFx0fVxyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgIFx0dGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gSG9ub3JQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/JoyPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4bac35/yfZAh5YNUjx7LGPG', 'JoyPanel');
// Scripts/UI/JoyPanel.js

"use strict";

var MateUnLockType = require("MateUnLockType");
var JoyTipPanel = require("JoyTipPanel");
var JoyPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    joyTipPanel: JoyTipPanel
  },
  ClickOpenBet: function ClickOpenBet() {
    cc.Mgr.AudioMgr.playSFX("click");
    //如何计算 赌博花费
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenBetTip, {});
    //var param = {};
    //this.joyTipPanel.node.active = true;
    //var seed = 1 + Math.floor(Math.random() * 5);
    //param.text = "人生就像赌博，怕输的人永远赢不了";//cc.Mgr.global.getTranslation("ToDate_" + seed);
    //param.forWhat = "ToBet";

    //this.joyTipPanel.ShowPanel(param);
  },

  ClickOpenDateRation: function ClickOpenDateRation() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.joyTipPanel.node.active = true;
    var param = {};
    var seed = 1 + Math.floor(Math.random() * 5);
    param.text = cc.Mgr.global.getTranslation("ToDate_" + seed);
    param.forWhat = "ToDate";
    this.joyTipPanel.ShowPanel(param);
  },
  ClickAds: function ClickAds() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.text = "现在没有广告，过段时间再来";
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
  }
});
module.exports = JoyPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEpveVBhbmVsLmpzIl0sIm5hbWVzIjpbIk1hdGVVbkxvY2tUeXBlIiwicmVxdWlyZSIsIkpveVRpcFBhbmVsIiwiSm95UGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImpveVRpcFBhbmVsIiwiQ2xpY2tPcGVuQmV0IiwiTWdyIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIk9wZW5CZXRUaXAiLCJDbGlja09wZW5EYXRlUmF0aW9uIiwibm9kZSIsImFjdGl2ZSIsInBhcmFtIiwic2VlZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRleHQiLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsImZvcldoYXQiLCJTaG93UGFuZWwiLCJDbGlja0FkcyIsIk9wZW5Db21tb25UaXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLGNBQWMsR0FBR0MsT0FBTyxDQUFDLGdCQUFnQixDQUFDO0FBQzlDLElBQUlDLFdBQVcsR0FBR0QsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUN4QyxJQUFJRSxRQUFRLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3BCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFdBQVcsRUFBQ047RUFDaEIsQ0FBQztFQUVETyxZQUFZLEVBQUMsU0FBQUEsYUFBQSxFQUFZO0lBQ3JCTCxFQUFFLENBQUNNLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ25DO0lBQ0FSLEVBQUUsQ0FBQ1MsUUFBUSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQ1gsRUFBRSxDQUFDTSxHQUFHLENBQUNNLEtBQUssQ0FBQ0MsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3REO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7O0lBRUE7RUFDSixDQUFDOztFQUVEQyxtQkFBbUIsRUFBQyxTQUFBQSxvQkFBQSxFQUFVO0lBQzFCZCxFQUFFLENBQUNNLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUksQ0FBQ0osV0FBVyxDQUFDVyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJO0lBQ25DLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxJQUFJQyxJQUFJLEdBQUcsQ0FBQyxHQUFHQyxJQUFJLENBQUNDLEtBQUssQ0FBQ0QsSUFBSSxDQUFDRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDNUNKLEtBQUssQ0FBQ0ssSUFBSSxHQUFHdEIsRUFBRSxDQUFDTSxHQUFHLENBQUNpQixNQUFNLENBQUNDLGNBQWMsQ0FBQyxTQUFTLEdBQUdOLElBQUksQ0FBQztJQUMzREQsS0FBSyxDQUFDUSxPQUFPLEdBQUcsUUFBUTtJQUV4QixJQUFJLENBQUNyQixXQUFXLENBQUNzQixTQUFTLENBQUNULEtBQUssQ0FBQztFQUVyQyxDQUFDO0VBRURVLFFBQVEsRUFBQyxTQUFBQSxTQUFBLEVBQVU7SUFDZjNCLEVBQUUsQ0FBQ00sR0FBRyxDQUFDQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDbkMsSUFBSVMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNYQSxLQUFLLENBQUNLLElBQUksR0FBRyxlQUFlO0lBQzVCdEIsRUFBRSxDQUFDUyxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDWCxFQUFFLENBQUNNLEdBQUcsQ0FBQ00sS0FBSyxDQUFDZ0IsYUFBYSxFQUFFWCxLQUFLLENBQUM7RUFDbkU7QUFDSixDQUFDLENBQUM7QUFDRlksTUFBTSxDQUFDQyxPQUFPLEdBQUcvQixRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTWF0ZVVuTG9ja1R5cGUgPSByZXF1aXJlKFwiTWF0ZVVuTG9ja1R5cGVcIik7XHJcbnZhciBKb3lUaXBQYW5lbCA9IHJlcXVpcmUoXCJKb3lUaXBQYW5lbFwiKTtcclxudmFyIEpveVBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBqb3lUaXBQYW5lbDpKb3lUaXBQYW5lbCxcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tPcGVuQmV0OmZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgXHQvL+WmguS9leiuoeeulyDotYzljZroirHotLlcclxuICAgIFx0Y2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkJldFRpcCwge30pO1xyXG4gICAgICAgIC8vdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgLy90aGlzLmpveVRpcFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAvL3ZhciBzZWVkID0gMSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUpO1xyXG4gICAgICAgIC8vcGFyYW0udGV4dCA9IFwi5Lq655Sf5bCx5YOP6LWM5Y2a77yM5oCV6L6T55qE5Lq65rC46L+c6LWi5LiN5LqGXCI7Ly9jYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiVG9EYXRlX1wiICsgc2VlZCk7XHJcbiAgICAgICAgLy9wYXJhbS5mb3JXaGF0ID0gXCJUb0JldFwiO1xyXG5cclxuICAgICAgICAvL3RoaXMuam95VGlwUGFuZWwuU2hvd1BhbmVsKHBhcmFtKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tPcGVuRGF0ZVJhdGlvbjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5qb3lUaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgdmFyIHNlZWQgPSAxICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNSk7XHJcbiAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJUb0RhdGVfXCIgKyBzZWVkKTtcclxuICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJUb0RhdGVcIjtcclxuXHJcbiAgICAgICAgdGhpcy5qb3lUaXBQYW5lbC5TaG93UGFuZWwocGFyYW0pO1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja0FkczpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICBcdHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLnRleHQgPSBcIueOsOWcqOayoeacieW5v+WRiu+8jOi/h+auteaXtumXtOWGjeadpVwiO1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEpveVBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/JoyTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b0d71pcqI9Kmby0GAkLjo21', 'JoyTipPanel');
// Scripts/UI/JoyTipPanel.js

"use strict";

var MateUnLockType = require("MateUnLockType");
var JoyTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    desLbl: cc.RichText,
    forWhat: "",
    cost: cc.Integer
  },
  ShowPanel: function ShowPanel(data) {
    if (data.forWhat == "ToDate") {
      this.desLbl.string = "<color=#696969>" + data.text + "\n花费</c>" + "<color=#e77122>" + cc.Mgr.global.DateInitCost + "</c>" + "<color=#696969>元</c>";
    } else if (data.forWhat == "ToBet") {
      this.desLbl.string = "<color=#696969>" + data.text + "\n投注</c>" + "<color=#e77122>" + cc.Mgr.global.BetInitCost + "</c>" + "<color=#696969>元</c>";
    }
    if (data.forWhat != null) this.forWhat = data.forWhat;else this.forWhat = "";
  },
  ConfirmClick: function ConfirmClick() {
    if (this.forWhat == "ToDate") {
      if (cc.Mgr.UserDataMgr.Cash < cc.Mgr.global.DateInitCost) {
        var param = {};
        var sd = Math.floor(Math.random() * 2);
        param.text = cc.Mgr.global.getTranslation("NoMoneyDate_" + sd);
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
        this.ClosePanel();
        return;
      }
      var seed = Math.random();
      cc.Mgr.UserDataMgr.Cash -= cc.Mgr.global.DateInitCost;
      cc.Mgr.global.DateInitCost *= 2;
      if (seed < cc.Mgr.UserDataMgr.DateSuccescRatio) {
        cc.Mgr.UserDataMgr.UnLockOneMate(MateUnLockType.ToDate, cc.Mgr.UserDataMgr.Sex);
      } else {
        var param = {};
        var sd = Math.floor(Math.random() * 2);
        param.text = cc.Mgr.global.getTranslation("DateFail_" + sd);
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      }
      cc.director.GlobalEvent.emit(cc.Mgr.Event.RefreshCashAsset, {});
    } else if (this.forWhat == "ToBet") {
      if (cc.Mgr.UserDataMgr.Cash < cc.Mgr.global.BetInitCost) {
        var param = {};
        param.text = cc.Mgr.global.getTranslation("MoneyNotEnough");
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
        this.ClosePanel();
        return;
      }
      var seed = Math.random();
      cc.Mgr.UserDataMgr.Cash -= cc.Mgr.global.BetInitCost;
      if (seed < cc.Mgr.global.BetWinRation) {
        var param = {};
        cc.Mgr.UserDataMgr.Cash += cc.Mgr.global.BetInitCost * 3;
        var str = cc.Mgr.global.getTranslation("BetWin");
        param.text = str + cc.Mgr.global.BetInitCost * 3;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
        //cc.Mgr.UserDataMgr.UnLockOneMate(MateUnLockType.ToDate, cc.Mgr.UserDataMgr.Sex);
      } else {
        var param = {};
        param.text = cc.Mgr.global.getTranslation("BetLose");
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      }
      cc.Mgr.global.BetInitCost *= 2;
      cc.director.GlobalEvent.emit(cc.Mgr.Event.RefreshCashAsset, {});
    }
    this.ClosePanel();
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.forWhat = "";
    this.node.active = false;
  }
});
module.exports = JoyTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEpveVRpcFBhbmVsLmpzIl0sIm5hbWVzIjpbIk1hdGVVbkxvY2tUeXBlIiwicmVxdWlyZSIsIkpveVRpcFBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJkZXNMYmwiLCJSaWNoVGV4dCIsImZvcldoYXQiLCJjb3N0IiwiSW50ZWdlciIsIlNob3dQYW5lbCIsImRhdGEiLCJzdHJpbmciLCJ0ZXh0IiwiTWdyIiwiZ2xvYmFsIiwiRGF0ZUluaXRDb3N0IiwiQmV0SW5pdENvc3QiLCJDb25maXJtQ2xpY2siLCJVc2VyRGF0YU1nciIsIkNhc2giLCJwYXJhbSIsInNkIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZ2V0VHJhbnNsYXRpb24iLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vblRpcCIsIkNsb3NlUGFuZWwiLCJzZWVkIiwiRGF0ZVN1Y2Nlc2NSYXRpbyIsIlVuTG9ja09uZU1hdGUiLCJUb0RhdGUiLCJTZXgiLCJSZWZyZXNoQ2FzaEFzc2V0IiwiQmV0V2luUmF0aW9uIiwic3RyIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibm9kZSIsImFjdGl2ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsY0FBYyxHQUFHQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7QUFDOUMsSUFBSUMsV0FBVyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN2QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxNQUFNLEVBQUNKLEVBQUUsQ0FBQ0ssUUFBUTtJQUNsQkMsT0FBTyxFQUFDLEVBQUU7SUFDVkMsSUFBSSxFQUFDUCxFQUFFLENBQUNRO0VBQ1osQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBU0MsSUFBSSxFQUFDO0lBQ3BCLElBQUdBLElBQUks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cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTWF0ZVVuTG9ja1R5cGUgPSByZXF1aXJlKFwiTWF0ZVVuTG9ja1R5cGVcIik7XHJcbnZhciBKb3lUaXBQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgZGVzTGJsOmNjLlJpY2hUZXh0LFxyXG4gICAgICAgIGZvcldoYXQ6XCJcIixcclxuICAgICAgICBjb3N0OmNjLkludGVnZXIsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICBpZihkYXRhLmZvcldoYXQgPT0gXCJUb0RhdGVcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzTGJsLnN0cmluZyA9IFwiPGNvbG9yPSM2OTY5Njk+XCIrZGF0YS50ZXh0ICsgXCJcXG7oirHotLk8L2M+XCIgK1wiPGNvbG9yPSNlNzcxMjI+XCIrIGNjLk1nci5nbG9iYWwuRGF0ZUluaXRDb3N0K1wiPC9jPlwiICsgXCI8Y29sb3I9IzY5Njk2OT7lhYM8L2M+XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZGF0YS5mb3JXaGF0ID09IFwiVG9CZXRcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzTGJsLnN0cmluZyA9IFwiPGNvbG9yPSM2OTY5Njk+XCIrZGF0YS50ZXh0ICsgXCJcXG7mipXms6g8L2M+XCIgK1wiPGNvbG9yPSNlNzcxMjI+XCIrIGNjLk1nci5nbG9iYWwuQmV0SW5pdENvc3QgKyBcIjwvYz5cIiArIFwiPGNvbG9yPSM2OTY5Njk+5YWDPC9jPlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihkYXRhLmZvcldoYXQgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5mb3JXaGF0ID0gZGF0YS5mb3JXaGF0O1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5mb3JXaGF0ID0gXCJcIjtcclxuICAgIH0sXHJcblxyXG4gICAgQ29uZmlybUNsaWNrOmZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgICAgICBpZih0aGlzLmZvcldoYXQgPT0gXCJUb0RhdGVcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIDwgY2MuTWdyLmdsb2JhbC5EYXRlSW5pdENvc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjIpO1xyXG4gICAgICAgICAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJOb01vbmV5RGF0ZV9cIitzZCk7XHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwLCBwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkNsb3NlUGFuZWwoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNlZWQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCAtPSBjYy5NZ3IuZ2xvYmFsLkRhdGVJbml0Q29zdDtcclxuICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5EYXRlSW5pdENvc3QgKj0gMjtcclxuICAgICAgICAgICAgaWYoc2VlZCA8IGNjLk1nci5Vc2VyRGF0YU1nci5EYXRlU3VjY2VzY1JhdGlvKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuVW5Mb2NrT25lTWF0ZShNYXRlVW5Mb2NrVHlwZS5Ub0RhdGUsIGNjLk1nci5Vc2VyRGF0YU1nci5TZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMik7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIkRhdGVGYWlsX1wiK3NkKTtcclxuICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5SZWZyZXNoQ2FzaEFzc2V0LCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mb3JXaGF0ID09IFwiVG9CZXRcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIDwgY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIk1vbmV5Tm90RW5vdWdoXCIpO1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzZWVkID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggLT0gY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdDtcclxuXHJcbiAgICAgICAgICAgIGlmKHNlZWQgPCBjYy5NZ3IuZ2xvYmFsLkJldFdpblJhdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCArPSAoY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdCAqIDMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJCZXRXaW5cIik7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gc3RyKyAoY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdCAqIDMpO1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgLy9jYy5NZ3IuVXNlckRhdGFNZ3IuVW5Mb2NrT25lTWF0ZShNYXRlVW5Mb2NrVHlwZS5Ub0RhdGUsIGNjLk1nci5Vc2VyRGF0YU1nci5TZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIkJldExvc2VcIik7XHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5CZXRJbml0Q29zdCAqPSAyO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5SZWZyZXNoQ2FzaEFzc2V0LCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuQ2xvc2VQYW5lbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLmZvcldoYXQgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEpveVRpcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/GameScene.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ca544mVJuxCB4EzJTe1hDmP', 'GameScene');
// Scripts/UI/GameScene.js

"use strict";

var ItemType = require("ItemType");
var UserState = require("UserState");
var GoodsItem = require("GoodsItem");
var BuyTipPanel = require("BuyTipPanel");
var SaleTipPanel = require("SaleTipPanel");
var CommonTipPanel = require("CommonTipPanel");
var CompanyCreateTipPanel = require("CompanyCreateTipPanel");
var CompanyBuyTipPanel = require("CompanyBuyTipPanel");
var CompanySaleTipPanel = require("CompanySaleTipPanel");
var MateTipPanel = require("MateTipPanel");
var MateItemPanel = require("MateItemPanel");
var EnjoyPanel = require("EnjoyPanel");
var CommonBuyPanel = require("CommonBuyPanel");
var OwnedPanel = require("OwnedPanel");
var BetPanel = require("BetPanel");
var RetirePanel = require("RetirePanel");
var AddCapacityPanel = require("AddCapacity");
var MarketTipPanel = require("MarketTipPanel");
var TreatPanel = require("TreatPanel");
var EventTipPanel = require("EventPanel");
var EventResultPanel = require("EventResultPanel");
var WatchAdsPanel = require("WatchAdsPanel");
var MarryPanel = require("MarryPanel");
var TutorialPanel = require("TutorialPanel");
var TimePanel = require("TimePanel");
var AdsRetirePanel = require("AdsRetirePanel");
var UnlockMatePanel = require("UnlockMatePanel");
var RankPanel = require("RankPanel");
var TutorialStep = require("TutorialStep");
var eyouClientTiktok = require('EyouClientTiktok');
var eyouClientKs = require('EyouClientKs');
var GameScene = cc.Class({
  "extends": cc.Component,
  properties: {
    MainAtlas: cc.SpriteAtlas,
    BigApAtlas: cc.SpriteAtlas,
    CashLbl: cc.Label,
    AssetLbl: cc.Label,
    CurAgeLbl: cc.Label,
    TotalAgeLbl: cc.Label,
    HpLbl: cc.Label,
    ReputationLbl: cc.Label,
    CapcityLbl: cc.Label,
    HpIcon: cc.Sprite,
    MarketItem: cc.Prefab,
    OwnItem: cc.Prefab,
    CompanyItem: cc.Prefab,
    MarketParent: cc.Node,
    OwnParent: cc.Node,
    CompanyParent: cc.Node,
    MarketPanel: cc.Node,
    BusinessPanel: cc.Node,
    WatchAdsBtn: cc.Sprite,
    TipCashSp: cc.Sprite,
    MarketTipPanel: MarketTipPanel,
    //市场行情提示
    BuyTip: BuyTipPanel,
    SaleTip: SaleTipPanel,
    CommonTip: CommonTipPanel,
    CompanyCreatePanel: CompanyCreateTipPanel,
    StockBuyTipPanel: CompanyBuyTipPanel,
    StockSaleTipPanel: CompanySaleTipPanel,
    MatePanel: MateTipPanel,
    MateItemTip: MateItemPanel,
    EnjoyTipPanel: EnjoyPanel,
    CommonBuyTipPanel: CommonBuyPanel,
    OwnedTipPanel: OwnedPanel,
    BetTipPanel: BetPanel,
    RetirePanelTip: RetirePanel,
    AdsRetirePanel: AdsRetirePanel,
    UnlockMatePanel: UnlockMatePanel,
    rankPanel: RankPanel,
    TreatPanel: TreatPanel,
    EventPanel: EventTipPanel,
    EventResultPanel: EventResultPanel,
    AddCapPanel: AddCapacityPanel,
    WatchAdsPanel: WatchAdsPanel,
    MarryPanel: MarryPanel,
    TutorialPanel: TutorialPanel,
    TimePanel: TimePanel,
    toggleMarket: cc.Toggle,
    toggleBussiness: cc.Toggle,
    toggleMate: cc.Toggle,
    toggleEnjoy: cc.Toggle,
    MateNewTip: cc.Node,
    AdSp: "aishen",
    wxSubContextView: cc.Node,
    SwanSubContextView: cc.Node,
    marketTipData: null,
    screenRecordingBtn: cc.Node,
    desktopBtn: cc.Node,
    useBtn: cc.Node
  },
  onLoad: function onLoad() {
    //監聽打開購買
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenBuyTip, function (data) {
      this.BuyTip.node.active = true;
      this.BuyTip.ShowPanel(data);
    }, this);
    //監聽購買成功
    cc.director.GlobalEvent.on(cc.Mgr.Event.BuySuccess, function (data) {
      this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshOwnedItems(data);
      this.RefreshUIShow();
    }, this);
    //监听 出售窗口
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenSaleTip, function (data) {
      this.SaleTip.node.active = true;
      this.SaleTip.ShowPanel(data);
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.SaleSuccess, function (data) {
      this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshOwnedItems(data);
      this.RefreshUIShow();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenCommonTip, function (data) {
      if (cc.Mgr.global.tutorialStep != -1) {
        this.CommonTip.node.active = false;
        return;
      }
      if (this.CommonTip.node.active == true) {
        return;
      }
      this.CommonTip.node.active = true;
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.CommonTip.ShowPanel(data);
      if (data.forWhat != null && data.forWhat == "Event_Yes") {
        //cc.log("----------------"+ data.Pdata.Id)
        if (data.Pdata.Id != -1) this.RefreshOwnedItems(data.Pdata);
        this.RefreshUIShow();
      }
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenEventResult, function (data) {
      this.EventResultPanel.node.active = true;
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.EventResultPanel.ShowPanel(data);
      if (data.forWhat != null && data.forWhat == "Event_Yes") {
        if (data.Pdata.Id != -1) this.RefreshOwnedItems(data.Pdata);else if (data.Pdata.companyId != -1) this.RefreshCompanyItemsFromEvent(data.Pdata.companyId);
        this.RefreshUIShow();
      }
    }, this);

    //打开创办公司panel
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenCompanyCreate, function (data) {
      this.CompanyCreatePanel.node.active = true;
      this.CompanyCreatePanel.ShowPanel(data);
    }, this);

    //创办公司
    cc.director.GlobalEvent.on(cc.Mgr.Event.CreateCompanySuccess, function (data) {
      this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
      this.RefreshCompanyItemsAfterBuy(data);
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
      this.CheckTutorialHappen(); //创办玩公司有一次引导
    }, this);

    //打开购买股票panel
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenStuckBuyTip, function (data) {
      this.StockBuyTipPanel.node.active = true;
      this.StockBuyTipPanel.ShowPanel(data);
    }, this);

    //购买股票成功
    cc.director.GlobalEvent.on(cc.Mgr.Event.BuyStockSuccess, function (data) {
      this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
      this.RefreshCompanyItemsAfterBuy(data);
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
    }, this);

    //打开出售股票panel
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenStuckSaleTip, function (data) {
      this.StockSaleTipPanel.node.active = true;
      this.StockSaleTipPanel.ShowPanel(data);
    }, this);

    //出售股票成功
    cc.director.GlobalEvent.on(cc.Mgr.Event.SaleStockSuccess, function (data) {
      this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
      this.RefreshCompanyItemsAfterBuy(data);
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
    }, this);

    //打开约会提示面板
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenMateTip, function (data) {
      this.MateItemTip.node.active = true;
      this.MateItemTip.ShowPanel(data);
    }, this);

    //打开约会完成
    cc.director.GlobalEvent.on(cc.Mgr.Event.DateSuccess, function (data) {
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshMateItemUI(data.Id);
      this.RefreshUIShow();
      //this.StartMateLoveTutorial();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.DateLater, function (data) {
      this.StartMateLoveTutorial();
    }, this);

    //打开共用买
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenCommonBuy, function (data) {
      //cc.log("收到打开");
      this.CommonBuyTipPanel.node.active = true;
      this.CommonBuyTipPanel.ShowPanel(data);
    }, this);

    //共用买mai 成功返回
    cc.director.GlobalEvent.on(cc.Mgr.Event.CommonBuySaleSuccess, function (data) {
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
      if (data.flag == "Sale") this.OwnedTipPanel.ShowPanel();
      if (data.Disvorce && data.Disvorce == true) {
        this.RefreshCompanyItemsAfterDisvorce();
        this.MatePanel.RefreshPanelItems();
        cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      }
    }, this);

    //治疗完成
    cc.director.GlobalEvent.on(cc.Mgr.Event.TreatSuccess, function (data) {
      cc.Mgr.UserDataMgr.userState = UserState.OK;
      cc.Mgr.UserDataMgr.RecoverYear = 0;
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
      ////cc.log("----------------士大夫胜多负少-----------------------" + cc.Mgr.UserDataMgr.HpPoint);
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.RefreshCashAsset, function (data) {
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
    }, this);

    //赌博
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenBetTip, function (data) {
      this.BetTipPanel.node.active = true;
      this.RefreshUIShow();
      this.BetTipPanel.ShowPanel(data);
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenUnLockMate, function (data) {
      this.UnlockMatePanel.node.active = true;
      this.MateNewTip.active = true;
      this.UnlockMatePanel.ShowPanel(data);
      this.MatePanel.RefreshPanelItems();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.Retire, function (data) {
      this.RetirePanelTip.node.active = true;
      this.RetirePanelTip.ShowPanel();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.RefreshAllUIShow, function (data) {
      this.RefreshUIShow();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.UseRetireAdsSkill, function (data) {
      this.AdsRetirePanel.node.active = true;
      this.AdsRetirePanel.ShowPanel();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.AddWareHouseCapacity, function (data) {
      cc.Mgr.UserDataMgr.RefreshUserAssets(false);
      this.RefreshUIShow();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenMarry, function (data) {
      this.MarryPanel.node.active = true;
      this.MarryPanel.ShowPanel(data);
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenTutorial, function (data) {
      this.TutorialPanel.node.active = true;
      this.TutorialPanel.ShowPanel(data);
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.ClockEnd, function (data) {
      this.ToNextYear();
    }, this);
    cc.director.GlobalEvent.on(cc.Mgr.Event.OpenEnjoy, function (data) {
      this.ChooseOpenEnjoy();
    }, this);

    //打开创办公司panel
    cc.director.GlobalEvent.on(cc.Mgr.Event.ShareVideo, function (data) {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.BYTEDANCE_GAME === cc.sys.platform) {
        var shareAppMessageInfo = {
          channel: 'video',
          extra: {
            videoPath: data.videoPath
          }
        };
        eyouClientTiktok.getIns().shareAppMessage(shareAppMessageInfo, function (shareAppMessageCallback) {
          console.log('分享录屏回调:>', shareAppMessageCallback);
        });
      } else if (isKuaiShou) {
        var publishVideoInfo = {
          videoID: data.videoPath
        };
        eyouClientKs.getIns().publishVideo(publishVideoInfo);
      }
    }, this);
  },
  start: function start() {
    this.initTopUIData();
    //初始化市场数据
    this.InitMarketItems();
    //初始化已经有的物品
    this.InitOwnedItems();
    //初始化股市公司数据
    this.InitCompanyItems();
    this.refreshAdsSp(3);
    cc.Mgr.AdsMgr.HideBannerAd();
    this.dealScreenRecordingBtnShow();
    this.desktopUseBtnShow();
  },
  dealScreenRecordingBtnShow: function dealScreenRecordingBtnShow() {
    var _this = this;
    eyouClientTiktok.getIns().screenRecordingFlag = 0;
    eyouClientKs.getIns().screenRecordingFlag = 0;
    this.syncScreenRecordingShow();
    var isKuaiShou = false;
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      isKuaiShou = true;
    }
    if (cc.sys.BYTEDANCE_GAME === cc.sys.platform) {
      var createGameRecorderInfo = {
        onStart: function onStart() {},
        onStop: function onStop(onStopRes) {
          eyouClientTiktok.getIns().screenRecordingFlag = 0;
          if (Date.now() - eyouClientTiktok.getIns().screenRecordingTime < 3000) {
            if (_this.CommonTip.node.active !== true) {
              _this.CommonTip.node.active = true;
              _this.CommonTip.ShowPanel({
                text: '录屏时间必须大于3秒'
              });
            }
            return;
          }
          if (_this.CommonTip.node.active !== true) {
            _this.CommonTip.node.active = true;
            _this.CommonTip.ShowPanel({
              text: '是否分享本次录屏',
              forWhat: 'shareVideo',
              videoPath: onStopRes.videoPath
            });
          }
        },
        onError: function onError(errMsg) {
          console.error('录屏异常:>', errMsg);
          eyouClientTiktok.getIns().screenRecordingFlag = 0;
          _this.syncScreenRecordingShow();
        },
        onInterruptionBegin: function onInterruptionBegin() {
          eyouClientTiktok.getIns().screenRecordingFlag = 0;
          _this.syncScreenRecordingShow();
          if (_this.CommonTip.node.active !== true) {
            _this.CommonTip.node.active = true;
            _this.CommonTip.ShowPanel({
              text: '录屏时间必须小于300秒'
            });
          }
        }
      };

      // 创建录屏管理工具
      eyouClientTiktok.getIns().createGameRecorder(createGameRecorderInfo, function (createGameRecorderCallback) {
        console.log('创建录屏管理工具回调:>', createGameRecorderCallback);
        if (createGameRecorderCallback.code === 0) {
          _this.screenRecordingBtn.active = true;
        }
      });
    } else if (isKuaiShou) {
      var _createGameRecorderInfo = {
        onStart: function onStart(res) {
          console.log("录屏开始:", res);
        },
        onStop: function onStop(stopRes) {
          console.log("结束录制:", stopRes);
          eyouClientKs.getIns().screenRecordingFlag = 0;
          if (Date.now() - eyouClientKs.getIns().screenRecordingTime < 3000) {
            if (_this.CommonTip.node.active !== true) {
              _this.CommonTip.node.active = true;
              _this.CommonTip.ShowPanel({
                text: '录屏时间必须大于3秒'
              });
            }
            return;
          }
          if (_this.CommonTip.node.active !== true) {
            console.log("是否分享本次录屏:", stopRes);
            _this.CommonTip.node.active = true;
            _this.CommonTip.ShowPanel({
              text: '是否分享本次录屏',
              forWhat: 'shareVideo',
              videoPath: stopRes.videoId
            });
          }
        },
        onError: function onError(errMsg) {
          var error = errMsg.error;
          console.error('录屏错误信息:>', error);
          eyouClientKs.getIns().screenRecordingFlag = 0;
          _this.syncScreenRecordingShow();
          if (error.code === ks.error.GameRecorder_RecordFailedTimeRangeTooShort) {
            if (_this.CommonTip.node.active !== true) {
              _this.CommonTip.node.active = true;
              _this.CommonTip.ShowPanel({
                text: '录制结束，录制时间太短'
              });
            }
          }
          if (error.code === ks.error.GameRecorder_RecordFailedTimeRangeTooLong) {
            if (_this.CommonTip.node.active !== true) {
              _this.CommonTip.node.active = true;
              _this.CommonTip.ShowPanel({
                text: '录制结束，录制时间太长'
              });
            }
          }
          if (error.code === ks.error.GameRecorder_RecordFailedNoVideo) {
            if (_this.CommonTip.node.active !== true) {
              _this.CommonTip.node.active = true;
              _this.CommonTip.ShowPanel({
                text: '录制结束，未录制到视频'
              });
            }
          }
          if (error.code === ks.error.GameRecorder_PublishVideoFailed) {
            if (_this.CommonTip.node.active !== true) {
              _this.CommonTip.node.active = true;
              _this.CommonTip.ShowPanel({
                text: '录屏失败'
              });
            }
          }
        },
        onAbort: function onAbort(res) {
          eyouClientKs.getIns().screenRecordingFlag = 0;
          _this.syncScreenRecordingShow();
          if (_this.CommonTip.node.active !== true) {
            _this.CommonTip.node.active = true;
            _this.CommonTip.ShowPanel({
              text: '录屏时间必须小于300秒'
            });
          }
        }
      };

      // 创建录屏管理工具
      eyouClientKs.getIns().createGameRecorder(_createGameRecorderInfo, function (createGameRecorderCallback) {
        console.log('创建快手录屏管理工具回调:>', createGameRecorderCallback);
        if (createGameRecorderCallback.code === 0) {
          _this.screenRecordingBtn.active = true;
        }
      });
    } else {
      this.screenRecordingBtn.active = false;
    }
  },
  onBtnScreenRecordingClick: function onBtnScreenRecordingClick() {
    var isKuaiShou = false;
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      isKuaiShou = true;
    }
    if (cc.sys.BYTEDANCE_GAME === cc.sys.platform) {
      if (eyouClientTiktok.getIns().screenRecordingFlag === 0) {
        eyouClientTiktok.getIns().gameRecorderStart({
          duration: 300
        });
        eyouClientTiktok.getIns().screenRecordingFlag = 1;
        eyouClientTiktok.getIns().screenRecordingTime = Date.now();
      } else {
        eyouClientTiktok.getIns().gameRecorderStop();
        eyouClientTiktok.getIns().screenRecordingFlag = 0;
      }
    } else {
      if (eyouClientKs.getIns().screenRecordingFlag === 0) {
        eyouClientKs.getIns().gameRecorderStart();
        eyouClientKs.getIns().screenRecordingFlag = 1;
        eyouClientKs.getIns().screenRecordingTime = Date.now();
      } else {
        console.log("按钮点击了停止录屏事件");
        eyouClientKs.getIns().gameRecorderStop();
        eyouClientKs.getIns().screenRecordingFlag = 0;
      }
    }
    this.syncScreenRecordingShow();
  },
  syncScreenRecordingShow: function syncScreenRecordingShow() {
    var _this2 = this;
    var isKuaiShou = false;
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      isKuaiShou = true;
    }
    var index = isKuaiShou ? eyouClientKs.getIns().screenRecordingFlag : eyouClientTiktok.getIns().screenRecordingFlag;
    var path = '/atlas/screenRecording-' + index;
    cc.loader.loadRes(path, cc.SpriteFrame, function (err, spriteFrame) {
      if (err) {
        console.error('set sprite frame failed! err', path, err);
        return;
      }
      _this2.screenRecordingBtn.getComponent(cc.Sprite).spriteFrame = spriteFrame;
    });
  },
  desktopUseBtnShow: function desktopUseBtnShow() {
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      //检查用户是否已经将小游戏设为常用
      var use = this.useBtn;
      ks.checkCommonUse({
        success: function success(res) {
          console.log("\u8BBE\u4E3A\u5E38\u7528\u67E5\u8BE2\u7ED3\u679C\u4E3A\uFF1A" + res.isCommonUse);
          use.active = !res.isCommonUse;
        },
        fail: function fail(err) {
          console.log("小游戏设为常用失败回调:", JSON.stringify(err));
        },
        complete: function complete(res) {
          console.log("小游戏设为常用回调:", JSON.stringify(res));
        }
      });

      //检查小游戏快捷方式是否已添加到手机桌面上，仅 Android 支持
      var desktop = this.desktopBtn;
      ks.checkShortcut({
        success: function success(res) {
          //根据res.installed 来判断是否添加成功
          console.log("是否已添加快捷方式", res.installed);
          desktop.active = !res.installed;
        },
        fail: function fail(err) {
          if (err.code === -10005) {
            console.log("暂不支持检查用户是否已添加手机桌面该功能");
          } else {
            console.log("检查快捷方式失败", err.msg);
            //注意：快捷方式和mini apk的方式，用户装了哪种都算成功走success回调。
            //但是如果都没装的情况下，为兼容以前版本，会先判断快捷方式，再判断mini apk的方式，这种情况最后会走到fail回调
            //所以当err.msg为"apk info is invalid"的情况出现时，也可以在游戏内展示添加桌面的icon提醒用户。
          }
        }
      });
    } else {
      this.desktopBtn.active = false;
      this.useBtn.active = false;
    }
  },
  onDesktopClick: function onDesktopClick() {
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      eyouClientKs.getIns().addShortcut(function (res) {
        console.log("添加桌面快捷方式结果:", JSON.stringify(res));
      });
    }
  },
  onUseClick: function onUseClick() {
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      eyouClientKs.getIns().addCommonUse(function (res) {
        console.log("设为常用结果:", JSON.stringify(res));
      });
    }
  },
  refreshAdsSp: function refreshAdsSp(seed) {
    if (seed == 1) this.AdSp = "aishen";else if (seed == 2) this.AdSp = "dushen";else if (seed == 3) this.AdSp = "caishen";else this.AdSp = "gushen";
    this.WatchAdsBtn.spriteFrame = this.BigApAtlas.getSpriteFrame(this.AdSp);
  },
  //初始化现金
  initCash: function initCash() {
    var seed = Math.random();
    if (cc.Mgr.UserDataMgr.tutorialInMarket == false) {
      seed = 0.999;
    }
    var param = {};
    if (seed <= cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Cash, 1).weight) {
      cc.Mgr.global.InitGetMoneyId = 1;
      param.text = cc.Mgr.global.getTranslation("Cash_1"); //cc.director.NoticeText.Cash_1;
      cc.Mgr.UserDataMgr.Cash = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Cash, 1).cash;
    } else if (seed <= cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Cash, 1).weight + cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Cash, 2).weight) {
      cc.Mgr.global.InitGetMoneyId = 2;
      param.text = cc.Mgr.global.getTranslation("Cash_2"); //cc.director.NoticeText.Cash_2;
      cc.Mgr.UserDataMgr.Cash = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Cash, 2).cash;
    } else {
      cc.Mgr.global.InitGetMoneyId = 3;
      this.TipCashSp.spriteFrame = this.MainAtlas.getSpriteFrame("bsqj");
      param.text = cc.Mgr.global.getTranslation("Cash_3"); //cc.director.NoticeText.Cash_3;
      cc.Mgr.UserDataMgr.Cash = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Cash, 3).cash;
    }
    if (this.CommonTip.active == true) {
      //cc.log("通用提示已经在展示");
    } else {
      this.CommonTip.node.active = true;
      this.CommonTip.ShowPanel(param);
    }
    cc.Mgr.UserDataMgr.Cash += cc.Mgr.UserDataMgr.InitMoneyBonus; //加上初始加成

    cc.Mgr.UserDataMgr.AssetsMoney = cc.Mgr.UserDataMgr.Cash;
    cc.Mgr.UserDataMgr.HighAssets = cc.Mgr.UserDataMgr.AssetsMoney;
  },
  //初始化Top UI 
  initTopUIData: function initTopUIData() {
    this.initCash();
    this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
    this.AssetLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.AssetsMoney);
    this.CurAgeLbl.string = cc.Mgr.UserDataMgr.Age;
    this.TotalAgeLbl.string = cc.Mgr.UserDataMgr.retireAge;
    this.HpLbl.string = cc.Mgr.UserDataMgr.HpPoint;
    this.ReputationLbl.string = cc.Mgr.UserDataMgr.Reputation;
    var lastCap = cc.Mgr.UserDataMgr.WareHouseAllCapcity - cc.Mgr.UserDataMgr.WareHouseCapcity;
    this.CapcityLbl.string = "(" + lastCap + "/" + cc.Mgr.UserDataMgr.WareHouseAllCapcity + ")";
  },
  //初始化市场 items
  InitMarketItems: function InitMarketItems() {
    cc.Mgr.UserDataMgr.ClearShowGoodsList();
    var DataList = cc.Mgr.MapDataMgr.getDataListBySex(cc.Mgr.UserDataMgr.Sex);
    var showArr = this.getArrayByItems(DataList.length, 5);
    var param = [];
    for (var i = DataList.length - 1; i >= 0; i--) {
      var data = DataList[i];
      var obj = cc.instantiate(this.MarketItem);
      obj.parent = this.MarketParent;
      obj.active = false;
      obj.getComponent("GoodsItem").init(data);
      for (var j = showArr.length - 1; j >= 0; j--) {
        if (i == showArr[j]) {
          var data = null;
          if (cc.Mgr.UserDataMgr.tutorialInMarket == false) {
            data = obj.getComponent("GoodsItem").refreshLowPrice();
          } else {
            data = obj.getComponent("GoodsItem").refreshPrice();
          }
          param.push(data);
          cc.Mgr.UserDataMgr.InsertGoodsIdToList(data.Id);
          obj.active = true;
          break;
        }
      }
    }
    this.MarketTipPanel.node.active = true;
    this.MarketTipPanel.ShowPanel(param);
    if (cc.Mgr.UserDataMgr.tutorialInMarket == false) {
      cc.Mgr.global.tutorialStep = 11; //开始引导第一步
      var self = this;
      this.TutorialPanel.SetCallFunc(function () {
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenBuyTip, param[0]);
        cc.Mgr.global.tutorialStep = 12;
        var dt = {};
        dt.step = 12;
        self.TutorialPanel.ShowPanel(dt);
        self.TutorialPanel.SetCallFunc(function () {
          cc.Mgr.global.tutorialGoodsId = self.BuyTip.ClickBuyBtn();
          cc.Mgr.global.tutorialStep = 13;
          var d3 = {};
          d3.step = 13;
          self.TutorialPanel.ShowPanel(d3);
          self.TutorialPanel.SetCallFunc(function () {
            //self.RefreshDataToNextYear();
            self.ToNextYear();
            cc.Mgr.global.tutorialStep = 14;
            var d4 = {};
            d4.step = 14;
            self.TutorialPanel.ShowPanel(d4);
            self.TutorialPanel.SetCallFunc(function () {
              cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenSaleTip, cc.Mgr.UserDataMgr.getGoodsDataById(param[0].Id));
              cc.Mgr.global.tutorialStep = 15;
              var d5 = {};
              d5.step = 15;
              self.TutorialPanel.ShowPanel(d5);
              self.TutorialPanel.SetCallFunc(function () {
                self.SaleTip.ClickSaleBtn();
                cc.Mgr.global.tutorialStep = -1;
                cc.Mgr.UserDataMgr.tutorialInMarket = true;
                self.TutorialPanel.node.active = false;
              });
            });
          });
        });
      });
    }
  },
  //向下刷新一年
  RefreshDataToNextYear: function RefreshDataToNextYear() {
    if (cc.Mgr.global.tutorialStep == 13) {
      //cc.log("引导时间=====================");
      cc.Mgr.UserDataMgr.RefreshUserAge();
      this.RefreshTutorialItems();
    } else {
      this.TimePanel.node.active = true;
      this.TimePanel.PlayAnima();
    }
    /*
    cc.Mgr.UserDataMgr.RefreshUserAge();
    cc.Mgr.AudioMgr.playSFX("click");
    this.CheckTutorialHappen();
      this.RefreshCompanyItems();
    if(cc.Mgr.global.tutorialStep == 13)
    {
        this.RefreshTutorialItems();
    }
    else
    {
        this.RefreshItems();
    }
      this.RefreshOwnedItemsState();
      cc.Mgr.UserDataMgr.RefreshUserAssets(true);
    
    //加成奖励
    cc.Mgr.UserDataMgr.GetBonusRewardEveryYear();
      cc.Mgr.UserDataMgr.RefreshHealthHp();
      this.RefreshUIShow();
      this.CheckEventHappen();
    */
  },

  ToNextYear: function ToNextYear() {
    this.marketTipData = null;
    cc.Mgr.UserDataMgr.RefreshUserAge();
    //cc.Mgr.AudioMgr.playSFX("click");
    this.CheckTutorialHappen();
    this.RefreshCompanyItems();
    if (cc.Mgr.global.tutorialStep == 13) {
      ////cc.log("==============================引导时间==============================");
      this.RefreshTutorialItems();
    } else {
      if (cc.Mgr.UserDataMgr.Age == 22 || cc.Mgr.UserDataMgr.Age == 24 || cc.Mgr.UserDataMgr.Age == 25 || cc.Mgr.UserDataMgr.Age == 27 || cc.Mgr.UserDataMgr.Age == 28 || cc.Mgr.UserDataMgr.Age == 30) {
        this.RefreshItemsForSpecialAge();
      } else {
        this.RefreshItems();
      }
    }
    this.RefreshOwnedItemsState();
    //加成奖励
    cc.Mgr.UserDataMgr.GetBonusRewardEveryYear();
    cc.Mgr.UserDataMgr.RefreshUserAssets(true);
    cc.Mgr.UserDataMgr.RefreshHealthHp();
    this.RefreshUIShow();
    this.CheckEventHappen();
  },
  CheckTutorialHappen: function CheckTutorialHappen() {
    if (cc.Mgr.UserDataMgr.Age == 25 && cc.Mgr.UserDataMgr.tutorialInDate == false) {
      cc.Mgr.global.tutorialStep = TutorialStep.MateDate_1;
      var dt = {};
      dt.step = TutorialStep.MateDate_1;
      this.TutorialPanel.node.active = true;
      this.TutorialPanel.ShowPanel(dt);
      var self = this;
      self.TutorialPanel.SetCallFunc(function () {
        self.ChooseOpenMatePanel();
        cc.Mgr.global.tutorialStep = TutorialStep.MateDate_2;
        var dt = {};
        dt.step = TutorialStep.MateDate_2;
        self.TutorialPanel.ShowPanel(dt);
        self.TutorialPanel.SetCallFunc(function () {
          cc.Mgr.global.tutorialStep = -1;
          self.TutorialPanel.node.active = false;
          cc.Mgr.UserDataMgr.tutorialInDate = true;
        });
      });
    }
    if (cc.Mgr.UserDataMgr.Age == 30 && cc.Mgr.UserDataMgr.tutorialInBus == false) {
      cc.Mgr.global.tutorialStep = TutorialStep.Business_1;
      var dt = {};
      dt.step = TutorialStep.Business_1;
      this.TutorialPanel.node.active = true;
      this.TutorialPanel.ShowPanel(dt);
      var self = this;
      self.TutorialPanel.SetCallFunc(function () {
        self.ChooseOpenBusisness();
        cc.Mgr.global.tutorialStep = TutorialStep.Business_2;
        var dt = {};
        dt.step = TutorialStep.Business_2;
        self.TutorialPanel.ShowPanel(dt);
        self.TutorialPanel.SetCallFunc(function () {
          cc.Mgr.global.tutorialStep = -1;
          self.TutorialPanel.node.active = false;
          cc.Mgr.UserDataMgr.tutorialInBus = true;
        });
      });
    }
    if (cc.Mgr.UserDataMgr.hasCompany == true && cc.Mgr.UserDataMgr.tutorialStockBonus == false) {
      cc.Mgr.global.tutorialStep = TutorialStep.StockBonus_1;
      var dt = {};
      dt.step = TutorialStep.StockBonus_1;
      this.TutorialPanel.node.active = true;
      this.TutorialPanel.ShowPanel(dt);
      var self = this;
      self.TutorialPanel.SetCallFunc(function () {
        cc.Mgr.global.tutorialStep = -1;
        self.TutorialPanel.node.active = false;
        cc.Mgr.UserDataMgr.tutorialStockBonus = true;
      });
    }
  },
  StartMateLoveTutorial: function StartMateLoveTutorial() {
    if (cc.Mgr.UserDataMgr.tutorialMatePoint == false) {
      cc.Mgr.global.tutorialStep = TutorialStep.DateToMarry_1;
      var dt = {};
      dt.step = TutorialStep.DateToMarry_1;
      this.TutorialPanel.node.active = true;
      this.TutorialPanel.ShowPanel(dt);
      var self = this;
      self.TutorialPanel.SetCallFunc(function () {
        cc.Mgr.global.tutorialStep = -1;
        self.TutorialPanel.node.active = false;
        cc.Mgr.UserDataMgr.tutorialMatePoint = true;
      });
    }
  },
  CheckEventHappen: function CheckEventHappen() {
    if (cc.Mgr.global.tutorialStep != -1) {
      return;
    }
    if (cc.Mgr.UserDataMgr.Age <= 25) {
      return;
    }
    if (cc.Mgr.UserDataMgr.EventDataIdList.length == 0) {
      //cc.log("沒有事件Id 了  直接返回");
      return;
    }
    if (cc.Mgr.UserDataMgr.Age == cc.Mgr.global.LastEventAge) {
      var eId = cc.Mgr.UserDataMgr.GetEventDataAndSpliceId();
      this.EventPanel.node.active = true;
      this.EventPanel.ShowPanel(eId);
      cc.Mgr.global.LastEventAge = cc.Mgr.UserDataMgr.Age;
    } else {
      var seed = cc.Mgr.global.SpawnSeedBetweenTwoNum(2, 3);
      //cc.log("cc.Mgr.UserDataMgr.Age = "+  cc.Mgr.UserDataMgr.Age+"   seed = " + seed + "  事件------------------ LastEventAge " + cc.Mgr.global.LastEventAge);
      if (cc.Mgr.UserDataMgr.Age - seed >= cc.Mgr.global.LastEventAge) {
        var eId = cc.Mgr.UserDataMgr.GetEventDataAndSpliceId();
        this.EventPanel.node.active = true;
        this.EventPanel.ShowPanel(eId);
        cc.Mgr.global.LastEventAge = cc.Mgr.UserDataMgr.Age;
      }
    }
  },
  //刷新UI
  RefreshUIShow: function RefreshUIShow() {
    this.ReputationLbl.string = cc.Mgr.UserDataMgr.Reputation;
    this.CashLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.Cash);
    this.AssetLbl.string = cc.Mgr.global.FormatNum(cc.Mgr.UserDataMgr.AssetsMoney);
    this.CurAgeLbl.string = cc.Mgr.UserDataMgr.Age;
    this.TotalAgeLbl.string = cc.Mgr.UserDataMgr.retireAge;
    this.HpLbl.string = cc.Mgr.UserDataMgr.HpPoint;
    this.RefreshHpIconSp();
    var lastCap = cc.Mgr.UserDataMgr.WareHouseAllCapcity - cc.Mgr.UserDataMgr.WareHouseCapcity;
    this.CapcityLbl.string = "(" + lastCap + "/" + cc.Mgr.UserDataMgr.WareHouseAllCapcity + ")";
    if (cc.Mgr.UserDataMgr.AssetsMoney < 100000) {
      this.TipCashSp.spriteFrame = this.MainAtlas.getSpriteFrame("bsqj");
    } else if (cc.Mgr.UserDataMgr.AssetsMoney > 100000 && cc.Mgr.UserDataMgr.AssetsMoney < 1000000) {
      this.TipCashSp.spriteFrame = this.MainAtlas.getSpriteFrame("scxx");
    } else if (cc.Mgr.UserDataMgr.AssetsMoney > 1000000 && cc.Mgr.UserDataMgr.AssetsMoney < 10000000) {
      this.TipCashSp.spriteFrame = this.MainAtlas.getSpriteFrame("sylx");
    } else if (cc.Mgr.UserDataMgr.AssetsMoney > 100000000) {
      this.TipCashSp.spriteFrame = this.MainAtlas.getSpriteFrame("bdzc");
    }
  },
  RefreshHpIconSp: function RefreshHpIconSp() {
    if (cc.Mgr.UserDataMgr.HpPoint >= cc.Mgr.global.HpStateA) {
      this.HpIcon.spriteFrame = this.MainAtlas.getSpriteFrame("state_1");
    } else if (cc.Mgr.UserDataMgr.HpPoint >= cc.Mgr.global.HpStateB) {
      this.HpIcon.spriteFrame = this.MainAtlas.getSpriteFrame("state_2");
    } else if (cc.Mgr.UserDataMgr.HpPoint <= cc.Mgr.global.HpStateC) {
      this.HpIcon.spriteFrame = this.MainAtlas.getSpriteFrame("state_3");
    }
  },
  //约会完成数据刷新返回
  RefreshMateItemUI: function RefreshMateItemUI(Id) {
    this.MatePanel.RefreshPanel(Id);
  },
  //随着年份刷新 刷新展示的物品 只刷出高价
  RefreshTutorialItems: function RefreshTutorialItems() {
    var children = this.MarketParent.children;
    var param = []; //数据
    this.marketTipData = null;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("GoodsItem");
      if (sc != null) {
        var data = null;
        if (children[i].active == true && sc.Id == cc.Mgr.global.tutorialGoodsId) {
          data = sc.refreshUpPrice();
        } else {
          data = sc.refreshPrice();
        }
        param.push(data);
      }
    }
    this.marketTipData = param;
  },
  CheckHasElement: function CheckHasElement(outarr, index) {
    for (var j = 0; j < outarr.length; j++) {
      if (index == outarr[j]) {
        return true;
      }
    }
    return false;
  },
  //随着年份刷新 刷新展示的物品  特别年份
  RefreshItemsForSpecialAge: function RefreshItemsForSpecialAge() {
    cc.Mgr.UserDataMgr.ClearShowGoodsList();
    var children = this.MarketParent.children;
    var outarr = [];
    var stateList = [];
    for (var i = 0; i < children.length; i++) {
      var sc = children[i].getComponent("GoodsItem");
      if (sc != null) {
        var has = cc.Mgr.UserDataMgr.JudeGoodsOwned(sc.Id);
        if (has) {
          var par = {};
          par.Id = sc.Id;
          par.State = sc.State;
          stateList.push(par);
          outarr.push(i);
        }
      }
    }
    var list = [];
    for (var i = children.length - 1; i >= 0; i--) {
      if (this.CheckHasElement(outarr, i) == false) {
        list.push(i);
      }
    }
    var showArr = this.getArrayItems(list, 5 - outarr.length);
    for (var i = outarr.length - 1; i >= 0; i--) {
      showArr.push(outarr[i]);
    }
    var param = []; //数据
    for (var i = children.length - 1; i >= 0; i--) {
      children[i].active = false;
      var sc = children[i].getComponent("GoodsItem");
      if (sc != null) {
        //sc.refreshPrice();
        for (var j = showArr.length - 1; j >= 0; j--) {
          if (i == showArr[j]) {
            var data = null;
            if (sc.Id == 1 || sc.Id == 3) {
              data = sc.refreshMidPrice();
            } else {
              var outdata = this.JudeGoodsHas(stateList, sc.Id);
              if (outdata.has == true) {
                if (outdata.State == 0) {
                  data = sc.refreshMidPrice();
                }
                if (outdata.State >= 1) {
                  data = sc.refreshUpPrice();
                }
              } else {
                data = sc.refreshPrice();
              }
            }
            param.push(data);
            cc.Mgr.UserDataMgr.InsertGoodsIdToList(sc.Id);
            children[i].active = true;
            break;
          }
        }
      }
    }
    if (cc.Mgr.global.tutorialStep != -1)
      //(cc.Mgr.UserDataMgr.Age == 25 && cc.Mgr.UserDataMgr.tutorialInDate == false) || (cc.Mgr.UserDataMgr.Age == 30 && cc.Mgr.UserDataMgr.tutorialInBus == false))
      {
        //cc.log("引导阶段")
      } else {
      this.MarketTipPanel.node.active = true;
      this.MarketTipPanel.ShowPanel(param);
    }
  },
  JudeGoodsHas: function JudeGoodsHas(List, Id) {
    var out = {};
    out.State = 0;
    out.has = false;
    for (var i = 0; i < List.length; i++) {
      if (List[i].Id == Id) {
        out.State = List[i].State;
        out.has = true;
        return out;
      }
    }
    return out;
  },
  //随着年份刷新 刷新展示的物品
  RefreshItems: function RefreshItems() {
    cc.Mgr.UserDataMgr.ClearShowGoodsList();
    //var DataList = cc.Mgr.MapDataMgr.getDataListByItemType(ItemType.Goods);
    var children = this.MarketParent.children;
    var outarr = [];
    if (cc.Mgr.global.GoodsForeId != -1) {
      for (var i = children.length - 1; i >= 0; i--) {
        var sc = children[i].getComponent("GoodsItem");
        if (sc != null) {
          if (cc.Mgr.global.GoodsForeId == sc.Id) {
            outarr.push(i);
            break;
          }
        }
      }
    }
    var list = [];
    for (var i = children.length - 1; i >= 0; i--) {
      if (this.CheckHasElement(outarr, i) == false) {
        list.push(i);
      }
    }
    var showArr = this.getArrayItems(list, 5 - outarr.length);
    for (var i = outarr.length - 1; i >= 0; i--) {
      showArr.push(outarr[i]);
    }
    var param = []; //数据
    for (var i = children.length - 1; i >= 0; i--) {
      children[i].active = false;
      var sc = children[i].getComponent("GoodsItem");
      if (sc != null) {
        for (var j = showArr.length - 1; j >= 0; j--) {
          if (i == showArr[j]) {
            var data = null;
            if (sc.Id == cc.Mgr.global.GoodsForeId) {
              var rat = Math.random();
              if (rat < 0.7) {
                if (sc.State == 0) data = sc.refreshMidPrice();else if (sc.State == 1) data = sc.refreshUpPrice();
              }
              cc.Mgr.global.GoodsForeId = -1;
            } else {
              if (j == 3) data = sc.refreshMidPrice();else data = sc.refreshPrice();
            }
            param.push(data);
            cc.Mgr.UserDataMgr.InsertGoodsIdToList(sc.Id);
            children[i].active = true;
            break;
          }
        }
      }
    }
    if (cc.Mgr.global.tutorialStep != -1)
      //(cc.Mgr.UserDataMgr.Age == 25 && cc.Mgr.UserDataMgr.tutorialInDate == false) || (cc.Mgr.UserDataMgr.Age == 30 && cc.Mgr.UserDataMgr.tutorialInBus == false))
      {
        //cc.log("引导阶段")
      } else {
      this.MarketTipPanel.node.active = true;
      this.MarketTipPanel.ShowPanel(param);
    }
  },
  //0-arrNum 之间随机抽取 num 个数出来
  getArrayByItems: function getArrayByItems(arrNum, num) {
    //新建一个数组,将传入的数组复制过来,用于运算,而不要直接操作传入的数组;
    var temp_array = new Array();
    for (var index = 0; index < arrNum; index++) {
      temp_array.push(index);
    }
    //取出的数值项,保存在此数组
    var return_array = new Array();
    for (var i = 0; i < num; i++) {
      //判断如果数组还有可以取出的元素,以防下标越界
      if (temp_array.length > 0) {
        //在数组中产生一个随机索引
        var arrIndex = Math.floor(Math.random() * temp_array.length);
        //将此随机索引的对应的数组元素值复制出来
        return_array[i] = temp_array[arrIndex];
        ////cc.log("+++++++++++++++++++++++++++" + return_array[i]);
        //然后删掉此索引的数组元素,这时候temp_array变为新的数组
        temp_array.splice(arrIndex, 1);
      } else {
        //数组中数据项取完后,退出循环,比如数组本来只有10项,但要求取出20项.
        break;
      }
    }
    return return_array;
  },
  //从数组arr中随机选取 num 个数
  getArrayItems: function getArrayItems(arr, num) {
    //新建一个数组,将传入的数组复制过来,用于运算,而不要直接操作传入的数组;
    var temp_array = new Array();
    for (var index = 0; index < arr.length; index++) {
      temp_array.push(arr[index]);
      //cc.log("塞进去的数值 = " + arr[index]);
    }
    //取出的数值项,保存在此数组
    var return_array = new Array();
    for (var i = 0; i < num; i++) {
      //判断如果数组还有可以取出的元素,以防下标越界
      if (temp_array.length > 0) {
        //在数组中产生一个随机索引
        var arrIndex = Math.floor(Math.random() * temp_array.length);
        //将此随机索引的对应的数组元素值复制出来
        return_array[i] = temp_array[arrIndex];
        //然后删掉此索引的数组元素,这时候temp_array变为新的数组
        temp_array.splice(arrIndex, 1);
      } else {
        //数组中数据项取完后,退出循环,比如数组本来只有10项,但要求取出20项.
        break;
      }
    }
    return return_array;
  },
  //初始化 已经拥有物品
  InitOwnedItems: function InitOwnedItems() {
    var DataList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Goods);
    for (var i = DataList.length - 1; i >= 0; i--) {
      var data = DataList[i];
      var obj = cc.instantiate(this.OwnItem);
      obj.parent = this.OwnParent;
      obj.active = false;
      if (data.ownNum > 0) {
        obj.active = true;
      }
      obj.getComponent("OwnItem").init(data);
    }
  },
  //购买和出售后刷新已经有的物品
  RefreshOwnedItems: function RefreshOwnedItems(data) {
    var children = this.OwnParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("OwnItem");
      if (sc != null) {
        if (sc.Id == data.Id) {
          sc.refreshData(data);
          if (data.ownNum > 0) {
            children[i].active = true;
          } else {
            children[i].active = false;
          }
          break;
        }
      }
    }
  },
  RefreshOwnedItemsState: function RefreshOwnedItemsState() {
    var children = this.OwnParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("OwnItem");
      if (sc != null && children[i].active == true) {
        sc.RefreshState();
      }
    }
  },
  //初始化股市数据
  InitCompanyItems: function InitCompanyItems() {
    var DataList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Company);
    for (var i = DataList.length - 1; i >= 0; i--) {
      var data = DataList[i];
      var obj = cc.instantiate(this.CompanyItem);
      obj.parent = this.CompanyParent;
      obj.active = true;
      obj.getComponent("CompanyItem").init(data);
    }
  },
  //刷新股市数据
  RefreshCompanyItems: function RefreshCompanyItems() {
    var children = this.CompanyParent.children;
    var canProfit = false;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("CompanyItem");
      if (sc != null) {
        sc.refreshPrice();
        if (sc.canGetProfit == true) {
          canProfit = true;
        }
      }
    }
    if (canProfit == true) {
      cc.Mgr.UserDataMgr.CanGetStockProfit = true;
      cc.Mgr.global.showStockProfit = true;
    } else {
      cc.Mgr.UserDataMgr.CanGetStockProfit = false;
      cc.Mgr.global.showStockProfit = false;
    }
  },
  //刷新ui显示
  RefreshCompanyItemsAfterBuy: function RefreshCompanyItemsAfterBuy(data) {
    var children = this.CompanyParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("CompanyItem");
      if (sc != null) {
        if (sc.Id == data.Id) {
          sc.RefreshUIShow(data);
          break;
        }
      }
    }
  },
  //刷新ui显示
  RefreshCompanyItemsFromEvent: function RefreshCompanyItemsFromEvent(Id) {
    var children = this.CompanyParent.children;
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Company, Id);
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("CompanyItem");
      if (sc != null) {
        if (sc.Id == data.Id) {
          sc.RefreshUIShow(data);
          break;
        }
      }
    }
  },
  RefreshCompanyItemsAfterDisvorce: function RefreshCompanyItemsAfterDisvorce() {
    var children = this.CompanyParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("CompanyItem");
      if (sc != null) {
        sc.RefreshUIShowAfter();
      }
    }
  },
  ChooseOpenMarket: function ChooseOpenMarket() {
    this.refreshAdsSp(3);
    cc.Mgr.AudioMgr.playSFX("click");
    this.MarketPanel.active = true;
    this.MatePanel.node.active = false;
    this.EnjoyTipPanel.node.active = false;
    this.BusinessPanel.active = false;
    this.toggleBussiness.isChecked = false;
    this.toggleMarket.isChecked = true;
    this.toggleEnjoy.isChecked = false;
    this.toggleMate.isChecked = false;
  },
  ChooseOpenBusisness: function ChooseOpenBusisness() {
    cc.Mgr.UserDataMgr.tutorialInBus = true;
    this.refreshAdsSp(4);
    cc.Mgr.AudioMgr.playSFX("click");
    this.MarketPanel.active = false;
    this.MatePanel.node.active = false;
    this.EnjoyTipPanel.node.active = false;
    this.BusinessPanel.active = true;
    this.toggleBussiness.isChecked = true;
    this.toggleMarket.isChecked = false;
    this.toggleEnjoy.isChecked = false;
    this.toggleMate.isChecked = false;
  },
  ChooseOpenMatePanel: function ChooseOpenMatePanel() {
    cc.Mgr.UserDataMgr.tutorialInDate = true;
    this.MateNewTip.active = false;
    this.refreshAdsSp(1);
    cc.Mgr.AudioMgr.playSFX("click");
    this.MarketPanel.active = false;
    this.MatePanel.node.active = true;
    this.EnjoyTipPanel.node.active = false;
    this.BusinessPanel.active = false;
    this.MatePanel.ShowPanel();
    this.toggleBussiness.isChecked = false;
    this.toggleMarket.isChecked = false;
    this.toggleEnjoy.isChecked = false;
    this.toggleMate.isChecked = true;
  },
  ChooseOpenEnjoy: function ChooseOpenEnjoy() {
    this.refreshAdsSp(2);
    cc.Mgr.AudioMgr.playSFX("click");
    this.MarketPanel.active = false;
    this.MatePanel.node.active = false;
    this.EnjoyTipPanel.node.active = true;
    this.BusinessPanel.active = false;
    this.EnjoyTipPanel.ShowPanel();
    this.toggleBussiness.isChecked = false;
    this.toggleMarket.isChecked = false;
    this.toggleEnjoy.isChecked = true;
    this.toggleMate.isChecked = false;
  },
  ChooseOpenBelong: function ChooseOpenBelong() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.OwnedTipPanel.node.active = true;
    this.OwnedTipPanel.ShowPanel();
  },
  ChooseOpenTreat: function ChooseOpenTreat() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.forWhat = "Treat";
    param.text = "消耗金钱回复健康";
    if (cc.Mgr.UserDataMgr.HpPoint == 100) {
      param.forWhat = "";
      param.text = "健康状况良好，无需治疗";
      this.CommonTip.node.active = true;
      this.CommonTip.ShowPanel(param);
    } else {
      this.TreatPanel.node.active = true;
      this.TreatPanel.ShowPanel();
      //var needMoney = Math.floor(2000* Math.pow(1.18, cc.Mgr.UserDataMgr.Age-20) *(1-cc.Mgr.UserDataMgr.HpPoint/100));
      //param.needMoney = needMoney;
    }
    //if(this.CommonTip.active == true)
    //{
    //    //cc.log("通用提示已经在展示");
    //    return;
    //}
    //this.CommonTip.node.active = true;
    //this.CommonTip.ShowPanel(param);
  },

  ChooseOpenRetirePanel: function ChooseOpenRetirePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    var param = {};
    param.forWhat = "Retire";
    param.text = "你确定要结束你的奋斗史？？";
    if (this.CommonTip.active == true) {
      //cc.log("通用提示已经在展示");
      return;
    }
    this.CommonTip.node.active = true;
    this.CommonTip.ShowPanel(param);
  },
  ChooseOpenRankPanel: function ChooseOpenRankPanel() {
    // todo 暂时先加上功能未开放
    this.CommonTip.node.active = true;
    this.CommonTip.ShowPanel({
      text: '功能暂未开放, 敬请期待'
    });
    return;
    cc.Mgr.AudioMgr.playSFX("click");
    if (!cc.Mgr.PlatformController.IsLoginSync()) {
      var param = {};
      param.text = "请先登陆手机百度";
      param.forWhat = "Login";
      this.CommonTip.node.active = true;
      this.CommonTip.ShowPanel(param);
      return;
    }
    var isKuaiShou = false;
    if (typeof ks !== 'undefined') {
      //运行在快手平台
      isKuaiShou = true;
    }
    if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) this.wxSubContextView.active = true;else if (cc.sys.platform === cc.sys.BAIDU_GAME) this.SwanSubContextView.active = true;
    cc.Mgr.PlatformController.showSubContentView();
    cc.Mgr.PlatformController.SendMessageToSubView("RankOpen");
    if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou || cc.sys.platform === cc.sys.BAIDU_GAME) {
      this.rankPanel.node.active = true;
    }
  },
  CloseRankView: function CloseRankView() {
    this.rankPanel.node.active = false;
    cc.Mgr.PlatformController.hideSubContentView();
    cc.Mgr.PlatformController.SendMessageToSubView("RankClose");
    this.wxSubContextView.active = false;
    this.SwanSubContextView.active = false;
  },
  OpenAddCapacity: function OpenAddCapacity() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.WareHouseAllCapcity == 200) {
      var param = {};
      param.forWhat = "";
      param.text = "仓储容量达到上限";
      this.CommonTip.node.active = true;
      this.CommonTip.ShowPanel(param);
      return;
    }
    this.AddCapPanel.node.active = true;
    this.AddCapPanel.ShowPanel();
  },
  OpenMarketTipPanel: function OpenMarketTipPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.MarketTipPanel.node.active = true;
    if (this.marketTipData != null) {
      this.MarketTipPanel.ShowPanel(this.marketTipData);
    }
  },
  OpenWatchAdPanel: function OpenWatchAdPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.WatchAdsPanel.node.active = true;
    var param = {};
    param.Sp = this.AdSp;
    this.WatchAdsPanel.ShowPanel(param);
  }
});
module.exports = GameScene;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEdhbWVTY2VuZS5qcyJdLCJuYW1lcyI6WyJJdGVtVHlwZSIsInJlcXVpcmUiLCJVc2VyU3RhdGUiLCJHb29kc0l0ZW0iLCJCdXlUaXBQYW5lbCIsIlNhbGVUaXBQYW5lbCIsIkNvbW1vblRpcFBhbmVsIiwiQ29tcGFueUNyZWF0ZVRpcFBhbmVsIiwiQ29tcGFueUJ1eVRpcFBhbmVsIiwiQ29tcGFueVNhbGVUaXBQYW5lbCIsIk1hdGVUaXBQYW5lbCIsIk1hdGVJdGVtUGFuZWwiLCJFbmpveVBhbmVsIiwiQ29tbW9uQnV5UGFuZWwiLCJPd25lZFBhbmVsIiwiQmV0UGFuZWwiLCJSZXRpcmVQYW5lbCIsIkFkZENhcGFjaXR5UGFuZWwiLCJNYXJrZXRUaXBQYW5lbCIsIlRyZWF0UGFuZWwiLCJFdmVudFRpcFBhbmVsIiwiRXZlbnRSZXN1bHRQYW5lbCIsIldhdGNoQWRzUGFuZWwiLCJNYXJyeVBhbmVsIiwiVHV0b3JpYWxQYW5lbCIsIlRpbWVQYW5lbCIsIkFkc1JldGlyZVBhbmVsIiwiVW5sb2NrTWF0ZVBhbmVsIiwiUmFua1BhbmVsIiwiVHV0b3JpYWxTdGVwIiwiZXlvdUNsaWVudFRpa3RvayIsImV5b3VDbGllbnRLcyIsIkdhbWVTY2VuZSIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiTWFpbkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJCaWdBcEF0bGFzIiwiQ2FzaExibCIsIkxhYmVsIiwiQXNzZXRMYmwiLCJDdXJBZ2VMYmwiLCJUb3RhbEFnZUxibCIsIkhwTGJsIiwiUmVwdXRhdGlvbkxibCIsIkNhcGNpdHlMYmwiLCJIcEljb24iLCJTcHJpdGUiLCJNYXJrZXRJdGVtIiwiUHJlZmFiIiwiT3duSXRlbSIsIkNvbXBhbnlJdGVtIiwiTWFya2V0UGFyZW50IiwiTm9kZSIsIk93blBhcmVudCIsIkNvbXBhbnlQYXJlbnQiLCJNYXJrZXRQYW5lbCIsIkJ1c2luZXNzUGFuZWwiLCJXYXRjaEFkc0J0biIsIlRpcENhc2hTcCIsIkJ1eVRpcCIsIlNhbGVUaXAiLCJDb21tb25UaXAiLCJDb21wYW55Q3JlYXRlUGFuZWwiLCJTdG9ja0J1eVRpcFBhbmVsIiwiU3RvY2tTYWxlVGlwUGFuZWwiLCJNYXRlUGFuZWwiLCJNYXRlSXRlbVRpcCIsIkVuam95VGlwUGFuZWwiLCJDb21tb25CdXlUaXBQYW5lbCIsIk93bmVkVGlwUGFuZWwiLCJCZXRUaXBQYW5lbCIsIlJldGlyZVBhbmVsVGlwIiwicmFua1BhbmVsIiwiRXZlbnRQYW5lbCIsIkFkZENhcFBhbmVsIiwidG9nZ2xlTWFya2V0IiwiVG9nZ2xlIiwidG9nZ2xlQnVzc2luZXNzIiwidG9nZ2xlTWF0ZSIsInRvZ2dsZUVuam95IiwiTWF0ZU5ld1RpcCIsIkFkU3AiLCJ3eFN1YkNvbnRleHRWaWV3IiwiU3dhblN1YkNvbnRleHRWaWV3IiwibWFya2V0VGlwRGF0YSIsInNjcmVlblJlY29yZGluZ0J0biIsImRlc2t0b3BCdG4iLCJ1c2VCdG4iLCJvbkxvYWQiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50Iiwib24iLCJNZ3IiLCJFdmVudCIsIk9wZW5CdXlUaXAiLCJkYXRhIiwibm9kZSIsImFjdGl2ZSIsIlNob3dQYW5lbCIsIkJ1eVN1Y2Nlc3MiLCJzdHJpbmciLCJnbG9iYWwiLCJGb3JtYXROdW0iLCJVc2VyRGF0YU1nciIsIkNhc2giLCJSZWZyZXNoVXNlckFzc2V0cyIsIlJlZnJlc2hPd25lZEl0ZW1zIiwiUmVmcmVzaFVJU2hvdyIsIk9wZW5TYWxlVGlwIiwiU2FsZVN1Y2Nlc3MiLCJPcGVuQ29tbW9uVGlwIiwidHV0b3JpYWxTdGVwIiwiZm9yV2hhdCIsIlBkYXRhIiwiSWQiLCJPcGVuRXZlbnRSZXN1bHQiLCJjb21wYW55SWQiLCJSZWZyZXNoQ29tcGFueUl0ZW1zRnJvbUV2ZW50IiwiT3BlbkNvbXBhbnlDcmVhdGUiLCJDcmVhdGVDb21wYW55U3VjY2VzcyIsIlJlZnJlc2hDb21wYW55SXRlbXNBZnRlckJ1eSIsIkNoZWNrVHV0b3JpYWxIYXBwZW4iLCJPcGVuU3R1Y2tCdXlUaXAiLCJCdXlTdG9ja1N1Y2Nlc3MiLCJPcGVuU3R1Y2tTYWxlVGlwIiwiU2FsZVN0b2NrU3VjY2VzcyIsIk9wZW5NYXRlVGlwIiwiRGF0ZVN1Y2Nlc3MiLCJSZWZyZXNoTWF0ZUl0ZW1VSSIsIkRhdGVMYXRlciIsIlN0YXJ0TWF0ZUxvdmVUdXRvcmlhbCIsIk9wZW5Db21tb25CdXkiLCJDb21tb25CdXlTYWxlU3VjY2VzcyIsImZsYWciLCJEaXN2b3JjZSIsIlJlZnJlc2hDb21wYW55SXRlbXNBZnRlckRpc3ZvcmNlIiwiUmVmcmVzaFBhbmVsSXRlbXMiLCJUcmVhdFN1Y2Nlc3MiLCJ1c2VyU3RhdGUiLCJPSyIsIlJlY292ZXJZZWFyIiwiUmVmcmVzaENhc2hBc3NldCIsIk9wZW5CZXRUaXAiLCJPcGVuVW5Mb2NrTWF0ZSIsIlJldGlyZSIsIlJlZnJlc2hBbGxVSVNob3ciLCJVc2VSZXRpcmVBZHNTa2lsbCIsIkFkZFdhcmVIb3VzZUNhcGFjaXR5IiwiT3Blbk1hcnJ5IiwiT3BlblR1dG9yaWFsIiwiQ2xvY2tFbmQiLCJUb05leHRZZWFyIiwiT3BlbkVuam95IiwiQ2hvb3NlT3BlbkVuam95IiwiU2hhcmVWaWRlbyIsImlzS3VhaVNob3UiLCJrcyIsInN5cyIsIkJZVEVEQU5DRV9HQU1FIiwicGxhdGZvcm0iLCJzaGFyZUFwcE1lc3NhZ2VJbmZvIiwiY2hhbm5lbCIsImV4dHJhIiwidmlkZW9QYXRoIiwiZ2V0SW5zIiwic2hhcmVBcHBNZXNzYWdlIiwic2hhcmVBcHBNZXNzYWdlQ2FsbGJhY2siLCJjb25zb2xlIiwibG9nIiwicHVibGlzaFZpZGVvSW5mbyIsInZpZGVvSUQiLCJwdWJsaXNoVmlkZW8iLCJzdGFydCIsImluaXRUb3BVSURhdGEiLCJJbml0TWFya2V0SXRlbXMiLCJJbml0T3duZWRJdGVtcyIsIkluaXRDb21wYW55SXRlbXMiLCJyZWZyZXNoQWRzU3AiLCJBZHNNZ3IiLCJIaWRlQmFubmVyQWQiLCJkZWFsU2NyZWVuUmVjb3JkaW5nQnRuU2hvdyIsImRlc2t0b3BVc2VCdG5TaG93IiwiX3RoaXMiLCJzY3JlZW5SZWNvcmRpbmdGbGFnIiwic3luY1NjcmVlblJlY29yZGluZ1Nob3ciLCJjcmVhdGVHYW1lUmVjb3JkZXJJbmZvIiwib25TdGFydCIsIm9uU3RvcCIsIm9uU3RvcFJlcyIsIkRhdGUiLCJub3ciLCJzY3JlZW5SZWNvcmRpbmdUaW1lIiwidGV4dCIsIm9uRXJyb3IiLCJlcnJNc2ciLCJlcnJvciIsIm9uSW50ZXJydXB0aW9uQmVnaW4iLCJjcmVhdGVHYW1lUmVjb3JkZXIiLCJjcmVhdGVHYW1lUmVjb3JkZXJDYWxsYmFjayIsImNvZGUiLCJyZXMiLCJzdG9wUmVzIiwidmlkZW9JZCIsIkdhbWVSZWNvcmRlcl9SZWNvcmRGYWlsZWRUaW1lUmFuZ2VUb29TaG9ydCIsIkdhbWVSZWNvcmRlcl9SZWNvcmRGYWlsZWRUaW1lUmFuZ2VUb29Mb25nIiwiR2FtZVJlY29yZGVyX1JlY29yZEZhaWxlZE5vVmlkZW8iLCJHYW1lUmVjb3JkZXJfUHVibGlzaFZpZGVvRmFpbGVkIiwib25BYm9ydCIsIm9uQnRuU2NyZWVuUmVjb3JkaW5nQ2xpY2siLCJnYW1lUmVjb3JkZXJTdGFydCIsImR1cmF0aW9uIiwiZ2FtZVJlY29yZGVyU3RvcCIsIl90aGlzMiIsImluZGV4IiwicGF0aCIsImxvYWRlciIsImxvYWRSZXMiLCJTcHJpdGVGcmFtZSIsImVyciIsInNwcml0ZUZyYW1lIiwiZ2V0Q29tcG9uZW50IiwidXNlIiwiY2hlY2tDb21tb25Vc2UiLCJzdWNjZXNzIiwiaXNDb21tb25Vc2UiLCJmYWlsIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbXBsZXRlIiwiZGVza3RvcCIsImNoZWNrU2hvcnRjdXQiLCJpbnN0YWxsZWQiLCJtc2ciLCJvbkRlc2t0b3BDbGljayIsImFkZFNob3J0Y3V0Iiwib25Vc2VDbGljayIsImFkZENvbW1vblVzZSIsInNlZWQiLCJnZXRTcHJpdGVGcmFtZSIsImluaXRDYXNoIiwiTWF0aCIsInJhbmRvbSIsInR1dG9yaWFsSW5NYXJrZXQiLCJwYXJhbSIsIk1hcERhdGFNZ3IiLCJnZXREYXRhQnlJdGVtVHlwZUFuZElkIiwid2VpZ2h0IiwiSW5pdEdldE1vbmV5SWQiLCJnZXRUcmFuc2xhdGlvbiIsImNhc2giLCJJbml0TW9uZXlCb251cyIsIkFzc2V0c01vbmV5IiwiSGlnaEFzc2V0cyIsIkFnZSIsInJldGlyZUFnZSIsIkhwUG9pbnQiLCJSZXB1dGF0aW9uIiwibGFzdENhcCIsIldhcmVIb3VzZUFsbENhcGNpdHkiLCJXYXJlSG91c2VDYXBjaXR5IiwiQ2xlYXJTaG93R29vZHNMaXN0IiwiRGF0YUxpc3QiLCJnZXREYXRhTGlzdEJ5U2V4IiwiU2V4Iiwic2hvd0FyciIsImdldEFycmF5QnlJdGVtcyIsImxlbmd0aCIsImkiLCJvYmoiLCJpbnN0YW50aWF0ZSIsInBhcmVudCIsImluaXQiLCJqIiwicmVmcmVzaExvd1ByaWNlIiwicmVmcmVzaFByaWNlIiwicHVzaCIsIkluc2VydEdvb2RzSWRUb0xpc3QiLCJzZWxmIiwiU2V0Q2FsbEZ1bmMiLCJlbWl0IiwiZHQiLCJzdGVwIiwidHV0b3JpYWxHb29kc0lkIiwiQ2xpY2tCdXlCdG4iLCJkMyIsImQ0IiwiZ2V0R29vZHNEYXRhQnlJZCIsImQ1IiwiQ2xpY2tTYWxlQnRuIiwiUmVmcmVzaERhdGFUb05leHRZZWFyIiwiUmVmcmVzaFVzZXJBZ2UiLCJSZWZyZXNoVHV0b3JpYWxJdGVtcyIsIlBsYXlBbmltYSIsIlJlZnJlc2hDb21wYW55SXRlbXMiLCJSZWZyZXNoSXRlbXNGb3JTcGVjaWFsQWdlIiwiUmVmcmVzaEl0ZW1zIiwiUmVmcmVzaE93bmVkSXRlbXNTdGF0ZSIsIkdldEJvbnVzUmV3YXJkRXZlcnlZZWFyIiwiUmVmcmVzaEhlYWx0aEhwIiwiQ2hlY2tFdmVudEhhcHBlbiIsInR1dG9yaWFsSW5EYXRlIiwiTWF0ZURhdGVfMSIsIkNob29zZU9wZW5NYXRlUGFuZWwiLCJNYXRlRGF0ZV8yIiwidHV0b3JpYWxJbkJ1cyIsIkJ1c2luZXNzXzEiLCJDaG9vc2VPcGVuQnVzaXNuZXNzIiwiQnVzaW5lc3NfMiIsImhhc0NvbXBhbnkiLCJ0dXRvcmlhbFN0b2NrQm9udXMiLCJTdG9ja0JvbnVzXzEiLCJ0dXRvcmlhbE1hdGVQb2ludCIsIkRhdGVUb01hcnJ5XzEiLCJFdmVudERhdGFJZExpc3QiLCJMYXN0RXZlbnRBZ2UiLCJlSWQiLCJHZXRFdmVudERhdGFBbmRTcGxpY2VJZCIsIlNwYXduU2VlZEJldHdlZW5Ud29OdW0iLCJSZWZyZXNoSHBJY29uU3AiLCJIcFN0YXRlQSIsIkhwU3RhdGVCIiwiSHBTdGF0ZUMiLCJSZWZyZXNoUGFuZWwiLCJjaGlsZHJlbiIsInNjIiwicmVmcmVzaFVwUHJpY2UiLCJDaGVja0hhc0VsZW1lbnQiLCJvdXRhcnIiLCJzdGF0ZUxpc3QiLCJoYXMiLCJKdWRlR29vZHNPd25lZCIsInBhciIsIlN0YXRlIiwibGlzdCIsImdldEFycmF5SXRlbXMiLCJyZWZyZXNoTWlkUHJpY2UiLCJvdXRkYXRhIiwiSnVkZUdvb2RzSGFzIiwiTGlzdCIsIm91dCIsIkdvb2RzRm9yZUlkIiwicmF0IiwiYXJyTnVtIiwibnVtIiwidGVtcF9hcnJheSIsIkFycmF5IiwicmV0dXJuX2FycmF5IiwiYXJySW5kZXgiLCJmbG9vciIsInNwbGljZSIsImFyciIsImdldE93bkRhdGFMaXN0QnlUeXBlIiwiR29vZHMiLCJvd25OdW0iLCJyZWZyZXNoRGF0YSIsIlJlZnJlc2hTdGF0ZSIsIkNvbXBhbnkiLCJjYW5Qcm9maXQiLCJjYW5HZXRQcm9maXQiLCJDYW5HZXRTdG9ja1Byb2ZpdCIsInNob3dTdG9ja1Byb2ZpdCIsIlJlZnJlc2hVSVNob3dBZnRlciIsIkNob29zZU9wZW5NYXJrZXQiLCJBdWRpb01nciIsInBsYXlTRlgiLCJpc0NoZWNrZWQiLCJDaG9vc2VPcGVuQmVsb25nIiwiQ2hvb3NlT3BlblRyZWF0IiwiQ2hvb3NlT3BlblJldGlyZVBhbmVsIiwiQ2hvb3NlT3BlblJhbmtQYW5lbCIsIlBsYXRmb3JtQ29udHJvbGxlciIsIklzTG9naW5TeW5jIiwiV0VDSEFUX0dBTUUiLCJCQUlEVV9HQU1FIiwic2hvd1N1YkNvbnRlbnRWaWV3IiwiU2VuZE1lc3NhZ2VUb1N1YlZpZXciLCJDbG9zZVJhbmtWaWV3IiwiaGlkZVN1YkNvbnRlbnRWaWV3IiwiT3BlbkFkZENhcGFjaXR5IiwiT3Blbk1hcmtldFRpcFBhbmVsIiwiT3BlbldhdGNoQWRQYW5lbCIsIlNwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsU0FBUyxHQUFHRCxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlFLFNBQVMsR0FBR0YsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUNwQyxJQUFJRyxXQUFXLEdBQUdILE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDeEMsSUFBSUksWUFBWSxHQUFHSixPQUFPLENBQUMsY0FBYyxDQUFDO0FBQzFDLElBQUlLLGNBQWMsR0FBR0wsT0FBTyxDQUFDLGdCQUFnQixDQUFDO0FBQzlDLElBQUlNLHFCQUFxQixHQUFHTixPQUFPLENBQUMsdUJBQXVCLENBQUM7QUFDNUQsSUFBSU8sa0JBQWtCLEdBQUdQLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztBQUN0RCxJQUFJUSxtQkFBbUIsR0FBR1IsT0FBTyxDQUFDLHFCQUFxQixDQUFDO0FBQ3hELElBQUlTLFlBQVksR0FBR1QsT0FBTyxDQUFDLGNBQWMsQ0FBQztBQUMxQyxJQUFJVSxhQUFhLEdBQUdWLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFDNUMsSUFBSVcsVUFBVSxHQUFHWCxPQUFPLENBQUMsWUFBWSxDQUFDO0FBQ3RDLElBQUlZLGNBQWMsR0FBR1osT0FBTyxDQUFDLGdCQUFnQixDQUFDO0FBQzlDLElBQUlhLFVBQVUsR0FBR2IsT0FBTyxDQUFDLFlBQVksQ0FBQztBQUN0QyxJQUFJYyxRQUFRLEdBQUdkLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSWUsV0FBVyxHQUFHZixPQUFPLENBQUMsYUFBYSxDQUFDO0FB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QUFJa0osS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkQSxLQUFLLENBQUMwSSxFQUFFLEdBQUcsSUFBSSxDQUFDNVMsSUFBSTtJQUNwQixJQUFJLENBQUM5RCxhQUFhLENBQUMrRSxTQUFTLENBQUNpSixLQUFLLENBQUM7RUFDdkM7QUFDSixDQUFDLENBQUM7QUFDRjJJLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHbFcsU0FBUyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgVXNlclN0YXRlID0gcmVxdWlyZShcIlVzZXJTdGF0ZVwiKTtcclxudmFyIEdvb2RzSXRlbSA9IHJlcXVpcmUoXCJHb29kc0l0ZW1cIik7XHJcbnZhciBCdXlUaXBQYW5lbCA9IHJlcXVpcmUoXCJCdXlUaXBQYW5lbFwiKTtcclxudmFyIFNhbGVUaXBQYW5lbCA9IHJlcXVpcmUoXCJTYWxlVGlwUGFuZWxcIik7XHJcbnZhciBDb21tb25UaXBQYW5lbCA9IHJlcXVpcmUoXCJDb21tb25UaXBQYW5lbFwiKTtcclxudmFyIENvbXBhbnlDcmVhdGVUaXBQYW5lbCA9IHJlcXVpcmUoXCJDb21wYW55Q3JlYXRlVGlwUGFuZWxcIik7XHJcbnZhciBDb21wYW55QnV5VGlwUGFuZWwgPSByZXF1aXJlKFwiQ29tcGFueUJ1eVRpcFBhbmVsXCIpO1xyXG52YXIgQ29tcGFueVNhbGVUaXBQYW5lbCA9IHJlcXVpcmUoXCJDb21wYW55U2FsZVRpcFBhbmVsXCIpO1xyXG52YXIgTWF0ZVRpcFBhbmVsID0gcmVxdWlyZShcIk1hdGVUaXBQYW5lbFwiKTtcclxudmFyIE1hdGVJdGVtUGFuZWwgPSByZXF1aXJlKFwiTWF0ZUl0ZW1QYW5lbFwiKTtcclxudmFyIEVuam95UGFuZWwgPSByZXF1aXJlKFwiRW5qb3lQYW5lbFwiKTtcclxudmFyIENvbW1vbkJ1eVBhbmVsID0gcmVxdWlyZShcIkNvbW1vbkJ1eVBhbmVsXCIpO1xyXG52YXIgT3duZWRQYW5lbCA9IHJlcXVpcmUoXCJPd25lZFBhbmVsXCIpO1xyXG52YXIgQmV0UGFuZWwgPSByZXF1aXJlKFwiQmV0UGFuZWxcIik7XHJcbnZhciBSZXRpcmVQYW5lbCA9IHJlcXVpcmUoXCJSZXRpcmVQYW5lbFwiKTtcclxudmFyIEFkZENhcGFjaXR5UGFuZWwgPSByZXF1aXJlKFwiQWRkQ2FwYWNpdHlcIik7XHJcbnZhciBNYXJrZXRUaXBQYW5lbCA9IHJlcXVpcmUoXCJNYXJrZXRUaXBQYW5lbFwiKTtcclxudmFyIFRyZWF0UGFuZWwgPSByZXF1aXJlKFwiVHJlYXRQYW5lbFwiKTtcclxudmFyIEV2ZW50VGlwUGFuZWwgPSByZXF1aXJlKFwiRXZlbnRQYW5lbFwiKTtcclxudmFyIEV2ZW50UmVzdWx0UGFuZWwgPSByZXF1aXJlKFwiRXZlbnRSZXN1bHRQYW5lbFwiKTtcclxudmFyIFdhdGNoQWRzUGFuZWwgPSByZXF1aXJlKFwiV2F0Y2hBZHNQYW5lbFwiKTtcclxudmFyIE1hcnJ5UGFuZWwgPSByZXF1aXJlKFwiTWFycnlQYW5lbFwiKTtcclxudmFyIFR1dG9yaWFsUGFuZWwgPSByZXF1aXJlKFwiVHV0b3JpYWxQYW5lbFwiKTtcclxudmFyIFRpbWVQYW5lbCA9IHJlcXVpcmUoXCJUaW1lUGFuZWxcIik7XHJcbnZhciBBZHNSZXRpcmVQYW5lbCA9IHJlcXVpcmUoXCJBZHNSZXRpcmVQYW5lbFwiKTtcclxudmFyIFVubG9ja01hdGVQYW5lbCA9IHJlcXVpcmUoXCJVbmxvY2tNYXRlUGFuZWxcIik7XHJcbnZhciBSYW5rUGFuZWwgPSByZXF1aXJlKFwiUmFua1BhbmVsXCIpO1xyXG5cclxudmFyIFR1dG9yaWFsU3RlcCA9IHJlcXVpcmUoXCJUdXRvcmlhbFN0ZXBcIik7XHJcblxyXG5jb25zdCBleW91Q2xpZW50VGlrdG9rID0gcmVxdWlyZSgnRXlvdUNsaWVudFRpa3RvaycpXHJcbmNvbnN0IGV5b3VDbGllbnRLcyA9IHJlcXVpcmUoJ0V5b3VDbGllbnRLcycpXHJcblxyXG52YXIgR2FtZVNjZW5lID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBNYWluQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgQmlnQXBBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuXHJcbiAgICAgICAgQ2FzaExibDpjYy5MYWJlbCxcclxuICAgICAgICBBc3NldExibDpjYy5MYWJlbCxcclxuICAgICAgICBDdXJBZ2VMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgVG90YWxBZ2VMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgSHBMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgUmVwdXRhdGlvbkxibDpjYy5MYWJlbCxcclxuICAgICAgICBDYXBjaXR5TGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIEhwSWNvbjpjYy5TcHJpdGUsXHJcblxyXG4gICAgICAgIE1hcmtldEl0ZW06Y2MuUHJlZmFiLFxyXG4gICAgICAgIE93bkl0ZW06Y2MuUHJlZmFiLFxyXG4gICAgICAgIENvbXBhbnlJdGVtOmNjLlByZWZhYixcclxuXHJcbiAgICAgICAgTWFya2V0UGFyZW50OmNjLk5vZGUsXHJcbiAgICAgICAgT3duUGFyZW50OmNjLk5vZGUsXHJcbiAgICAgICAgQ29tcGFueVBhcmVudDpjYy5Ob2RlLFxyXG5cclxuICAgICAgICBNYXJrZXRQYW5lbDpjYy5Ob2RlLFxyXG4gICAgICAgIEJ1c2luZXNzUGFuZWw6Y2MuTm9kZSxcclxuICAgICAgICBXYXRjaEFkc0J0bjpjYy5TcHJpdGUsXHJcbiAgICAgICAgVGlwQ2FzaFNwOmNjLlNwcml0ZSxcclxuXHJcbiAgICAgICAgTWFya2V0VGlwUGFuZWw6TWFya2V0VGlwUGFuZWwsLy/luILlnLrooYzmg4Xmj5DnpLpcclxuICAgICAgICBCdXlUaXA6QnV5VGlwUGFuZWwsXHJcbiAgICAgICAgU2FsZVRpcDpTYWxlVGlwUGFuZWwsXHJcbiAgICAgICAgQ29tbW9uVGlwOkNvbW1vblRpcFBhbmVsLFxyXG4gICAgICAgIENvbXBhbnlDcmVhdGVQYW5lbDpDb21wYW55Q3JlYXRlVGlwUGFuZWwsXHJcbiAgICAgICAgU3RvY2tCdXlUaXBQYW5lbDpDb21wYW55QnV5VGlwUGFuZWwsXHJcbiAgICAgICAgU3RvY2tTYWxlVGlwUGFuZWw6Q29tcGFueVNhbGVUaXBQYW5lbCxcclxuICAgICAgICBNYXRlUGFuZWw6TWF0ZVRpcFBhbmVsLFxyXG4gICAgICAgIE1hdGVJdGVtVGlwOk1hdGVJdGVtUGFuZWwsXHJcbiAgICAgICAgRW5qb3lUaXBQYW5lbDpFbmpveVBhbmVsLFxyXG4gICAgICAgIENvbW1vbkJ1eVRpcFBhbmVsOkNvbW1vbkJ1eVBhbmVsLFxyXG4gICAgICAgIE93bmVkVGlwUGFuZWw6T3duZWRQYW5lbCxcclxuICAgICAgICBCZXRUaXBQYW5lbDpCZXRQYW5lbCxcclxuICAgICAgICBSZXRpcmVQYW5lbFRpcDpSZXRpcmVQYW5lbCxcclxuICAgICAgICBBZHNSZXRpcmVQYW5lbDpBZHNSZXRpcmVQYW5lbCxcclxuICAgICAgICBVbmxvY2tNYXRlUGFuZWw6VW5sb2NrTWF0ZVBhbmVsLFxyXG4gICAgICAgIHJhbmtQYW5lbDpSYW5rUGFuZWwsXHJcblxyXG4gICAgICAgIFRyZWF0UGFuZWw6VHJlYXRQYW5lbCxcclxuICAgICAgICBFdmVudFBhbmVsOkV2ZW50VGlwUGFuZWwsXHJcbiAgICAgICAgRXZlbnRSZXN1bHRQYW5lbDpFdmVudFJlc3VsdFBhbmVsLFxyXG5cclxuICAgICAgICBBZGRDYXBQYW5lbDpBZGRDYXBhY2l0eVBhbmVsLFxyXG5cclxuICAgICAgICBXYXRjaEFkc1BhbmVsOldhdGNoQWRzUGFuZWwsXHJcbiAgICAgICAgTWFycnlQYW5lbDpNYXJyeVBhbmVsLFxyXG4gICAgICAgIFR1dG9yaWFsUGFuZWw6VHV0b3JpYWxQYW5lbCxcclxuXHJcbiAgICAgICAgVGltZVBhbmVsOlRpbWVQYW5lbCxcclxuXHJcbiAgICAgICAgdG9nZ2xlTWFya2V0OmNjLlRvZ2dsZSxcclxuICAgICAgICB0b2dnbGVCdXNzaW5lc3M6Y2MuVG9nZ2xlLFxyXG4gICAgICAgIHRvZ2dsZU1hdGU6Y2MuVG9nZ2xlLFxyXG4gICAgICAgIHRvZ2dsZUVuam95OmNjLlRvZ2dsZSxcclxuXHJcbiAgICAgICAgTWF0ZU5ld1RpcDpjYy5Ob2RlLFxyXG5cclxuICAgICAgICBBZFNwOlwiYWlzaGVuXCIsXHJcblxyXG4gICAgICAgIHd4U3ViQ29udGV4dFZpZXc6Y2MuTm9kZSxcclxuICAgICAgICBTd2FuU3ViQ29udGV4dFZpZXc6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgbWFya2V0VGlwRGF0YTpudWxsLFxyXG5cclxuICAgICAgICBzY3JlZW5SZWNvcmRpbmdCdG46IGNjLk5vZGUsXHJcbiAgICAgICAgZGVza3RvcEJ0bjogY2MuTm9kZSxcclxuICAgICAgICB1c2VCdG46IGNjLk5vZGUsXHJcbiAgICB9LFxyXG5cclxuICAgIG9uTG9hZCAoKSB7XHJcblxyXG4gICAgXHQvL+ebo+iBveaJk+mWi+izvOiyt1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuQnV5VGlwLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5CdXlUaXAubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkJ1eVRpcC5TaG93UGFuZWwoZGF0YSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgLy/nm6Pogb3os7zosrfmiJDlip9cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuQnV5U3VjY2VzcywgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuQ2FzaExibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCk7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoVXNlckFzc2V0cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaE93bmVkSXRlbXMoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFVJU2hvdygpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIC8v55uR5ZCsIOWHuuWUrueql+WPo1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuU2FsZVRpcCwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuU2FsZVRpcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuU2FsZVRpcC5TaG93UGFuZWwoZGF0YSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5TYWxlU3VjY2VzcywgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuQ2FzaExibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCk7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoVXNlckFzc2V0cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaE93bmVkSXRlbXMoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFVJU2hvdygpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5nbG9iYWwudHV0b3JpYWxTdGVwICE9IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hVc2VyQXNzZXRzKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKGRhdGEpO1xyXG4gICAgICAgICAgICBpZihkYXRhLmZvcldoYXQgIT0gbnVsbCAmJiBkYXRhLmZvcldoYXQgPT0gXCJFdmVudF9ZZXNcIilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCItLS0tLS0tLS0tLS0tLS0tXCIrIGRhdGEuUGRhdGEuSWQpXHJcbiAgICAgICAgICAgICAgICBpZihkYXRhLlBkYXRhLklkICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUmVmcmVzaE93bmVkSXRlbXMoZGF0YS5QZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlJlZnJlc2hVSVNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlbkV2ZW50UmVzdWx0LCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5FdmVudFJlc3VsdFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hVc2VyQXNzZXRzKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5FdmVudFJlc3VsdFBhbmVsLlNob3dQYW5lbChkYXRhKTtcclxuICAgICAgICAgICAgaWYoZGF0YS5mb3JXaGF0ICE9IG51bGwgJiYgZGF0YS5mb3JXaGF0ID09IFwiRXZlbnRfWWVzXCIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGRhdGEuUGRhdGEuSWQgIT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5SZWZyZXNoT3duZWRJdGVtcyhkYXRhLlBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZGF0YS5QZGF0YS5jb21wYW55SWQgIT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5SZWZyZXNoQ29tcGFueUl0ZW1zRnJvbUV2ZW50KGRhdGEuUGRhdGEuY29tcGFueUlkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuUmVmcmVzaFVJU2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIC8v5omT5byA5Yib5Yqe5YWs5Y+4cGFuZWxcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlbkNvbXBhbnlDcmVhdGUsIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB0aGlzLkNvbXBhbnlDcmVhdGVQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQ29tcGFueUNyZWF0ZVBhbmVsLlNob3dQYW5lbChkYXRhKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy/liJvlip7lhazlj7hcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuQ3JlYXRlQ29tcGFueVN1Y2Nlc3MsIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB0aGlzLkNhc2hMYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0oY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2gpO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hDb21wYW55SXRlbXNBZnRlckJ1eShkYXRhKTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hVc2VyQXNzZXRzKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5SZWZyZXNoVUlTaG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuQ2hlY2tUdXRvcmlhbEhhcHBlbigpOyAvL+WIm+WKnueOqeWFrOWPuOacieS4gOasoeW8leWvvFxyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAvL+aJk+W8gOi0reS5sOiCoeelqHBhbmVsXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50Lk9wZW5TdHVja0J1eVRpcCwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuU3RvY2tCdXlUaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuU3RvY2tCdXlUaXBQYW5lbC5TaG93UGFuZWwoZGF0YSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIC8v6LSt5Lmw6IKh56Wo5oiQ5YqfXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LkJ1eVN0b2NrU3VjY2VzcywgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuQ2FzaExibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaENvbXBhbnlJdGVtc0FmdGVyQnV5KGRhdGEpO1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaFVzZXJBc3NldHMoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hVSVNob3coKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy/miZPlvIDlh7rllK7ogqHnpahwYW5lbFxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuU3R1Y2tTYWxlVGlwLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5TdG9ja1NhbGVUaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuU3RvY2tTYWxlVGlwUGFuZWwuU2hvd1BhbmVsKGRhdGEpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAvL+WHuuWUruiCoeelqOaIkOWKn1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5TYWxlU3RvY2tTdWNjZXNzLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5DYXNoTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoKTtcclxuICAgICAgICAgICAgdGhpcy5SZWZyZXNoQ29tcGFueUl0ZW1zQWZ0ZXJCdXkoZGF0YSk7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoVXNlckFzc2V0cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFVJU2hvdygpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAvL+aJk+W8gOe6puS8muaPkOekuumdouadv1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuTWF0ZVRpcCwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuTWF0ZUl0ZW1UaXAubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLk1hdGVJdGVtVGlwLlNob3dQYW5lbChkYXRhKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy/miZPlvIDnuqbkvJrlrozmiJBcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuRGF0ZVN1Y2Nlc3MsIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaFVzZXJBc3NldHMoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hNYXRlSXRlbVVJKGRhdGEuSWQpO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hVSVNob3coKTtcclxuICAgICAgICAgICAgLy90aGlzLlN0YXJ0TWF0ZUxvdmVUdXRvcmlhbCgpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuRGF0ZUxhdGVyLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5TdGFydE1hdGVMb3ZlVHV0b3JpYWwoKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy/miZPlvIDlhbHnlKjkubBcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vbkJ1eSwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5pS25Yiw5omT5byAXCIpO1xyXG4gICAgICAgICAgICB0aGlzLkNvbW1vbkJ1eVRpcFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5Db21tb25CdXlUaXBQYW5lbC5TaG93UGFuZWwoZGF0YSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIC8v5YWx55So5LmwbWFpIOaIkOWKn+i/lOWbnlxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5Db21tb25CdXlTYWxlU3VjY2VzcywgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoVXNlckFzc2V0cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFVJU2hvdygpO1xyXG4gICAgICAgICAgICBpZihkYXRhLmZsYWcgPT0gXCJTYWxlXCIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLk93bmVkVGlwUGFuZWwuU2hvd1BhbmVsKCk7XHJcblxyXG4gICAgICAgICAgICBpZihkYXRhLkRpc3ZvcmNlICYmIGRhdGEuRGlzdm9yY2UgPT0gdHJ1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5SZWZyZXNoQ29tcGFueUl0ZW1zQWZ0ZXJEaXN2b3JjZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5NYXRlUGFuZWwuUmVmcmVzaFBhbmVsSXRlbXMoKTtcclxuICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoVXNlckFzc2V0cyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy/msrvnlpflrozmiJBcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuVHJlYXRTdWNjZXNzLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnVzZXJTdGF0ZSA9IFVzZXJTdGF0ZS5PSztcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlY292ZXJZZWFyID0gMDtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hVc2VyQXNzZXRzKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5SZWZyZXNoVUlTaG93KCk7XHJcbiAgICAgICAgICAgIC8vLy9jYy5sb2coXCItLS0tLS0tLS0tLS0tLS0t5aOr5aSn5aSr6IOc5aSa6LSf5bCRLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIiArIGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50KTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LlJlZnJlc2hDYXNoQXNzZXQsIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaFVzZXJBc3NldHMoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hVSVNob3coKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy/otYzljZpcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlbkJldFRpcCwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuQmV0VGlwUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hVSVNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5CZXRUaXBQYW5lbC5TaG93UGFuZWwoZGF0YSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuVW5Mb2NrTWF0ZSwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuVW5sb2NrTWF0ZVBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5NYXRlTmV3VGlwLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuVW5sb2NrTWF0ZVBhbmVsLlNob3dQYW5lbChkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5NYXRlUGFuZWwuUmVmcmVzaFBhbmVsSXRlbXMoKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LlJldGlyZSwgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuUmV0aXJlUGFuZWxUaXAubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlJldGlyZVBhbmVsVGlwLlNob3dQYW5lbCgpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuUmVmcmVzaEFsbFVJU2hvdywgZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFVJU2hvdygpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuVXNlUmV0aXJlQWRzU2tpbGwsIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB0aGlzLkFkc1JldGlyZVBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5BZHNSZXRpcmVQYW5lbC5TaG93UGFuZWwoKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LkFkZFdhcmVIb3VzZUNhcGFjaXR5LCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hVc2VyQXNzZXRzKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5SZWZyZXNoVUlTaG93KCk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuTWFycnksIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB0aGlzLk1hcnJ5UGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLk1hcnJ5UGFuZWwuU2hvd1BhbmVsKGRhdGEpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5vbihjYy5NZ3IuRXZlbnQuT3BlblR1dG9yaWFsLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5UdXRvcmlhbFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5UdXRvcmlhbFBhbmVsLlNob3dQYW5lbChkYXRhKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LkNsb2NrRW5kLCBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5Ub05leHRZZWFyKCk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50Lm9uKGNjLk1nci5FdmVudC5PcGVuRW5qb3ksIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB0aGlzLkNob29zZU9wZW5FbmpveSgpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAvL+aJk+W8gOWIm+WKnuWFrOWPuHBhbmVsXHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQub24oY2MuTWdyLkV2ZW50LlNoYXJlVmlkZW8sIGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBsZXQgaXNLdWFpU2hvdSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgLy/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuICAgICAgICAgICAgICAgIGlzS3VhaVNob3UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjYy5zeXMuQllURURBTkNFX0dBTUUgPT09IGNjLnN5cy5wbGF0Zm9ybSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNoYXJlQXBwTWVzc2FnZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogJ3ZpZGVvJyxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1BhdGg6IGRhdGEudmlkZW9QYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5zaGFyZUFwcE1lc3NhZ2Uoc2hhcmVBcHBNZXNzYWdlSW5mbywgc2hhcmVBcHBNZXNzYWdlQ2FsbGJhY2sgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfliIbkuqvlvZXlsY/lm57osIM6PicsIHNoYXJlQXBwTWVzc2FnZUNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfWVsc2UgaWYgKGlzS3VhaVNob3Upe1xyXG4gICAgICAgICAgICAgICAgbGV0IHB1Ymxpc2hWaWRlb0luZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9JRDogZGF0YS52aWRlb1BhdGhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV5b3VDbGllbnRLcy5nZXRJbnMoKS5wdWJsaXNoVmlkZW8ocHVibGlzaFZpZGVvSW5mbylcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0ICgpIHtcclxuICAgIFx0dGhpcy5pbml0VG9wVUlEYXRhKCk7XHJcbiAgICAgICAgLy/liJ3lp4vljJbluILlnLrmlbDmja5cclxuICAgICAgICB0aGlzLkluaXRNYXJrZXRJdGVtcygpO1xyXG4gICAgICAgIC8v5Yid5aeL5YyW5bey57uP5pyJ55qE54mp5ZOBXHJcbiAgICAgICAgdGhpcy5Jbml0T3duZWRJdGVtcygpO1xyXG4gICAgICAgIC8v5Yid5aeL5YyW6IKh5biC5YWs5Y+45pWw5o2uXHJcbiAgICAgICAgdGhpcy5Jbml0Q29tcGFueUl0ZW1zKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaEFkc1NwKDMpO1xyXG5cclxuICAgICAgICBjYy5NZ3IuQWRzTWdyLkhpZGVCYW5uZXJBZCgpO1xyXG5cclxuICAgICAgICB0aGlzLmRlYWxTY3JlZW5SZWNvcmRpbmdCdG5TaG93KCk7XHJcbiAgICAgICAgdGhpcy5kZXNrdG9wVXNlQnRuU2hvdygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWFsU2NyZWVuUmVjb3JkaW5nQnRuU2hvdygpIHtcclxuICAgICAgICBleW91Q2xpZW50VGlrdG9rLmdldElucygpLnNjcmVlblJlY29yZGluZ0ZsYWcgPSAwXHJcbiAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLnNjcmVlblJlY29yZGluZ0ZsYWcgPSAwXHJcbiAgICAgICAgdGhpcy5zeW5jU2NyZWVuUmVjb3JkaW5nU2hvdygpXHJcbiAgICAgICAgbGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG4gICAgICAgICAgICBpc0t1YWlTaG91ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNjLnN5cy5CWVRFREFOQ0VfR0FNRSA9PT0gY2Muc3lzLnBsYXRmb3JtKSB7XHJcbiAgICAgICAgICAgIGxldCBjcmVhdGVHYW1lUmVjb3JkZXJJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgb25TdGFydDogKCkgPT4ge30sXHJcbiAgICAgICAgICAgICAgICBvblN0b3A6IG9uU3RvcFJlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5zY3JlZW5SZWNvcmRpbmdGbGFnID0gMFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5zY3JlZW5SZWNvcmRpbmdUaW1lIDwgMzAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5b2V5bGP5pe26Ze05b+F6aG75aSn5LqOM+enkid9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5TaG93UGFuZWwoe3RleHQ6ICfmmK/lkKbliIbkuqvmnKzmrKHlvZXlsY8nLCBmb3JXaGF0OiAnc2hhcmVWaWRlbycsIHZpZGVvUGF0aDogb25TdG9wUmVzLnZpZGVvUGF0aH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJNc2cgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+W9leWxj+W8guW4uDo+JywgZXJyTXNnKVxyXG4gICAgICAgICAgICAgICAgICAgIGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nRmxhZyA9IDBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNTY3JlZW5SZWNvcmRpbmdTaG93KClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkludGVycnVwdGlvbkJlZ2luOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5zY3JlZW5SZWNvcmRpbmdGbGFnID0gMFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY1NjcmVlblJlY29yZGluZ1Nob3coKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5b2V5bGP5pe26Ze05b+F6aG75bCP5LqOMzAw56eSJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g5Yib5bu65b2V5bGP566h55CG5bel5YW3XHJcbiAgICAgICAgICAgIGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuY3JlYXRlR2FtZVJlY29yZGVyKGNyZWF0ZUdhbWVSZWNvcmRlckluZm8sIGNyZWF0ZUdhbWVSZWNvcmRlckNhbGxiYWNrID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfliJvlu7rlvZXlsY/nrqHnkIblt6Xlhbflm57osIM6PicsIGNyZWF0ZUdhbWVSZWNvcmRlckNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUdhbWVSZWNvcmRlckNhbGxiYWNrLmNvZGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmVlblJlY29yZGluZ0J0bi5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfWVsc2UgaWYgKGlzS3VhaVNob3Upe1xyXG4gICAgICAgICAgICBsZXQgY3JlYXRlR2FtZVJlY29yZGVySW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIG9uU3RhcnQ6IHJlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLlvZXlsY/lvIDlp4s6XCIsIHJlcylcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblN0b3A6IHN0b3BSZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi57uT5p2f5b2V5Yi2OlwiLHN0b3BSZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLnNjcmVlblJlY29yZGluZ0ZsYWcgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBleW91Q2xpZW50S3MuZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nVGltZSA8IDMwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLlNob3dQYW5lbCh7dGV4dDogJ+W9leWxj+aXtumXtOW/hemhu+Wkp+S6jjPnp5InfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaYr+WQpuWIhuS6q+acrOasoeW9leWxjzpcIixzdG9wUmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5piv5ZCm5YiG5Lqr5pys5qyh5b2V5bGPJywgZm9yV2hhdDogJ3NoYXJlVmlkZW8nLCB2aWRlb1BhdGg6IHN0b3BSZXMudmlkZW9JZH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJNc2cgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyTXNnLmVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign5b2V5bGP6ZSZ6K+v5L+h5oGvOj4nLCBlcnJvcilcclxuICAgICAgICAgICAgICAgICAgICBleW91Q2xpZW50S3MuZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nRmxhZyA9IDBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNTY3JlZW5SZWNvcmRpbmdTaG93KClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0ga3MuZXJyb3IuR2FtZVJlY29yZGVyX1JlY29yZEZhaWxlZFRpbWVSYW5nZVRvb1Nob3J0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLlNob3dQYW5lbCh7dGV4dDogJ+W9leWItue7k+adn++8jOW9leWItuaXtumXtOWkquefrSd9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0ga3MuZXJyb3IuR2FtZVJlY29yZGVyX1JlY29yZEZhaWxlZFRpbWVSYW5nZVRvb0xvbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5b2V5Yi257uT5p2f77yM5b2V5Yi25pe26Ze05aSq6ZW/J30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBrcy5lcnJvci5HYW1lUmVjb3JkZXJfUmVjb3JkRmFpbGVkTm9WaWRlbyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5TaG93UGFuZWwoe3RleHQ6ICflvZXliLbnu5PmnZ/vvIzmnKrlvZXliLbliLDop4bpopEnfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGtzLmVycm9yLkdhbWVSZWNvcmRlcl9QdWJsaXNoVmlkZW9GYWlsZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5b2V5bGP5aSx6LSlJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkFib3J0OiByZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV5b3VDbGllbnRLcy5nZXRJbnMoKS5zY3JlZW5SZWNvcmRpbmdGbGFnID0gMFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY1NjcmVlblJlY29yZGluZ1Nob3coKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5b2V5bGP5pe26Ze05b+F6aG75bCP5LqOMzAw56eSJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g5Yib5bu65b2V5bGP566h55CG5bel5YW3XHJcbiAgICAgICAgICAgIGV5b3VDbGllbnRLcy5nZXRJbnMoKS5jcmVhdGVHYW1lUmVjb3JkZXIoY3JlYXRlR2FtZVJlY29yZGVySW5mbywgY3JlYXRlR2FtZVJlY29yZGVyQ2FsbGJhY2sgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+WIm+W7uuW/q+aJi+W9leWxj+euoeeQhuW3peWFt+Wbnuiwgzo+JywgY3JlYXRlR2FtZVJlY29yZGVyQ2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlR2FtZVJlY29yZGVyQ2FsbGJhY2suY29kZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NyZWVuUmVjb3JkaW5nQnRuLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuUmVjb3JkaW5nQnRuLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkJ0blNjcmVlblJlY29yZGluZ0NsaWNrKCkge1xyXG4gICAgICAgIGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuICAgICAgICAgICAgaXNLdWFpU2hvdSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYy5zeXMuQllURURBTkNFX0dBTUUgPT09IGNjLnN5cy5wbGF0Zm9ybSkge1xyXG4gICAgICAgICAgICBpZiAoZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5zY3JlZW5SZWNvcmRpbmdGbGFnID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBleW91Q2xpZW50VGlrdG9rLmdldElucygpLmdhbWVSZWNvcmRlclN0YXJ0KHtkdXJhdGlvbjogMzAwfSlcclxuICAgICAgICAgICAgICAgIGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nRmxhZyA9IDFcclxuICAgICAgICAgICAgICAgIGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nVGltZSA9IERhdGUubm93KClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuZ2FtZVJlY29yZGVyU3RvcCgpXHJcbiAgICAgICAgICAgICAgICBleW91Q2xpZW50VGlrdG9rLmdldElucygpLnNjcmVlblJlY29yZGluZ0ZsYWcgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChleW91Q2xpZW50S3MuZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nRmxhZyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLmdhbWVSZWNvcmRlclN0YXJ0KClcclxuICAgICAgICAgICAgICAgIGV5b3VDbGllbnRLcy5nZXRJbnMoKS5zY3JlZW5SZWNvcmRpbmdGbGFnID0gMVxyXG4gICAgICAgICAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLnNjcmVlblJlY29yZGluZ1RpbWUgPSBEYXRlLm5vdygpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaMiemSrueCueWHu+S6huWBnOatouW9leWxj+S6i+S7tlwiKVxyXG4gICAgICAgICAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLmdhbWVSZWNvcmRlclN0b3AoKVxyXG4gICAgICAgICAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLnNjcmVlblJlY29yZGluZ0ZsYWcgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3luY1NjcmVlblJlY29yZGluZ1Nob3coKVxyXG4gICAgfSxcclxuXHJcbiAgICBzeW5jU2NyZWVuUmVjb3JkaW5nU2hvdygpIHtcclxuICAgICAgICBsZXQgaXNLdWFpU2hvdSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcbiAgICAgICAgICAgIGlzS3VhaVNob3UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmRleCA9IGlzS3VhaVNob3UgPyBleW91Q2xpZW50S3MuZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nRmxhZyA6IGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuc2NyZWVuUmVjb3JkaW5nRmxhZ1xyXG4gICAgICAgIGxldCBwYXRoID0gJy9hdGxhcy9zY3JlZW5SZWNvcmRpbmctJyArIGluZGV4O1xyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKHBhdGgsIGNjLlNwcml0ZUZyYW1lLCAoZXJyLCBzcHJpdGVGcmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NldCBzcHJpdGUgZnJhbWUgZmFpbGVkISBlcnInLCBwYXRoLCBlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcmVlblJlY29yZGluZ0J0bi5nZXRDb21wb25lbnQoY2MuU3ByaXRlKS5zcHJpdGVGcmFtZSA9IHNwcml0ZUZyYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc2t0b3BVc2VCdG5TaG93KCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcbiAgICAgICAgICAgIC8v5qOA5p+l55So5oi35piv5ZCm5bey57uP5bCG5bCP5ri45oiP6K6+5Li65bi455SoXHJcbiAgICAgICAgICAgIGxldCB1c2UgPSB0aGlzLnVzZUJ0bjtcclxuICAgICAgICAgICAga3MuY2hlY2tDb21tb25Vc2Uoe1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg6K6+5Li65bi455So5p+l6K+i57uT5p6c5Li677yaJHtyZXMuaXNDb21tb25Vc2V9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlLmFjdGl2ZSA9ICFyZXMuaXNDb21tb25Vc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmFpbChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWwj+a4uOaIj+iuvuS4uuW4uOeUqOWksei0peWbnuiwgzpcIixKU09OLnN0cmluZ2lmeShlcnIpKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKHJlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLlsI/muLjmiI/orr7kuLrluLjnlKjlm57osIM6XCIsSlNPTi5zdHJpbmdpZnkocmVzKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy/mo4Dmn6XlsI/muLjmiI/lv6vmjbfmlrnlvI/mmK/lkKblt7Lmt7vliqDliLDmiYvmnLrmoYzpnaLkuIrvvIzku4UgQW5kcm9pZCDmlK/mjIFcclxuICAgICAgICAgICAgbGV0IGRlc2t0b3AgPSB0aGlzLmRlc2t0b3BCdG47XHJcbiAgICAgICAgICAgIGtzLmNoZWNrU2hvcnRjdXQoe1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+agueaNrnJlcy5pbnN0YWxsZWQg5p2l5Yik5pat5piv5ZCm5re75Yqg5oiQ5YqfXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLmmK/lkKblt7Lmt7vliqDlv6vmjbfmlrnlvI9cIiwgcmVzLmluc3RhbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVza3RvcC5hY3RpdmUgPSAhcmVzLmluc3RhbGxlZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmYWlsKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gLTEwMDA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5pqC5LiN5pSv5oyB5qOA5p+l55So5oi35piv5ZCm5bey5re75Yqg5omL5py65qGM6Z2i6K+l5Yqf6IO9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5qOA5p+l5b+r5o235pa55byP5aSx6LSlXCIsIGVyci5tc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+azqOaEj++8muW/q+aNt+aWueW8j+WSjG1pbmkgYXBr55qE5pa55byP77yM55So5oi36KOF5LqG5ZOq56eN6YO9566X5oiQ5Yqf6LWwc3VjY2Vzc+Wbnuiwg+OAglxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+S9huaYr+WmguaenOmDveayoeijheeahOaDheWGteS4i++8jOS4uuWFvOWuueS7peWJjeeJiOacrO+8jOS8muWFiOWIpOaWreW/q+aNt+aWueW8j++8jOWGjeWIpOaWrW1pbmkgYXBr55qE5pa55byP77yM6L+Z56eN5oOF5Ya15pyA5ZCO5Lya6LWw5YiwZmFpbOWbnuiwg1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+aJgOS7peW9k2Vyci5tc2fkuLpcImFwayBpbmZvIGlzIGludmFsaWRcIueahOaDheWGteWHuueOsOaXtu+8jOS5n+WPr+S7peWcqOa4uOaIj+WGheWxleekuua3u+WKoOahjOmdoueahGljb27mj5DphpLnlKjmiLfjgIJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNrdG9wQnRuLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIHRoaXMudXNlQnRuLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgb25EZXNrdG9wQ2xpY2soKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuICAgICAgICAgICAgZXlvdUNsaWVudEtzLmdldElucygpLmFkZFNob3J0Y3V0KHJlcyA9PntcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5re75Yqg5qGM6Z2i5b+r5o235pa55byP57uT5p6cOlwiLEpTT04uc3RyaW5naWZ5KHJlcykpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblVzZUNsaWNrKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcbiAgICAgICAgICAgIGV5b3VDbGllbnRLcy5nZXRJbnMoKS5hZGRDb21tb25Vc2UocmVzID0+e1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLorr7kuLrluLjnlKjnu5Pmnpw6XCIsSlNPTi5zdHJpbmdpZnkocmVzKSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlZnJlc2hBZHNTcDpmdW5jdGlvbiAoc2VlZCkge1xyXG4gICAgICAgIGlmKHNlZWQgPT0gMSlcclxuICAgICAgICAgICAgdGhpcy5BZFNwID0gXCJhaXNoZW5cIjtcclxuICAgICAgICBlbHNlIGlmKHNlZWQgPT0gMilcclxuICAgICAgICAgICAgdGhpcy5BZFNwID0gXCJkdXNoZW5cIjtcclxuICAgICAgICBlbHNlIGlmKHNlZWQgPT0gMylcclxuICAgICAgICAgICAgdGhpcy5BZFNwID0gXCJjYWlzaGVuXCI7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLkFkU3AgPSBcImd1c2hlblwiO1xyXG5cclxuICAgICAgICB0aGlzLldhdGNoQWRzQnRuLnNwcml0ZUZyYW1lID0gdGhpcy5CaWdBcEF0bGFzLmdldFNwcml0ZUZyYW1lKHRoaXMuQWRTcCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v5Yid5aeL5YyW546w6YeRXHJcbiAgICBpbml0Q2FzaDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWVkID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IudHV0b3JpYWxJbk1hcmtldCA9PSBmYWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNlZWQgPSAwLjk5OTtcclxuICAgICAgICB9XHJcbiAgICBcdFxyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG5cclxuICAgIFx0aWYoc2VlZCA8PSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNhc2gsIDEpLndlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5nbG9iYWwuSW5pdEdldE1vbmV5SWQgPSAxO1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIkNhc2hfMVwiKTsgLy9jYy5kaXJlY3Rvci5Ob3RpY2VUZXh0LkNhc2hfMTtcclxuICAgIFx0XHRjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuQ2FzaCwgMSkuY2FzaDtcclxuICAgICAgICB9XHJcbiAgICBcdGVsc2UgaWYoc2VlZCA8PSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNhc2gsIDEpLndlaWdodCArIGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuQ2FzaCwgMikud2VpZ2h0KVxyXG5cdFx0e1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLkluaXRHZXRNb25leUlkID0gMjtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJDYXNoXzJcIik7Ly9jYy5kaXJlY3Rvci5Ob3RpY2VUZXh0LkNhc2hfMjtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNhc2gsIDIpLmNhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgXHRlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLkluaXRHZXRNb25leUlkID0gMztcclxuICAgICAgICAgICAgdGhpcy5UaXBDYXNoU3Auc3ByaXRlRnJhbWUgPSB0aGlzLk1haW5BdGxhcy5nZXRTcHJpdGVGcmFtZShcImJzcWpcIik7XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiQ2FzaF8zXCIpOy8vY2MuZGlyZWN0b3IuTm90aWNlVGV4dC5DYXNoXzM7XHJcbiAgICBcdFx0Y2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNhc2gsIDMpLmNhc2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLkNvbW1vblRpcC5hY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi6YCa55So5o+Q56S65bey57uP5Zyo5bGV56S6XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLlNob3dQYW5lbChwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoICs9IGNjLk1nci5Vc2VyRGF0YU1nci5Jbml0TW9uZXlCb251czsvL+WKoOS4iuWIneWni+WKoOaIkFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5Bc3NldHNNb25leSA9IGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5IaWdoQXNzZXRzID0gY2MuTWdyLlVzZXJEYXRhTWdyLkFzc2V0c01vbmV5O1xyXG4gICAgfSxcclxuICAgIC8v5Yid5aeL5YyWVG9wIFVJIFxyXG4gICAgaW5pdFRvcFVJRGF0YTpmdW5jdGlvbiAoKSB7XHJcbiAgICBcdHRoaXMuaW5pdENhc2goKTtcclxuICAgIFx0dGhpcy5DYXNoTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoKTtcclxuICAgIFx0dGhpcy5Bc3NldExibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShjYy5NZ3IuVXNlckRhdGFNZ3IuQXNzZXRzTW9uZXkpO1xyXG4gICAgXHR0aGlzLkN1ckFnZUxibC5zdHJpbmcgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlO1xyXG4gICAgICAgIHRoaXMuVG90YWxBZ2VMYmwuc3RyaW5nID0gY2MuTWdyLlVzZXJEYXRhTWdyLnJldGlyZUFnZTtcclxuICAgIFx0dGhpcy5IcExibC5zdHJpbmcgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludDtcclxuICAgIFx0dGhpcy5SZXB1dGF0aW9uTGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5SZXB1dGF0aW9uO1xyXG4gICAgICAgIHZhciBsYXN0Q2FwID0gY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUFsbENhcGNpdHkgLSBjYy5NZ3IuVXNlckRhdGFNZ3IuV2FyZUhvdXNlQ2FwY2l0eTtcclxuICAgIFx0dGhpcy5DYXBjaXR5TGJsLnN0cmluZyA9IFwiKFwiK2xhc3RDYXAgK1wiL1wiK2NjLk1nci5Vc2VyRGF0YU1nci5XYXJlSG91c2VBbGxDYXBjaXR5K1wiKVwiO1xyXG4gICAgfSxcclxuICAgIC8v5Yid5aeL5YyW5biC5Zy6IGl0ZW1zXHJcbiAgICBJbml0TWFya2V0SXRlbXM6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2xlYXJTaG93R29vZHNMaXN0KCk7XHJcblxyXG4gICAgICAgIHZhciBEYXRhTGlzdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFMaXN0QnlTZXgoY2MuTWdyLlVzZXJEYXRhTWdyLlNleCk7XHJcbiAgICAgICAgdmFyIHNob3dBcnIgPSB0aGlzLmdldEFycmF5QnlJdGVtcyhEYXRhTGlzdC5sZW5ndGgsIDUpO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBEYXRhTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IERhdGFMaXN0W2ldO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gY2MuaW5zdGFudGlhdGUodGhpcy5NYXJrZXRJdGVtKTtcclxuICAgICAgICAgICAgb2JqLnBhcmVudCA9IHRoaXMuTWFya2V0UGFyZW50O1xyXG4gICAgICAgICAgICBvYmouYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9iai5nZXRDb21wb25lbnQoXCJHb29kc0l0ZW1cIikuaW5pdChkYXRhKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHNob3dBcnIubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmKGkgPT0gc2hvd0FycltqXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsSW5NYXJrZXQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gb2JqLmdldENvbXBvbmVudChcIkdvb2RzSXRlbVwiKS5yZWZyZXNoTG93UHJpY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG9iai5nZXRDb21wb25lbnQoXCJHb29kc0l0ZW1cIikucmVmcmVzaFByaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkluc2VydEdvb2RzSWRUb0xpc3QoZGF0YS5JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuTWFya2V0VGlwUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuTWFya2V0VGlwUGFuZWwuU2hvd1BhbmVsKHBhcmFtKTtcclxuXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsSW5NYXJrZXQgPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IDExOy8v5byA5aeL5byV5a+856ys5LiA5q2lXHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5UdXRvcmlhbFBhbmVsLlNldENhbGxGdW5jKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQnV5VGlwLCBwYXJhbVswXSk7XHJcbiAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IDEyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR0ID0ge307XHJcbiAgICAgICAgICAgICAgICBkdC5zdGVwID0gMTI7XHJcbiAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2hvd1BhbmVsKGR0KTtcclxuICAgICAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5TZXRDYWxsRnVuYyhmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5nbG9iYWwudHV0b3JpYWxHb29kc0lkID0gc2VsZi5CdXlUaXAuQ2xpY2tCdXlCdG4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IDEzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkMyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGQzLnN0ZXAgPSAxMztcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2hvd1BhbmVsKGQzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2V0Q2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWxmLlJlZnJlc2hEYXRhVG9OZXh0WWVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlRvTmV4dFllYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgPSAxNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQ0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ0LnN0ZXAgPSAxNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5UdXRvcmlhbFBhbmVsLlNob3dQYW5lbChkNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5TZXRDYWxsRnVuYyhmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlblNhbGVUaXAsIGNjLk1nci5Vc2VyRGF0YU1nci5nZXRHb29kc0RhdGFCeUlkKHBhcmFtWzBdLklkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IDE1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQ1ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkNS5zdGVwID0gMTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2hvd1BhbmVsKGQ1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5TZXRDYWxsRnVuYyhmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuU2FsZVRpcC5DbGlja1NhbGVCdG4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbEluTWFya2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTsgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WQkeS4i+WIt+aWsOS4gOW5tFxyXG4gICAgUmVmcmVzaERhdGFUb05leHRZZWFyOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgPT0gMTMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuW8leWvvOaXtumXtD09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hVc2VyQWdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFR1dG9yaWFsSXRlbXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5UaW1lUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlRpbWVQYW5lbC5QbGF5QW5pbWEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaFVzZXJBZ2UoKTtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMuQ2hlY2tUdXRvcmlhbEhhcHBlbigpO1xyXG5cclxuICAgICAgICB0aGlzLlJlZnJlc2hDb21wYW55SXRlbXMoKTtcclxuICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9PSAxMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFR1dG9yaWFsSXRlbXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5SZWZyZXNoSXRlbXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuUmVmcmVzaE93bmVkSXRlbXNTdGF0ZSgpO1xyXG5cclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaFVzZXJBc3NldHModHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/liqDmiJDlpZblirFcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuR2V0Qm9udXNSZXdhcmRFdmVyeVllYXIoKTtcclxuXHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hIZWFsdGhIcCgpO1xyXG5cclxuICAgICAgICB0aGlzLlJlZnJlc2hVSVNob3coKTtcclxuXHJcbiAgICAgICAgdGhpcy5DaGVja0V2ZW50SGFwcGVuKCk7XHJcbiAgICAgICAgKi9cclxuICAgIH0sXHJcblxyXG4gICAgVG9OZXh0WWVhcjpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubWFya2V0VGlwRGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoVXNlckFnZSgpO1xyXG4gICAgICAgIC8vY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLkNoZWNrVHV0b3JpYWxIYXBwZW4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5SZWZyZXNoQ29tcGFueUl0ZW1zKCk7XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgPT0gMTMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLy8vY2MubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT09PT095byV5a+85pe26Ze0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hUdXRvcmlhbEl0ZW1zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPT0gMjIgfHwgY2MuTWdyLlVzZXJEYXRhTWdyLkFnZSA9PSAyNCB8fCBjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlID09IDI1XHJcbiAgICAgICAgICAgICAgICB8fCBjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlID09IDI3IHx8IGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPT0gMjggfHwgY2MuTWdyLlVzZXJEYXRhTWdyLkFnZSA9PSAzMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5SZWZyZXNoSXRlbXNGb3JTcGVjaWFsQWdlKCk7XHJcbiAgICAgICAgICAgIH1lbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuUmVmcmVzaEl0ZW1zKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLlJlZnJlc2hPd25lZEl0ZW1zU3RhdGUoKTtcclxuICAgICAgICAvL+WKoOaIkOWlluWKsVxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5HZXRCb251c1Jld2FyZEV2ZXJ5WWVhcigpO1xyXG5cclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaFVzZXJBc3NldHModHJ1ZSk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5SZWZyZXNoSGVhbHRoSHAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5SZWZyZXNoVUlTaG93KCk7XHJcblxyXG4gICAgICAgIHRoaXMuQ2hlY2tFdmVudEhhcHBlbigpO1xyXG4gICAgfSxcclxuXHJcbiAgICBDaGVja1R1dG9yaWFsSGFwcGVuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkFnZSA9PSAyNSAmJiBjYy5NZ3IuVXNlckRhdGFNZ3IudHV0b3JpYWxJbkRhdGUgPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IFR1dG9yaWFsU3RlcC5NYXRlRGF0ZV8xO1xyXG4gICAgICAgICAgICB2YXIgZHQgPSB7fTtcclxuICAgICAgICAgICAgZHQuc3RlcCA9IFR1dG9yaWFsU3RlcC5NYXRlRGF0ZV8xO1xyXG4gICAgICAgICAgICB0aGlzLlR1dG9yaWFsUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlR1dG9yaWFsUGFuZWwuU2hvd1BhbmVsKGR0KTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2V0Q2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuQ2hvb3NlT3Blbk1hdGVQYW5lbCgpO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgPSBUdXRvcmlhbFN0ZXAuTWF0ZURhdGVfMjtcclxuICAgICAgICAgICAgICAgIHZhciBkdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZHQuc3RlcCA9IFR1dG9yaWFsU3RlcC5NYXRlRGF0ZV8yO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5UdXRvcmlhbFBhbmVsLlNob3dQYW5lbChkdCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2V0Q2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbEluRGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPT0gMzAgJiYgY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsSW5CdXMgPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IFR1dG9yaWFsU3RlcC5CdXNpbmVzc18xO1xyXG4gICAgICAgICAgICB2YXIgZHQgPSB7fTtcclxuICAgICAgICAgICAgZHQuc3RlcCA9IFR1dG9yaWFsU3RlcC5CdXNpbmVzc18xO1xyXG4gICAgICAgICAgICB0aGlzLlR1dG9yaWFsUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlR1dG9yaWFsUGFuZWwuU2hvd1BhbmVsKGR0KTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2V0Q2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuQ2hvb3NlT3BlbkJ1c2lzbmVzcygpO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgPSBUdXRvcmlhbFN0ZXAuQnVzaW5lc3NfMjtcclxuICAgICAgICAgICAgICAgIHZhciBkdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZHQuc3RlcCA9IFR1dG9yaWFsU3RlcC5CdXNpbmVzc18yO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5UdXRvcmlhbFBhbmVsLlNob3dQYW5lbChkdCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2V0Q2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbEluQnVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5oYXNDb21wYW55ID09IHRydWUgJiYgY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsU3RvY2tCb251cyA9PSBmYWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5nbG9iYWwudHV0b3JpYWxTdGVwID0gVHV0b3JpYWxTdGVwLlN0b2NrQm9udXNfMTtcclxuICAgICAgICAgICAgdmFyIGR0ID0ge307XHJcbiAgICAgICAgICAgIGR0LnN0ZXAgPSBUdXRvcmlhbFN0ZXAuU3RvY2tCb251c18xO1xyXG4gICAgICAgICAgICB0aGlzLlR1dG9yaWFsUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlR1dG9yaWFsUGFuZWwuU2hvd1BhbmVsKGR0KTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwuU2V0Q2FsbEZ1bmMoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIGNjLk1nci5nbG9iYWwudHV0b3JpYWxTdGVwID0gLTE7XHJcbiAgICAgICAgICAgICAgICBzZWxmLlR1dG9yaWFsUGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbFN0b2NrQm9udXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFN0YXJ0TWF0ZUxvdmVUdXRvcmlhbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbE1hdGVQb2ludCA9PSBmYWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5nbG9iYWwudHV0b3JpYWxTdGVwID0gVHV0b3JpYWxTdGVwLkRhdGVUb01hcnJ5XzE7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHt9O1xyXG4gICAgICAgICAgICBkdC5zdGVwID0gVHV0b3JpYWxTdGVwLkRhdGVUb01hcnJ5XzE7XHJcbiAgICAgICAgICAgIHRoaXMuVHV0b3JpYWxQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuVHV0b3JpYWxQYW5lbC5TaG93UGFuZWwoZHQpO1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5TZXRDYWxsRnVuYyhmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgPSAtMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuVHV0b3JpYWxQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsTWF0ZVBvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBDaGVja0V2ZW50SGFwcGVuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgIT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPD0gMjUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuRXZlbnREYXRhSWRMaXN0Lmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCLmspLmnInkuovku7ZJZCDkuoYgIOebtOaOpei/lOWbnlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIFxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPT0gY2MuTWdyLmdsb2JhbC5MYXN0RXZlbnRBZ2UpXHJcbiAgICAgICAgeyAgIFxyXG4gICAgICAgICAgICB2YXIgZUlkID0gY2MuTWdyLlVzZXJEYXRhTWdyLkdldEV2ZW50RGF0YUFuZFNwbGljZUlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuRXZlbnRQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuRXZlbnRQYW5lbC5TaG93UGFuZWwoZUlkKTtcclxuICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5MYXN0RXZlbnRBZ2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VlZCA9IGNjLk1nci5nbG9iYWwuU3Bhd25TZWVkQmV0d2VlblR3b051bSgyLDMpO1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcImNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPSBcIisgIGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UrXCIgICBzZWVkID0gXCIgKyBzZWVkICsgXCIgIOS6i+S7ti0tLS0tLS0tLS0tLS0tLS0tLSBMYXN0RXZlbnRBZ2UgXCIgKyBjYy5NZ3IuZ2xvYmFsLkxhc3RFdmVudEFnZSk7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgLSBzZWVkID49IGNjLk1nci5nbG9iYWwuTGFzdEV2ZW50QWdlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZUlkID0gY2MuTWdyLlVzZXJEYXRhTWdyLkdldEV2ZW50RGF0YUFuZFNwbGljZUlkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkV2ZW50UGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5FdmVudFBhbmVsLlNob3dQYW5lbChlSWQpO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5MYXN0RXZlbnRBZ2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8v5Yi35pawVUlcclxuICAgIFJlZnJlc2hVSVNob3c6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLlJlcHV0YXRpb25MYmwuc3RyaW5nID0gY2MuTWdyLlVzZXJEYXRhTWdyLlJlcHV0YXRpb247XHJcbiAgICAgICAgdGhpcy5DYXNoTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoKTtcclxuICAgICAgICB0aGlzLkFzc2V0TGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKGNjLk1nci5Vc2VyRGF0YU1nci5Bc3NldHNNb25leSk7XHJcbiAgICAgICAgdGhpcy5DdXJBZ2VMYmwuc3RyaW5nID0gY2MuTWdyLlVzZXJEYXRhTWdyLkFnZTtcclxuICAgICAgICB0aGlzLlRvdGFsQWdlTGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5yZXRpcmVBZ2U7XHJcbiAgICAgICAgdGhpcy5IcExibC5zdHJpbmcgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludDtcclxuICAgICAgICB0aGlzLlJlZnJlc2hIcEljb25TcCgpO1xyXG4gICAgICAgIHZhciBsYXN0Q2FwID0gY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUFsbENhcGNpdHkgLSBjYy5NZ3IuVXNlckRhdGFNZ3IuV2FyZUhvdXNlQ2FwY2l0eTtcclxuICAgICAgICB0aGlzLkNhcGNpdHlMYmwuc3RyaW5nID0gXCIoXCIrbGFzdENhcCArXCIvXCIrY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUFsbENhcGNpdHkrXCIpXCI7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkFzc2V0c01vbmV5IDwgMTAwMDAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5UaXBDYXNoU3Auc3ByaXRlRnJhbWUgPSB0aGlzLk1haW5BdGxhcy5nZXRTcHJpdGVGcmFtZShcImJzcWpcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkFzc2V0c01vbmV5ID4gMTAwMDAwICYmY2MuTWdyLlVzZXJEYXRhTWdyLkFzc2V0c01vbmV5IDwgMTAwMDAwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwQ2FzaFNwLnNwcml0ZUZyYW1lID0gdGhpcy5NYWluQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJzY3h4XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5Bc3NldHNNb25leSA+IDEwMDAwMDAgJiZjYy5NZ3IuVXNlckRhdGFNZ3IuQXNzZXRzTW9uZXkgPCAxMDAwMDAwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwQ2FzaFNwLnNwcml0ZUZyYW1lID0gdGhpcy5NYWluQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJzeWx4XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5Bc3NldHNNb25leSA+IDEwMDAwMDAwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwQ2FzaFNwLnNwcml0ZUZyYW1lID0gdGhpcy5NYWluQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJiZHpjXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaEhwSWNvblNwOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQgPj0gY2MuTWdyLmdsb2JhbC5IcFN0YXRlQSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuSHBJY29uLnNwcml0ZUZyYW1lID0gdGhpcy5NYWluQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJzdGF0ZV8xXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50ID49IGNjLk1nci5nbG9iYWwuSHBTdGF0ZUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkhwSWNvbi5zcHJpdGVGcmFtZSA9IHRoaXMuTWFpbkF0bGFzLmdldFNwcml0ZUZyYW1lKFwic3RhdGVfMlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludCA8PSBjYy5NZ3IuZ2xvYmFsLkhwU3RhdGVDKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5IcEljb24uc3ByaXRlRnJhbWUgPSB0aGlzLk1haW5BdGxhcy5nZXRTcHJpdGVGcmFtZShcInN0YXRlXzNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+e6puS8muWujOaIkOaVsOaNruWIt+aWsOi/lOWbnlxyXG4gICAgUmVmcmVzaE1hdGVJdGVtVUk6ZnVuY3Rpb24oSWQpe1xyXG4gICAgICAgIHRoaXMuTWF0ZVBhbmVsLlJlZnJlc2hQYW5lbChJZClcclxuICAgIH0sXHJcblxyXG4gICAgLy/pmo/nnYDlubTku73liLfmlrAg5Yi35paw5bGV56S655qE54mp5ZOBIOWPquWIt+WHuumrmOS7t1xyXG4gICAgUmVmcmVzaFR1dG9yaWFsSXRlbXM6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLk1hcmtldFBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgcGFyYW0gPSBbXTsvL+aVsOaNrlxyXG4gICAgICAgIHRoaXMubWFya2V0VGlwRGF0YSA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IFxyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJHb29kc0l0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmKGNoaWxkcmVuW2ldLmFjdGl2ZSA9PSB0cnVlICYmIHNjLklkID09IGNjLk1nci5nbG9iYWwudHV0b3JpYWxHb29kc0lkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYy5yZWZyZXNoVXBQcmljZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYy5yZWZyZXNoUHJpY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmFtLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJrZXRUaXBEYXRhID0gcGFyYW07XHJcbiAgICB9LFxyXG5cclxuICAgIENoZWNrSGFzRWxlbWVudDpmdW5jdGlvbihvdXRhcnIsIGluZGV4KXtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dGFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZihpbmRleCA9PSBvdXRhcnJbal0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/pmo/nnYDlubTku73liLfmlrAg5Yi35paw5bGV56S655qE54mp5ZOBICDnibnliKvlubTku71cclxuICAgIFJlZnJlc2hJdGVtc0ZvclNwZWNpYWxBZ2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2xlYXJTaG93R29vZHNMaXN0KCk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5NYXJrZXRQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIG91dGFyciA9IFtdO1xyXG4gICAgICAgIHZhciBzdGF0ZUxpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgdmFyIHNjID0gY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiR29vZHNJdGVtXCIpO1xyXG4gICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhcyA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlR29vZHNPd25lZChzYy5JZCk7XHJcbiAgICAgICAgICAgICAgICBpZihoYXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhciA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhci5JZCA9IHNjLklkO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhci5TdGF0ZSA9IHNjLlN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTGlzdC5wdXNoKHBhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0YXJyLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLkNoZWNrSGFzRWxlbWVudChvdXRhcnIsIGkpID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaG93QXJyID0gdGhpcy5nZXRBcnJheUl0ZW1zKGxpc3QsIDUtb3V0YXJyLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IG91dGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBzaG93QXJyLnB1c2gob3V0YXJyW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBhcmFtID0gW107Ly/mlbDmja5cclxuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgXHJcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJHb29kc0l0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vc2MucmVmcmVzaFByaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc2hvd0Fyci5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT0gc2hvd0FycltqXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2MuSWQgPT0gMSB8fCBzYy5JZCA9PSAzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2MucmVmcmVzaE1pZFByaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ZGF0YSA9IHRoaXMuSnVkZUdvb2RzSGFzKHN0YXRlTGlzdCwgc2MuSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3V0ZGF0YS5oYXMgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvdXRkYXRhLlN0YXRlID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2MucmVmcmVzaE1pZFByaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG91dGRhdGEuU3RhdGUgPj0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYy5yZWZyZXNoVXBQcmljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2MucmVmcmVzaFByaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkluc2VydEdvb2RzSWRUb0xpc3Qoc2MuSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgIT0gLTEpLy8oY2MuTWdyLlVzZXJEYXRhTWdyLkFnZSA9PSAyNSAmJiBjYy5NZ3IuVXNlckRhdGFNZ3IudHV0b3JpYWxJbkRhdGUgPT0gZmFsc2UpIHx8IChjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlID09IDMwICYmIGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbEluQnVzID09IGZhbHNlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5byV5a+86Zi25q61XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuTWFya2V0VGlwUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLk1hcmtldFRpcFBhbmVsLlNob3dQYW5lbChwYXJhbSk7XHJcbiAgICAgICAgfSAgICBcclxuICAgIH0sXHJcblxyXG4gICAgSnVkZUdvb2RzSGFzOmZ1bmN0aW9uKExpc3QsIElkKXtcclxuICAgICAgICB2YXIgb3V0ID0ge307XHJcbiAgICAgICAgb3V0LlN0YXRlID0gMDsgXHJcbiAgICAgICAgb3V0LmhhcyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZihMaXN0W2ldLklkID09IElkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXQuU3RhdGUgPSBMaXN0W2ldLlN0YXRlOyBcclxuICAgICAgICAgICAgICAgIG91dC5oYXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+maj+edgOW5tOS7veWIt+aWsCDliLfmlrDlsZXnpLrnmoTnianlk4FcclxuICAgIFJlZnJlc2hJdGVtczpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DbGVhclNob3dHb29kc0xpc3QoKTtcclxuICAgICAgICAvL3ZhciBEYXRhTGlzdCA9IGNjLk1nci5NYXBEYXRhTWdyLmdldERhdGFMaXN0QnlJdGVtVHlwZShJdGVtVHlwZS5Hb29kcyk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5NYXJrZXRQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIG91dGFyciA9W107XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC5Hb29kc0ZvcmVJZCAhPSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjID0gY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiR29vZHNJdGVtXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLkdvb2RzRm9yZUlkID09IHNjLklkKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0YXJyLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLkNoZWNrSGFzRWxlbWVudChvdXRhcnIsIGkpID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNob3dBcnIgPSB0aGlzLmdldEFycmF5SXRlbXMobGlzdCwgNS1vdXRhcnIubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gb3V0YXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHNob3dBcnIucHVzaChvdXRhcnJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcGFyYW0gPSBbXTsvL+aVsOaNrlxyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyBcclxuICAgICAgICAgICAgY2hpbGRyZW5baV0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIkdvb2RzSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHNob3dBcnIubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihpID09IHNob3dBcnJbal0pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNjLklkID09IGNjLk1nci5nbG9iYWwuR29vZHNGb3JlSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXQgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmF0IDwgMC43KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNjLlN0YXRlID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYy5yZWZyZXNoTWlkUHJpY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHNjLlN0YXRlID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYy5yZWZyZXNoVXBQcmljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5Hb29kc0ZvcmVJZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiA9PSAzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYy5yZWZyZXNoTWlkUHJpY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2MucmVmcmVzaFByaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkluc2VydEdvb2RzSWRUb0xpc3Qoc2MuSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC50dXRvcmlhbFN0ZXAgIT0gLTEpLy8oY2MuTWdyLlVzZXJEYXRhTWdyLkFnZSA9PSAyNSAmJiBjYy5NZ3IuVXNlckRhdGFNZ3IudHV0b3JpYWxJbkRhdGUgPT0gZmFsc2UpIHx8IChjYy5NZ3IuVXNlckRhdGFNZ3IuQWdlID09IDMwICYmIGNjLk1nci5Vc2VyRGF0YU1nci50dXRvcmlhbEluQnVzID09IGZhbHNlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5byV5a+86Zi25q61XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuTWFya2V0VGlwUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLk1hcmtldFRpcFBhbmVsLlNob3dQYW5lbChwYXJhbSk7XHJcbiAgICAgICAgfSAgICBcclxuICAgIH0sXHJcbiAgICAvLzAtYXJyTnVtIOS5i+mXtOmaj+acuuaKveWPliBudW0g5Liq5pWw5Ye65p2lXHJcbiAgICBnZXRBcnJheUJ5SXRlbXM6ZnVuY3Rpb24oYXJyTnVtLCBudW0pe1xyXG4gICAgICAgIC8v5paw5bu65LiA5Liq5pWw57uELOWwhuS8oOWFpeeahOaVsOe7hOWkjeWItui/h+adpSznlKjkuo7ov5Dnrpcs6ICM5LiN6KaB55u05o6l5pON5L2c5Lyg5YWl55qE5pWw57uEO1xyXG4gICAgICAgIHZhciB0ZW1wX2FycmF5ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPTA7IGluZGV4IDwgYXJyTnVtIDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB0ZW1wX2FycmF5LnB1c2goaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WPluWHuueahOaVsOWAvOmhuSzkv53lrZjlnKjmraTmlbDnu4RcclxuICAgICAgICB2YXIgcmV0dXJuX2FycmF5ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGk8bnVtOyBpKyspIHtcclxuICAgICAgICAgICAgLy/liKTmlq3lpoLmnpzmlbDnu4Tov5jmnInlj6/ku6Xlj5blh7rnmoTlhYPntKAs5Lul6Ziy5LiL5qCH6LaK55WMXHJcbiAgICAgICAgICAgIGlmICh0ZW1wX2FycmF5Lmxlbmd0aD4wKSB7XHJcbiAgICAgICAgICAgICAgICAvL+WcqOaVsOe7hOS4reS6p+eUn+S4gOS4qumaj+acuue0ouW8lVxyXG4gICAgICAgICAgICAgICAgdmFyIGFyckluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnRlbXBfYXJyYXkubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIC8v5bCG5q2k6ZqP5py657Si5byV55qE5a+55bqU55qE5pWw57uE5YWD57Sg5YC85aSN5Yi25Ye65p2lXHJcbiAgICAgICAgICAgICAgICByZXR1cm5fYXJyYXlbaV0gPSB0ZW1wX2FycmF5W2FyckluZGV4XTtcclxuICAgICAgICAgICAgICAgIC8vLy9jYy5sb2coXCIrKysrKysrKysrKysrKysrKysrKysrKysrKytcIiArIHJldHVybl9hcnJheVtpXSk7XHJcbiAgICAgICAgICAgICAgICAvL+eEtuWQjuWIoOaOieatpOe0ouW8leeahOaVsOe7hOWFg+e0oCzov5nml7blgJl0ZW1wX2FycmF55Y+Y5Li65paw55qE5pWw57uEXHJcbiAgICAgICAgICAgICAgICB0ZW1wX2FycmF5LnNwbGljZShhcnJJbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+aVsOe7hOS4reaVsOaNrumhueWPluWujOWQjizpgIDlh7rlvqrnjq8s5q+U5aaC5pWw57uE5pys5p2l5Y+q5pyJMTDpobks5L2G6KaB5rGC5Y+W5Ye6MjDpobkuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuX2FycmF5O1xyXG4gICAgfSxcclxuICAgIC8v5LuO5pWw57uEYXJy5Lit6ZqP5py66YCJ5Y+WIG51bSDkuKrmlbBcclxuICAgIGdldEFycmF5SXRlbXM6ZnVuY3Rpb24oYXJyLCBudW0pe1xyXG4gICAgICAgIC8v5paw5bu65LiA5Liq5pWw57uELOWwhuS8oOWFpeeahOaVsOe7hOWkjeWItui/h+adpSznlKjkuo7ov5Dnrpcs6ICM5LiN6KaB55u05o6l5pON5L2c5Lyg5YWl55qE5pWw57uEO1xyXG4gICAgICAgIHZhciB0ZW1wX2FycmF5ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPTA7IGluZGV4IDwgYXJyLmxlbmd0aCA7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdGVtcF9hcnJheS5wdXNoKGFycltpbmRleF0pO1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuWhnui/m+WOu+eahOaVsOWAvCA9IFwiICsgYXJyW2luZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5Y+W5Ye655qE5pWw5YC86aG5LOS/neWtmOWcqOatpOaVsOe7hFxyXG4gICAgICAgIHZhciByZXR1cm5fYXJyYXkgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaTxudW07IGkrKykge1xyXG4gICAgICAgICAgICAvL+WIpOaWreWmguaenOaVsOe7hOi/mOacieWPr+S7peWPluWHuueahOWFg+e0oCzku6XpmLLkuIvmoIfotornlYxcclxuICAgICAgICAgICAgaWYgKHRlbXBfYXJyYXkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy/lnKjmlbDnu4TkuK3kuqfnlJ/kuIDkuKrpmo/mnLrntKLlvJVcclxuICAgICAgICAgICAgICAgIHZhciBhcnJJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp0ZW1wX2FycmF5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAvL+WwhuatpOmaj+acuue0ouW8leeahOWvueW6lOeahOaVsOe7hOWFg+e0oOWAvOWkjeWItuWHuuadpVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuX2FycmF5W2ldID0gdGVtcF9hcnJheVthcnJJbmRleF07XHJcbiAgICAgICAgICAgICAgICAvL+eEtuWQjuWIoOaOieatpOe0ouW8leeahOaVsOe7hOWFg+e0oCzov5nml7blgJl0ZW1wX2FycmF55Y+Y5Li65paw55qE5pWw57uEXHJcbiAgICAgICAgICAgICAgICB0ZW1wX2FycmF5LnNwbGljZShhcnJJbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+aVsOe7hOS4reaVsOaNrumhueWPluWujOWQjizpgIDlh7rlvqrnjq8s5q+U5aaC5pWw57uE5pys5p2l5Y+q5pyJMTDpobks5L2G6KaB5rGC5Y+W5Ye6MjDpobkuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuX2FycmF5O1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+WIneWni+WMliDlt7Lnu4/mi6XmnInnianlk4FcclxuICAgIEluaXRPd25lZEl0ZW1zOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIERhdGFMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLkdvb2RzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gRGF0YUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBEYXRhTGlzdFtpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuT3duSXRlbSk7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLk93blBhcmVudDtcclxuICAgICAgICAgICAgb2JqLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZihkYXRhLm93bk51bSA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iai5nZXRDb21wb25lbnQoXCJPd25JdGVtXCIpLmluaXQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8v6LSt5Lmw5ZKM5Ye65ZSu5ZCO5Yi35paw5bey57uP5pyJ55qE54mp5ZOBXHJcbiAgICBSZWZyZXNoT3duZWRJdGVtczpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLk93blBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIHNjID0gY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiT3duSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoc2MuSWQgPT0gZGF0YS5JZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzYy5yZWZyZXNoRGF0YShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihkYXRhLm93bk51bSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlOyBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBSZWZyZXNoT3duZWRJdGVtc1N0YXRlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5Pd25QYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIk93bkl0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmKHNjICE9IG51bGwgJiYgY2hpbGRyZW5baV0uYWN0aXZlID09IHRydWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNjLlJlZnJlc2hTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy/liJ3lp4vljJbogqHluILmlbDmja5cclxuICAgIEluaXRDb21wYW55SXRlbXM6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgRGF0YUxpc3QgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0T3duRGF0YUxpc3RCeVR5cGUoSXRlbVR5cGUuQ29tcGFueSlcclxuICAgICAgICBmb3IgKHZhciBpID0gRGF0YUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBEYXRhTGlzdFtpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuQ29tcGFueUl0ZW0pO1xyXG4gICAgICAgICAgICBvYmoucGFyZW50ID0gdGhpcy5Db21wYW55UGFyZW50O1xyXG4gICAgICAgICAgICBvYmouYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkNvbXBhbnlJdGVtXCIpLmluaXQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WIt+aWsOiCoeW4guaVsOaNrlxyXG4gICAgUmVmcmVzaENvbXBhbnlJdGVtczpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuQ29tcGFueVBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgY2FuUHJvZml0ID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIkNvbXBhbnlJdGVtXCIpO1xyXG4gICAgICAgICAgICBpZihzYyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzYy5yZWZyZXNoUHJpY2UoKTtcclxuICAgICAgICAgICAgICAgIGlmKHNjLmNhbkdldFByb2ZpdCA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblByb2ZpdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2FuUHJvZml0ID09IHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FuR2V0U3RvY2tQcm9maXQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnNob3dTdG9ja1Byb2ZpdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5DYW5HZXRTdG9ja1Byb2ZpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnNob3dTdG9ja1Byb2ZpdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvL+WIt+aWsHVp5pi+56S6XHJcbiAgICBSZWZyZXNoQ29tcGFueUl0ZW1zQWZ0ZXJCdXk6ZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5Db21wYW55UGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJDb21wYW55SXRlbVwiKTtcclxuICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoc2MuSWQgPT0gZGF0YS5JZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzYy5SZWZyZXNoVUlTaG93KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvL+WIt+aWsHVp5pi+56S6XHJcbiAgICBSZWZyZXNoQ29tcGFueUl0ZW1zRnJvbUV2ZW50OmZ1bmN0aW9uKElkKXtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLkNvbXBhbnlQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5Db21wYW55ICxJZClcclxuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIHNjID0gY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiQ29tcGFueUl0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKHNjLklkID09IGRhdGEuSWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2MuUmVmcmVzaFVJU2hvdyhkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaENvbXBhbnlJdGVtc0FmdGVyRGlzdm9yY2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLkNvbXBhbnlQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIkNvbXBhbnlJdGVtXCIpO1xyXG4gICAgICAgICAgICBpZihzYyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzYy5SZWZyZXNoVUlTaG93QWZ0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgQ2hvb3NlT3Blbk1hcmtldDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEFkc1NwKDMpO1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5NYXJrZXRQYW5lbC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuTWF0ZVBhbmVsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5FbmpveVRpcFBhbmVsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5CdXNpbmVzc1BhbmVsLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnRvZ2dsZUJ1c3NpbmVzcy5pc0NoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvZ2dsZU1hcmtldC5pc0NoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlRW5qb3kuaXNDaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b2dnbGVNYXRlLmlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBDaG9vc2VPcGVuQnVzaXNuZXNzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsSW5CdXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEFkc1NwKDQpO1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5NYXJrZXRQYW5lbC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLk1hdGVQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuRW5qb3lUaXBQYW5lbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuQnVzaW5lc3NQYW5lbC5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLnRvZ2dsZUJ1c3NpbmVzcy5pc0NoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlTWFya2V0LmlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlRW5qb3kuaXNDaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b2dnbGVNYXRlLmlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBDaG9vc2VPcGVuTWF0ZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLnR1dG9yaWFsSW5EYXRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLk1hdGVOZXdUaXAuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoQWRzU3AoMSk7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLk1hcmtldFBhbmVsLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuTWF0ZVBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLkVuam95VGlwUGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLkJ1c2luZXNzUGFuZWwuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5NYXRlUGFuZWwuU2hvd1BhbmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMudG9nZ2xlQnVzc2luZXNzLmlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlTWFya2V0LmlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlRW5qb3kuaXNDaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b2dnbGVNYXRlLmlzQ2hlY2tlZCA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgQ2hvb3NlT3BlbkVuam95OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoQWRzU3AoMik7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLk1hcmtldFBhbmVsLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuTWF0ZVBhbmVsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5FbmpveVRpcFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLkJ1c2luZXNzUGFuZWwuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5FbmpveVRpcFBhbmVsLlNob3dQYW5lbCgpO1xyXG5cclxuICAgICAgICB0aGlzLnRvZ2dsZUJ1c3NpbmVzcy5pc0NoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvZ2dsZU1hcmtldC5pc0NoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvZ2dsZUVuam95LmlzQ2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50b2dnbGVNYXRlLmlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBDaG9vc2VPcGVuQmVsb25nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLk93bmVkVGlwUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuT3duZWRUaXBQYW5lbC5TaG93UGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2hvb3NlT3BlblRyZWF0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJUcmVhdFwiO1xyXG4gICAgICAgIHBhcmFtLnRleHQgPSBcIua2iOiAl+mHkemSseWbnuWkjeWBpeW6t1wiO1xyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50ID09IDEwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIlwiO1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLlgaXlurfnirblhrXoia/lpb3vvIzml6DpnIDmsrvnlpdcIjtcclxuICAgICAgICAgICAgdGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5TaG93UGFuZWwocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLlRyZWF0UGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlRyZWF0UGFuZWwuU2hvd1BhbmVsKCk7XHJcbiAgICAgICAgICAgIC8vdmFyIG5lZWRNb25leSA9IE1hdGguZmxvb3IoMjAwMCogTWF0aC5wb3coMS4xOCwgY2MuTWdyLlVzZXJEYXRhTWdyLkFnZS0yMCkgKigxLWNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50LzEwMCkpO1xyXG4gICAgICAgICAgICAvL3BhcmFtLm5lZWRNb25leSA9IG5lZWRNb25leTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZih0aGlzLkNvbW1vblRpcC5hY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICAvL3tcclxuICAgICAgICAvLyAgICAvL2NjLmxvZyhcIumAmueUqOaPkOekuuW3sue7j+WcqOWxleekulwiKTtcclxuICAgICAgICAvLyAgICByZXR1cm47XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgLy90aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgLy90aGlzLkNvbW1vblRpcC5TaG93UGFuZWwocGFyYW0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBDaG9vc2VPcGVuUmV0aXJlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIlJldGlyZVwiO1xyXG4gICAgICAgIHBhcmFtLnRleHQgPSBcIuS9oOehruWumuimgee7k+adn+S9oOeahOWli+aWl+WPsu+8n++8n1wiO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuQ29tbW9uVGlwLmFjdGl2ZSA9PSB0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCLpgJrnlKjmj5DnpLrlt7Lnu4/lnKjlsZXnpLpcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuQ29tbW9uVGlwLlNob3dQYW5lbChwYXJhbSk7XHJcbiAgICB9LFxyXG5cclxuICAgIENob29zZU9wZW5SYW5rUGFuZWw6ZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgLy8gdG9kbyDmmoLml7blhYjliqDkuIrlip/og73mnKrlvIDmlL5cclxuICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHt0ZXh0OiAn5Yqf6IO95pqC5pyq5byA5pS+LCDmlazor7fmnJ/lvoUnfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG5cclxuICAgICAgICBpZighY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5Jc0xvZ2luU3luYygpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBcIuivt+WFiOeZu+mZhuaJi+acuueZvuW6plwiO1xyXG4gICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJMb2dpblwiO1xyXG4gICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLlNob3dQYW5lbChwYXJhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuICAgICAgICAgICAgaXNLdWFpU2hvdSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSlcclxuICAgICAgICAgICAgdGhpcy53eFN1YkNvbnRleHRWaWV3LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgZWxzZSBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CQUlEVV9HQU1FKVxyXG4gICAgICAgICAgICB0aGlzLlN3YW5TdWJDb250ZXh0Vmlldy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLnNob3dTdWJDb250ZW50VmlldygpO1xyXG4gICAgICAgIGNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIuU2VuZE1lc3NhZ2VUb1N1YlZpZXcoXCJSYW5rT3BlblwiKTtcclxuICAgICAgICBpZigoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuV0VDSEFUX0dBTUUgJiYgIWlzS3VhaVNob3UpIHx8IGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJBSURVX0dBTUUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJhbmtQYW5lbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVJhbmtWaWV3OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5yYW5rUGFuZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLmhpZGVTdWJDb250ZW50VmlldygpO1xyXG4gICAgICAgIGNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIuU2VuZE1lc3NhZ2VUb1N1YlZpZXcoXCJSYW5rQ2xvc2VcIik7XHJcbiAgICAgICAgdGhpcy53eFN1YkNvbnRleHRWaWV3LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuU3dhblN1YkNvbnRleHRWaWV3LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBPcGVuQWRkQ2FwYWNpdHk6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5XYXJlSG91c2VBbGxDYXBjaXR5ID09IDIwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJcIjtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IFwi5LuT5YKo5a656YeP6L6+5Yiw5LiK6ZmQXCI7XHJcbiAgICAgICAgICAgIHRoaXMuQ29tbW9uVGlwLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLkFkZENhcFBhbmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLkFkZENhcFBhbmVsLlNob3dQYW5lbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBPcGVuTWFya2V0VGlwUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMuTWFya2V0VGlwUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGlmKHRoaXMubWFya2V0VGlwRGF0YSAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5NYXJrZXRUaXBQYW5lbC5TaG93UGFuZWwodGhpcy5tYXJrZXRUaXBEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBPcGVuV2F0Y2hBZFBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLldhdGNoQWRzUGFuZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgIHBhcmFtLlNwID0gdGhpcy5BZFNwO1xyXG4gICAgICAgIHRoaXMuV2F0Y2hBZHNQYW5lbC5TaG93UGFuZWwocGFyYW0pO1xyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZVNjZW5lO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/MarketTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3b6091ONMZPw7fhwHDkwbmF', 'MarketTipPanel');
// Scripts/UI/MarketTipPanel.js

"use strict";

var MarketTipItem = require("MarketTipItem");
var MarketTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    TipList: {
      "default": [],
      type: [MarketTipItem]
    },
    DesLbl: cc.Label,
    IntoNode: cc.Node,
    IntoDes: cc.Label,
    IntoDesNull: cc.Node
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;

    //弹出计算股票收益
    if (cc.Mgr.UserDataMgr.CanGetStockProfit == true && cc.Mgr.global.showStockProfit == true) {
      var bonus = 0;
      var Id = -1;
      for (var i = cc.Mgr.UserDataMgr.CompanyList.length - 1; i >= 0; i--) {
        var da = cc.Mgr.UserDataMgr.CompanyList[i];
        if (da.stockNum > 0) {
          Id = da.Id;
          bonus += Math.floor(da.stockNum * da.stockPrice * (da.bonusRatio + cc.Mgr.UserDataMgr.StockAddBonus / 100));
        }
      }
      var param = {};
      param.forWhat = "StockBonus";
      param.bonus = bonus;
      param.Id = Id;
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      cc.Mgr.global.showStockProfit = false;
    }
    if (cc.Mgr.global.tutorialStep == 11 && cc.Mgr.UserDataMgr.tutorialInMarket == false)
      //引导步骤 采用 11 表示第一个大步骤 第一小步
      {
        var dt = {};
        dt.step = 11;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenTutorial, dt);
      }
  },
  ShowPanel: function ShowPanel(param) {
    for (var i = this.TipList.length - 1; i >= 0; i--) {
      this.TipList[i].node.active = false;
    }
    this.IntoDes.string = "";
    this.IntoDesNull.active = false;
    //-2表示暴跌 -1表示跌了  0 表示稳定  1有所增长 2表示暴涨
    var list = this.CheckShowDes(param);
    if (list.length == 0) {
      this.DesLbl.node.active = true;
      this.DesLbl.string = cc.Mgr.global.getTranslation("Market_25");
    } else {
      this.DesLbl.node.active = false;
      for (var i = 0; i <= list.length - 1; i++) {
        var des = this.DickDes(list[i].State, list[i].name, list[i].Id);
        this.TipList[i].node.active = true;
        var par = {};
        par.des = des;
        par.Id = list[i].Id;
        this.TipList[i].SetData(par);
      }
    }
  },
  DickDes: function DickDes(State, name, Id) {
    var des = "";
    if (State == 0) {
      var desId = "Market_" + (2 * Id - 1);
      //des = cc.Mgr.global.getTranslation(desId);
    } else if (State == 2) {
      var desId = "Market_" + 2 * Id;
      //des = cc.Mgr.global.getTranslation(desId);;
    }

    var re = {};
    re.State = State;
    re.desId = desId;
    return re;
  },
  CheckShowDes: function CheckShowDes(param) {
    var list = [];
    var checkNum = 0;
    var rem = [];
    for (var i = param.length - 1; i >= 0; i--) {
      if (param[i].State != null) {
        if (param[i].State != 1) {
          list.push(param[i]);
          checkNum += 1;
        }
        if (param[i].State != 2 && param[i].Id != 3)
          //Id 为3 是字画还是黄金来着
          {
            rem.push(param[i]);
          }
      }
    }
    cc.Mgr.global.GoodsForeId = -1;
    if (checkNum <= 3 && cc.Mgr.UserDataMgr.Age >= 30 && rem.length > 0) {
      var seed = Math.random();
      if (seed < 0.4) {
        var d = Math.floor(Math.random() * rem.length);
        cc.Mgr.global.GoodsForeId = rem[d].Id;
        this.IntoDes.string = cc.Mgr.global.getTranslation("goods_" + rem[d].Id) + "下一年可能出现涨价" + "\n(前瞻有风险,盈亏自负)";
      } else {
        this.IntoDesNull.active = true;
      }
    } else {
      this.IntoDesNull.active = true;
    }
    return list;
  }
});
module.exports = MarketTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE1hcmtldFRpcFBhbmVsLmpzIl0sIm5hbWVzIjpbIk1hcmtldFRpcEl0ZW0iLCJyZXF1aXJlIiwiTWFya2V0VGlwUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIlRpcExpc3QiLCJ0eXBlIiwiRGVzTGJsIiwiTGFiZWwiLCJJbnRvTm9kZSIsIk5vZGUiLCJJbnRvRGVzIiwiSW50b0Rlc051bGwiLCJDbG9zZVBhbmVsIiwiTWdyIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibm9kZSIsImFjdGl2ZSIsIlVzZXJEYXRhTWdyIiwiQ2FuR2V0U3RvY2tQcm9maXQiLCJnbG9iYWwiLCJzaG93U3RvY2tQcm9maXQiLCJib251cyIsIklkIiwiaSIsIkNvbXBhbnlMaXN0IiwibGVuZ3RoIiwiZGEiLCJzdG9ja051bSIsIk1hdGgiLCJmbG9vciIsInN0b2NrUHJpY2UiLCJib251c1JhdGlvIiwiU3RvY2tBZGRCb251cyIsInBhcmFtIiwiZm9yV2hhdCIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiRXZlbnQiLCJPcGVuQ29tbW9uVGlwIiwidHV0b3JpYWxTdGVwIiwidHV0b3JpYWxJbk1hcmtldCIsImR0Iiwic3RlcCIsIk9wZW5UdXRvcmlhbCIsIlNob3dQYW5lbCIsInN0cmluZyIsImxpc3QiLCJDaGVja1Nob3dEZXMiLCJnZXRUcmFuc2xhdGlvbiIsImRlcyIsIkRpY2tEZXMiLCJTdGF0ZSIsIm5hbWUiLCJwYXIiLCJTZXREYXRhIiwiZGVzSWQiLCJyZSIsImNoZWNrTnVtIiwicmVtIiwicHVzaCIsIkdvb2RzRm9yZUlkIiwiQWdlIiwic2VlZCIsInJhbmRvbSIsImQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLGFBQWEsR0FBR0MsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUM1QyxJQUFJQyxjQUFjLEdBQUdDLEVBQUUs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QUFJLENBQUNaLFdBQVcsQ0FBQ00sTUFBTSxHQUFHLElBQUk7TUFDbEM7SUFDSixDQUFDLE1BRUQ7TUFDSSxJQUFJLENBQUNOLFdBQVcsQ0FBQ00sTUFBTSxHQUFHLElBQUk7SUFDbEM7SUFDQSxPQUFPK0IsSUFBSTtFQUNmO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZtQixNQUFNLENBQUNDLE9BQU8sR0FBR3JFLGNBQWMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBNYXJrZXRUaXBJdGVtID0gcmVxdWlyZShcIk1hcmtldFRpcEl0ZW1cIik7XHJcbnZhciBNYXJrZXRUaXBQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICBUaXBMaXN0OntcclxuICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgIHR5cGU6W01hcmtldFRpcEl0ZW1dLFxyXG4gICAgICAgfSxcclxuICAgICAgIERlc0xibDpjYy5MYWJlbCxcclxuICAgICAgIEludG9Ob2RlOmNjLk5vZGUsXHJcbiAgICAgICBJbnRvRGVzOmNjLkxhYmVsLFxyXG4gICAgICAgSW50b0Rlc051bGw6Y2MuTm9kZSxcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8v5by55Ye66K6h566X6IKh56Wo5pS255uKXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkNhbkdldFN0b2NrUHJvZml0ID09IHRydWUgJiYgY2MuTWdyLmdsb2JhbC5zaG93U3RvY2tQcm9maXQgPT0gdHJ1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBib251cyA9IDA7XHJcbiAgICAgICAgICAgIHZhciBJZCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2MuTWdyLlVzZXJEYXRhTWdyLkNvbXBhbnlMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQ29tcGFueUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBpZihkYS5zdG9ja051bSA+IDApXHJcbiAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgIElkID0gZGEuSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9udXMgKz0gTWF0aC5mbG9vcihkYS5zdG9ja051bSAqIGRhLnN0b2NrUHJpY2UgKiAoZGEuYm9udXNSYXRpbyArIChjYy5NZ3IuVXNlckRhdGFNZ3IuU3RvY2tBZGRCb251cyAvIDEwMCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiU3RvY2tCb251c1wiO1xyXG4gICAgICAgICAgICBwYXJhbS5ib251cyA9IGJvbnVzO1xyXG4gICAgICAgICAgICBwYXJhbS5JZCA9IElkO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuQ29tbW9uVGlwICwgcGFyYW0pO1xyXG4gICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLnNob3dTdG9ja1Byb2ZpdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLnR1dG9yaWFsU3RlcCA9PSAxMSAmJiBjYy5NZ3IuVXNlckRhdGFNZ3IudHV0b3JpYWxJbk1hcmtldCA9PSBmYWxzZSkgIC8v5byV5a+85q2l6aqkIOmHh+eUqCAxMSDooajnpLrnrKzkuIDkuKrlpKfmraXpqqQg56ys5LiA5bCP5q2lXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZHQgPSB7fTtcclxuICAgICAgICAgICAgZHQuc3RlcCA9IDExO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuVHV0b3JpYWwsIGR0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbihwYXJhbSl7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuVGlwTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuVGlwTGlzdFtpXS5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLkludG9EZXMuc3RyaW5nID0gXCJcIjtcclxuICAgICAgICB0aGlzLkludG9EZXNOdWxsLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vLTLooajnpLrmmrTot4wgLTHooajnpLrot4zkuoYgIDAg6KGo56S656iz5a6aICAx5pyJ5omA5aKe6ZW/IDLooajnpLrmmrTmtqhcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuQ2hlY2tTaG93RGVzKHBhcmFtKTtcclxuICAgICAgICBpZihsaXN0Lmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5EZXNMYmwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkRlc0xibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiTWFya2V0XzI1XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkRlc0xibC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsaXN0Lmxlbmd0aCAtIDE7IGkrKylcclxuICAgICAgICAgICAgeyAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGRlcyA9IHRoaXMuRGlja0RlcyhsaXN0W2ldLlN0YXRlLCBsaXN0W2ldLm5hbWUsIGxpc3RbaV0uSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5UaXBMaXN0W2ldLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXIgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhci5kZXMgPSBkZXM7XHJcbiAgICAgICAgICAgICAgICBwYXIuSWQgPSBsaXN0W2ldLklkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5UaXBMaXN0W2ldLlNldERhdGEocGFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9IFxyXG4gICAgfSxcclxuXHJcbiAgICBEaWNrRGVzOmZ1bmN0aW9uKFN0YXRlLCBuYW1lLCBJZClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGVzID0gXCJcIjtcclxuICAgICAgICBpZihTdGF0ZSA9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlc0lkID0gXCJNYXJrZXRfXCIgKyAoMipJZCAtMSk7XHJcbiAgICAgICAgICAgIC8vZGVzID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihkZXNJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoU3RhdGUgPT0gMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZXNJZCA9IFwiTWFya2V0X1wiICsgKDIqSWQpO1xyXG4gICAgICAgICAgICAvL2RlcyA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oZGVzSWQpOztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlID0ge307XHJcbiAgICAgICAgcmUuU3RhdGUgPSBTdGF0ZTtcclxuICAgICAgICByZS5kZXNJZCA9IGRlc0lkO1xyXG4gICAgICAgIHJldHVybiByZTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2hlY2tTaG93RGVzOmZ1bmN0aW9uKHBhcmFtKXtcclxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG4gICAgICAgIHZhciBjaGVja051bSA9IDA7XHJcbiAgICAgICAgdmFyIHJlbSA9W107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmKHBhcmFtW2ldLlN0YXRlICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKHBhcmFtW2ldLlN0YXRlICE9IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHBhcmFtW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja051bSArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYocGFyYW1baV0uU3RhdGUgIT0gMiAmJiBwYXJhbVtpXS5JZCAhPSAzKSAvL0lkIOS4ujMg5piv5a2X55S76L+Y5piv6buE6YeR5p2l552AXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtLnB1c2gocGFyYW1baV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLk1nci5nbG9iYWwuR29vZHNGb3JlSWQgPSAtMTtcclxuICAgICAgICBpZihjaGVja051bSA8PSAzICYmIGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UgPj0gMzAgJiYgcmVtLmxlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VlZCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgIGlmIChzZWVkIDwgMC40KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5Hb29kc0ZvcmVJZCA9IHJlbVtkXS5JZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuSW50b0Rlcy5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiZ29vZHNfXCIrcmVtW2RdLklkKSArIFwi5LiL5LiA5bm05Y+v6IO95Ye6546w5rao5Lu3XCIgK1wiXFxuKOWJjeeeu+aciemjjumZqSznm4jkuo/oh6rotJ8pXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkludG9EZXNOdWxsLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5JbnRvRGVzTnVsbC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtldFRpcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/MarketTipItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '7a0a3U2JNhPMKUbl49888uN', 'MarketTipItem');
// Scripts/UI/MarketTipItem.js

"use strict";

var ItemType = require("ItemType");
var MarketTipItem = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    iconAtlas: cc.SpriteAtlas,
    Des: cc.Label,
    Icon: cc.Sprite,
    updown: cc.Sprite
  },
  SetData: function SetData(param) {
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Goods, param.Id);
    this.Des.string = cc.Mgr.global.getTranslation(param.des.desId);
    this.Icon.spriteFrame = this.iconAtlas.getSpriteFrame(data.icon);
    //this.Icon.setState(1);
    if (param.des.State == 0) this.updown.spriteFrame = this.Atlas.getSpriteFrame("sdown");else this.updown.spriteFrame = this.Atlas.getSpriteFrame("dup");
  }
});
module.exports = MarketTipItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE1hcmtldFRpcEl0ZW0uanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiTWFya2V0VGlwSXRlbSIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiQXRsYXMiLCJTcHJpdGVBdGxhcyIsImljb25BdGxhcyIsIkRlcyIsIkxhYmVsIiwiSWNvbiIsIlNwcml0ZSIsInVwZG93biIsIlNldERhdGEiLCJwYXJhbSIsImRhdGEiLCJNZ3IiLCJVc2VyRGF0YU1nciIsImdldERhdGFCeUl0ZW1UeXBlQW5kSWQiLCJHb29kcyIsIklkIiwic3RyaW5nIiwiZ2xvYmFsIiwiZ2V0VHJhbnNsYXRpb24iLCJkZXMiLCJkZXNJZCIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJpY29uIiwiU3RhdGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxhQUFhLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3pCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLEtBQUssRUFBQ0osRUFBRSxDQUFDSyxXQUFXO0lBQ3BCQyxTQUFTLEVBQUNOLEVBQUUsQ0FBQ0ssV0FBVztJQUN4QkUsR0FBRyxFQUFDUCxFQUFFLENBQUNRLEtBQUs7SUFDWkMsSUFBSSxFQUFFVCxFQUFFLENBQUNVLE1BQU07SUFDZkMsTUFBTSxFQUFDWCxFQUFFLENBQUNVO0VBQ2QsQ0FBQztFQUVERSxPQUFPLEVBQUMsU0FBQUEsUUFBU0MsS0FBSyxFQUN0QjtJQUNJLElBQUlDLElBQUksR0FBR2QsRUFBRSxDQUFDZSxHQUFHLENBQUNDLFdBQVcsQ0FBQ0Msc0JBQXNCLENBQUNwQixRQUFRLENBQUNxQixLQUFLLEVBQUNMLEtBQUssQ0FBQ00sRUFBRSxDQUFDO0lBQzdFLElBQUksQ0FBQ1osR0FBRyxDQUFDYSxNQUFNLEdBQUdwQixFQUFFLENBQUNlLEdBQUcsQ0FBQ00sTUFBTSxDQUFDQyxjQUFjLENBQUNULEtBQUssQ0FBQ1UsR0FBRyxDQUFDQyxLQUFLLENBQUM7SUFDL0QsSUFBSSxDQUFDZixJQUFJLENBQUNnQixXQUFXLEdBQUcsSUFBSSxDQUFDbkIsU0FBUyxDQUFDb0IsY0FBYyxDQUFDWixJQUFJLENBQUNhLElBQUksQ0FBQztJQUNoRTtJQUNBLElBQUdkLEtBQUssQ0FBQ1UsR0FBRyxDQUFDSyxLQUFLLElBQUksQ0FBQyxFQUNuQixJQUFJLENBQUNqQixNQUFNLENBQUNjLFdBQVcsR0FBRyxJQUFJLENBQUNyQixLQUFLLENBQUNzQixjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsS0FFN0QsSUFBSSxDQUFDZixNQUFNLENBQUNjLFdBQVcsR0FBRyxJQUFJLENBQUNyQixLQUFLLENBQUNzQixjQUFjLENBQUMsS0FBSyxDQUFDO0VBQ2xFO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZHLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHL0IsYUFBYSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgTWFya2V0VGlwSXRlbSA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgaWNvbkF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIERlczpjYy5MYWJlbCxcclxuICAgICAgICBJY29uOiBjYy5TcHJpdGUsXHJcbiAgICAgICAgdXBkb3duOmNjLlNwcml0ZSxcclxuICAgIH0sXHJcblxyXG4gICAgU2V0RGF0YTpmdW5jdGlvbihwYXJhbSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkdvb2RzLHBhcmFtLklkKTtcclxuICAgICAgICB0aGlzLkRlcy5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKHBhcmFtLmRlcy5kZXNJZCk7XHJcbiAgICAgICAgdGhpcy5JY29uLnNwcml0ZUZyYW1lID0gdGhpcy5pY29uQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICAvL3RoaXMuSWNvbi5zZXRTdGF0ZSgxKTtcclxuICAgICAgICBpZihwYXJhbS5kZXMuU3RhdGUgPT0gMClcclxuICAgICAgICAgICAgdGhpcy51cGRvd24uc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKFwic2Rvd25cIik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLnVwZG93bi5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJkdXBcIik7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZXRUaXBJdGVtOyJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/MateItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0462dTAi55IlqmXd7sQC2sa', 'MateItem');
// Scripts/UI/MateItem.js

"use strict";

var ItemType = require("ItemType");
var MateItem = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    NameLbl: cc.Sprite,
    iconSp: cc.Sprite,
    LovePointBar: cc.ProgressBar,
    LovePoint: cc.Integer,
    Id: cc.Integer,
    dateBtnSp: cc.Sprite,
    unlock: false
  },
  ChangeUnLockState: function ChangeUnLockState(data) {
    if (!data.canDate) {
      this.dateBtnSp.setState(1);
      this.NameLbl.node.active = false;
      if (cc.Mgr.UserDataMgr.Sex == 1) this.iconSp.spriteFrame = this.Atlas.getSpriteFrame("nowoman");else this.iconSp.spriteFrame = this.Atlas.getSpriteFrame("noman");
    } else {
      this.NameLbl.node.active = true;
      this.dateBtnSp.setState(0);
      this.iconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    }
    this.unlock = data.canDate;
  },
  init: function init(data) {
    this.LovePoint = 0;
    this.NameLbl.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.iconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.LovePointBar.progress = this.LovePoint / 100;
    this.Id = data.Id;
    this.unlock = data.canDate;
    this.ChangeUnLockState(data);
  },
  RefreshLovePoint: function RefreshLovePoint(data) {
    this.LovePoint = data.LovePoint;
    this.LovePointBar.progress = this.LovePoint / 100;
    if (this.LovePoint >= 100) this.dateBtnSp.node.active = false;else this.dateBtnSp.node.active = true;
  },
  OpenMateItemPanel: function OpenMateItemPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Mate, this.Id);
    if (data.UpLv == true) {
      //var param = {};
      //param.text = cc.Mgr.global.getTranslation("MateHas_" + cc.Mgr.UserDataMgr.Sex);
      //cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    if (data.canDate == false) {
      var param = {};
      param.forWhat = "OpenDate"; //打开约会面板
      param.text = cc.Mgr.global.getTranslation("MateUnlockTip");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenMateTip, data);
  }
});
module.exports = MateItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE1hdGVJdGVtLmpzIl0sIm5hbWVzIjpbIkl0ZW1UeXBlIiwicmVxdWlyZSIsIk1hdGVJdGVtIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJBdGxhcyIsIlNwcml0ZUF0bGFzIiwiTmFtZUxibCIsIlNwcml0ZSIsImljb25TcCIsIkxvdmVQb2ludEJhciIsIlByb2dyZXNzQmFyIiwiTG92ZVBvaW50IiwiSW50ZWdlciIsIklkIiwiZGF0ZUJ0blNwIiwidW5sb2NrIiwiQ2hhbmdlVW5Mb2NrU3RhdGUiLCJkYXRhIiwiY2FuRGF0ZSIsInNldFN0YXRlIiwibm9kZSIsImFjdGl2ZSIsIk1nciIsIlVzZXJEYXRhTWdyIiwiU2V4Iiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsImljb24iLCJpbml0IiwibmFtZSIsInByb2dyZXNzIiwiUmVmcmVzaExvdmVQb2ludCIsIk9wZW5NYXRlSXRlbVBhbmVsIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwiZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZCIsIk1hdGUiLCJVcEx2IiwicGFyYW0iLCJmb3JXaGF0IiwidGV4dCIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIk9wZW5Db21tb25UaXAiLCJPcGVuTWF0ZVRpcCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLFFBQVEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDcEIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsS0FBSyxFQUFDSixFQUFFLENBQUNLLFdBQVc7SUFDcEJDLE9BQU8sRUFBQ04sRUFBRSxDQUFDTyxNQUFNO0lBQ2pCQyxNQUFNLEVBQUNSLEVBQUUsQ0FBQ08sTUFBTTtJQUNoQkUsWUFBWSxFQUFDVCxFQUFFLENBQUNVLFdBQVc7SUFDM0JDLFNBQVMsRUFBQ1gsRUFBRSxDQUFDWSxPQUFPO0lBQ3BCQyxFQUFFLEVBQUNiLEVBQUUsQ0FBQ1ksT0FBTztJQUViRSxTQUFTLEVBQUNkLEVBQUUsQ0FBQ08sTUFBTTtJQUVuQlEsTUFBTSxFQUFDO0VBQ1gsQ0FBQztFQUVEQyxpQkFBaUIsRUFBQyxTQUFBQSxrQkFBU0MsSUFBSSxFQUFDO0lBQzVCLElBQUcsQ0FBQ0EsSUFBSSxDQUFDQyxPQUFPLEVBQ2hCO01BQ0ksSUFBSSxDQUFDSixTQUFTLENBQUNLLFFBQVEsQ0FBQyxDQUFDLENBQUM7TUFDMUIsSUFBSSxDQUFDYixPQUFPLENBQUNjLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7TUFDaEMsSUFBR3JCLEVBQUUsQ0FBQ3NCLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLElBQUksQ0FBQyxFQUMxQixJQUFJLENBQUNoQixNQUFNLENBQUNpQixXQUFXLEdBQUcsSUFBSSxDQUFDckIsS0FBSyxDQUFDc0IsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBRS9ELElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ2lCLFdBQVcsR0FBRyxJQUFJLENBQUNyQixLQUFLLENBQUNzQixjQUFjLENBQUMsT0FBTyxDQUFDO0lBQ3BFLENBQUMsTUFFRDtNQUNJLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ2MsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSTtNQUMvQixJQUFJLENBQUNQLFNBQVMsQ0FBQ0ssUUFBUSxDQUFDLENBQUMsQ0FBQztNQUMxQixJQUFJLENBQUNYLE1BQU0sQ0FBQ2lCLFdBQVcsR0FBRyxJQUFJLENBQUNyQixLQUFLLENBQUNzQixjQUFjLENBQUNULElBQUksQ0FBQ1UsSUFBSSxDQUFDO0lBQ2xFO0lBQ0EsSUFBSSxDQUFDWixNQUFNLEdBQUdFLElBQUksQ0FBQ0MsT0FBTztFQUM5QixDQUFDO0VBRURVLElBQUksRUFBQyxTQUFBQSxLQUFVWCxJQUFJLEVBQUU7SUFDakIsSUFBSSxDQUFDTixTQUFTLEdBQUcsQ0FBQztJQUNsQixJQUFJLENBQUNMLE9BQU8sQ0FBQ21CLFdBQVcsR0FBRyxJQUFJLENBQUNyQixLQUFLLENBQUNzQixjQUFjLENBQUNULElBQUksQ0FBQ1ksSUFBSSxDQUFDO0lBQy9ELElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ2lCLFdBQVcsR0FBRyxJQUFJLENBQUNyQixLQUFLLENBQUNzQixjQUFjLENBQUNULElBQUksQ0FBQ1UsSUFBSSxDQUFDO0lBQzlELElBQUksQ0FBQ2xCLFlBQVksQ0FBQ3FCLFFBQVEsR0FBRyxJQUFJLENBQUNuQixTQUFTLEdBQUMsR0FBRztJQUMvQyxJQUFJLENBQUNFLEVBQUUsR0FBR0ksSUFBSSxDQUFDSixFQUFFO0lBQ2pCLElBQUksQ0FBQ0UsTUFBTSxHQUFHRSxJQUFJLENBQUNDLE9BQU87SUFDMUIsSUFBSSxDQUFDRixpQkFBaUIsQ0FBQ0MsSUFBSSxDQUFDO0VBQ2hDLENBQUM7RUFFRGMsZ0JBQWdCLEVBQUMsU0FBQUEsaUJBQVNkLElBQUksRUFBQztJQUMzQixJQUFJLENBQUNOLFNBQVMsR0FBR00sSUFBSSxDQUFDTixTQUFTO0lBQy9CLElBQUksQ0FBQ0YsWUFBWSxDQUFDcUIsUUFBUSxHQUFHLElBQUksQ0FBQ25CLFNBQVMsR0FBQyxHQUFHO0lBQy9DLElBQUcsSUFBSSxDQUFDQSxTQUFTLElBQUksR0FBRyxFQUNwQixJQUFJLENBQUNHLFNBQVMsQ0FBQ00sSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSyxDQUFDLEtBRW5DLElBQUksQ0FBQ1AsU0FBUyxDQUFDTSxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJO0VBQ3pDLENBQUM7RUFFRFcsaUJBQWlCLEVBQUMsU0FBQUEsa0JBQUEsRUFBVTtJQUN4QmhDLEVBQUUsQ0FBQ3NCLEdBQUcsQ0FBQ1csUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUlqQixJQUFJLEdBQUdqQixFQUFFLENBQUNzQixHQUFHLENBQUNDLFdBQVcsQ0FBQ1ksc0JBQXNCLENBQUN0QyxRQUFRLENBQUN1QyxJQUFJLEVBQUUsSUFBSSxDQUFDdkIsRUFBRSxDQUFDO0lBQzVFLElBQUdJLElBQUksQ0FBQ29CLElBQUksSUFBSSxJQUFJLEVBQ3BCO01BQ0k7TUFDQTtNQUNBO01BQ0E7SUFDSjtJQUNBLElBQUdwQixJQUFJLENBQUNDLE9BQU8sSUFBSSxLQUFLLEVBQ3hCO01BQ0ksSUFBSW9CLEtBQUssR0FBRyxDQUFDLENBQUM7TUFDZEEsS0FBSyxDQUFDQyxPQUFPLEdBQUcsVUFBVSxDQUFDO01BQzNCRCxLQUFLLENBQUNFLElBQUksR0FBR3hDLEVBQUUsQ0FBQ3NCLEdBQUcsQ0FBQ21CLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDLGVBQWUsQ0FBQztNQUMxRDFDLEVBQUUsQ0FBQzJDLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUM3QyxFQUFFLENBQUNzQixHQUFHLENBQUN3QixLQUFLLENBQUNDLGFBQWEsRUFBRVQsS0FBSyxDQUFDO01BQy9EO0lBQ0o7SUFFQXRDLEVBQUUsQ0FBQzJDLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUM3QyxFQUFFLENBQUNzQixHQUFHLENBQUN3QixLQUFLLENBQUNFLFdBQVcsRUFBRS9CLElBQUksQ0FBQztFQUNoRTtBQUNKLENBQUMsQ0FBQztBQUNGZ0MsTUFBTSxDQUFDQyxPQUFPLEdBQUduRCxRQUFRIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBNYXRlSXRlbSA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgTmFtZUxibDpjYy5TcHJpdGUsXHJcbiAgICAgICAgaWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBMb3ZlUG9pbnRCYXI6Y2MuUHJvZ3Jlc3NCYXIsXHJcbiAgICAgICAgTG92ZVBvaW50OmNjLkludGVnZXIsXHJcbiAgICAgICAgSWQ6Y2MuSW50ZWdlcixcclxuXHJcbiAgICAgICAgZGF0ZUJ0blNwOmNjLlNwcml0ZSxcclxuXHJcbiAgICAgICAgdW5sb2NrOmZhbHNlLFxyXG4gICAgfSxcclxuXHJcbiAgICBDaGFuZ2VVbkxvY2tTdGF0ZTpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICBpZighZGF0YS5jYW5EYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlQnRuU3Auc2V0U3RhdGUoMSk7XHJcbiAgICAgICAgICAgIHRoaXMuTmFtZUxibC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuU2V4ID09IDEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJub3dvbWFuXCIpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJub21hblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5OYW1lTGJsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kYXRlQnRuU3Auc2V0U3RhdGUoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWNvblNwLnNwcml0ZUZyYW1lID0gdGhpcy5BdGxhcy5nZXRTcHJpdGVGcmFtZShkYXRhLmljb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVubG9jayA9IGRhdGEuY2FuRGF0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuTG92ZVBvaW50ID0gMDtcclxuICAgICAgICB0aGlzLk5hbWVMYmwuc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEubmFtZSk7XHJcbiAgICAgICAgdGhpcy5pY29uU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgdGhpcy5Mb3ZlUG9pbnRCYXIucHJvZ3Jlc3MgPSB0aGlzLkxvdmVQb2ludC8xMDA7XHJcbiAgICAgICAgdGhpcy5JZCA9IGRhdGEuSWQ7XHJcbiAgICAgICAgdGhpcy51bmxvY2sgPSBkYXRhLmNhbkRhdGU7XHJcbiAgICAgICAgdGhpcy5DaGFuZ2VVbkxvY2tTdGF0ZShkYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaExvdmVQb2ludDpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLkxvdmVQb2ludCA9IGRhdGEuTG92ZVBvaW50O1xyXG4gICAgICAgIHRoaXMuTG92ZVBvaW50QmFyLnByb2dyZXNzID0gdGhpcy5Mb3ZlUG9pbnQvMTAwO1xyXG4gICAgICAgIGlmKHRoaXMuTG92ZVBvaW50ID49IDEwMClcclxuICAgICAgICAgICAgdGhpcy5kYXRlQnRuU3Aubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUJ0blNwLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgT3Blbk1hdGVJdGVtUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHZhciBkYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuTWF0ZSwgdGhpcy5JZCk7XHJcbiAgICAgICAgaWYoZGF0YS5VcEx2ID09IHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL3ZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICAvL3BhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiTWF0ZUhhc19cIiArIGNjLk1nci5Vc2VyRGF0YU1nci5TZXgpO1xyXG4gICAgICAgICAgICAvL2NjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihkYXRhLmNhbkRhdGUgPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgcGFyYW0uZm9yV2hhdCA9IFwiT3BlbkRhdGVcIjsvL+aJk+W8gOe6puS8mumdouadv1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIk1hdGVVbmxvY2tUaXBcIik7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuTWF0ZVRpcCwgZGF0YSk7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlSXRlbTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/MarryPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'eb741mIlZRK75k4lUgcl2d+', 'MarryPanel');
// Scripts/UI/MarryPanel.js

"use strict";

var MarryPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    RoleAtlas: cc.SpriteAtlas,
    roleSp: cc.Sprite,
    TipLbl: cc.Label,
    MarryLbl1: cc.Label,
    MarryLbl2: cc.Label
  },
  ShowPanel: function ShowPanel(data) {
    if (cc.Mgr.UserDataMgr.MarryAge == 0) {
      cc.Mgr.UserDataMgr.MarryRoleId = data.Id;
      cc.Mgr.UserDataMgr.MarryAge = cc.Mgr.UserDataMgr.Age;
    }
    this.roleSp.spriteFrame = this.RoleAtlas.getSpriteFrame(data.icon);
    var name = cc.Mgr.global.getTranslation("role_" + data.Id);
    this.TipLbl.string = "恭喜" + cc.Mgr.UserDataMgr.playerName + "&&" + name + "结成伴侣";
    this.MarryLbl1.string = cc.Mgr.UserDataMgr.playerName;
    this.MarryLbl2.string = name;
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  },
  ShareToFriend: function ShareToFriend() {
    cc.Mgr.PlatformController.ShareToFriend(1);
  }
});
module.exports = MarryPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE1hcnJ5UGFuZWwuanMiXSwibmFtZXMiOlsiTWFycnlQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiUm9sZUF0bGFzIiwiU3ByaXRlQXRsYXMiLCJyb2xlU3AiLCJTcHJpdGUiLCJUaXBMYmwiLCJMYWJlbCIsIk1hcnJ5TGJsMSIsIk1hcnJ5TGJsMiIsIlNob3dQYW5lbCIsImRhdGEiLCJNZ3IiLCJVc2VyRGF0YU1nciIsIk1hcnJ5QWdlIiwiTWFycnlSb2xlSWQiLCJJZCIsIkFnZSIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJpY29uIiwibmFtZSIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwic3RyaW5nIiwicGxheWVyTmFtZSIsIkNsb3NlUGFuZWwiLCJBdWRpb01nciIsInBsYXlTRlgiLCJub2RlIiwiYWN0aXZlIiwiU2hhcmVUb0ZyaWVuZCIsIlBsYXRmb3JtQ29udHJvbGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsVUFBVSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN0QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNUQyxTQUFTLEVBQUNKLEVBQUUsQ0FBQ0ssV0FBVztJQUN4QkMsTUFBTSxFQUFDTixFQUFFLENBQUNPLE1BQU07SUFDaEJDLE1BQU0sRUFBQ1IsRUFBRSxDQUFDUyxLQUFLO0lBQ2ZDLFNBQVMsRUFBQ1YsRUFBRSxDQUFDUyxLQUFLO0lBQ2xCRSxTQUFTLEVBQUNYLEVBQUUsQ0FBQ1M7RUFDaEIsQ0FBQztFQUVERyxTQUFTLEVBQUMsU0FBQUEsVUFBU0MsSUFBSSxFQUN2QjtJQUNJLElBQUdiLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDQyxXQUFXLENBQUNDLFFBQVEsSUFBSSxDQUFDLEVBQ25DO01BQ0VoQixFQUFFLENBQUNjLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDRSxXQUFXLEdBQUdKLElBQUksQ0FBQ0ssRUFBRTtNQUN4Q2xCLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDQyxXQUFXLENBQUNDLFFBQVEsR0FBR2hCLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDQyxXQUFXLENBQUNJLEdBQUc7SUFDdEQ7SUFDQSxJQUFJLENBQUNiLE1BQU0sQ0FBQ2MsV0FBVyxHQUFHLElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ2lCLGNBQWMsQ0FBQ1IsSUFBSSxDQUFDUyxJQUFJLENBQUM7SUFDbEUsSUFBSUMsSUFBSSxHQUFHdkIsRUFBRSxDQUFDYyxHQUFHLENBQUNVLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDLE9BQU8sR0FBQ1osSUFBSSxDQUFDSyxFQUFFLENBQUM7SUFDeEQsSUFBSSxDQUFDVixNQUFNLENBQUNrQixNQUFNLEdBQUcsSUFBSSxHQUFDMUIsRUFBRSxDQUFDYyxHQUFHLENBQUNDLFdBQVcsQ0FBQ1ksVUFBVSxHQUFFLElBQUksR0FBQ0osSUFBSSxHQUFFLE1BQU07SUFDMUUsSUFBSSxDQUFDYixTQUFTLENBQUNnQixNQUFNLEdBQUcxQixFQUFFLENBQUNjLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDWSxVQUFVO0lBQ3JELElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ2UsTUFBTSxHQUFHSCxJQUFJO0VBQ2hDLENBQUM7RUFFREssVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBVTtJQUNqQjVCLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDZSxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0VBQzVCLENBQUM7RUFFREMsYUFBYSxFQUFDLFNBQUFBLGNBQUEsRUFBVTtJQUN0QmpDLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDb0Isa0JBQWtCLENBQUNELGFBQWEsQ0FBQyxDQUFDLENBQUM7RUFDNUM7QUFFSixDQUFDLENBQUM7QUFDRkUsTUFBTSxDQUFDQyxPQUFPLEdBQUdyQyxVQUFVIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIE1hcnJ5UGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgUm9sZUF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgcm9sZVNwOmNjLlNwcml0ZSxcclxuICAgICAgIFRpcExibDpjYy5MYWJlbCxcclxuICAgICAgIE1hcnJ5TGJsMTpjYy5MYWJlbCxcclxuICAgICAgIE1hcnJ5TGJsMjpjYy5MYWJlbCxcclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uKGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLk1hcnJ5QWdlID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLk1hcnJ5Um9sZUlkID0gZGF0YS5JZDtcclxuICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5NYXJyeUFnZSA9IGNjLk1nci5Vc2VyRGF0YU1nci5BZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm9sZVNwLnNwcml0ZUZyYW1lID0gdGhpcy5Sb2xlQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICB2YXIgbmFtZSA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJyb2xlX1wiK2RhdGEuSWQpO1xyXG4gICAgICAgIHRoaXMuVGlwTGJsLnN0cmluZyA9IFwi5oGt5ZacXCIrY2MuTWdyLlVzZXJEYXRhTWdyLnBsYXllck5hbWUgK1wiJiZcIituYW1lICtcIue7k+aIkOS8tOS+o1wiO1xyXG4gICAgICAgIHRoaXMuTWFycnlMYmwxLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5wbGF5ZXJOYW1lO1xyXG4gICAgICAgIHRoaXMuTWFycnlMYmwyLnN0cmluZyA9IG5hbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgU2hhcmVUb0ZyaWVuZDpmdW5jdGlvbigpe1xyXG4gICAgICBjYy5NZ3IuUGxhdGZvcm1Db250cm9sbGVyLlNoYXJlVG9GcmllbmQoMSk7XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTWFycnlQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/HousePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '70e30r+0Z5MO40fnrAWptL7', 'HousePanel');
// Scripts/UI/HousePanel.js

"use strict";

var ItemType = require("ItemType");
var HousePanel = cc.Class({
  "extends": cc.Component,
  properties: {
    houseItemPre: cc.Prefab,
    houseItemParent: cc.Node,
    hasInit: false
  },
  ShowPanel: function ShowPanel() {
    if (this.hasInit == true) {
      //cc.log("已经初始化过了，不用重复");
      return;
    }
    var dataList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.House);
    for (var i = dataList.length - 1; i >= 0; i--) {
      var data = dataList[i];
      var obj = cc.instantiate(this.houseItemPre);
      obj.parent = this.houseItemParent;
      obj.active = true;
      obj.getComponent("HouseItem").init(data);
    }
    this.hasInit = true;
  }
});
module.exports = HousePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEhvdXNlUGFuZWwuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiSG91c2VQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiaG91c2VJdGVtUHJlIiwiUHJlZmFiIiwiaG91c2VJdGVtUGFyZW50IiwiTm9kZSIsImhhc0luaXQiLCJTaG93UGFuZWwiLCJkYXRhTGlzdCIsIk1nciIsIlVzZXJEYXRhTWdyIiwiZ2V0T3duRGF0YUxpc3RCeVR5cGUiLCJIb3VzZSIsImkiLCJsZW5ndGgiLCJkYXRhIiwib2JqIiwiaW5zdGFudGlhdGUiLCJwYXJlbnQiLCJhY3RpdmUiLCJnZXRDb21wb25lbnQiLCJpbml0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsVUFBVSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN0QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxZQUFZLEVBQUNKLEVBQUUsQ0FBQ0ssTUFBTTtJQUN0QkMsZUFBZSxFQUFDTixFQUFFLENBQUNPLElBQUk7SUFDdkJDLE9BQU8sRUFBQztFQUNaLENBQUM7RUFFREMsU0FBUyxFQUFDLFNBQUFBLFVBQUEsRUFBWTtJQUNsQixJQUFHLElBQUksQ0FBQ0QsT0FBTyxJQUFJLElBQUksRUFDdkI7TUFDSTtNQUNBO0lBQ0o7SUFFQSxJQUFJRSxRQUFRLEdBQUdWLEVBQUUsQ0FBQ1csR0FBRyxDQUFDQyxXQUFXLENBQUNDLG9CQUFvQixDQUFDaEIsUUFBUSxDQUFDaUIsS0FBSyxDQUFDO0lBQ3RFLEtBQUssSUFBSUMsQ0FBQyxHQUFHTCxRQUFRLENBQUNNLE1BQU0sR0FBRyxDQUFDLEVBQUVELENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO01BQzNDLElBQUlFLElBQUksR0FBR1AsUUFBUSxDQUFDSyxDQUFDLENBQUM7TUFDdEIsSUFBSUcsR0FBRyxHQUFHbEIsRUFBRSxDQUFDbUIsV0FBVyxDQUFDLElBQUksQ0FBQ2YsWUFBWSxDQUFDO01BQzNDYyxHQUFHLENBQUNFLE1BQU0sR0FBRyxJQUFJLENBQUNkLGVBQWU7TUFDakNZLEdBQUcsQ0FBQ0csTUFBTSxHQUFHLElBQUk7TUFDakJILEdBQUcsQ0FBQ0ksWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDQyxJQUFJLENBQUNOLElBQUksQ0FBQztJQUM1QztJQUNBLElBQUksQ0FBQ1QsT0FBTyxHQUFHLElBQUk7RUFDdkI7QUFDSixDQUFDLENBQUM7QUFDRmdCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHMUIsVUFBVSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgSG91c2VQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgaG91c2VJdGVtUHJlOmNjLlByZWZhYixcclxuICAgICAgICBob3VzZUl0ZW1QYXJlbnQ6Y2MuTm9kZSxcclxuICAgICAgICBoYXNJbml0OmZhbHNlLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKHRoaXMuaGFzSW5pdCA9PSB0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCLlt7Lnu4/liJ3lp4vljJbov4fkuobvvIzkuI3nlKjph43lpI1cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkYXRhTGlzdCA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRPd25EYXRhTGlzdEJ5VHlwZShJdGVtVHlwZS5Ib3VzZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRhdGFMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YUxpc3RbaV07XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLmhvdXNlSXRlbVByZSk7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLmhvdXNlSXRlbVBhcmVudDtcclxuICAgICAgICAgICAgb2JqLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG9iai5nZXRDb21wb25lbnQoXCJIb3VzZUl0ZW1cIikuaW5pdChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYXNJbml0ID0gdHJ1ZTtcclxuICAgIH0sIFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBIb3VzZVBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/MateTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '5a11blHIqdHvKiejxvT7eu5', 'MateTipPanel');
// Scripts/UI/MateTipPanel.js

"use strict";

var ItemType = require("ItemType");
var MateTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    mateItem: cc.Prefab,
    mateParent: cc.Node,
    hasInit: false
  },
  ShowPanel: function ShowPanel() {
    if (this.hasInit == true) {
      this.RefreshPanelItems();
      //cc.log("已经初始化了，返回");
      return;
    }
    var MateList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Mate);
    var dataList = this.getMateListBySex(cc.Mgr.UserDataMgr.Sex, MateList);
    for (var i = 0; i <= dataList.length - 1; i++) {
      //if() 判断解锁条件  我们会有男女的区别
      var data = dataList[i];
      var obj = cc.instantiate(this.mateItem);
      obj.parent = this.mateParent;
      obj.getComponent("MateItem").init(data);
    }
    this.hasInit = true;
  },
  getMateListBySex: function getMateListBySex(Sex, dataList) {
    var param = [];
    for (var i = 0; i < dataList.length; i++) {
      if (Sex == dataList[i].sex) {
        param.push(dataList[i]);
      }
    }
    return param;
  },
  RefreshPanelItems: function RefreshPanelItems() {
    var children = this.mateParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("MateItem");
      if (sc != null) {
        var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Mate, sc.Id);
        sc.RefreshLovePoint(data);
        if (data.canDate) {
          sc.ChangeUnLockState(data);
          //children[i].active = true;
        }
      }
    }
  },

  RefreshPanel: function RefreshPanel(Id) {
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Mate, Id);
    //cc.log("============" + data.LovePoint);
    var children = this.mateParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("MateItem");
      if (sc != null) {
        if (sc.Id == Id) {
          if (data.canDate) {
            children[i].active = true;
            sc.RefreshLovePoint(data);
          }
          break;
        }
      }
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = MateTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE1hdGVUaXBQYW5lbC5qcyJdLCJuYW1lcyI6WyJJdGVtVHlwZSIsInJlcXVpcmUiLCJNYXRlVGlwUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIm1hdGVJdGVtIiwiUHJlZmFiIiwibWF0ZVBhcmVudCIsIk5vZGUiLCJoYXNJbml0IiwiU2hvd1BhbmVsIiwiUmVmcmVzaFBhbmVsSXRlbXMiLCJNYXRlTGlzdCIsIk1nciIsIlVzZXJEYXRhTWdyIiwiZ2V0T3duRGF0YUxpc3RCeVR5cGUiLCJNYXRlIiwiZGF0YUxpc3QiLCJnZXRNYXRlTGlzdEJ5U2V4IiwiU2V4IiwiaSIsImxlbmd0aCIsImRhdGEiLCJvYmoiLCJpbnN0YW50aWF0ZSIsInBhcmVudCIsImdldENvbXBvbmVudCIsImluaXQiLCJwYXJhbSIsInNleCIsInB1c2giLCJjaGlsZHJlbiIsInNjIiwiZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZCIsIklkIiwiUmVmcmVzaExvdmVQb2ludCIsImNhbkRhdGUiLCJDaGFuZ2VVbkxvY2tTdGF0ZSIsIlJlZnJlc2hQYW5lbCIsImFjdGl2ZSIsIkNsb3NlUGFuZWwiLCJBdWRpb01nciIsInBsYXlTRlgiLCJub2RlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsWUFBWSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN4QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNUQyxRQUFRLEVBQUNKLEVBQUUsQ0FBQ0ssTUFBTTtJQUNsQkMsVUFBVSxFQUFDTixFQUFFLENBQUNPLElBQUk7SUFDbEJDLE9BQU8sRUFBQztFQUNYLENBQUM7RUFFREMsU0FBUyxFQUFDLFNBQUFBLFVBQUEsRUFBWTtJQUNsQixJQUFHLElBQUks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QzNDLElBQUlZLEVBQUUsR0FBR0QsUUFBUSxDQUFDWCxDQUFDLENBQUMsQ0FBQ00sWUFBWSxDQUFDLFVBQVUsQ0FBQztNQUM3QyxJQUFHTSxFQUFFLElBQUksSUFBSSxFQUNiO1FBQ0ksSUFBR0EsRUFBRSxDQUFDRSxFQUFFLElBQUlBLEVBQUUsRUFDZDtVQUNJLElBQUdaLElBQUksQ0FBQ2MsT0FBTyxFQUNmO1lBQ0lMLFFBQVEsQ0FBQ1gsQ0FBQyxDQUFDLENBQUNtQixNQUFNLEdBQUcsSUFBSTtZQUN6QlAsRUFBRSxDQUFDRyxnQkFBZ0IsQ0FBQ2IsSUFBSSxDQUFDO1VBQzdCO1VBQ0E7UUFDSjtNQUNKO0lBQ0o7RUFDSixDQUFDO0VBRURrQixVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCdkMsRUFBRSxDQUFDWSxHQUFHLENBQUM0QixRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDQyxJQUFJLENBQUNKLE1BQU0sR0FBRyxLQUFLO0VBQzVCO0FBRUosQ0FBQyxDQUFDO0FBQ0ZLLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHN0MsWUFBWSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgTWF0ZVRpcFBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgIG1hdGVJdGVtOmNjLlByZWZhYixcclxuICAgICAgIG1hdGVQYXJlbnQ6Y2MuTm9kZSxcclxuICAgICAgIGhhc0luaXQ6ZmFsc2UsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy5oYXNJbml0ID09IHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLlJlZnJlc2hQYW5lbEl0ZW1zKCk7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5bey57uP5Yid5aeL5YyW5LqG77yM6L+U5ZueXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBNYXRlTGlzdCA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRPd25EYXRhTGlzdEJ5VHlwZShJdGVtVHlwZS5NYXRlKTtcclxuICAgICAgICB2YXIgZGF0YUxpc3QgPSB0aGlzLmdldE1hdGVMaXN0QnlTZXgoY2MuTWdyLlVzZXJEYXRhTWdyLlNleCwgTWF0ZUxpc3QpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRhdGFMaXN0Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAvL2lmKCkg5Yik5pat6Kej6ZSB5p2h5Lu2ICDmiJHku6zkvJrmnInnlLflpbPnmoTljLrliKtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMubWF0ZUl0ZW0pO1xyXG4gICAgICAgICAgICBvYmoucGFyZW50ID0gdGhpcy5tYXRlUGFyZW50O1xyXG4gICAgICAgICAgICBvYmouZ2V0Q29tcG9uZW50KFwiTWF0ZUl0ZW1cIikuaW5pdChkYXRhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGFzSW5pdCA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1hdGVMaXN0QnlTZXg6ZnVuY3Rpb24oU2V4LCBkYXRhTGlzdCl7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZihTZXggPT0gZGF0YUxpc3RbaV0uc2V4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5wdXNoKGRhdGFMaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9LFxyXG5cclxuICAgIFJlZnJlc2hQYW5lbEl0ZW1zOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5tYXRlUGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJNYXRlSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5NYXRlLCBzYy5JZCk7XHJcbiAgICAgICAgICAgICAgICBzYy5SZWZyZXNoTG92ZVBvaW50KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYoZGF0YS5jYW5EYXRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjLkNoYW5nZVVuTG9ja1N0YXRlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hpbGRyZW5baV0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBSZWZyZXNoUGFuZWw6ZnVuY3Rpb24oSWQpe1xyXG4gICAgICAgIHZhciBkYXRhID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldERhdGFCeUl0ZW1UeXBlQW5kSWQoSXRlbVR5cGUuTWF0ZSwgSWQpO1xyXG4gICAgICAgIC8vY2MubG9nKFwiPT09PT09PT09PT09XCIgKyBkYXRhLkxvdmVQb2ludCk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5tYXRlUGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJNYXRlSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYoc2MuSWQgPT0gSWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YS5jYW5EYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2MuUmVmcmVzaExvdmVQb2ludChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTWF0ZVRpcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/MateItemPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3ddc1fmT9tNz7yE3bKf6WIK', 'MateItemPanel');
// Scripts/UI/MateItemPanel.js

"use strict";

var ItemType = require("ItemType");
var MateGetType = require("MateGetType");
var MateBonusType = require("MateBonusType");
var MateItemPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    cost: cc.Integer,
    nameLbl: cc.Sprite,
    iconSp: cc.Sprite,
    desLbl: cc.Label,
    MarryCond: cc.Node,
    MarryCondLbl: cc.Label,
    Id: cc.Integer,
    LovePoint: cc.Integer,
    PdesLbl: cc.Label
  },
  ShowPanel: function ShowPanel(data) {
    this.Id = data.Id;
    this.LovePoint = data.LovePoint;
    this.iconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    //this.nameLbl.string = data.name;
    var mateData = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, data.Id);
    var lovePointList = mateData.lovePointList;
    var index = 0;
    for (var i = lovePointList.length - 1; i >= 0; i--) {
      if (lovePointList[i].curLevel == data.curLevel) {
        index = i;
        break;
      }
    }
    var idex = 1 + Math.floor(Math.random() * 6);
    this.PdesLbl.string = cc.Mgr.global.getTranslation("date_" + this.Id);
    this.cost = lovePointList[index].cost - Math.floor(lovePointList[index].cost * cc.Mgr.UserDataMgr.DateMoneyBonus);
    this.desLbl.string = this.cost;
    this.MarryCond.active = true;
    if (this.LovePoint == 99) {
      var DD = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, this.Id);
      this.PdesLbl.string = "结婚后:" + this.getMateBonusDes();
      this.MarryCondLbl.string = this.getUnlockTypes(DD.getCondList);
    } else {
      this.MarryCondLbl.string = "亲密度达到99显示";
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  },
  getMateBonusDes: function getMateBonusDes() {
    var bonusList = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, this.Id).bonusList;
    var str = "";
    for (var i = 0; i < bonusList.length; i++) {
      switch (bonusList[i].bonusType) {
        case MateBonusType.HP:
          if (bonusList[i].bonusNum > 0) str = str + " " + "每年健康:+" + bonusList[i].bonusNum;else str = str + " " + "每年健康:" + bonusList[i].bonusNum;
          break;
        case MateBonusType.Reputation:
          str = str + " " + "每年名声:+" + bonusList[i].bonusNum;
          break;
        case MateBonusType.Money:
          str = str + " " + "每年现金:+" + bonusList[i].bonusNum;
          break;
        case MateBonusType.WareHouseCapcity:
          str = str + " " + "仓储:+" + bonusList[i].bonusNum;
          break;
        case MateBonusType.Treat:
          str = str + " " + "治疗降费:" + bonusList[i].bonusNum * 100 + "%";
          break;
      }
    }
    return str;
  },
  //约起来
  DateClick: function DateClick() {
    var flag = cc.Mgr.UserDataMgr.JudeHasAnyMate();
    if (flag && this.LovePoint == 99) {
      cc.Mgr.AudioMgr.playSFX("click");
      var param = {};
      var seed = Math.floor(Math.random() * 2);
      param.text = cc.Mgr.global.getTranslation("HasMarray_" + seed);
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    if (cc.Mgr.UserDataMgr.Cash < this.cost) {
      cc.Mgr.AudioMgr.playSFX("click");
      var param = {};
      var seed = Math.floor(Math.random() * 2);
      param.text = cc.Mgr.global.getTranslation("NoMoneyDate_" + seed);
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    var DD = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Mate, this.Id);
    var result = this.JudeCanMarry(DD.getCondList);
    if (this.LovePoint == 99 && !result.canMarry) {
      cc.Mgr.AudioMgr.playSFX("click");
      var param = {};
      var des = "";
      //cc.log("=======================" + result.desList.length);
      for (var i = 0; i < result.desList.length; i++) {
        des = des + "\n" + cc.Mgr.global.getTranslation("MateMarryCond_" + this.Id);
      }
      param.text = des;
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
    } else {
      cc.Mgr.UserDataMgr.Cash -= this.cost;
      var outpar = cc.Mgr.UserDataMgr.RefreshMateData(this.Id);
      if (outpar.isFull == true) {
        var bonusList = DD.bonusList;
        this.getBonus(bonusList);
        //var param = {};
        //param.text = cc.Mgr.global.getTranslation("MarryTxt_" + cc.Mgr.UserDataMgr.Sex);
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenMarry, DD);
      } else {
        var seed = Math.floor(Math.random() * 6);
        var param = {};
        param.forWhat = "DateLater";
        param.text = cc.Mgr.global.getTranslation("DateOut_" + seed) + "\n" + "<color=#e77122>亲密度达到:" + outpar.LovePoint + "</c>";
        cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      }
      var dt = {};
      dt.Id = this.Id;
      cc.director.GlobalEvent.emit(cc.Mgr.Event.DateSuccess, dt);
      this.ClosePanel();
    }
  },
  JudeCanMarry: function JudeCanMarry(getCondList) {
    var canMarry = false;
    var result = {};
    var txt = [];
    for (var i = 0; i < getCondList.length; i++) {
      var cond = getCondList[i];
      switch (cond.unlockType) {
        case MateGetType.Money:
          canMarry = true;
          break;
        case MateGetType.House:
          canMarry = cc.Mgr.UserDataMgr.JudeHasHouse(cond.value);
          break;
        case MateGetType.Car:
          canMarry = cc.Mgr.UserDataMgr.JudeHasCar(cond.value);
          break;
        case MateGetType.Asset:
          canMarry = cc.Mgr.UserDataMgr.JudeAsset(cond.value);
          break;
        case MateGetType.Reputation:
          canMarry = cc.Mgr.UserDataMgr.JudeReputation(cond.value);
          break;
        case MateGetType.HP:
          canMarry = cc.Mgr.UserDataMgr.JudeHpPoint(cond.value);
          break;
        case MateGetType.Company:
          canMarry = cc.Mgr.UserDataMgr.JudeHasCompany();
          break;
      }
      if (canMarry == false) {
        txt.push(cond.unlockType);
        result.canMarry = canMarry;
        result.desList = txt;
        return result;
        break;
      }
    }
    result.canMarry = canMarry;
    result.desList = txt;
    return result;
  },
  getUnlockTypes: function getUnlockTypes(getCondList) {
    var txt = "";
    for (var i = 0; i < getCondList.length; i++) {
      var cond = getCondList[i];
      txt += this.getCondDes(cond.unlockType, cond.value) + " ";
    }
    return txt;
  },
  getCondDes: function getCondDes(type, value) {
    var txt = "";
    if (value == 0) {
      switch (type) {
        case MateGetType.Money:
          txt = "腰缠万贯";
          break;
        case MateGetType.House:
          txt = "房子一套";
          break;
        case MateGetType.Car:
          txt = "小车一辆";
          break;
        case MateGetType.Asset:
          txt = "资产百万";
          break;
        case MateGetType.Reputation:
          txt = "声名鹊起";
          break;
        case MateGetType.HP:
          txt = "身体健康";
          break;
        case MateGetType.Company:
          txt = "拥有任意一家公司";
          break;
      }
    } else {
      switch (type) {
        case MateGetType.Money:
          txt = "现金" + value;
          break;
        case MateGetType.House:
          var DD = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.House, value);
          txt = DD.name + "一套";
          break;
        case MateGetType.Car:
          var DD = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Car, value);
          txt = DD.name + "一辆";
          break;
        case MateGetType.Asset:
          txt = "资产达到:" + value;
          break;
        case MateGetType.Reputation:
          txt = "名声达到:" + value;
          break;
        case MateGetType.HP:
          txt = "健康值达到:" + value;
          break;
        case MateGetType.Company:
          var DD = cc.Mgr.MapDataMgr.getDataByItemTypeAndId(ItemType.Company, value);
          txt = DD.name + "一家";
          break;
      }
    }
    return txt;
  },
  getBonus: function getBonus(bonusList) {
    cc.Mgr.UserDataMgr.getMateBonusReward(bonusList);
  }
});
module.exports = MateItemPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE1hdGVJdGVtUGFuZWwuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiTWF0ZUdldFR5cGUiLCJNYXRlQm9udXNUeXBlIiwiTWF0ZUl0ZW1QYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiQXRsYXMiLCJTcHJpdGVBdGxhcyIsImNvc3QiLCJJbnRlZ2VyIiwibmFtZUxibCIsIlNwcml0ZSIsImljb25TcCIsImRlc0xibCIsIkxhYmVsIiwiTWFycnlDb25kIiwiTm9kZSIsIk1hcnJ5Q29uZExibCIsIklkIiwiTG92ZVBvaW50IiwiUGRlc0xibCIsIlNob3dQYW5lbCIsImRhdGEiLCJzcHJpdGVGcmFtZSIsImdldFNwcml0ZUZyYW1lIiwiaWNvbiIsIm1hdGVEYXRhIiwiTWdyIiwiTWFwRGF0YU1nciIsImdldERhdGFCeUl0ZW1UeXBlQW5kSWQiLCJNYXRlIiwibG92ZVBvaW50TGlzdCIsImluZGV4IiwiaSIsImxlbmd0aCIsImN1ckxldmVsIiwiaWRleCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInN0cmluZyIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwiVXNlckRhdGFNZ3IiLCJEYXRlTW9uZXlCb251cyIsImFjdGl2ZSIsIkREIiwiZ2V0TWF0ZUJvbnVzRGVzIiwiZ2V0VW5sb2NrVHlwZXMiLCJnZXRDb25kTGlzdCIsIkNsb3NlUGFuZWwiLCJBdWRpb01nciIsInBsYXlTRlgiLCJub2RlIiwiYm9udXNMaXN0Iiwic3RyIiwiYm9udXNUeXBlIiwiSFAiLCJib251c051bSIsIlJlcHV0YXRpb24iLCJNb25leSIsIldhcmVIb3VzZUNhcGNpdHkiLCJUcmVhdCIsIkRhdGVDbGljayIsImZsYWciLCJKdWRlSGFzQW55TWF0ZSIsInBhcmFtIiwic2VlZCIsInRleHQiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlbkNvbW1vblRpcCIsIkNhc2giLCJyZXN1bHQiLCJKdWRlQ2FuTWFycnkiLCJjYW5NYXJyeSIsImRlcyIsImRlc0xpc3QiLCJvdXRwYXIiLCJSZWZyZXNoTWF0ZURhdGEiLCJpc0Z1bGwiLCJnZXRCb251cyIsIk9wZW5NYXJyeSIsImZvcldoYXQiLCJkdCIsIkRhdGVTdWNjZXNzIiwidHh0IiwiY29uZCIsInVubG9ja1R5cGUiLCJIb3VzZSIsIkp1ZGVIYXNIb3VzZSIsInZhbHVlIiwiQ2FyIiwiSnVkZUhhc0NhciIsIkFzc2V0IiwiSnVkZUFzc2V0IiwiSnVkZVJlcHV0YXRpb24iLCJKdWRlSHBQb2ludCIsIkNvbXBhbnkiLCJKdWRlSGFzQ29tcGFueSIsInB1c2giLCJnZXRDb25kRGVzIiwidHlwZSIsIm5hbWUiLCJnZXRNYXRlQm9udXNSZXdhcmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxXQUFXLEdBQUdELE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDeEMsSUFBSUUsYUFBYSxHQUFHRixPQUFPLENBQUMsZUFBZSxDQUFDO0FBQzVDLElBQUlHLGFBQWEsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDekIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsS0FBSyxFQUFDSixFQUFFLENBQUNLLFdBQVc7SUFDcEJDLElBQUksRUFBQ04sRUFBRSxDQUFDTyxPQUFPO0lBQ2ZDLE9BQU8sRUFBQ1IsRUFBRSxDQUFDUyxNQUFNO0lBQ2pCQyxNQUFNLEVBQUNWLEVBQUUsQ0FBQ1MsTUFBTTtJQUNoQkUsTUFBTSxFQUFDWCxFQUFFLENBQUNZLEtBQUs7SUFDZkMsU0FBUyxFQUFDYixFQUFFLENBQUNjLElBQUk7SUFDakJDLFlBQVksRUFBQ2YsRUFBRSxDQUFDWSxLQUFLO0lBQ3JCSSxFQUFFLEVBQUNoQixFQUFFLENBQUNPLE9BQU87SUFDYlUsU0FB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ZVwiKTtcclxudmFyIE1hdGVHZXRUeXBlID0gcmVxdWlyZShcIk1hdGVHZXRUeXBlXCIpO1xyXG52YXIgTWF0ZUJvbnVzVHlwZSA9IHJlcXVpcmUoXCJNYXRlQm9udXNUeXBlXCIpO1xyXG52YXIgTWF0ZUl0ZW1QYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgY29zdDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIG5hbWVMYmw6Y2MuU3ByaXRlLFxyXG4gICAgICAgIGljb25TcDpjYy5TcHJpdGUsXHJcbiAgICAgICAgZGVzTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIE1hcnJ5Q29uZDpjYy5Ob2RlLFxyXG4gICAgICAgIE1hcnJ5Q29uZExibDpjYy5MYWJlbCxcclxuICAgICAgICBJZDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIExvdmVQb2ludDpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIFBkZXNMYmw6Y2MuTGFiZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgXHR0aGlzLklkID0gZGF0YS5JZDtcclxuICAgICAgICB0aGlzLkxvdmVQb2ludCA9IGRhdGEuTG92ZVBvaW50O1xyXG4gICAgXHR0aGlzLmljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgIFx0Ly90aGlzLm5hbWVMYmwuc3RyaW5nID0gZGF0YS5uYW1lO1xyXG4gICAgXHR2YXIgbWF0ZURhdGEgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLk1hdGUsIGRhdGEuSWQpO1xyXG4gICAgXHR2YXIgbG92ZVBvaW50TGlzdCA9IG1hdGVEYXRhLmxvdmVQb2ludExpc3Q7XHJcbiAgICBcdHZhciBpbmRleCA9IDA7XHJcbiAgICBcdGZvciAodmFyIGkgPSBsb3ZlUG9pbnRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBcdFx0aWYobG92ZVBvaW50TGlzdFtpXS5jdXJMZXZlbCA9PSBkYXRhLmN1ckxldmVsKVxyXG4gICAgXHRcdHtcclxuICAgIFx0XHRcdGluZGV4ID0gaTtcclxuICAgIFx0XHRcdGJyZWFrO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgICAgIHZhciBpZGV4ID0gMSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDYpO1xyXG4gICAgICAgIHRoaXMuUGRlc0xibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiZGF0ZV9cIit0aGlzLklkKTtcclxuICAgICAgICB0aGlzLmNvc3QgPSBsb3ZlUG9pbnRMaXN0W2luZGV4XS5jb3N0IC0gTWF0aC5mbG9vcihsb3ZlUG9pbnRMaXN0W2luZGV4XS5jb3N0ICogY2MuTWdyLlVzZXJEYXRhTWdyLkRhdGVNb25leUJvbnVzKTtcclxuICAgIFx0dGhpcy5kZXNMYmwuc3RyaW5nID0gdGhpcy5jb3N0O1xyXG5cclxuICAgICAgICB0aGlzLk1hcnJ5Q29uZC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGlmKHRoaXMuTG92ZVBvaW50ID09IDk5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIEREID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5NYXRlLCB0aGlzLklkKTtcclxuICAgICAgICAgICAgdGhpcy5QZGVzTGJsLnN0cmluZyA9IFwi57uT5ama5ZCOOlwiK3RoaXMuZ2V0TWF0ZUJvbnVzRGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuTWFycnlDb25kTGJsLnN0cmluZyA9IHRoaXMuZ2V0VW5sb2NrVHlwZXMoREQuZ2V0Q29uZExpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLk1hcnJ5Q29uZExibC5zdHJpbmcgPSBcIuS6suWvhuW6pui+vuWIsDk55pi+56S6XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgIFx0dGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNYXRlQm9udXNEZXM6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBib251c0xpc3QgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLk1hdGUgLHRoaXMuSWQpLmJvbnVzTGlzdDtcclxuICAgICAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvbnVzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzd2l0Y2goYm9udXNMaXN0W2ldLmJvbnVzVHlwZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRlQm9udXNUeXBlLkhQOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJvbnVzTGlzdFtpXS5ib251c051bT4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIrXCIgXCIgKyBcIuavj+W5tOWBpeW6tzorXCIgKyBib251c0xpc3RbaV0uYm9udXNOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIrXCIgXCIgKyBcIuavj+W5tOWBpeW6tzpcIiArIGJvbnVzTGlzdFtpXS5ib251c051bTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0ZUJvbnVzVHlwZS5SZXB1dGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0citcIiBcIiAgKyBcIuavj+W5tOWQjeWjsDorXCIgKyBib251c0xpc3RbaV0uYm9udXNOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGVCb251c1R5cGUuTW9uZXk6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyK1wiIFwiICArIFwi5q+P5bm0546w6YeROitcIiArIGJvbnVzTGlzdFtpXS5ib251c051bTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0ZUJvbnVzVHlwZS5XYXJlSG91c2VDYXBjaXR5OlxyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0citcIiBcIiAgKyBcIuS7k+WCqDorXCIgKyBib251c0xpc3RbaV0uYm9udXNOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGVCb251c1R5cGUuVHJlYXQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyK1wiIFwiICArIFwi5rK755aX6ZmN6LS5OlwiICsgYm9udXNMaXN0W2ldLmJvbnVzTnVtKjEwMCArIFwiJVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v57qm6LW35p2lXHJcbiAgICBEYXRlQ2xpY2s6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgZmxhZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlSGFzQW55TWF0ZSgpO1xyXG4gICAgICAgIGlmKGZsYWcgJiYgdGhpcy5Mb3ZlUG9pbnQgPT0gOTkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJIYXNNYXJyYXlfXCIgKyBzZWVkKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgIFx0aWYoY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggPCB0aGlzLmNvc3QpXHJcbiAgICBcdHtcclxuICAgICAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgIFx0XHR2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcclxuICAgIFx0XHRwYXJhbS50ZXh0ID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIk5vTW9uZXlEYXRlX1wiICsgc2VlZCk7XHJcbiAgICBcdFx0Y2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgXHRcdHJldHVybjtcclxuICAgIFx0fVxyXG5cclxuICAgICAgICB2YXIgREQgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLk1hdGUsIHRoaXMuSWQpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLkp1ZGVDYW5NYXJyeShERC5nZXRDb25kTGlzdCk7XHJcbiAgICAgICAgaWYodGhpcy5Mb3ZlUG9pbnQgPT0gOTkgJiYgIXJlc3VsdC5jYW5NYXJyeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgZGVzID0gXCJcIjtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PVwiICsgcmVzdWx0LmRlc0xpc3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZGVzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZGVzID0gZGVzK1wiXFxuXCIgKyBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiTWF0ZU1hcnJ5Q29uZF9cIiArIHRoaXMuSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBkZXM7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkNhc2ggLT0gdGhpcy5jb3N0O1xyXG4gICAgICAgICAgICB2YXIgb3V0cGFyID0gY2MuTWdyLlVzZXJEYXRhTWdyLlJlZnJlc2hNYXRlRGF0YSh0aGlzLklkKTtcclxuICAgICAgICAgICAgaWYob3V0cGFyLmlzRnVsbCA9PSB0cnVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9udXNMaXN0ID0gREQuYm9udXNMaXN0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCb251cyhib251c0xpc3QpO1xyXG4gICAgICAgICAgICAgICAgLy92YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgICAgIC8vcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJNYXJyeVR4dF9cIiArIGNjLk1nci5Vc2VyRGF0YU1nci5TZXgpO1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3Blbk1hcnJ5LCBERCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbS5mb3JXaGF0ID0gXCJEYXRlTGF0ZXJcIjtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiRGF0ZU91dF9cIiArIHNlZWQpICsgXCJcXG5cIiArIFwiPGNvbG9yPSNlNzcxMjI+5Lqy5a+G5bqm6L6+5YiwOlwiKyBvdXRwYXIuTG92ZVBvaW50K1wiPC9jPlwiO1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkdCA9IHt9O1xyXG4gICAgICAgICAgICBkdC5JZCA9IHRoaXMuSWQ7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LkRhdGVTdWNjZXNzLCBkdCk7XHJcbiAgICAgICAgICAgIHRoaXMuQ2xvc2VQYW5lbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgSnVkZUNhbk1hcnJ5OmZ1bmN0aW9uKGdldENvbmRMaXN0KXtcclxuICAgICAgICB2YXIgY2FuTWFycnkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgdmFyIHR4dCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2V0Q29uZExpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvbmQgPSBnZXRDb25kTGlzdFtpXTtcclxuICAgICAgICAgICAgc3dpdGNoIChjb25kLnVubG9ja1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWF0ZUdldFR5cGUuTW9uZXk6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuTWFycnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Ib3VzZTpcclxuICAgICAgICAgICAgICAgICAgICBjYW5NYXJyeSA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlSGFzSG91c2UoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGVHZXRUeXBlLkNhcjpcclxuICAgICAgICAgICAgICAgICAgICBjYW5NYXJyeSA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlSGFzQ2FyKGNvbmQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Bc3NldDpcclxuICAgICAgICAgICAgICAgICAgICBjYW5NYXJyeSA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlQXNzZXQoY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGVHZXRUeXBlLlJlcHV0YXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuTWFycnkgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSnVkZVJlcHV0YXRpb24oY29uZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hdGVHZXRUeXBlLkhQOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhbk1hcnJ5ID0gY2MuTWdyLlVzZXJEYXRhTWdyLkp1ZGVIcFBvaW50KGNvbmQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Db21wYW55OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhbk1hcnJ5ID0gY2MuTWdyLlVzZXJEYXRhTWdyLkp1ZGVIYXNDb21wYW55KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGNhbk1hcnJ5ID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0eHQucHVzaChjb25kLnVubG9ja1R5cGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhbk1hcnJ5ID0gY2FuTWFycnk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZGVzTGlzdCA9IHR4dDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuY2FuTWFycnkgPSBjYW5NYXJyeTtcclxuICAgICAgICByZXN1bHQuZGVzTGlzdCA9IHR4dDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRVbmxvY2tUeXBlczpmdW5jdGlvbihnZXRDb25kTGlzdClcclxuICAgIHtcclxuICAgICAgICB2YXIgdHh0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdldENvbmRMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25kID0gZ2V0Q29uZExpc3RbaV07XHJcbiAgICAgICAgICAgIHR4dCArPSB0aGlzLmdldENvbmREZXMoY29uZC51bmxvY2tUeXBlLCBjb25kLnZhbHVlKSArIFwiIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHh0O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb25kRGVzOmZ1bmN0aW9uKHR5cGUsIHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0eHQgPSBcIlwiO1xyXG4gICAgICAgIGlmKHZhbHVlID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Nb25leTpcclxuICAgICAgICAgICAgICAgIHR4dCA9IFwi6IWw57yg5LiH6LSvXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Ib3VzZTpcclxuICAgICAgICAgICAgICAgIHR4dCA9IFwi5oi/5a2Q5LiA5aWXXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5DYXI6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSBcIuWwj+i9puS4gOi+hlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTWF0ZUdldFR5cGUuQXNzZXQ6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSBcIui1hOS6p+eZvuS4h1wiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTWF0ZUdldFR5cGUuUmVwdXRhdGlvbjpcclxuICAgICAgICAgICAgICAgIHR4dCA9IFwi5aOw5ZCN6bmK6LW3XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5IUDpcclxuICAgICAgICAgICAgICAgIHR4dCA9IFwi6Lqr5L2T5YGl5bq3XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Db21wYW55OlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gXCLmi6XmnInku7vmhI/kuIDlrrblhazlj7hcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIE1hdGVHZXRUeXBlLk1vbmV5OlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gXCLnjrDph5FcIit2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1hdGVHZXRUeXBlLkhvdXNlOlxyXG4gICAgICAgICAgICAgICAgdmFyIEREID0gY2MuTWdyLk1hcERhdGFNZ3IuZ2V0RGF0YUJ5SXRlbVR5cGVBbmRJZChJdGVtVHlwZS5Ib3VzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdHh0ID0gREQubmFtZSArIFwi5LiA5aWXXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5DYXI6XHJcbiAgICAgICAgICAgICAgICB2YXIgREQgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNhciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdHh0ID0gREQubmFtZSArIFwi5LiA6L6GXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNYXRlR2V0VHlwZS5Bc3NldDpcclxuICAgICAgICAgICAgICAgIHR4dCA9IFwi6LWE5Lqn6L6+5YiwOlwiK3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTWF0ZUdldFR5cGUuUmVwdXRhdGlvbjpcclxuICAgICAgICAgICAgICAgIHR4dCA9IFwi5ZCN5aOw6L6+5YiwOlwiK3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTWF0ZUdldFR5cGUuSFA6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSBcIuWBpeW6t+WAvOi+vuWIsDpcIit2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1hdGVHZXRUeXBlLkNvbXBhbnk6XHJcbiAgICAgICAgICAgICAgICB2YXIgREQgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkNvbXBhbnksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHR4dCA9IERELm5hbWUgKyBcIuS4gOWutlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgICAgIHJldHVybiB0eHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJvbnVzOmZ1bmN0aW9uKGJvbnVzTGlzdClcclxuICAgIHtcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0TWF0ZUJvbnVzUmV3YXJkKGJvbnVzTGlzdCk7XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRlSXRlbVBhbmVsOyJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/OwnedCarPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ad9d3CyhUxCh4EiJnGSOdv4', 'OwnedCarPanel');
// Scripts/UI/OwnedCarPanel.js

"use strict";

var ItemType = require("ItemType");
var OwnedCarPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    ownedPre: cc.Prefab,
    ownedParent: cc.Node,
    tipLbl: cc.Label
  },
  ShowPanel: function ShowPanel() {
    this.tipLbl.string = "";
    if (this.JudeHasAny() == false) {
      this.tipLbl.string = "您还未拥有任何一辆属于您的座驾,去汽车市场购买吧";
      //return;
    }

    var carList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Car);
    if (this.ownedParent.children.length != 0) {
      //cc.log("不用再实例化，已经有了");
      var children = this.ownedParent.children;
      for (var i = children.length - 1; i >= 0; i--) {
        var sc = children[i].getComponent("BelongItem");
        if (sc != null) {
          for (var j = 0; j < carList.length; j++) {
            if (carList[j].Id == sc.Id) {
              sc.Refresh(carList[j]);
              if (carList[j].ownNum > 0) children[i].active = true;else children[i].active = false;
            }
          }
        }
      }
    } else {
      for (var i = carList.length - 1; i >= 0; i--) {
        //cc.log("实例化汽车");
        var obj = cc.instantiate(this.ownedPre);
        obj.parent = this.ownedParent;
        obj.getComponent("BelongItem").init(carList[i], ItemType.Car);
        if (carList[i].ownNum > 0) {
          obj.active = true;
        } else {
          obj.active = false;
        }
      }
    }
  },
  JudeHasAny: function JudeHasAny() {
    var mateList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Car);
    var hasAny = false;
    for (var i = 0; i < mateList.length; i++) {
      if (mateList[i].ownNum > 0) {
        hasAny = true;
        return true;
      }
    }
    return hasAny;
  }
});
module.exports = OwnedCarPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE93bmVkQ2FyUGFuZWwuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiT3duZWRDYXJQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwib3duZWRQcmUiLCJQcmVmYWIiLCJvd25lZFBhcmVudCIsIk5vZGUiLCJ0aXBMYmwiLCJMYWJlbCIsIlNob3dQYW5lbCIsInN0cmluZyIsIkp1ZGVIYXNBbnkiLCJjYXJMaXN0IiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJnZXRPd25EYXRhTGlzdEJ5VHlwZSIsIkNhciIsImNoaWxkcmVuIiwibGVuZ3RoIiwiaSIsInNjIiwiZ2V0Q29tcG9uZW50IiwiaiIsIklkIiwiUmVmcmVzaCIsIm93bk51bSIsImFjdGl2ZSIsIm9iaiIsImluc3RhbnRpYXRlIiwicGFyZW50IiwiaW5pdCIsIm1hdGVMaXN0IiwiaGFzQW55IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsYUFBYSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN6QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxRQUFRLEVBQUNKLEVBQUUsQ0FBQ0ssTUFBTTtJQUNsQkMsV0FBVyxFQUFDTixFQUFFLENBQUNPLElBQUk7SUFDbkJDLE1BQU0sRUFBQ1IsRUFBRSxDQUFDUztFQUNkLENBQUM7RUFFREMsU0FBUyxFQUFDLFNBQUFBLFVBQUEsRUFBWTtJQUNsQixJQUFJLENBQUNGLE1BQU0sQ0FBQ0csTUFBTSxHQUFHLEVBQUU7SUFDdkIsSUFBRyxJQUFJLENBQUNDLFVBQVUsRUFBRSxJQUFJLEtBQUssRUFDN0I7TUFDSSxJQUFJLENBQUNKLE1BQU0sQ0FBQ0csTUFBTSxHQUFHLDBCQUEwQjtNQUMvQztJQUNKOztJQUVBLElBQUlFLE9BQU8sR0FBR2IsRUFBRSxDQUFDYyxHQUFHLENBQUNDLFdBQVcsQ0FBQ0Msb0JBQW9CLENBQUNuQixRQUFRLENBQUNvQixHQUFHLENBQUM7SUFDbkUsSUFBRyxJQUFJLENBQUNYLFdBQVcsQ0FBQ1ksUUFBUSxDQUFDQyxNQUFNLElBQUksQ0FBQyxFQUN4QztNQUNJO01BQ0EsSUFBSUQsUUFBUSxHQUFHLElBQUksQ0FBQ1osV0FBVyxDQUFDWSxRQUFRO01BQ3hDLEtBQUssSUFBSUUsQ0FBQyxHQUFHRixRQUFRLENBQUNDLE1BQU0sR0FBRyxDQUFDLEVBQUVDLENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO1FBQzNDLElBQUlDLEVBQUUsR0FBR0gsUUFBUSxDQUFDRSxDQUFDLENBQUMsQ0FBQ0UsWUFBWSxDQUFDLFlBQVksQ0FBQztRQUMvQyxJQUFHRCxFQUFFLElBQUksSUFBSSxFQUNiO1VBQ0ksS0FBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdWLE9BQU8sQ0FBQ00sTUFBTSxFQUFFSSxDQUFDLEVBQUUsRUFBRTtZQUNyQyxJQUFHVixPQUFPLENBQUNVLENBQUMsQ0FBQyxDQUFDQyxFQUFFLElBQUlILEVBQUUsQ0FBQ0csRUFBRSxFQUN6QjtjQUNJSCxFQUFFLENBQUNJLE9BQU8sQ0FBQ1osT0FBTyxDQUFDVSxDQUFDLENBQUMsQ0FBQztjQUN0QixJQUFHVixPQUFPLENBQUNVLENBQUMsQ0FBQyxDQUFDRyxNQUFNLEdBQUcsQ0FBQyxFQUNwQlIsUUFBUSxDQUFDRSxDQUFDLENBQUMsQ0FBQ08sTUFBTSxHQUFHLElBQUksQ0FBQyxLQUUxQlQsUUFBUSxDQUFDRSxDQUFDLENBQUMsQ0FBQ08sTUFBTSxHQUFHLEtBQUs7WUFDbEM7VUFDSjtRQUNKO01BQ0o7SUFDSixDQUFDLE1BRUQ7TUFDSSxLQUFLLElBQUlQLENBQUMsR0FBR1AsT0FBTyxDQUFDTSxNQUFNLEdBQUcsQ0FBQyxFQUFFQyxDQUFDLElBQUksQ0FBQyxFQUFFQSxDQUFDLEVBQUUsRUFBRTtRQUMxQztRQUNBLElBQUlRLEdBQUcsR0FBRzVCLEVBQUUsQ0FBQzZCLFdBQVcsQ0FBQyxJQUFJLENBQUN6QixRQUFRLENBQUM7UUFDdkN3QixHQUFHLENBQUNFLE1BQU0sR0FBRyxJQUFJLENBQUN4QixXQUFXO1FBQzdCc0IsR0FBRyxDQUFDTixZQUFZLENBQUMsWUFBWSxDQUFDLENBQUNTLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ08sQ0FBQyxDQUFDLEVBQUV2QixRQUFRLENBQUNvQixHQUFHLENBQUM7UUFDN0QsSUFBR0osT0FBTyxDQUFDTyxDQUFDLENBQUMsQ0FBQ00sTUFBTSxHQUFHLENBQUMsRUFDeEI7VUFDSUUsR0FBRyxDQUFDRCxNQUFNLEdBQUcsSUFBSTtRQUNyQixDQUFDLE1BRUQ7VUFDSUMsR0FBRyxDQUFDRCxNQUFNLEdBQUcsS0FBSztRQUN0QjtNQUNKO0lBQ0o7RUFDSixDQUFDO0VBRURmLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQVU7SUFDakIsSUFBSW9CLFFBQVEsR0FBR2hDLEVBQUUsQ0FBQ2MsR0FBRyxDQUFDQyxXQUFXLENBQUNDLG9CQUFvQixDQUFDbkIsUUFBUSxDQUFDb0IsR0FBRyxDQUFDO0lBQ3BFLElBQUlnQixNQUFNLEdBQUcsS0FBSztJQUNsQixLQUFLLElBQUliLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR1ksUUFBUSxDQUFDYixNQUFNLEVBQUVDLENBQUMsRUFBRSxFQUFFO01BQ3RDLElBQUdZLFFBQVEsQ0FBQ1osQ0FBQyxDQUFDLENBQUNNLE1BQU0sR0FBRyxDQUFDLEVBQ3pCO1FBQ0lPLE1BQU0sR0FBRyxJQUFJO1FBQ2IsT0FBTyxJQUFJO01BQ2Y7SUFDSjtJQUNBLE9BQU9BLE1BQU07RUFDakI7QUFDSixDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUdwQyxhQUFhIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBPd25lZENhclBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBvd25lZFByZTpjYy5QcmVmYWIsXHJcbiAgICAgICAgb3duZWRQYXJlbnQ6Y2MuTm9kZSxcclxuICAgICAgICB0aXBMYmw6Y2MuTGFiZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50aXBMYmwuc3RyaW5nID0gXCJcIjtcclxuICAgICAgICBpZih0aGlzLkp1ZGVIYXNBbnkoKSA9PSBmYWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudGlwTGJsLnN0cmluZyA9IFwi5oKo6L+Y5pyq5oul5pyJ5Lu75L2V5LiA6L6G5bGe5LqO5oKo55qE5bqn6am+LOWOu+axvei9puW4guWcuui0reS5sOWQp1wiO1xyXG4gICAgICAgICAgICAvL3JldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjYXJMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLkNhcik7XHJcbiAgICAgICAgaWYodGhpcy5vd25lZFBhcmVudC5jaGlsZHJlbi5sZW5ndGggIT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5LiN55So5YaN5a6e5L6L5YyW77yM5bey57uP5pyJ5LqGXCIpO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm93bmVkUGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIkJlbG9uZ0l0ZW1cIik7XHJcbiAgICAgICAgICAgICAgICBpZihzYyAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FyTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYXJMaXN0W2pdLklkID09IHNjLklkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5SZWZyZXNoKGNhckxpc3Rbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FyTGlzdFtqXS5vd25OdW0gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uYWN0aXZlID0gZmFsc2U7ICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBjYXJMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIuWunuS+i+WMluaxvei9plwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLm93bmVkUHJlKTtcclxuICAgICAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLm93bmVkUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkJlbG9uZ0l0ZW1cIikuaW5pdChjYXJMaXN0W2ldLCBJdGVtVHlwZS5DYXIpO1xyXG4gICAgICAgICAgICAgICAgaWYoY2FyTGlzdFtpXS5vd25OdW0gPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgSnVkZUhhc0FueTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBtYXRlTGlzdCA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRPd25EYXRhTGlzdEJ5VHlwZShJdGVtVHlwZS5DYXIpO1xyXG4gICAgICAgIHZhciBoYXNBbnkgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKG1hdGVMaXN0W2ldLm93bk51bSA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGhhc0FueSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzQW55O1xyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gT3duZWRDYXJQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/OwnedHousePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b10caBioeJCtoJguoXBWF9j', 'OwnedHousePanel');
// Scripts/UI/OwnedHousePanel.js

"use strict";

var ItemType = require("ItemType");
var OwnedHousePanel = cc.Class({
  "extends": cc.Component,
  properties: {
    ownedPre: cc.Prefab,
    ownedParent: cc.Node,
    tipLbl: cc.Label
  },
  ShowPanel: function ShowPanel() {
    this.tipLbl.string = "";
    if (this.JudeHasAny() == false) {
      this.tipLbl.string = "居无定所,不是您的所想,去房产市场购买一套房产吧";
      //return;
    }

    var houseList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.House);
    if (this.ownedParent.children.length != 0) {
      //cc.log("不用再实例化，已经有了");
      var children = this.ownedParent.children;
      for (var i = children.length - 1; i >= 0; i--) {
        var sc = children[i].getComponent("BelongItem");
        if (sc != null) {
          for (var j = 0; j < houseList.length; j++) {
            if (houseList[j].Id == sc.Id) {
              sc.Refresh(houseList[j]);
              if (houseList[j].ownNum > 0) children[i].active = true;else children[i].active = false;
            }
          }
        }
      }
    } else {
      for (var i = houseList.length - 1; i >= 0; i--) {
        //cc.log("实例化房子");
        var obj = cc.instantiate(this.ownedPre);
        obj.parent = this.ownedParent;
        obj.getComponent("BelongItem").init(houseList[i], ItemType.House);
        if (houseList[i].ownNum > 0) {
          obj.active = true;
        } else {
          obj.active = false;
        }
      }
    }
  },
  JudeHasAny: function JudeHasAny() {
    var mateList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.House);
    var hasAny = false;
    for (var i = 0; i < mateList.length; i++) {
      if (mateList[i].ownNum > 0) {
        hasAny = true;
        return true;
      }
    }
    return hasAny;
  }
});
module.exports = OwnedHousePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE93bmVkSG91c2VQYW5lbC5qcyJdLCJuYW1lcyI6WyJJdGVtVHlwZSIsInJlcXVpcmUiLCJPd25lZEhvdXNlUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIm93bmVkUHJlIiwiUHJlZmFiIiwib3duZWRQYXJlbnQiLCJOb2RlIiwidGlwTGJsIiwiTGFiZWwiLCJTaG93UGFuZWwiLCJzdHJpbmciLCJKdWRlSGFzQW55IiwiaG91c2VMaXN0IiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJnZXRPd25EYXRhTGlzdEJ5VHlwZSIsIkhvdXNlIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJpIiwic2MiLCJnZXRDb21wb25lbnQiLCJqIiwiSWQiLCJSZWZyZXNoIiwib3duTnVtIiwiYWN0aXZlIiwib2JqIiwiaW5zdGFudGlhdGUiLCJwYXJlbnQiLCJpbml0IiwibWF0ZUxpc3QiLCJoYXNBbnkiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJQyxlQUFlLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQzNCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLFFBQVEsRUFBQ0osRUFBRSxDQUFDSyxNQUFNO0lBQ2xCQyxXQUFXLEVBQUNOLEVBQUUsQ0FBQ08sSUFBSTtJQUNuQkMsTUFBTSxFQUFDUixFQUFFLENBQUNTO0VBQ2QsQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFZO0lBQ2xCLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxNQUFNLEdBQUcsRUFBRTtJQUN2QixJQUFHLElBQUksQ0FBQ0MsVUFBVSxFQUFFLElBQUksS0FBSyxFQUM3QjtNQUNJLElBQUksQ0FBQ0osTUFBTSxDQUFDRyxNQUFNLEdBQUcsMEJBQTBCO01BQy9DO0lBQ0o7O0lBRUEsSUFBSUUsU0FBUyxHQUFHYixFQUFFLENBQUNjLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDQyxvQkFBb0IsQ0FBQ25CLFFBQVEsQ0FBQ29CLEtBQUssQ0FBQztJQUN2RSxJQUFHLElBQUksQ0FBQ1gsV0FBVyxDQUFDWSxRQUFRLENBQUNDLE1BQU0sSUFBSSxDQUFDLEVBQ3hDO01BQ0k7TUFDQSxJQUFJRCxRQUFRLEdBQUcsSUFBSSxDQUFDWixXQUFXLENBQUNZLFFBQVE7TUFDeEMsS0FBSyxJQUFJRSxDQUFDLEdBQUdGLFFBQVEsQ0FBQ0MsTUFBTSxHQUFHLENBQUMsRUFBRUMsQ0FBQyxJQUFJLENBQUMsRUFBRUEsQ0FBQyxFQUFFLEVBQUU7UUFDM0MsSUFBSUMsRUFBRSxHQUFHSCxRQUFRLENBQUNFLENBQUMsQ0FBQyxDQUFDRSxZQUFZLENBQUMsWUFBWSxDQUFDO1FBQy9DLElBQUdELEVBQUUsSUFBSSxJQUFJLEVBQ2I7VUFDSSxLQUFLLElBQUlFLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR1YsU0FBUyxDQUFDTSxNQUFNLEVBQUVJLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLElBQUdWLFNBQVMsQ0FBQ1UsQ0FBQyxDQUFDLENBQUNDLEVBQUUsSUFBSUgsRUFBRSxDQUFDRyxFQUFFLEVBQzNCO2NBQ0lILEVBQUUsQ0FBQ0ksT0FBTyxDQUFDWixTQUFTLENBQUNVLENBQUMsQ0FBQyxDQUFDO2NBQ3hCLElBQUdWLFNBQVMsQ0FBQ1UsQ0FBQyxDQUFDLENBQUNHLE1BQU0sR0FBRyxDQUFDLEVBQ3RCUixRQUFRLENBQUNFLENBQUMsQ0FBQyxDQUFDTyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBRTFCVCxRQUFRLENBQUNFLENBQUMsQ0FBQyxDQUFDTyxNQUFNLEdBQUcsS0FBSztZQUNsQztVQUNKO1FBQ0o7TUFDSjtJQUNKLENBQUMsTUFFRDtNQUNJLEtBQUssSUFBSVAsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLE1BQU0sR0FBRyxDQUFDLEVBQUVDLENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO1FBQzVDO1FBQ0EsSUFBSVEsR0FBRyxHQUFHNUIsRUFBRSxDQUFDNkIsV0FBVyxDQUFDLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQztRQUN2Q3dCLEdBQUcsQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ3hCLFdBQVc7UUFDN0JzQixHQUFHLENBQUNOLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQ1MsSUFBSSxDQUFDbEIsU0FBUyxDQUFDTyxDQUFDLENBQUMsRUFBRXZCLFFBQVEsQ0FBQ29CLEtBQUssQ0FBQztRQUNqRSxJQUFHSixTQUFTLENBQUNPLENBQUMsQ0FBQyxDQUFDTSxNQUFNLEdBQUcsQ0FBQyxFQUMxQjtVQUNJRSxHQUFHLENBQUNELE1BQU0sR0FBRyxJQUFJO1FBQ3JCLENBQUMsTUFFRDtVQUNJQyxHQUFHLENBQUNELE1BQU0sR0FBRyxLQUFLO1FBQ3RCO01BQ0o7SUFDSjtFQUNKLENBQUM7RUFFRGYsVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBVTtJQUNqQixJQUFJb0IsUUFBUSxHQUFHaEMsRUFBRSxDQUFDYyxHQUFHLENBQUNDLFdBQVcsQ0FBQ0Msb0JBQW9CLENBQUNuQixRQUFRLENBQUNvQixLQUFLLENBQUM7SUFDdEUsSUFBSWdCLE1BQU0sR0FBRyxLQUFLO0lBQ2xCLEtBQUssSUFBSWIsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHWSxRQUFRLENBQUNiLE1BQU0sRUFBRUMsQ0FBQyxFQUFFLEVBQUU7TUFDdEMsSUFBR1ksUUFBUSxDQUFDWixDQUFDLENBQUMsQ0FBQ00sTUFBTSxHQUFHLENBQUMsRUFDekI7UUFDSU8sTUFBTSxHQUFHLElBQUk7UUFDYixPQUFPLElBQUk7TUFDZjtJQUNKO0lBQ0EsT0FBT0EsTUFBTTtFQUNqQjtBQUNKLENBQUMsQ0FBQztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR3BDLGVBQWUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIE93bmVkSG91c2VQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgb3duZWRQcmU6Y2MuUHJlZmFiLFxyXG4gICAgICAgIG93bmVkUGFyZW50OmNjLk5vZGUsXHJcbiAgICAgICAgdGlwTGJsOmNjLkxhYmVsLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudGlwTGJsLnN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgaWYodGhpcy5KdWRlSGFzQW55KCkgPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRpcExibC5zdHJpbmcgPSBcIuWxheaXoOWumuaJgCzkuI3mmK/mgqjnmoTmiYDmg7Ms5Y675oi/5Lqn5biC5Zy66LSt5Lmw5LiA5aWX5oi/5Lqn5ZCnXCI7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhvdXNlTGlzdCA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRPd25EYXRhTGlzdEJ5VHlwZShJdGVtVHlwZS5Ib3VzZSk7XHJcbiAgICAgICAgaWYodGhpcy5vd25lZFBhcmVudC5jaGlsZHJlbi5sZW5ndGggIT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vY2MubG9nKFwi5LiN55So5YaN5a6e5L6L5YyW77yM5bey57uP5pyJ5LqGXCIpO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm93bmVkUGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIkJlbG9uZ0l0ZW1cIik7XHJcbiAgICAgICAgICAgICAgICBpZihzYyAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaG91c2VMaXN0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhvdXNlTGlzdFtqXS5JZCA9PSBzYy5JZClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuUmVmcmVzaChob3VzZUxpc3Rbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaG91c2VMaXN0W2pdLm93bk51bSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGhvdXNlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCLlrp7kvovljJbmiL/lrZBcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2MuaW5zdGFudGlhdGUodGhpcy5vd25lZFByZSk7XHJcbiAgICAgICAgICAgICAgICBvYmoucGFyZW50ID0gdGhpcy5vd25lZFBhcmVudDtcclxuICAgICAgICAgICAgICAgIG9iai5nZXRDb21wb25lbnQoXCJCZWxvbmdJdGVtXCIpLmluaXQoaG91c2VMaXN0W2ldLCBJdGVtVHlwZS5Ib3VzZSk7XHJcbiAgICAgICAgICAgICAgICBpZihob3VzZUxpc3RbaV0ub3duTnVtID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmouYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmouYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBcclxuXHJcbiAgICBKdWRlSGFzQW55OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG1hdGVMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLkhvdXNlKTtcclxuICAgICAgICB2YXIgaGFzQW55ID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZihtYXRlTGlzdFtpXS5vd25OdW0gPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoYXNBbnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc0FueTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE93bmVkSG91c2VQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/RetirePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '393298qS/VMIY4kEK8N31J9', 'RetirePanel');
// Scripts/UI/RetirePanel.js

"use strict";

var AchieveCond = require("AchieveCond");
var RecordStruct = require("RecordStruct");
var AdsParam = require("AdsParam");
var RetirePanel = cc.Class({
  "extends": cc.Component,
  properties: {
    desLbl: cc.RichText,
    crCode: cc.Sprite,
    SkillGetLbl: cc.Label,
    ReGetLbl: cc.Label,
    roundGetSkillPoint: 0,
    skillPointPanel: cc.Node,
    nameLbl: cc.Label,
    zongjieLbl: cc.Label,
    InitMoneyLbl: cc.Label,
    CompanyNode: cc.Node,
    CompanyLbl: cc.Label,
    MarryNode: cc.Node,
    MarryLbl: cc.Label,
    MillionNode: cc.Node,
    MillionLbl: cc.Label,
    TenMillionNode: cc.Node,
    TenMillionLabel: cc.Label,
    HundredMillionNode: cc.Node,
    HundredMillionLbl: cc.Label,
    RetireAgeLbl: cc.Label,
    RetireAssetLbl: cc.Label,
    HighAssetsLbl: cc.Label
  },
  ShowPanel: function ShowPanel() {
    var _this = this;
    var playerName = cc.Mgr.UserDataMgr.playerName;
    var Assets = cc.Mgr.UserDataMgr.AssetsMoney;
    var hasMarry = cc.Mgr.UserDataMgr.JudeHasMarryCond();
    var hasCar = cc.Mgr.UserDataMgr.JudeHasCar();
    var hasHouse = cc.Mgr.UserDataMgr.JudeHasHouse();
    var HasFLL = cc.Mgr.UserDataMgr.JudeHasCarById(2);
    var HasGuBao = cc.Mgr.UserDataMgr.JudeHasHouseById(1); //古堡的id
    var seed = 0; //Math.floor(Math.random()*2);
    var ast = Math.floor(Assets / 10000);
    if (ast < 100 && !hasMarry) {
      seed = 0;
    } else if (ast < 100 && hasMarry) {
      seed = 1;
    } else if (ast > 100 && ast < 1000) {
      seed = 2;
    } else if (ast > 1000 && ast < 10000 && (!hasCar || !hasHouse)) {
      seed = 3;
    } else if (ast > 1000 && ast < 10000 && hasCar && hasHouse) {
      seed = 4;
    } else if (ast > 10000 && (!HasFLL || !HasGuBao)) {
      seed = 5;
    } else if (ast > 10000 && HasFLL && HasGuBao) {
      seed = 6;
    }
    var str = cc.Mgr.global.getTranslation("Retire_" + seed);
    var age = cc.Mgr.UserDataMgr.Age;
    if (cc.Mgr.global.useRetireAds == false) age -= 1;
    var HighAssets = cc.Mgr.UserDataMgr.HighAssets;
    var k = 0;
    this.zongjieLbl.string = "";
    this.schedule(function () {
      k++;
      _this.zongjieLbl.string = str.substring(0, k);
    }, 0.3, str.length + 1, 0.3);
    this.nameLbl.string = playerName;
    this.InitMoneyLbl.string = cc.Mgr.global.getTranslation("CashInit_" + cc.Mgr.global.InitGetMoneyId);
    if (cc.Mgr.UserDataMgr.MarryAge != 0) {
      this.MarryNode.active = true;
      var marryage = cc.Mgr.UserDataMgr.MarryAge;
      var marryrole = cc.Mgr.global.getTranslation("role_" + cc.Mgr.UserDataMgr.MarryRoleId);
      this.MarryLbl.string = marryage + "岁时同: " + marryrole + "结成伴侣";
    } else {
      this.MarryNode.active = false;
    }

    //if(cc.Mgr.UserDataMgr.DivorceAge != 0)
    //{
    //    var marryage = cc.Mgr.UserDataMgr.DivorceAge;
    //}

    if (cc.Mgr.UserDataMgr.FundationAge != 0) {
      this.CompanyNode.active = true;
      var marryage = cc.Mgr.UserDataMgr.FundationAge;
      var companyName = cc.Mgr.global.getTranslation("company_" + cc.Mgr.UserDataMgr.FundationCompanyId);
      this.CompanyLbl.string = marryage + "岁时创办: " + companyName;
    } else {
      this.CompanyNode.active = false;
    }

    //if(cc.Mgr.UserDataMgr.BankruptAge != 0)
    //{
    //    var marryage = cc.Mgr.UserDataMgr.BankruptAge;
    //}

    if (cc.Mgr.UserDataMgr.MillionAge != 0) {
      this.MillionNode.active = true;
      var marryage = cc.Mgr.UserDataMgr.MillionAge;
      this.MillionLbl.string = marryage + "岁时资产突破百万";
    } else {
      this.MillionNode.active = false;
    }
    if (cc.Mgr.UserDataMgr.TenMillionAge != 0) {
      this.TenMillionNode.active = true;
      var marryage = cc.Mgr.UserDataMgr.TenMillionAge;
      this.TenMillionLabel.string = marryage + "岁时资产突破千万";
    } else {
      this.TenMillionNode.active = false;
    }
    if (cc.Mgr.UserDataMgr.HundredMillionAge != 0) {
      this.HundredMillionNode.active = true;
      var marryage = cc.Mgr.UserDataMgr.HundredMillionAge;
      this.HundredMillionLbl.string = marryage + "岁时进入亿万富豪榜";
    } else {
      this.HundredMillionNode.active = false;
    }
    this.RetireAgeLbl.string = age + "退休时资产:";
    this.RetireAssetLbl.string = cc.Mgr.global.FormatNum(Assets);
    this.HighAssetsLbl.string = cc.Mgr.global.FormatNum(HighAssets);
    this.desLbl.string = "";
    cc.Mgr.UserDataMgr.playTimes += 1; //玩家的游戏次数增加

    cc.Mgr.UserDataMgr.CreateRecord();
    this.CaculateSkillPoint();
    this.CaculateAchieveState();
  },
  showRewardVideo: function showRewardVideo() {
    this.js2android('show_reward_video', '1');
  },
  ///激励视频播放完成回调方法 continue_game
  /// Native.android2js("continue_game", ()=>{
  ///     //激励视频播放完成，原生端回调
  /// });
  js2android: function js2android(name, data) {
    console.log("name:" + name + "-data:" + data);
    if (window.injectedObject && window.injectedObject.setJsContent) {
      window.injectedObject.setJsContent(name, data);
    }
  },
  ClickConfirm: function ClickConfirm() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.HistoryHighAssets < cc.Mgr.UserDataMgr.AssetsMoney) {
      cc.Mgr.UserDataMgr.RefreshHistoryHighAsset(cc.Mgr.UserDataMgr.AssetsMoney);
      cc.Mgr.PlatformController.setUserCloudStorage(cc.Mgr.UserDataMgr.AssetsMoney);
    }
    cc.Mgr.UserDataMgr.SaveUserData();
    cc.director.loadScene("start_scene");
  },
  ClickShare: function ClickShare() {
    cc.Mgr.PlatformController.ShareToFriend(1);
  },
  //结算技能点
  CaculateSkillPoint: function CaculateSkillPoint() {
    var asset = Math.floor(cc.Mgr.UserDataMgr.AssetsMoney / 10000);
    var skillPoint = 0;
    if (asset <= 100) {
      skillPoint = 0;
    } else if (asset > 100 && asset <= 999) {
      skillPoint = Math.floor(asset / 100) * 10;
    } else if (asset >= 1000 && asset <= 9999) {
      skillPoint = 90 + Math.floor(asset / 500) * 10;
    } else if (asset >= 10000 && asset <= 99999) {
      skillPoint = 300 + Math.floor(asset / 5000) * 10;
    } else if (asset >= 100000) {
      skillPoint = 500;
    }
    this.ReGetLbl.node.active = false;
    var reputationSkillPoint = 0;
    if (asset >= 100) {
      reputationSkillPoint = Math.floor(cc.Mgr.UserDataMgr.Reputation / 2);
      if (reputationSkillPoint > 50) {
        this.ReGetLbl.node.active = true;
        reputationSkillPoint = 500;
      }
    }
    this.roundGetSkillPoint += skillPoint + Math.floor(skillPoint * (cc.Mgr.UserDataMgr.SkillPointGetBonus / 100)) + reputationSkillPoint;
    cc.Mgr.UserDataMgr.SkillBonusPoint += this.roundGetSkillPoint;
    this.SkillGetLbl.string = this.roundGetSkillPoint;
    //cc.log("本局获得的技能点 = " + this.roundGetSkillPoint);
    this.skillPointPanel.active = true;
    if (this.roundGetSkillPoint == 0) this.skillPointPanel.active = false;
    //cc.Mgr.UserDataMgr.SkillBonusPoint = skillPoint + Math.floor(skillPoint * (cc.Mgr.UserDataMgr.SkillPointGetBonus / 100));
  },

  DoubleSkillPoint: function DoubleSkillPoint() {
    var self = this;
    self.showRewardVideo();
    cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointE, function (out) {
      if (out == 0) {
        cc.Mgr.UserDataMgr.SkillBonusPoint += self.roundGetSkillPoint;
        self.CloseDoublePanel();
      }
    });

    //var index = Math.floor(Math.random()*6);
    //cc.Mgr.PlatformController.ShareToFriend(index);
  },

  CloseDoublePanel: function CloseDoublePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.skillPointPanel.active = false;
  },
  //结算是否完成了 成就
  CaculateAchieveState: function CaculateAchieveState() {
    var AchievementList = cc.Mgr.UserDataMgr.AchievementList;
    for (var i = 0; i < AchievementList.length; i++) {
      var dt = AchievementList[i];
      if (!dt.hasFinish) {
        cc.Mgr.UserDataMgr.JudeFinishAnyAchievement(dt.Id);
      }
    }
  }
});
module.exports = RetirePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFJldGlyZVBhbmVsLmpzIl0sIm5hbWVzIjpbIkFjaGlldmVDb25kIiwicmVxdWlyZSIsIlJlY29yZFN0cnVjdCIsIkFkc1BhcmFtIiwiUmV0aXJlUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsImRlc0xibCIsIlJpY2hUZXh0IiwiY3JDb2RlIiwiU3ByaXRlIiwiU2tpbGxHZXRMYmwiLCJMYWJlbCIsIlJlR2V0TGJsIiwicm91bmRHZXRTa2lsbFBvaW50Iiwic2tpbGxQb2ludFBhbmVsIiwiTm9kZSIsIm5hbWVMYmwiLCJ6b25namllTGJsIiwiSW5pdE1vbmV5TGJsIiwiQ29tcGFueU5vZGUiLCJDb21wYW55TGJsIiwiTWFycnlOb2RlIiwiTWFycnlMYmwiLCJNaWxsaW9uTm9kZSIsIk1pbGxpb25MYmwiLCJUZW5NaWxsaW9uTm9kZSIsIlRlbk1pbGxpb25MYWJlbCIsIkh1bmRyZWRNaWxsaW9uTm9kZSIsIkh1bmRyZWRNaWxsaW9uTGJsIiwiUmV0aXJlQWdlTGJsIiwiUmV0aXJlQXNzZXRMYmwiLCJIaWdoQXNzZXRzTGJsIiwiU2hvd1BhbmVsIiwiX3RoaXMiLCJwbGF5ZXJOYW1lIiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJBc3NldHMiLCJBc3NldHNNb25leSIsImhhc01hcnJ5IiwiSnVkZUhhc01hcnJ5Q29uZCIsImhhc0NhciIsIkp1ZGVIYXNDYXIiLCJoYXNIb3VzZSIsIkp1ZGVIYXNIb3VzZSIsIkhhc0ZMTCIsIkp1ZGVIYXNDYXJCeUlkIiwiSGFzR3VCYW8iLCJKdWRlSGFzSG91c2VCeUlkIiwic2VlZCIsImFzdCIsIk1hdGgiLCJmbG9vciIsInN0ciIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwiYWdlIiwiQWdlIiwidXNlUmV0aXJlQWRzIiwiSGlnaEFzc2V0cyIsImsiLCJzdHJpbmciLCJzY2hlZHVsZSIsInN1YnN0cmluZyIsImxlbmd0aCIsIkluaXRHZXRNb25leUlkIiwiTWFycnlBZ2UiLCJhY3RpdmUiLCJtYXJyeWFnZSIsIm1hcnJ5cm9sZSIsIk1hcnJ5Um9sZUlkIiwiRnVuZGF0aW9uQWdlIiwiY29tcGFueU5hbWUiLCJGdW5kYXRpb25Db21wYW55SWQiLCJNaWxsaW9uQWdlIiwiVGVuTWlsbGlvbkFnZSIsIkh1bmRyZWRNaWxsaW9uQWdlIiwiRm9ybWF0TnVtIiwicGxheVRpbWVzIiwiQ3JlYXRlUmVjb3JkIiwiQ2FjdWxhdGVTa2lsbFBvaW50IiwiQ2FjdWxhdGVBY2hpZXZlU3RhdGUiLCJzaG93UmV3YXJkVmlkZW8iLCJqczJhbmRyb2lkIiwibmFtZSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwid2luZG93IiwiaW5qZWN0ZWRPYmplY3QiLCJzZXRKc0NvbnRlbnQiLCJDbGlja0NvbmZpcm0iLCJBdWRpb01nciIsInBsYXlTRlgiLCJIaXN0b3J5SGlnaEFzc2V0cyIsIlJlZnJlc2hIaXN0b3J5SGlnaEFzc2V0IiwiUGxhdGZvcm1Db250cm9sbGVyIiwic2V0VXNlckNsb3VkU3RvcmFnZSIsIlNhdmVVc2VyRGF0YSIsImRpcmVjdG9yIiwibG9hZFNjZW5lIiwiQ2xpY2tTaGFyZSIsIlNoYXJlVG9GcmllbmQiLCJhc3NldCIsInNraWxsUG9pbnQiLCJub2RlIiwicmVwdXRhdGlvblNraWxsUG9pbnQiLCJSZXB1dGF0aW9uIiwiU2tpbGxQb2ludEdldEJvbnVzIiwiU2tpbGxCb251c1BvaW50IiwiRG91YmxlU2tpbGxQb2ludCIsInNlbGYiLCJBZHNNZ3IiLCJTaG93VmlkZW9BZHMiLCJQb2ludEUiLCJvdXQiLCJDbG9zZURvdWJsZVBhbmVsIiwiQWNoaWV2ZW1lbnRMaXN0IiwiaSIsImR0IiwiaGFzRmluaXNoIiwiSnVkZUZpbmlzaEFueUFjaGlldmVtZW50IiwiSWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFdBQVcsR0FBR0MsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUN4QyxJQUFJQyxZQUFZ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Q0FBQzs7SUFFRjtJQUNBO0VBQ0osQ0FBQzs7RUFFREEsZ0JBQWdCLEVBQUMsU0FBQUEsaUJBQUEsRUFBVTtJQUN2QmxILEVBQUUsQ0FBQ2lDLEdBQUcsQ0FBQ3lELFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxJQUFJLENBQUMvRSxlQUFlLENBQUNxRCxNQUFNLEdBQUcsS0FBSztFQUN2QyxDQUFDO0VBRUQ7RUFDQWMsb0JBQW9CLEVBQUMsU0FBQUEscUJBQUEsRUFDckI7SUFDSSxJQUFJb0MsZUFBZSxHQUFHbkgsRUFBRSxDQUFDaUMsR0FBRyxDQUFDQyxXQUFXLENBQUNpRixlQUFlO0lBQ3hELEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRCxlQUFlLENBQUNyRCxNQUFNLEVBQUVzRCxDQUFDLEVBQUUsRUFBRTtNQUM3QyxJQUFJQyxFQUFFLEdBQUdGLGVBQWUsQ0FBQ0MsQ0FBQyxDQUFDO01BQzNCLElBQUcsQ0FBQ0MsRUFBRSxDQUFDQyxTQUFTLEVBQ2hCO1FBQ0l0SCxFQUFFLENBQUNpQyxHQUFHLENBQUNDLFdBQVcsQ0FBQ3FGLHdCQUF3QixDQUFDRixFQUFFLENBQUNHLEVBQUUsQ0FBQztNQUN0RDtJQUNKO0VBQ0o7QUFHSixDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUczSCxXQUFXIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQWNoaWV2ZUNvbmQgPSByZXF1aXJlKFwiQWNoaWV2ZUNvbmRcIik7XHJcbnZhciBSZWNvcmRTdHJ1Y3QgPSByZXF1aXJlKFwiUmVjb3JkU3RydWN0XCIpO1xyXG52YXIgQWRzUGFyYW0gPSByZXF1aXJlKFwiQWRzUGFyYW1cIik7XHJcbnZhciBSZXRpcmVQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgZGVzTGJsOmNjLlJpY2hUZXh0LFxyXG4gICAgICAgIGNyQ29kZTpjYy5TcHJpdGUsXHJcbiAgICAgICAgU2tpbGxHZXRMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgUmVHZXRMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgcm91bmRHZXRTa2lsbFBvaW50OjAsXHJcbiAgICAgICAgc2tpbGxQb2ludFBhbmVsOmNjLk5vZGUsXHJcblxyXG4gICAgICAgIG5hbWVMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgem9uZ2ppZUxibDpjYy5MYWJlbCxcclxuXHJcbiAgICAgICAgSW5pdE1vbmV5TGJsOmNjLkxhYmVsLFxyXG5cclxuICAgICAgICBDb21wYW55Tm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIENvbXBhbnlMYmw6Y2MuTGFiZWwsXHJcblxyXG4gICAgICAgIE1hcnJ5Tm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIE1hcnJ5TGJsOmNjLkxhYmVsLFxyXG5cclxuICAgICAgICBNaWxsaW9uTm9kZTpjYy5Ob2RlLFxyXG4gICAgICAgIE1pbGxpb25MYmw6Y2MuTGFiZWwsXHJcblxyXG4gICAgICAgIFRlbk1pbGxpb25Ob2RlOmNjLk5vZGUsXHJcbiAgICAgICAgVGVuTWlsbGlvbkxhYmVsOmNjLkxhYmVsLFxyXG5cclxuICAgICAgICBIdW5kcmVkTWlsbGlvbk5vZGU6Y2MuTm9kZSxcclxuICAgICAgICBIdW5kcmVkTWlsbGlvbkxibDpjYy5MYWJlbCxcclxuXHJcbiAgICAgICAgUmV0aXJlQWdlTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIFJldGlyZUFzc2V0TGJsOmNjLkxhYmVsLFxyXG5cclxuICAgICAgICBIaWdoQXNzZXRzTGJsOmNjLkxhYmVsLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwbGF5ZXJOYW1lID0gY2MuTWdyLlVzZXJEYXRhTWdyLnBsYXllck5hbWU7XHJcbiAgICAgICAgdmFyIEFzc2V0cyA9IGNjLk1nci5Vc2VyRGF0YU1nci5Bc3NldHNNb25leTtcclxuICAgICAgICB2YXIgaGFzTWFycnkgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSnVkZUhhc01hcnJ5Q29uZCgpO1xyXG4gICAgICAgIHZhciBoYXNDYXIgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSnVkZUhhc0NhcigpO1xyXG4gICAgICAgIHZhciBoYXNIb3VzZSA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlSGFzSG91c2UoKTtcclxuICAgICAgICB2YXIgSGFzRkxMID0gY2MuTWdyLlVzZXJEYXRhTWdyLkp1ZGVIYXNDYXJCeUlkKDIpO1xyXG4gICAgICAgIHZhciBIYXNHdUJhbyA9IGNjLk1nci5Vc2VyRGF0YU1nci5KdWRlSGFzSG91c2VCeUlkKDEpOy8v5Y+k5aCh55qEaWRcclxuICAgICAgICB2YXIgc2VlZCA9IDA7Ly9NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMik7XHJcbiAgICAgICAgdmFyIGFzdCA9IE1hdGguZmxvb3IoQXNzZXRzIC8gMTAwMDApO1xyXG4gICAgICAgIGlmKGFzdCA8IDEwMCAmJiAhaGFzTWFycnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZWVkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhc3QgPCAxMDAgJiYgaGFzTWFycnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZWVkID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhc3QgPiAxMDAgJiYgYXN0IDwgMTAwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNlZWQgPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGFzdCA+IDEwMDAgJiYgYXN0IDwgMTAwMDAgJiYgKCFoYXNDYXIgfHwgIWhhc0hvdXNlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNlZWQgPSAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGFzdCA+IDEwMDAgJiYgYXN0IDwgMTAwMDAgJiYgaGFzQ2FyICYmIGhhc0hvdXNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2VlZCA9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoYXN0ID4gMTAwMDAgJiYgKCFIYXNGTEwgfHwgIUhhc0d1QmFvKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNlZWQgPSA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGFzdCA+IDEwMDAwICYmIEhhc0ZMTCAmJiBIYXNHdUJhbylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNlZWQgPSA2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN0ciA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJSZXRpcmVfXCIgKyBzZWVkKTtcclxuICAgICAgICB2YXIgYWdlID0gY2MuTWdyLlVzZXJEYXRhTWdyLkFnZTtcclxuICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLnVzZVJldGlyZUFkcyA9PSBmYWxzZSlcclxuICAgICAgICAgICAgYWdlIC09IDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIEhpZ2hBc3NldHMgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSGlnaEFzc2V0cztcclxuXHJcbiAgICAgICAgdmFyIGs9MDtcclxuICAgICAgICB0aGlzLnpvbmdqaWVMYmwuc3RyaW5nID0gXCJcIjtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlKCgpPT57XHJcbiAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgdGhpcy56b25namllTGJsLnN0cmluZyA9IHN0ci5zdWJzdHJpbmcoMCxrKTtcclxuICAgICAgICB9LCAwLjMsIHN0ci5sZW5ndGggKyAxLCAwLjMpOyBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5hbWVMYmwuc3RyaW5nID0gcGxheWVyTmFtZTtcclxuXHJcbiAgICAgICAgdGhpcy5Jbml0TW9uZXlMYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcIkNhc2hJbml0X1wiK2NjLk1nci5nbG9iYWwuSW5pdEdldE1vbmV5SWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5NYXJyeUFnZSAhPSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5NYXJyeU5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIG1hcnJ5YWdlID0gY2MuTWdyLlVzZXJEYXRhTWdyLk1hcnJ5QWdlO1xyXG4gICAgICAgICAgICB2YXIgbWFycnlyb2xlID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihcInJvbGVfXCIrY2MuTWdyLlVzZXJEYXRhTWdyLk1hcnJ5Um9sZUlkKTtcclxuICAgICAgICAgICAgdGhpcy5NYXJyeUxibC5zdHJpbmcgPSBtYXJyeWFnZStcIuWygeaXtuWQjDogXCIrIG1hcnJ5cm9sZStcIue7k+aIkOS8tOS+o1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLk1hcnJ5Tm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkRpdm9yY2VBZ2UgIT0gMClcclxuICAgICAgICAvL3tcclxuICAgICAgICAvLyAgICB2YXIgbWFycnlhZ2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuRGl2b3JjZUFnZTtcclxuICAgICAgICAvL31cclxuXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkZ1bmRhdGlvbkFnZSAhPSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5Db21wYW55Tm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgbWFycnlhZ2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuRnVuZGF0aW9uQWdlO1xyXG4gICAgICAgICAgICB2YXIgY29tcGFueU5hbWUgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiY29tcGFueV9cIiArIGNjLk1nci5Vc2VyRGF0YU1nci5GdW5kYXRpb25Db21wYW55SWQpO1xyXG4gICAgICAgICAgICB0aGlzLkNvbXBhbnlMYmwuc3RyaW5nID0gbWFycnlhZ2UrXCLlsoHml7bliJvlip46IFwiK2NvbXBhbnlOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkNvbXBhbnlOb2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZihjYy5NZ3IuVXNlckRhdGFNZ3IuQmFua3J1cHRBZ2UgIT0gMClcclxuICAgICAgICAvL3tcclxuICAgICAgICAvLyAgICB2YXIgbWFycnlhZ2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQmFua3J1cHRBZ2U7XHJcbiAgICAgICAgLy99XHJcblxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5NaWxsaW9uQWdlICE9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLk1pbGxpb25Ob2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBtYXJyeWFnZSA9IGNjLk1nci5Vc2VyRGF0YU1nci5NaWxsaW9uQWdlO1xyXG4gICAgICAgICAgICB0aGlzLk1pbGxpb25MYmwuc3RyaW5nID0gbWFycnlhZ2UrXCLlsoHml7botYTkuqfnqoHnoLTnmb7kuIdcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5NaWxsaW9uTm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5UZW5NaWxsaW9uQWdlICE9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLlRlbk1pbGxpb25Ob2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBtYXJyeWFnZSA9IGNjLk1nci5Vc2VyRGF0YU1nci5UZW5NaWxsaW9uQWdlO1xyXG4gICAgICAgICAgICB0aGlzLlRlbk1pbGxpb25MYWJlbC5zdHJpbmcgPSBtYXJyeWFnZStcIuWygeaXtui1hOS6p+eqgeegtOWNg+S4h1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLlRlbk1pbGxpb25Ob2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLkh1bmRyZWRNaWxsaW9uQWdlICE9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkh1bmRyZWRNaWxsaW9uTm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgbWFycnlhZ2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuSHVuZHJlZE1pbGxpb25BZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuSHVuZHJlZE1pbGxpb25MYmwuc3RyaW5nID0gbWFycnlhZ2UrXCLlsoHml7bov5vlhaXkur/kuIflr4zosarmppxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5IdW5kcmVkTWlsbGlvbk5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLlJldGlyZUFnZUxibC5zdHJpbmcgPSBhZ2UgKyBcIumAgOS8keaXtui1hOS6pzpcIjtcclxuICAgICAgICB0aGlzLlJldGlyZUFzc2V0TGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKEFzc2V0cyk7XHJcbiAgICAgICAgdGhpcy5IaWdoQXNzZXRzTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKEhpZ2hBc3NldHMpO1xyXG5cclxuICAgICAgICB0aGlzLmRlc0xibC5zdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5wbGF5VGltZXMgKz0gMTsgLy/njqnlrrbnmoTmuLjmiI/mrKHmlbDlop7liqBcclxuICAgICAgICBcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ3JlYXRlUmVjb3JkKCk7XHJcbiAgICAgICAgdGhpcy5DYWN1bGF0ZVNraWxsUG9pbnQoKTtcclxuICAgICAgICB0aGlzLkNhY3VsYXRlQWNoaWV2ZVN0YXRlKCk7XHJcbiAgICB9LFxyXG4gICAgc2hvd1Jld2FyZFZpZGVvKCkge1xyXG4gICAgICAgIHRoaXMuanMyYW5kcm9pZCgnc2hvd19yZXdhcmRfdmlkZW8nLCAnMScpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vL+a/gOWKseinhumikeaSreaUvuWujOaIkOWbnuiwg+aWueazlSBjb250aW51ZV9nYW1lXHJcbiAgICAvLy8gTmF0aXZlLmFuZHJvaWQyanMoXCJjb250aW51ZV9nYW1lXCIsICgpPT57XHJcbiAgICAvLy8gICAgIC8v5r+A5Yqx6KeG6aKR5pKt5pS+5a6M5oiQ77yM5Y6f55Sf56uv5Zue6LCDXHJcbiAgICAvLy8gfSk7XHJcbiAgICBqczJhbmRyb2lkKG5hbWUsIGRhdGEpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBuYW1lOiR7bmFtZX0tZGF0YToke2RhdGF9YCk7XHJcbiAgICAgICAgaWYod2luZG93LmluamVjdGVkT2JqZWN0ICYmIHdpbmRvdy5pbmplY3RlZE9iamVjdC5zZXRKc0NvbnRlbnQpe1xyXG4gICAgICAgICAgICB3aW5kb3cuaW5qZWN0ZWRPYmplY3Quc2V0SnNDb250ZW50KG5hbWUsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tDb25maXJtOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuSGlzdG9yeUhpZ2hBc3NldHMgPCBjYy5NZ3IuVXNlckRhdGFNZ3IuQXNzZXRzTW9uZXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuUmVmcmVzaEhpc3RvcnlIaWdoQXNzZXQoY2MuTWdyLlVzZXJEYXRhTWdyLkFzc2V0c01vbmV5KTtcclxuICAgICAgICAgICAgY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5zZXRVc2VyQ2xvdWRTdG9yYWdlKGNjLk1nci5Vc2VyRGF0YU1nci5Bc3NldHNNb25leSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5TYXZlVXNlckRhdGEoKTtcclxuICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJzdGFydF9zY2VuZVwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xpY2tTaGFyZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5QbGF0Zm9ybUNvbnRyb2xsZXIuU2hhcmVUb0ZyaWVuZCgxKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/nu5PnrpfmioDog73ngrlcclxuICAgIENhY3VsYXRlU2tpbGxQb2ludDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBhc3NldCA9IE1hdGguZmxvb3IoY2MuTWdyLlVzZXJEYXRhTWdyLkFzc2V0c01vbmV5IC8gMTAwMDApO1xyXG4gICAgICAgIHZhciBza2lsbFBvaW50ID0gMDtcclxuICAgICAgICBpZihhc3NldCA8PSAxMDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBza2lsbFBvaW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhc3NldCA+IDEwMCAmJiBhc3NldCA8PSA5OTkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBza2lsbFBvaW50ID0gTWF0aC5mbG9vcihhc3NldC8xMDApKjEwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGFzc2V0ID49IDEwMDAgJiYgYXNzZXQgPD0gOTk5OSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNraWxsUG9pbnQgPSA5MCArIE1hdGguZmxvb3IoYXNzZXQvNTAwKSoxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhc3NldCA+PSAxMDAwMCAmJiBhc3NldCA8PSA5OTk5OSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNraWxsUG9pbnQgPSAzMDAgKyBNYXRoLmZsb29yKGFzc2V0LzUwMDApKjEwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGFzc2V0ID49IDEwMDAwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNraWxsUG9pbnQgPSA1MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuUmVHZXRMYmwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcmVwdXRhdGlvblNraWxsUG9pbnQgPSAwO1xyXG4gICAgICAgIGlmKGFzc2V0ID49IDEwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlcHV0YXRpb25Ta2lsbFBvaW50ID0gTWF0aC5mbG9vcihjYy5NZ3IuVXNlckRhdGFNZ3IuUmVwdXRhdGlvbiAvIDIpO1xyXG4gICAgICAgICAgICBpZiAocmVwdXRhdGlvblNraWxsUG9pbnQgPiA1MClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5SZUdldExibC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXB1dGF0aW9uU2tpbGxQb2ludCA9IDUwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yb3VuZEdldFNraWxsUG9pbnQgKz0gc2tpbGxQb2ludCArIE1hdGguZmxvb3Ioc2tpbGxQb2ludCAqIChjYy5NZ3IuVXNlckRhdGFNZ3IuU2tpbGxQb2ludEdldEJvbnVzIC8gMTAwKSkgKyByZXB1dGF0aW9uU2tpbGxQb2ludDtcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuU2tpbGxCb251c1BvaW50ICs9IHRoaXMucm91bmRHZXRTa2lsbFBvaW50O1xyXG4gICAgICAgIHRoaXMuU2tpbGxHZXRMYmwuc3RyaW5nID0gdGhpcy5yb3VuZEdldFNraWxsUG9pbnQ7XHJcbiAgICAgICAgLy9jYy5sb2coXCLmnKzlsYDojrflvpfnmoTmioDog73ngrkgPSBcIiArIHRoaXMucm91bmRHZXRTa2lsbFBvaW50KTtcclxuICAgICAgICB0aGlzLnNraWxsUG9pbnRQYW5lbC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGlmKHRoaXMucm91bmRHZXRTa2lsbFBvaW50ID09IDApXHJcbiAgICAgICAgICAgIHRoaXMuc2tpbGxQb2ludFBhbmVsLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vY2MuTWdyLlVzZXJEYXRhTWdyLlNraWxsQm9udXNQb2ludCA9IHNraWxsUG9pbnQgKyBNYXRoLmZsb29yKHNraWxsUG9pbnQgKiAoY2MuTWdyLlVzZXJEYXRhTWdyLlNraWxsUG9pbnRHZXRCb251cyAvIDEwMCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBEb3VibGVTa2lsbFBvaW50OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYuc2hvd1Jld2FyZFZpZGVvKCk7XHJcbiAgICAgICAgY2MuTWdyLkFkc01nci5TaG93VmlkZW9BZHMoQWRzUGFyYW0uUG9pbnRFLCBmdW5jdGlvbihvdXQpe1xyXG4gICAgICAgICAgICBpZihvdXQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlNraWxsQm9udXNQb2ludCArPSBzZWxmLnJvdW5kR2V0U2tpbGxQb2ludDtcclxuICAgICAgICAgICAgICAgIHNlbGYuQ2xvc2VEb3VibGVQYW5lbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7IFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vdmFyIGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjYpO1xyXG4gICAgICAgIC8vY2MuTWdyLlBsYXRmb3JtQ29udHJvbGxlci5TaGFyZVRvRnJpZW5kKGluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VEb3VibGVQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5za2lsbFBvaW50UGFuZWwuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8v57uT566X5piv5ZCm5a6M5oiQ5LqGIOaIkOWwsVxyXG4gICAgQ2FjdWxhdGVBY2hpZXZlU3RhdGU6ZnVuY3Rpb24oKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBBY2hpZXZlbWVudExpc3QgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuQWNoaWV2ZW1lbnRMaXN0O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQWNoaWV2ZW1lbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IEFjaGlldmVtZW50TGlzdFtpXTtcclxuICAgICAgICAgICAgaWYoIWR0Lmhhc0ZpbmlzaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkp1ZGVGaW5pc2hBbnlBY2hpZXZlbWVudChkdC5JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBSZXRpcmVQYW5lbDsiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/OwnedMatePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '6bbf4fFQi5LuIwabuh8dbw2', 'OwnedMatePanel');
// Scripts/UI/OwnedMatePanel.js

"use strict";

var ItemType = require("ItemType");
var OwnedMatePanel = cc.Class({
  "extends": cc.Component,
  properties: {
    ownedPre: cc.Prefab,
    ownedParent: cc.Node,
    tipLbl: cc.Label
  },
  ShowPanel: function ShowPanel() {
    this.tipLbl.string = "";
    if (this.JudeHasAny() == false) {
      this.tipLbl.string = "您还未与任何一位喜结良缘,去约会圣地约起来吧";
      //return;
    }

    var mateList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Mate);
    if (this.ownedParent.children.length != 0) {
      //cc.log("不用再实例化，已经有了");
      var children = this.ownedParent.children;
      for (var i = children.length - 1; i >= 0; i--) {
        var sc = children[i].getComponent("BelongMateItem");
        if (sc != null) {
          for (var j = 0; j < mateList.length; j++) {
            if (mateList[j].Id == sc.Data.Id) {
              //cc.log("+++++++++++++++++++++" + mateList[j].UpLv);
              if (mateList[j].UpLv == true) children[i].active = true;else children[i].active = false;
            }
          }
        }
      }
    } else {
      for (var i = mateList.length - 1; i >= 0; i--) {
        //cc.log("实例化伴侣");
        var obj = cc.instantiate(this.ownedPre);
        obj.parent = this.ownedParent;
        obj.getComponent("BelongMateItem").init(mateList[i], ItemType.Mate);
        if (mateList[i].UpLv == true) {
          obj.active = true;
        } else {
          obj.active = false;
        }
      }
    }
  },
  JudeHasAny: function JudeHasAny() {
    var mateList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Mate);
    var hasAny = false;
    for (var i = 0; i < mateList.length; i++) {
      if (mateList[i].UpLv == true) {
        hasAny = true;
        return true;
      }
    }
    return hasAny;
  }
});
module.exports = OwnedMatePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE93bmVkTWF0ZVBhbmVsLmpzIl0sIm5hbWVzIjpbIkl0ZW1UeXBlIiwicmVxdWlyZSIsIk93bmVkTWF0ZVBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJvd25lZFByZSIsIlByZWZhYiIsIm93bmVkUGFyZW50IiwiTm9kZSIsInRpcExibCIsIkxhYmVsIiwiU2hvd1BhbmVsIiwic3RyaW5nIiwiSnVkZUhhc0FueSIsIm1hdGVMaXN0IiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJnZXRPd25EYXRhTGlzdEJ5VHlwZSIsIk1hdGUiLCJjaGlsZHJlbiIsImxlbmd0aCIsImkiLCJzYyIsImdldENvbXBvbmVudCIsImoiLCJJZCIsIkRhdGEiLCJVcEx2IiwiYWN0aXZlIiwib2JqIiwiaW5zdGFudGlhdGUiLCJwYXJlbnQiLCJpbml0IiwiaGFzQW55IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsY0FBYyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUMxQixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxRQUFRLEVBQUNKLEVBQUUsQ0FBQ0ssTUFBTTtJQUNsQkMsV0FBVyxFQUFDTixFQUFFLENBQUNPLElBQUk7SUFDbkJDLE1BQU0sRUFBQ1IsRUFBRSxDQUFDUztFQUNkLENBQUM7RUFFREMsU0FBUyxFQUFDLFNBQUFBLFVBQUEsRUFBWTtJQUNsQixJQUFJLENBQUNGLE1BQU0sQ0FBQ0csTUFBTSxHQUFHLEVBQUU7SUFDdkIsSUFBRyxJQUFJLENBQUNDLFVBQVUsRUFBRSxJQUFJLEtBQUssRUFDN0I7TUFDSSxJQUFJLENBQUNKLE1BQU0sQ0FBQ0csTUFBTSxHQUFHLHdCQUF3QjtNQUM3QztJQUNKOztJQUVBLElBQUlFLFFBQVEsR0FBR2IsRUFBRSxDQUFDYyxHQUFHLENBQUNDLFdBQVcsQ0FBQ0Msb0JBQW9CLENBQUNuQixRQUFRLENBQUNvQixJQUFJLENBQUM7SUFDckUsSUFBRyxJQUFJLENBQUNYLFdBQVcsQ0FBQ1ksUUFBUSxDQUFDQyxNQUFNLElBQUksQ0FBQyxFQUN4QztNQUNJO01BQ0EsSUFBSUQsUUFBUSxHQUFHLElBQUksQ0FBQ1osV0FBVyxDQUFDWSxRQUFRO01BQ3hDLEtBQUssSUFBSUUsQ0FBQyxHQUFHRixRQUFRLENBQUNDLE1BQU0sR0FBRyxDQUFDLEVBQUVDLENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO1FBQzNDLElBQUlDLEVBQUUsR0FBR0gsUUFBUSxDQUFDRSxDQUFDLENBQUMsQ0FBQ0UsWUFBWSxDQUFDLGdCQUFnQixDQUFDO1FBQ25ELElBQUdELEVBQUUsSUFBSSxJQUFJLEVBQ2I7VUFDSSxLQUFLLElBQUlFLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR1YsUUFBUSxDQUFDTSxNQUFNLEVBQUVJLENBQUMsRUFBRSxFQUFFO1lBQ3RDLElBQUdWLFFBQVEsQ0FBQ1UsQ0FBQyxDQUFDLENBQUNDLEVBQUUsSUFBSUgsRUFBRSxDQUFDSSxJQUFJLENBQUNELEVBQUUsRUFDL0I7Y0FDSTtjQUNBLElBQUdYLFFBQVEsQ0FBQ1UsQ0FBQyxDQUFDLENBQUNHLElBQUksSUFBSSxJQUFJLEVBQ3ZCUixRQUFRLENBQUNFLENBQUMsQ0FBQyxDQUFDTyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBRTFCVCxRQUFRLENBQUNFLENBQUMsQ0FBQyxDQUFDTyxNQUFNLEdBQUcsS0FBSztZQUNsQztVQUNKO1FBQ0o7TUFDSjtJQUNKLENBQUMsTUFFRDtNQUNJLEtBQUssSUFBSVAsQ0FBQyxHQUFHUCxRQUFRLENBQUNNLE1BQU0sR0FBRyxDQUFDLEVBQUVDLENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO1FBQzNDO1FBQ0EsSUFBSVEsR0FBRyxHQUFHNUIsRUFBRSxDQUFDNkIsV0FBVyxDQUFDLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQztRQUN2Q3dCLEdBQUcsQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ3hCLFdBQVc7UUFDN0JzQixHQUFHLENBQUNOLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDUyxJQUFJLENBQUNsQixRQUFRLENBQUNPLENBQUMsQ0FBQyxFQUFFdkIsUUFBUSxDQUFDb0IsSUFBSSxDQUFDO1FBQ25FLElBQUdKLFFBQVEsQ0FBQ08sQ0FBQyxDQUFDLENBQUNNLElBQUksSUFBSSxJQUFJLEVBQzNCO1VBQ0lFLEdBQUcsQ0FBQ0QsTUFBTSxHQUFHLElBQUk7UUFDckIsQ0FBQyxNQUVEO1VBQ0lDLEdBQUcsQ0FBQ0QsTUFBTSxHQUFHLEtBQUs7UUFDdEI7TUFDSjtJQUNKO0VBQ0osQ0FBQztFQUVEZixVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCLElBQUlDLFFBQVEsR0FBR2IsRUFBRSxDQUFDYyxHQUFHLENBQUNDLFdBQVcsQ0FBQ0Msb0JBQW9CLENBQUNuQixRQUFRLENBQUNvQixJQUFJLENBQUM7SUFDckUsSUFBSWUsTUFBTSxHQUFHLEtBQUs7SUFDbEIsS0FBSyxJQUFJWixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdQLFFBQVEsQ0FBQ00sTUFBTSxFQUFFQyxDQUFDLEVBQUUsRUFBRTtNQUN0QyxJQUFHUCxRQUFRLENBQUNPLENBQUMsQ0FBQyxDQUFDTSxJQUFJLElBQUksSUFBSSxFQUMzQjtRQUNJTSxNQUFNLEdBQUcsSUFBSTtRQUNiLE9BQU8sSUFBSTtNQUNmO0lBQ0o7SUFDQSxPQUFPQSxNQUFNO0VBQ2pCO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHbkMsY0FBYyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEl0ZW1UeXBlID0gcmVxdWlyZShcIkl0ZW1UeXBlXCIpO1xyXG52YXIgT3duZWRNYXRlUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIG93bmVkUHJlOmNjLlByZWZhYixcclxuICAgICAgICBvd25lZFBhcmVudDpjYy5Ob2RlLFxyXG4gICAgICAgIHRpcExibDpjYy5MYWJlbCxcclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRpcExibC5zdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgIGlmKHRoaXMuSnVkZUhhc0FueSgpID09IGZhbHNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50aXBMYmwuc3RyaW5nID0gXCLmgqjov5jmnKrkuI7ku7vkvZXkuIDkvY3llpznu5Poia/nvJgs5Y6757qm5Lya5Zyj5Zyw57qm6LW35p2l5ZCnXCI7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1hdGVMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLk1hdGUpO1xyXG4gICAgICAgIGlmKHRoaXMub3duZWRQYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICE9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuS4jeeUqOWGjeWunuS+i+WMlu+8jOW3sue7j+acieS6hlwiKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5vd25lZFBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJCZWxvbmdNYXRlSXRlbVwiKTtcclxuICAgICAgICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRlTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYXRlTGlzdFtqXS5JZCA9PSBzYy5EYXRhLklkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIisrKysrKysrKysrKysrKysrKysrK1wiICsgbWF0ZUxpc3Rbal0uVXBMdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXRlTGlzdFtqXS5VcEx2ID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGVMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIuWunuS+i+WMluS8tOS+o1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLm93bmVkUHJlKTtcclxuICAgICAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLm93bmVkUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkJlbG9uZ01hdGVJdGVtXCIpLmluaXQobWF0ZUxpc3RbaV0sIEl0ZW1UeXBlLk1hdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYobWF0ZUxpc3RbaV0uVXBMdiA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICB9LFxyXG5cclxuICAgIEp1ZGVIYXNBbnk6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbWF0ZUxpc3QgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0T3duRGF0YUxpc3RCeVR5cGUoSXRlbVR5cGUuTWF0ZSk7XHJcbiAgICAgICAgdmFyIGhhc0FueSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0ZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYobWF0ZUxpc3RbaV0uVXBMdiA9PSB0cnVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoYXNBbnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc0FueTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE93bmVkTWF0ZVBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/OwnItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1adcaxG3ZtKyKc9SYzmKyAE', 'OwnItem');
// Scripts/UI/OwnItem.js

"use strict";

var Event = require("Event");
var UserState = require("UserState");
var ItemType = require("ItemType");
var OwnItem = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    udAtlas: cc.SpriteAtlas,
    IconSp: cc.Sprite,
    stateSp: cc.Sprite,
    NameLbl: cc.Sprite,
    PriceLbl: cc.Label,
    NumLbl: cc.Label,
    Id: cc.Integer,
    buyPrice: cc.Integer,
    Data: null
  },
  init: function init(data) {
    this.Id = data.Id;
    this.Data = data;
    this.buyPrice = data.buyPrice;
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.NameLbl.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    this.NumLbl.string = data.ownNum.toString();
    this.PriceLbl.string = data.buyPrice.toString();
  },
  refreshData: function refreshData(data) {
    this.PriceLbl.string = data.buyPrice.toString();
    this.NumLbl.string = data.ownNum.toString();
    this.buyPrice = data.buyPrice;
    this.stateSp.node.active = false;
  },
  RefreshState: function RefreshState() {
    var data = cc.Mgr.UserDataMgr.getDataByItemTypeAndId(ItemType.Goods, this.Id);
    var marketPrice = data.marketPrice;
    var ownNum = data.ownNum;
    var flag = cc.Mgr.UserDataMgr.CheckIdIsInShowList(this.Id);
    if (data != null && ownNum > 0 && flag == true) {
      this.stateSp.node.active = true;
      if (marketPrice > this.buyPrice) {
        this.stateSp.spriteFrame = this.udAtlas.getSpriteFrame("up");
      } else if (marketPrice < this.buyPrice) {
        this.stateSp.spriteFrame = this.udAtlas.getSpriteFrame("down");
      } else {
        this.stateSp.node.active = false;
      }
    } else {
      this.stateSp.node.active = false;
    }
  },
  OpenSaleTipPanel: function OpenSaleTipPanel() {
    cc.Mgr.AudioMgr.playSFX("goods_" + this.Id);
    if (cc.Mgr.UserDataMgr.userState == UserState.NotOK) {
      var param = {};
      param.text = cc.Mgr.global.getTranslation("InHealDownLine");
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    var flag = cc.Mgr.UserDataMgr.CheckIdIsInShowList(this.Data.Id);
    if (flag == true) {
      //cc.log("准备出售东西 = " + this.Data.name);
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenSaleTip, this.Data);
    } else {
      var param = {};
      param.text = cc.Mgr.global.getTranslation("goods_" + this.Data.Id) + "沒有市場需求";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      //cc.log("當前該物品不參與交易");
    }
  }
});

module.exports = OwnItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE93bkl0ZW0uanMiXSwibmFtZXMiOlsiRXZlbnQiLCJyZXF1aXJlIiwiVXNlclN0YXRlIiwiSXRlbVR5cGUiLCJPd25JdGVtIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJBdGxhcyIsIlNwcml0ZUF0bGFzIiwidWRBdGxhcyIsIkljb25TcCIsIlNwcml0ZSIsInN0YXRlU3AiLCJOYW1lTGJsIiwiUHJpY2VMYmwiLCJMYWJlbCIsIk51bUxibCIsIklkIiwiSW50ZWdlciIsImJ1eVByaWNlIiwiRGF0YSIsImluaXQiLCJkYXRhIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsImljb24iLCJuYW1lIiwic3RyaW5nIiwib3duTnVtIiwidG9TdHJpbmciLCJyZWZyZXNoRGF0YSIsIm5vZGUiLCJhY3RpdmUiLCJSZWZyZXNoU3RhdGUiLCJNZ3IiLCJVc2VyRGF0YU1nciIsImdldERhdGFCeUl0ZW1UeXBlQW5kSWQiLCJHb29kcyIsIm1hcmtldFByaWNlIiwiZmxhZyIsIkNoZWNrSWRJc0luU2hvd0xpc3QiLCJPcGVuU2FsZVRpcFBhbmVsIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwidXNlclN0YXRlIiwiTm90T0siLCJwYXJhbSIsInRleHQiLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiT3BlbkNvbW1vblRpcCIsIk9wZW5TYWxlVGlwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDNUIsSUFBSUMsU0FBUyxHQUFHRCxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3BDLElBQUlFLFFBQVEsR0FBR0YsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUNsQyxJQUFJRyxPQUFPLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFD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QUN3RCxXQUFXLEVBQUUsSUFBSSxDQUFDbEMsSUFBSSxDQUFDO0lBQ3JFLENBQUMsTUFFRDtNQUNJLElBQUkwQixLQUFLLEdBQUcsQ0FBQyxDQUFDO01BQ2RBLEtBQUssQ0FBQ0MsSUFBSSxHQUFHNUMsRUFBRSxDQUFDK0IsR0FBRyxDQUFDYyxNQUFNLENBQUNDLGNBQWMsQ0FBQyxRQUFRLEdBQUMsSUFBSSxDQUFDN0IsSUFBSSxDQUFDSCxFQUFFLENBQUMsR0FBRSxRQUFRO01BQzFFZCxFQUFFLENBQUMrQyxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDakQsRUFBRSxDQUFDK0IsR0FBRyxDQUFDcEMsS0FBSyxDQUFDdUQsYUFBYSxFQUFFUCxLQUFLLENBQUM7TUFDL0Q7SUFDSjtFQUNKO0FBQ0osQ0FBQyxDQUFDOztBQUNGUyxNQUFNLENBQUNDLE9BQU8sR0FBR3RELE9BQU8iLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFdmVudCA9IHJlcXVpcmUoXCJFdmVudFwiKTtcclxudmFyIFVzZXJTdGF0ZSA9IHJlcXVpcmUoXCJVc2VyU3RhdGVcIik7XHJcbnZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIE93bkl0ZW0gPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIEF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIHVkQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgSWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBzdGF0ZVNwOmNjLlNwcml0ZSxcclxuICAgICAgICBOYW1lTGJsOmNjLlNwcml0ZSxcclxuICAgICAgICBQcmljZUxibDpjYy5MYWJlbCxcclxuICAgICAgICBOdW1MYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgSWQ6Y2MuSW50ZWdlcixcclxuICAgICAgICBidXlQcmljZTpjYy5JbnRlZ2VyLFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXQ6ZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLklkID0gZGF0YS5JZDtcclxuICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuYnV5UHJpY2UgPSBkYXRhLmJ1eVByaWNlO1xyXG4gICAgICAgIHRoaXMuSWNvblNwLnNwcml0ZUZyYW1lID0gdGhpcy5BdGxhcy5nZXRTcHJpdGVGcmFtZShkYXRhLmljb24pO1xyXG4gICAgICAgIHRoaXMuTmFtZUxibC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5uYW1lKTtcclxuICAgICAgICB0aGlzLk51bUxibC5zdHJpbmcgPSBkYXRhLm93bk51bS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuUHJpY2VMYmwuc3RyaW5nID0gZGF0YS5idXlQcmljZS50b1N0cmluZygpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWZyZXNoRGF0YTpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLlByaWNlTGJsLnN0cmluZyA9IGRhdGEuYnV5UHJpY2UudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLk51bUxibC5zdHJpbmcgPSBkYXRhLm93bk51bS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuYnV5UHJpY2UgPSBkYXRhLmJ1eVByaWNlO1xyXG4gICAgICAgIHRoaXMuc3RhdGVTcC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBSZWZyZXNoU3RhdGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgZGF0YSA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXREYXRhQnlJdGVtVHlwZUFuZElkKEl0ZW1UeXBlLkdvb2RzLCB0aGlzLklkKTtcclxuICAgICAgICB2YXIgbWFya2V0UHJpY2UgPSBkYXRhLm1hcmtldFByaWNlO1xyXG4gICAgICAgIHZhciBvd25OdW0gPSBkYXRhLm93bk51bTtcclxuICAgICAgICB2YXIgZmxhZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5DaGVja0lkSXNJblNob3dMaXN0KHRoaXMuSWQpO1xyXG4gICAgICAgIGlmKGRhdGEgIT0gbnVsbCAmJiBvd25OdW0gPiAwICYmIGZsYWcgPT0gdHJ1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVTcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKG1hcmtldFByaWNlID4gdGhpcy5idXlQcmljZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVNwLnNwcml0ZUZyYW1lID0gdGhpcy51ZEF0bGFzLmdldFNwcml0ZUZyYW1lKFwidXBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihtYXJrZXRQcmljZSA8IHRoaXMuYnV5UHJpY2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVTcC5zcHJpdGVGcmFtZSA9IHRoaXMudWRBdGxhcy5nZXRTcHJpdGVGcmFtZShcImRvd25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlU3Aubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlU3Aubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5TYWxlVGlwUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImdvb2RzX1wiICsgdGhpcy5JZCk7XHJcbiAgICAgICAgaWYoY2MuTWdyLlVzZXJEYXRhTWdyLnVzZXJTdGF0ZSA9PSBVc2VyU3RhdGUuTm90T0spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgcGFyYW0udGV4dCA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJJbkhlYWxEb3duTGluZVwiKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmxhZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5DaGVja0lkSXNJblNob3dMaXN0KHRoaXMuRGF0YS5JZCk7XHJcbiAgICAgICAgaWYoZmxhZyA9PSB0cnVlKVxyXG4gICAgICAgIHsgIFxyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuWHhuWkh+WHuuWUruS4nOilvyA9IFwiICsgdGhpcy5EYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5PcGVuU2FsZVRpcCwgdGhpcy5EYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLnRleHQgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiZ29vZHNfXCIrdGhpcy5EYXRhLklkKSsgXCLmspLmnInluILloLTpnIDmsYJcIjtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlbkNvbW1vblRpcCwgcGFyYW0pO1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIueVtuWJjeipsueJqeWTgeS4jeWPg+iIh+S6pOaYk1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBPd25JdGVtOyJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/SaleTipPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '3cfd5BQoA9DJq4CJlf4uaUk', 'SaleTipPanel');
// Scripts/UI/SaleTipPanel.js

"use strict";

var Event = require("Event");
var AdsParam = require("AdsParam");
var TempBonus = require("TempBonus");
var SaleTipPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    IconSp: cc.Sprite,
    nameSp: cc.Sprite,
    Atlas: cc.SpriteAtlas,
    GoodsName: cc.Label,
    SaleNumLbl: cc.Label,
    EarnLbl: cc.Label,
    CBLbl: cc.Label,
    Slider: cc.Slider,
    InPutBox: cc.EditBox,
    Progress: cc.ProgressBar,
    SaleNum: 0,
    Data: null,
    needDouble: 1 //是否收益翻倍
  },

  ShowPanel: function ShowPanel(data) {
    this.needDouble = 1;
    this.Data = null;
    this.SaleNum = data.ownNum;
    this.IconSp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.nameSp.spriteFrame = this.Atlas.getSpriteFrame(data.name);
    var marketPrice = cc.Mgr.UserDataMgr.getGoodsDataById(data.Id).marketPrice;
    var money = data.ownNum * (marketPrice - data.buyPrice);
    var chengben = data.ownNum * marketPrice;
    if (cc.Mgr.global.TempAdsAssetBonus == TempBonus.AssetBonus) {
      if (money > 0) money = Math.floor(money * 1.2); //有之前看过广告
    }

    this.EarnLbl.string = cc.Mgr.global.FormatNum(money);
    this.CBLbl.string = cc.Mgr.global.FormatNum(chengben);
    this.SaleNumLbl.string = data.ownNum;
    this.InPutBox.string = data.ownNum;
    this.Slider.progress = 1;
    this.Progress.progress = 1;
    this.Data = data;
  },
  OnSliderChange: function OnSliderChange() {
    this.SaleNum = Math.floor(this.Slider.progress * this.Data.ownNum);
    this.Progress.progress = this.Slider.progress;
    var marketPrice = cc.Mgr.UserDataMgr.getGoodsDataById(this.Data.Id).marketPrice;
    var money = this.SaleNum * (marketPrice - this.Data.buyPrice);
    var chengben = this.SaleNum * marketPrice;
    this.CBLbl.string = cc.Mgr.global.FormatNum(chengben);
    this.InPutBox.string = this.SaleNum;
    if (cc.Mgr.global.TempAdsAssetBonus == TempBonus.AssetBonus) {
      if (money > 0) money = Math.floor(money * 1.2); //有之前看过广告
    }

    this.EarnLbl.string = cc.Mgr.global.FormatNum(money);
    this.SaleNumLbl.string = this.SaleNum;
  },
  OnInputBoxEnd: function OnInputBoxEnd() {
    if (this.InPutBox.string != "") {
      if (Number(this.InPutBox.string) != null) {
        if (Number(this.InPutBox.string) > this.Data.ownNum) {
          this.InPutBox.string = this.Data.ownNum;
          this.SaleNum = this.Data.ownNum;
          this.Progress.progress = 1;
          this.Slider.progress = 1;
        } else {
          this.SaleNum = Number(this.InPutBox.string);
          this.Slider.progress = this.SaleNum / this.Data.ownNum;
          this.Progress.progress = this.Slider.progress;
        }
      }
    } else {
      this.InPutBox.string = "0";
      this.SaleNum = 0;
      this.Progress.progress = 0;
      this.Slider.progress = 0;
    }
    var marketPrice = cc.Mgr.UserDataMgr.getGoodsDataById(this.Data.Id).marketPrice;
    var money = this.SaleNum * (marketPrice - this.Data.buyPrice);
    var chengben = this.SaleNum * marketPrice;
    this.CBLbl.string = cc.Mgr.global.FormatNum(chengben);
    if (cc.Mgr.global.TempAdsAssetBonus == TempBonus.AssetBonus) {
      if (money > 0) money = Math.floor(money * 1.2); //有之前看过广告
    }

    this.EarnLbl.string = cc.Mgr.global.FormatNum(money);
  },
  showRewardVideo: function showRewardVideo() {
    this.js2android('show_reward_video', '1');
  },
  ///激励视频播放完成回调方法 continue_game
  /// Native.android2js("continue_game", ()=>{
  ///     //激励视频播放完成，原生端回调
  /// });
  js2android: function js2android(name, data) {
    console.log("name:" + name + "-data:" + data);
    if (window.injectedObject && window.injectedObject.setJsContent) {
      window.injectedObject.setJsContent(name, data);
    }
  },
  ClickSaleBtn: function ClickSaleBtn() {
    if (this.SaleNum <= 0) {
      cc.Mgr.AudioMgr.playSFX("click");
      return;
    }
    cc.Mgr.UserDataMgr.WareHouseCapcity += this.SaleNum;
    var marketPrice = cc.Mgr.UserDataMgr.getGoodsDataById(this.Data.Id).marketPrice;
    var getMoney = marketPrice * this.SaleNum;
    if (cc.Mgr.global.TempAdsAssetBonus == TempBonus.AssetBonus) {
      var money = this.SaleNum * (marketPrice - this.Data.buyPrice);
      if (money > 0) getMoney = Math.floor(getMoney * 1.2) * this.needDouble;
      //cc.Mgr.global.TempAdsBonus = TempBonus.NULL;
    }

    cc.Mgr.UserDataMgr.Cash += getMoney;
    var param = {};
    param.Num = this.SaleNum;
    param.price = this.Data.buyPrice;
    param.Id = this.Data.Id;
    var data = cc.Mgr.UserDataMgr.SaleGoods(param);
    if (marketPrice > this.Data.buyPrice) cc.Mgr.UserDataMgr.Reputation += 2;
    //通知刷新现金
    cc.director.GlobalEvent.emit(cc.Mgr.Event.SaleSuccess, data);
    this.ClosePanel();
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  },
  DoubleGetByVedio: function DoubleGetByVedio() {
    if (this.SaleNum <= 0) {
      cc.Mgr.AudioMgr.playSFX("click");
      return;
    }
    var self = this;
    self.showRewardVideo();
    cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointC, function (out) {
      if (out == 0) {
        self.needDouble = 2;
        self.ClickSaleBtn();
      }
    });
  }
});
module.exports = SaleTipPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFNhbGVUaXBQYW5lbC5qcyJdLCJuYW1lcyI6WyJFdmVudCIsInJlcXVpcmUiLCJBZHNQYXJhbSIsIlRlbXBCb251cyIsIlNhbGVUaXBQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiSWNvblNwIiwiU3ByaXRlIiwibmFtZVNwIiwiQXRsYXMiLCJTcHJpdGVBdGxhcyIsIkdvb2RzTmFtZSIsIkxhYmVsIiwiU2FsZU51bUxibCIsIkVhcm5MYmwiLCJDQkxibCIsIlNsaWRlciIsIkluUHV0Qm94IiwiRWRpdEJveCIsIlByb2dyZXNzIiwiUHJvZ3Jlc3NCYXIiLCJTYWxlTnVtIiwiRGF0YSIsIm5lZWREb3VibGUiLCJTaG93UGFuZWwiLCJkYXRhIiwib3duTnVtIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsImljb24iLCJuYW1lIiwibWFya2V0UHJpY2UiLCJNZ3IiLCJVc2VyRGF0YU1nciIsImdldEdvb2RzRGF0YUJ5SWQiLCJJZCIsIm1vbmV5IiwiYnV5UHJpY2UiLCJjaGVuZ2JlbiIsImdsb2JhbCIsIlRlbXBBZHNBc3NldEJvbnVzIiwiQXNzZXRCb251cyIsIk1hdGgiLCJmbG9vciIsInN0cmluZyIsIkZvcm1hdE51bSIsInByb2dyZXNzIiwiT25TbGlkZXJDaGFuZ2UiLCJPbklucHV0Qm94RW5kIiwiTnVtYmVyIiwic2hvd1Jld2FyZFZpZGVvIiwianMyYW5kcm9pZCIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJpbmplY3RlZE9iamVjdCIsInNldEpzQ29udGVudCIsIkNsaWNrU2FsZUJ0biIsIkF1ZGlvTWdyIiwicGxheVNGWCIsIldhcmVIb3VzZUNhcGNpdHkiLCJnZXRNb25leSIsIkNhc2giLCJwYXJhbSIsIk51bSIsInByaWNlIiwiU2FsZUdvb2RzIiwiUmVwdXRhdGlvbiIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiU2FsZVN1Y2Nlc3MiLCJDbG9zZVBhbmVsIiwibm9kZSIsImFjdGl2ZSIsIkRvdWJsZUdldEJ5VmVkaW8iLCJzZWxmIiwiQWRzTWdyIiwiU2hvd1ZpZGVvQWRzIiwiUG9pbnRDIiwib3V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDNUIsSUFBSUMsUUFBUSxHQUFHRCxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlFLFNBQVMsR0FBR0YsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUNwQyxJQUFJRyxZQUFZLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLE1BQU0sRUFBQ0osRUFBRSxDQUFDSyxNQUFNO0lBQ2hCQyxNQUFNLEVBQUNOLEVBQUUsQ0FBQ0ssTUFBTTtJQUNoQkUsS0FBSyxFQUFDUCxFQUFFLENBQUNRLFdBQVc7SUFDcEJDLFNBQVMsRUFBQ1QsRUFBRSxDQUFDVSxLQUFLO0lBQ2xCQyxVQUFVLEVBQUNYLEVBQUUsQ0FBQ1UsS0FBSztJQUNuQkUsT0FBTyxFQUFDWixFQUFFLENBQUNVLEtBQUs7SUFDaEJHLEtBQUssRUFBQ2IsRUFBRSxDQUFDVSxLQUFLO0lBQ2RJLE1BQU0sRUFBQ2QsRUFBRSxDQUFDYyxNQUFNO0lBQ2hCQyxRQUFRLEVBQUNmLEVBQUUsQ0FBQ2dCLE9BQU87SUFDbkJDLFFBQVEsRUFBQ2pCLEVBQUUsQ0FBQ2tCLFdBQVc7SUFDdkJDLE9BQU8sRUFBQyxDQUFDO0lBQ1RDLElBQUksRUFBQyxJQUFJO0lBRVRDLFVBQVUsRUFBQyxDQUFDLENBQUM7RUFDakIsQ0FBQzs7RUFFREMsU0FBUyxFQUFDLFNBQUFBLFVBQVVDLElBQUksRUFBRTtJQUN0QixJQUFJLENBQUNGLFVBQVUsR0FBRyxDQUFDO0lBQ25CLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUk7SUFDaEIsSUFBSSxDQUFDRCxP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LElBQUcsSUFBSSxDQUFDdEQsT0FBTyxJQUFJLENBQUMsRUFDcEI7TUFDSW5CLEVBQUUsQ0FBQzhCLEdBQUcsQ0FBQzBCLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztNQUNoQztJQUNKO0lBQ0EsSUFBSWlCLElBQUksR0FBRyxJQUFJO0lBQ2ZBLElBQUksQ0FBQzFCLGVBQWUsRUFBRTtJQUN0QmhELEVBQUUsQ0FBQzhCLEdBQUcsQ0FBQzZDLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDL0UsUUFBUSxDQUFDZ0YsTUFBTSxFQUFFLFVBQVNDLEdBQUcsRUFBQztNQUVyRCxJQUFHQSxHQUFHLElBQUksQ0FBQyxFQUNYO1FBQ0lKLElBQUksQ0FBQ3JELFVBQVUsR0FBRyxDQUFDO1FBQ25CcUQsSUFBSSxDQUFDbkIsWUFBWSxFQUFFO01BQ3ZCO0lBQ0osQ0FBQyxDQUFDO0VBQ047QUFFSixDQUFDLENBQUM7QUFDRndCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHakYsWUFBWSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50ID0gcmVxdWlyZShcIkV2ZW50XCIpO1xyXG52YXIgQWRzUGFyYW0gPSByZXF1aXJlKFwiQWRzUGFyYW1cIik7XHJcbnZhciBUZW1wQm9udXMgPSByZXF1aXJlKFwiVGVtcEJvbnVzXCIpO1xyXG52YXIgU2FsZVRpcFBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBJY29uU3A6Y2MuU3ByaXRlLFxyXG4gICAgICAgIG5hbWVTcDpjYy5TcHJpdGUsXHJcbiAgICAgICAgQXRsYXM6Y2MuU3ByaXRlQXRsYXMsXHJcbiAgICAgICAgR29vZHNOYW1lOmNjLkxhYmVsLFxyXG4gICAgICAgIFNhbGVOdW1MYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgRWFybkxibDpjYy5MYWJlbCxcclxuICAgICAgICBDQkxibDpjYy5MYWJlbCxcclxuICAgICAgICBTbGlkZXI6Y2MuU2xpZGVyLFxyXG4gICAgICAgIEluUHV0Qm94OmNjLkVkaXRCb3gsXHJcbiAgICAgICAgUHJvZ3Jlc3M6Y2MuUHJvZ3Jlc3NCYXIsXHJcbiAgICAgICAgU2FsZU51bTowLFxyXG4gICAgICAgIERhdGE6bnVsbCxcclxuXHJcbiAgICAgICAgbmVlZERvdWJsZToxLC8v5piv5ZCm5pS255uK57+75YCNXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMubmVlZERvdWJsZSA9IDE7XHJcbiAgICAgICAgdGhpcy5EYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLlNhbGVOdW0gPSBkYXRhLm93bk51bTtcclxuICAgICAgICB0aGlzLkljb25TcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5pY29uKTtcclxuICAgICAgICB0aGlzLm5hbWVTcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoZGF0YS5uYW1lKTtcclxuICAgICAgICB2YXIgbWFya2V0UHJpY2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0R29vZHNEYXRhQnlJZChkYXRhLklkKS5tYXJrZXRQcmljZTtcclxuICAgICAgICB2YXIgbW9uZXkgPSBkYXRhLm93bk51bSAqIChtYXJrZXRQcmljZSAtIGRhdGEuYnV5UHJpY2UpO1xyXG4gICAgICAgIHZhciBjaGVuZ2JlbiA9IGRhdGEub3duTnVtICogbWFya2V0UHJpY2U7XHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC5UZW1wQWRzQXNzZXRCb251cyA9PSBUZW1wQm9udXMuQXNzZXRCb251cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKG1vbmV5ID4gMClcclxuICAgICAgICAgICAgICAgIG1vbmV5ID0gTWF0aC5mbG9vcihtb25leSAqIDEuMik7IC8v5pyJ5LmL5YmN55yL6L+H5bm/5ZGKXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuRWFybkxibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShtb25leSk7XHJcbiAgICAgICAgdGhpcy5DQkxibC5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLkZvcm1hdE51bShjaGVuZ2Jlbik7XHJcbiAgICAgICAgdGhpcy5TYWxlTnVtTGJsLnN0cmluZyA9IGRhdGEub3duTnVtO1xyXG4gICAgICAgIHRoaXMuSW5QdXRCb3guc3RyaW5nID0gZGF0YS5vd25OdW07XHJcbiAgICAgICAgdGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuUHJvZ3Jlc3MucHJvZ3Jlc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuRGF0YSA9IGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIE9uU2xpZGVyQ2hhbmdlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5TYWxlTnVtID0gTWF0aC5mbG9vcih0aGlzLlNsaWRlci5wcm9ncmVzcyAqIHRoaXMuRGF0YS5vd25OdW0pO1xyXG4gICAgICAgIHRoaXMuUHJvZ3Jlc3MucHJvZ3Jlc3MgPSB0aGlzLlNsaWRlci5wcm9ncmVzcztcclxuICAgICAgICB2YXIgbWFya2V0UHJpY2UgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0R29vZHNEYXRhQnlJZCh0aGlzLkRhdGEuSWQpLm1hcmtldFByaWNlO1xyXG4gICAgICAgIHZhciBtb25leSA9IHRoaXMuU2FsZU51bSAqIChtYXJrZXRQcmljZSAtIHRoaXMuRGF0YS5idXlQcmljZSk7XHJcblxyXG4gICAgICAgIHZhciBjaGVuZ2JlbiA9IHRoaXMuU2FsZU51bSAqIG1hcmtldFByaWNlO1xyXG4gICAgICAgIHRoaXMuQ0JMYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0oY2hlbmdiZW4pO1xyXG5cclxuICAgICAgICB0aGlzLkluUHV0Qm94LnN0cmluZyA9IHRoaXMuU2FsZU51bTtcclxuICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLlRlbXBBZHNBc3NldEJvbnVzID09IFRlbXBCb251cy5Bc3NldEJvbnVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYobW9uZXkgPiAwKVxyXG4gICAgICAgICAgICAgICAgbW9uZXkgPSBNYXRoLmZsb29yKG1vbmV5ICoxLjIpOyAvL+acieS5i+WJjeeci+i/h+W5v+WRilxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLkVhcm5MYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5Gb3JtYXROdW0obW9uZXkpO1xyXG4gICAgICAgIHRoaXMuU2FsZU51bUxibC5zdHJpbmcgPSB0aGlzLlNhbGVOdW07XHJcbiAgICB9LFxyXG5cclxuICAgIE9uSW5wdXRCb3hFbmQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZih0aGlzLkluUHV0Qm94LnN0cmluZyAhPSBcIlwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYoTnVtYmVyKHRoaXMuSW5QdXRCb3guc3RyaW5nKSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihOdW1iZXIodGhpcy5JblB1dEJveC5zdHJpbmcpID4gdGhpcy5EYXRhLm93bk51bSkgXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSB0aGlzLkRhdGEub3duTnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuU2FsZU51bSA9IHRoaXMuRGF0YS5vd25OdW07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuU2FsZU51bSA9IE51bWJlcih0aGlzLkluUHV0Qm94LnN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TbGlkZXIucHJvZ3Jlc3MgPSAgdGhpcy5TYWxlTnVtIC8gdGhpcy5EYXRhLm93bk51bTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gdGhpcy5TbGlkZXIucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5JblB1dEJveC5zdHJpbmcgPSBcIjBcIjtcclxuICAgICAgICAgICAgdGhpcy5TYWxlTnVtID0gMDtcclxuICAgICAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuU2xpZGVyLnByb2dyZXNzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hcmtldFByaWNlID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldEdvb2RzRGF0YUJ5SWQodGhpcy5EYXRhLklkKS5tYXJrZXRQcmljZTtcclxuICAgICAgICB2YXIgbW9uZXkgPSB0aGlzLlNhbGVOdW0gKiAobWFya2V0UHJpY2UgLSB0aGlzLkRhdGEuYnV5UHJpY2UpO1xyXG5cclxuICAgICAgICB2YXIgY2hlbmdiZW4gPSB0aGlzLlNhbGVOdW0gKiBtYXJrZXRQcmljZTtcclxuICAgICAgICB0aGlzLkNCTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKGNoZW5nYmVuKTtcclxuXHJcbiAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC5UZW1wQWRzQXNzZXRCb251cyA9PSBUZW1wQm9udXMuQXNzZXRCb251cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKG1vbmV5ID4gMClcclxuICAgICAgICAgICAgICAgIG1vbmV5ID0gTWF0aC5mbG9vcihtb25leSAqMS4yKTsgLy/mnInkuYvliY3nnIvov4flub/lkYpcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5FYXJuTGJsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuRm9ybWF0TnVtKG1vbmV5KTtcclxuICAgIH0sXHJcbiAgICBzaG93UmV3YXJkVmlkZW8oKSB7XHJcbiAgICAgICAgdGhpcy5qczJhbmRyb2lkKCdzaG93X3Jld2FyZF92aWRlbycsICcxJylcclxuICAgIH0sXHJcblxyXG4gICAgLy8v5r+A5Yqx6KeG6aKR5pKt5pS+5a6M5oiQ5Zue6LCD5pa55rOVIGNvbnRpbnVlX2dhbWVcclxuICAgIC8vLyBOYXRpdmUuYW5kcm9pZDJqcyhcImNvbnRpbnVlX2dhbWVcIiwgKCk9PntcclxuICAgIC8vLyAgICAgLy/mv4DlirHop4bpopHmkq3mlL7lrozmiJDvvIzljp/nlJ/nq6/lm57osINcclxuICAgIC8vLyB9KTtcclxuICAgIGpzMmFuZHJvaWQobmFtZSwgZGF0YSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coYG5hbWU6JHtuYW1lfS1kYXRhOiR7ZGF0YX1gKTtcclxuICAgICAgICBpZih3aW5kb3cuaW5qZWN0ZWRPYmplY3QgJiYgd2luZG93LmluamVjdGVkT2JqZWN0LnNldEpzQ29udGVudCl7XHJcbiAgICAgICAgICAgIHdpbmRvdy5pbmplY3RlZE9iamVjdC5zZXRKc0NvbnRlbnQobmFtZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIENsaWNrU2FsZUJ0bjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuU2FsZU51bSA8PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuV2FyZUhvdXNlQ2FwY2l0eSArPSB0aGlzLlNhbGVOdW07XHJcblxyXG4gICAgICAgIHZhciBtYXJrZXRQcmljZSA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRHb29kc0RhdGFCeUlkKHRoaXMuRGF0YS5JZCkubWFya2V0UHJpY2U7XHJcbiAgICAgICAgdmFyIGdldE1vbmV5ID0gKG1hcmtldFByaWNlICogdGhpcy5TYWxlTnVtKTtcclxuICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLlRlbXBBZHNBc3NldEJvbnVzID09IFRlbXBCb251cy5Bc3NldEJvbnVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG1vbmV5ID0gdGhpcy5TYWxlTnVtICogKG1hcmtldFByaWNlIC0gdGhpcy5EYXRhLmJ1eVByaWNlKTtcclxuICAgICAgICAgICAgaWYobW9uZXkgPiAwKVxyXG4gICAgICAgICAgICAgICAgZ2V0TW9uZXkgPSBNYXRoLmZsb29yKGdldE1vbmV5ICogMS4yKSAqIHRoaXMubmVlZERvdWJsZTtcclxuICAgICAgICAgICAgLy9jYy5NZ3IuZ2xvYmFsLlRlbXBBZHNCb251cyA9IFRlbXBCb251cy5OVUxMO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCArPSBnZXRNb25leTtcclxuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcclxuICAgICAgICBwYXJhbS5OdW0gPSB0aGlzLlNhbGVOdW07XHJcbiAgICAgICAgcGFyYW0ucHJpY2UgPSB0aGlzLkRhdGEuYnV5UHJpY2U7XHJcbiAgICAgICAgcGFyYW0uSWQgPSB0aGlzLkRhdGEuSWQ7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuU2FsZUdvb2RzKHBhcmFtKTtcclxuICAgICAgICBpZihtYXJrZXRQcmljZSA+IHRoaXMuRGF0YS5idXlQcmljZSlcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlJlcHV0YXRpb24gKz0gMjtcclxuICAgICAgICAvL+mAmuefpeWIt+aWsOeOsOmHkVxyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LlNhbGVTdWNjZXNzLCBkYXRhKTtcclxuICAgICAgICB0aGlzLkNsb3NlUGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBEb3VibGVHZXRCeVZlZGlvOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5TYWxlTnVtIDw9IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLnNob3dSZXdhcmRWaWRlbygpXHJcbiAgICAgICAgY2MuTWdyLkFkc01nci5TaG93VmlkZW9BZHMoQWRzUGFyYW0uUG9pbnRDLCBmdW5jdGlvbihvdXQpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYob3V0ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubmVlZERvdWJsZSA9IDI7XHJcbiAgICAgICAgICAgICAgICBzZWxmLkNsaWNrU2FsZUJ0bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gU2FsZVRpcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/RankPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'eec0cXLqh5Fx73Z9d31Hnh2', 'RankPanel');
// Scripts/UI/RankPanel.js

"use strict";

var RankPanel = cc.Class({
  "extends": cc.Component,
  properties: {},
  ShowPanel: function ShowPanel(DataList) {
    /*
    var index = 0;
    var children = this.itemParent.children;
    for (var j = 0; j <= children.length - 1; j++) {
    var sc = children[i].getComponent("RankItem");
    if(sc != null)
    {
    	if(DataList[j] != null)
    	{
    		sc.ShowData(DataList[j]);
    		index = j;
    	}
    	else
    	{
    		children[i].active = false;
    	}
    }
    }
    //如果需要重新初始化一些实例
    if(index < DataList.length-1)
    {
    for (var i = index + 1; i <= DataList.length-1; i++) {
    	var data = DataList[i];
           var obj = cc.instantiate(this.rankPre);
           obj.parent = this.itemParent;
           obj.active = true;
           obj.getComponent("RankItem").init(data);
    }
    }
    */
  }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFJhbmtQYW5lbC5qcyJdLCJuYW1lcyI6WyJSYW5rUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIlNob3dQYW5lbCIsIkRhdGFMaXN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLFNBQVMsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDckIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUUsQ0FFWixDQUFDO0VBRURDLFNBQVMsRUFBQyxTQUFBQSxVQUFTQyxRQUFRLEVBQUM7SUFDMUI7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBN0JNO0FBK0JOLENBQUMsQ0FBQyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBSYW5rUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICBcdFNob3dQYW5lbDpmdW5jdGlvbihEYXRhTGlzdCl7XHJcbiAgICAgIC8qXHJcbiAgIFx0XHR2YXIgaW5kZXggPSAwO1xyXG4gICBcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5pdGVtUGFyZW50LmNoaWxkcmVuO1xyXG4gICBcdFx0Zm9yICh2YXIgaiA9IDA7IGogPD0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgIFx0XHRcdHZhciBzYyA9IGNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIlJhbmtJdGVtXCIpO1xyXG4gICBcdFx0XHRpZihzYyAhPSBudWxsKVxyXG4gICBcdFx0XHR7XHJcbiAgIFx0XHRcdFx0aWYoRGF0YUxpc3Rbal0gIT0gbnVsbClcclxuICAgXHRcdFx0XHR7XHJcbiAgIFx0XHRcdFx0XHRzYy5TaG93RGF0YShEYXRhTGlzdFtqXSk7XHJcbiAgIFx0XHRcdFx0XHRpbmRleCA9IGo7XHJcbiAgIFx0XHRcdFx0fVxyXG4gICBcdFx0XHRcdGVsc2VcclxuICAgXHRcdFx0XHR7XHJcbiAgIFx0XHRcdFx0XHRjaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTtcclxuICAgXHRcdFx0XHR9XHJcbiAgIFx0XHRcdH1cclxuICAgXHRcdH1cclxuICAgXHRcdC8v5aaC5p6c6ZyA6KaB6YeN5paw5Yid5aeL5YyW5LiA5Lqb5a6e5L6LXHJcbiAgIFx0XHRpZihpbmRleCA8IERhdGFMaXN0Lmxlbmd0aC0xKVxyXG4gICBcdFx0e1xyXG4gICBcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyAxOyBpIDw9IERhdGFMaXN0Lmxlbmd0aC0xOyBpKyspIHtcclxuXHQgICBcdFx0XHR2YXIgZGF0YSA9IERhdGFMaXN0W2ldO1xyXG5cdCAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnJhbmtQcmUpO1xyXG5cdCAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLml0ZW1QYXJlbnQ7XHJcblx0ICAgICAgICAgICAgb2JqLmFjdGl2ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIlJhbmtJdGVtXCIpLmluaXQoZGF0YSk7XHJcblx0ICAgXHRcdH1cclxuICAgXHRcdH1cclxuICAgICAgKi9cclxuICAgXHR9LFxyXG59KTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/RotationLoading.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c0cf11hDX9OiYlBfIY8A5Kk', 'RotationLoading');
// Scripts/UI/RotationLoading.js

"use strict";

var RotationLoading = cc.Class({
  "extends": cc.Component,
  properties: {},
  // LIFE-CYCLE CALLBACKS:
  // onLoad () {},
  start: function start() {},
  update: function update(dt) {}
});
module.exports = RotationLoading;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFJvdGF0aW9uTG9hZGluZy5qcyJdLCJuYW1lcyI6WyJSb3RhdGlvbkxvYWRpbmciLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsInN0YXJ0IiwidXBkYXRlIiwiZHQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLGVBQWUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDM0IsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUUsQ0FFWixDQUFDO0VBRUQ7RUFFQTtFQUVBQyxLQUFLLFdBQUFBLE1BQUEsRUFBSSxDQUVULENBQUM7RUFFREMsTUFBTSxXQUFBQSxPQUFFQyxFQUFFLEVBQUUsQ0FFWjtBQUNKLENBQUMsQ0FBQztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR1QsZUFBZSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBSb3RhdGlvbkxvYWRpbmcgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBMSUZFLUNZQ0xFIENBTExCQUNLUzpcclxuXHJcbiAgICAvLyBvbkxvYWQgKCkge30sXHJcblxyXG4gICAgc3RhcnQgKCkge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlIChkdCkge1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25Mb2FkaW5nO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/SettingPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '91575+sKBJGHor0RR//JfzB', 'SettingPanel');
// Scripts/UI/SettingPanel.js

"use strict";

var SettingPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    togMan: cc.Toggle,
    togWoMan: cc.Toggle
  },
  ShowPanel: function ShowPanel() {
    if (cc.Mgr.UserDataMgr.Sex == 1) this.togMan.isChecked = true;else this.togWoMan.isChecked = true;
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  },
  ConfrimSexMan: function ConfrimSexMan() {
    cc.Mgr.AudioMgr.playSFX("click");
    cc.Mgr.UserDataMgr.Sex = 1;
  },
  ConfrimSexWoMan: function ConfrimSexWoMan() {
    cc.Mgr.AudioMgr.playSFX("click");
    cc.Mgr.UserDataMgr.Sex = 2;
  },
  OpenSound: function OpenSound() {
    cc.Mgr.AudioMgr.resumeAll();
    cc.Mgr.AudioMgr.playSFX("click");
  },
  OffSound: function OffSound() {
    cc.Mgr.AudioMgr.pauseAll();
  }
});
module.exports = SettingPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFNldHRpbmdQYW5lbC5qcyJdLCJuYW1lcyI6WyJTZXR0aW5nUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsInRvZ01hbiIsIlRvZ2dsZSIsInRvZ1dvTWFuIiwiU2hvd1BhbmVsIiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJTZXgiLCJpc0NoZWNrZWQiLCJDbG9zZVBhbmVsIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibm9kZSIsImFjdGl2ZSIsIkNvbmZyaW1TZXhNYW4iLCJDb25mcmltU2V4V29NYW4iLCJPcGVuU291bmQiLCJyZXN1bWVBbGwiLCJPZmZTb3VuZCIsInBhdXNlQWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxZQUFZLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLE1BQU0sRUFBQ0osRUFBRSxDQUFDSyxNQUFNO0lBQ2hCQyxRQUFRLEVBQUNOLEVBQUUsQ0FBQ0s7RUFDaEIsQ0FBQztFQUVERSxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFVO0lBQ2hCLElBQUdQLEVBQUUsQ0FBQ1EsR0FBRyxDQUFDQyxXQUFXLENBQUNDLEdBQUcsSUFBSSxDQUFDLEVBQzFCLElBQUksQ0FBQ04sTUFBTSxDQUFDTyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBRTdCLElBQUksQ0FBQ0wsUUFBUSxDQUFDSyxTQUFTLEdBQUcsSUFBSTtFQUN0QyxDQUFDO0VBRURDLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQVU7SUFDakJaLEVBQUUsQ0FBQ1EsR0FBRyxDQUFDSyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0VBQzVCLENBQUM7RUFFREMsYUFBYSxFQUFDLFNBQUFBLGNBQUEsRUFBVTtJQUNwQmpCLEVBQUUsQ0FBQ1EsR0FBRyxDQUFDSyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaENkLEVBQUUsQ0FBQ1EsR0FBRyxDQUFDQyxXQUFXLENBQUNDLEdBQUcsR0FBRyxDQUFDO0VBQzlCLENBQUM7RUFFRFEsZUFBZSxFQUFDLFNBQUFBLGdCQUFBLEVBQVU7SUFDdEJsQixFQUFFLENBQUNRLEdBQUcsQ0FBQ0ssUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDZCxFQUFFLENBQUNRLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLEdBQUcsQ0FBQztFQUM5QixDQUFDO0VBRURTLFNBQVMsRUFBQyxTQUFBQSxVQUFBLEVBQVU7SUFDaEJuQixFQUFFLENBQUNRLEdBQUcsQ0FBQ0ssUUFBUSxDQUFDTyxTQUFTLEVBQUU7SUFDM0JwQixFQUFFLENBQUNRLEdBQUcsQ0FBQ0ssUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0VBQ3BDLENBQUM7RUFFRE8sUUFBUSxFQUFDLFNBQUFBLFNBQUEsRUFBVTtJQUNmckIsRUFBRSxDQUFDUSxHQUFHLENBQUNLLFFBQVEsQ0FBQ1MsUUFBUSxFQUFFO0VBQzlCO0FBRUosQ0FBQyxDQUFDO0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHekIsWUFBWSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBTZXR0aW5nUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHRvZ01hbjpjYy5Ub2dnbGUsXHJcbiAgICAgICAgdG9nV29NYW46Y2MuVG9nZ2xlLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZihjYy5NZ3IuVXNlckRhdGFNZ3IuU2V4ID09IDEpXHJcbiAgICAgICAgICAgIHRoaXMudG9nTWFuLmlzQ2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLnRvZ1dvTWFuLmlzQ2hlY2tlZCA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgQ29uZnJpbVNleE1hbjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlNleCA9IDE7XHJcbiAgICB9LFxyXG5cclxuICAgIENvbmZyaW1TZXhXb01hbjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlNleCA9IDI7XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5Tb3VuZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5yZXN1bWVBbGwoKTtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBPZmZTb3VuZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wYXVzZUFsbCgpO1xyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/SkillItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'f6879+wYDZNurbu1VwNBr0v', 'SkillItem');
// Scripts/UI/SkillItem.js

"use strict";

var SkillItem = cc.Class({
  "extends": cc.Component,
  properties: {
    StartAtlas: cc.SpriteAtlas,
    Atlas: cc.SpriteAtlas,
    icon: cc.Sprite,
    maskSp: cc.Sprite,
    lvLbl: cc.Label,
    Line: cc.Sprite,
    UpTip: cc.Node,
    Data: null
  },
  ShowData: function ShowData(data, len) {
    this.UpTip.active = false;
    this.Data = data;
    this.lvLbl.string = data.level;
    this.icon.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    if (data.level != 0) {
      //this.icon.setState(0);
      this.maskSp.node.active = false;
      this.Line.setState(0);
    } else {
      //this.icon.setState(1);
      this.maskSp.node.active = true;
      this.Line.setState(1);
    }
    this.Line.node.active = false;
    if (data.subId != len) {
      this.Line.node.active = true;
    }
    this.JudeShowUpTip();
  },
  JudeShowUpTip: function JudeShowUpTip() {
    var isOk = cc.Mgr.UserDataMgr.CanShowUpTip(this.Data.Id, this.Data.subId, this.Data.level + 1);
    this.UpTip.active = isOk;
  },
  ClickOpenUp: function ClickOpenUp() {
    cc.Mgr.AudioMgr.playSFX("click");
    cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenUpgradeSkill, this.Data);
  }
});
module.exports = SkillItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFNraWxsSXRlbS5qcyJdLCJuYW1lcyI6WyJTa2lsbEl0ZW0iLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIlN0YXJ0QXRsYXMiLCJTcHJpdGVBdGxhcyIsIkF0bGFzIiwiaWNvbiIsIlNwcml0ZSIsIm1hc2tTcCIsImx2TGJsIiwiTGFiZWwiLCJMaW5lIiwiVXBUaXAiLCJOb2RlIiwiRGF0YSIsIlNob3dEYXRhIiwiZGF0YSIsImxlbiIsImFjdGl2ZSIsInN0cmluZyIsImxldmVsIiwic3ByaXRlRnJhbWUiLCJnZXRTcHJpdGVGcmFtZSIsIm5vZGUiLCJzZXRTdGF0ZSIsInN1YklkIiwiSnVkZVNob3dVcFRpcCIsImlzT2siLCJNZ3IiLCJVc2VyRGF0YU1nciIsIkNhblNob3dVcFRpcCIsIklkIiwiQ2xpY2tPcGVuVXAiLCJBdWRpb01nciIsInBsYXlTRlgiLCJkaXJlY3RvciIsIkdsb2JhbEV2ZW50IiwiZW1pdCIsIkV2ZW50IiwiT3BlblVwZ3JhZGVTa2lsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsU0FBUyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNyQixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNYQyxVQUFVLEVBQUNKLEVBQUUsQ0FBQ0ssV0FBVztJQUN0QkMsS0FBSyxFQUFDTixFQUFFLENBQUNLLFdBQVc7SUFDcEJFLElBQUksRUFBQ1AsRUFBRSxDQUFDUSxNQUFNO0lBQ2RDLE1BQU0sRUFBQ1QsRUFBRSxDQUFDUSxNQUFNO0lBQ2hCRSxLQUFLLEVBQUNWLEVBQUUsQ0FBQ1csS0FBSztJQUNkQyxJQUFJLEVBQUNaLEVBQUUsQ0FBQ1EsTUFBTTtJQUNkSyxLQUFLLEVBQUNiLEVBQUUsQ0FBQ2MsSUFBSTtJQUNiQyxJQUFJLEVBQUM7RUFDVCxDQUFDO0VBRURDLFFBQVEsRUFBQyxTQUFBQSxTQUFVQyxJQUFJLEVBQUVDLEdBQUcsRUFBRTtJQUMxQixJQUFJLENBQUNMLEtBQUssQ0FBQ00sTUFBTSxHQUFHLEtBQUs7SUFDekIsSUFBSSxDQUFDSixJQUFJLEdBQUdFLElBQUk7SUFDaEIsSUFBSSxDQUFDUCxLQUFLLENBQUNVLE1BQU0sR0FBR0gsSUFBSSxDQUFDSSxLQUFLO0lBQzlCLElBQUksQ0FBQ2QsSUFBSSxDQUFDZSxXQUFXLEdBQUcsSUFBSSxDQUFDaEIsS0FBSyxDQUFDaUIsY0FBYyxDQUFDTixJQUFJLENBQUNWLElBQUksQ0FBQztJQUM1RCxJQUFHVSxJQUFJLENBQUNJLEtBQUssSUFBSSxDQUFDLEVBQ2xCO01BQ0k7TUFDQSxJQUFJLENBQUNaLE1BQU0sQ0FBQ2UsSUFBSSxDQUFDTCxNQUFNLEdBQUcsS0FBSztNQUMvQixJQUFJLENBQUNQLElBQUksQ0FBQ2EsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDLE1BRUQ7TUFDSTtNQUNBLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ2UsSUFBSSxDQUFDTCxNQUFNLEdBQUcsSUFBSTtNQUM5QixJQUFJLENBQUNQLElBQUksQ0FBQ2EsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUN6QjtJQUNBLElBQUksQ0FBQ2IsSUFBSSxDQUFDWSxJQUFJLENBQUNMLE1BQU0sR0FBRyxLQUFLO0lBQzdCLElBQUdGLElBQUksQ0FBQ1MsS0FBSyxJQUFJUixHQUFHLEVBQ3BCO01BQ0ksSUFBSSxDQUFDTixJQUFJLENBQUNZLElBQUksQ0FBQ0wsTUFBTSxHQUFHLElBQUk7SUFDaEM7SUFFQSxJQUFJLENBQUNRLGFBQWEsRUFBRTtFQUN4QixDQUFDO0VBRURBLGFBQWEsRUFBQyxTQUFBQSxjQUFBLEVBQVU7SUFDcEIsSUFBSUMsSUFBSSxHQUFHNUIsRUFBRSxDQUFDNkIsR0FBRyxDQUFDQyxXQUFXLENBQUNDLFlBQVksQ0FBQyxJQUFJLENBQUNoQixJQUFJLENBQUNpQixFQUFFLEVBQUUsSUFBSSxDQUFDakIsSUFBSSxDQUFDVyxLQUFLLEVBQUcsSUFBSSxDQUFDWCxJQUFJLENBQUNNLEtBQUssR0FBRyxDQUFDLENBQUU7SUFDaEcsSUFBSSxDQUFDUixLQUFLLENBQUNNLE1BQU0sR0FBR1MsSUFBSTtFQUM1QixDQUFDO0VBRURLLFdBQVcsRUFBQyxTQUFBQSxZQUFBLEVBQVU7SUFDbEJqQyxFQUFFLENBQUM2QixHQUFHLENBQUNLLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQ25DLEVBQUUsQ0FBQ29DLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUN0QyxFQUFFLENBQUM2QixHQUFHLENBQUNVLEtBQUssQ0FBQ0MsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDekIsSUFBSSxDQUFDO0VBQzFFO0FBQ0osQ0FBQyxDQUFDO0FBQ0YwQixNQUFNLENBQUNDLE9BQU8sR0FBRzNDLFNBQVMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgU2tpbGxJdGVtID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgIFx0U3RhcnRBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICBBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICBpY29uOmNjLlNwcml0ZSxcclxuICAgICAgICBtYXNrU3A6Y2MuU3ByaXRlLFxyXG4gICAgICAgIGx2TGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIExpbmU6Y2MuU3ByaXRlLFxyXG4gICAgICAgIFVwVGlwOmNjLk5vZGUsXHJcbiAgICAgICAgRGF0YTpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93RGF0YTpmdW5jdGlvbiAoZGF0YSAsbGVuKSB7XHJcbiAgICAgICAgdGhpcy5VcFRpcC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubHZMYmwuc3RyaW5nID0gZGF0YS5sZXZlbDtcclxuICAgICAgICB0aGlzLmljb24uc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgaWYoZGF0YS5sZXZlbCAhPSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy90aGlzLmljb24uc2V0U3RhdGUoMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFza1NwLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuTGluZS5zZXRTdGF0ZSgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy90aGlzLmljb24uc2V0U3RhdGUoMSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFza1NwLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5MaW5lLnNldFN0YXRlKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLkxpbmUubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZihkYXRhLnN1YklkICE9IGxlbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuTGluZS5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfSBcclxuXHJcbiAgICAgICAgdGhpcy5KdWRlU2hvd1VwVGlwKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIEp1ZGVTaG93VXBUaXA6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaXNPayA9IGNjLk1nci5Vc2VyRGF0YU1nci5DYW5TaG93VXBUaXAodGhpcy5EYXRhLklkLCB0aGlzLkRhdGEuc3ViSWQsICh0aGlzLkRhdGEubGV2ZWwgKyAxKSk7XHJcbiAgICAgICAgdGhpcy5VcFRpcC5hY3RpdmUgPSBpc09rO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja09wZW5VcDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuR2xvYmFsRXZlbnQuZW1pdChjYy5NZ3IuRXZlbnQuT3BlblVwZ3JhZGVTa2lsbCwgdGhpcy5EYXRhKTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNraWxsSXRlbTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/OwnedPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2261fC2TRNHybMTckS9cQMY', 'OwnedPanel');
// Scripts/UI/OwnedPanel.js

"use strict";

var ItemType = require("ItemType");
var OwnedCarPanel = require("OwnedCarPanel");
var OwnedMatePanel = require("OwnedMatePanel");
var OwnedHousePanel = require("OwnedHousePanel");
var OwnedPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    ownedCarScroll: OwnedCarPanel,
    ownedMateScroll: OwnedMatePanel,
    ownedHouseScroll: OwnedHousePanel,
    togMate: cc.Toggle,
    togCar: cc.Toggle,
    togHouse: cc.Toggle
  },
  OpenMatePanel: function OpenMatePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.ownedMateScroll.node.active = true;
    this.ownedHouseScroll.node.active = false;
    this.ownedCarScroll.node.active = false;
    this.ownedMateScroll.ShowPanel();
  },
  OpenHousePanel: function OpenHousePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.ownedMateScroll.node.active = false;
    this.ownedHouseScroll.node.active = true;
    this.ownedCarScroll.node.active = false;
    this.ownedHouseScroll.ShowPanel();
  },
  OpenCarPanel: function OpenCarPanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.ownedMateScroll.node.active = false;
    this.ownedHouseScroll.node.active = false;
    this.ownedCarScroll.node.active = true;
    this.ownedCarScroll.ShowPanel();
  },
  ShowPanel: function ShowPanel() {
    if (this.togMate.isChecked == true) {
      this.OpenMatePanel();
    } else if (this.togHouse.isChecked == true) {
      this.OpenHousePanel();
    } else if (this.togCar.isChecked == true) {
      this.OpenCarPanel();
    }

    /*
    var carList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Car);
    for (var i = carList.length - 1; i >= 0; i--) {
        if(this.judeIsInitAndRefresh(ItemType.Car, carList[i]))
        {
            //cc.log("不用再实例化，已经有了");
        }
        else
        {
            //cc.log("实例化车子");
            var obj = cc.instantiate(this.ownedPre);
            obj.parent = this.ownedParent;
            obj.getComponent("BelongItem").init(carList[i], ItemType.Car);
        }
    }
      var houseList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.House);
    for (var i = houseList.length - 1; i >= 0; i--) {
        if(this.judeIsInitAndRefresh(ItemType.House, houseList[i]))
        {
            //cc.log("不用再实例化，已经有了");
        }
        else
        {
            //cc.log("实例化房子");
            var obj = cc.instantiate(this.ownedPre);
            obj.parent = this.ownedParent;
            obj.getComponent("BelongItem").init(houseList[i], ItemType.House);
        }
    }
      var mateList = cc.Mgr.UserDataMgr.getOwnDataListByType(ItemType.Mate);
    for (var i = mateList.length - 1; i >= 0; i--) {
        if(this.judeIsInitAndRefresh(ItemType.Mate, mateList[i]))
        {
            //cc.log("不用再实例化，已经有了");
        }
        else
        {
            //cc.log("实例化伴侣");
            var obj = cc.instantiate(this.ownedPre);
            obj.parent = this.ownedParent;
            obj.getComponent("BelongItem").init(mateList[i], ItemType.Mate);
        }
    }
    */
  },

  //判断这个 obj是否已经实例化了
  judeIsInitAndRefresh: function judeIsInitAndRefresh(itemType, data) {
    var flag = false;
    if (itemType == ItemType.Car) {
      if (data.ownNum > 0) flag = true;
    } else if (itemType == ItemType.House) {
      //cc.log("+++++++++++" + data.ownNum);
      if (data.ownNum > 0) flag = true;
    } else if (itemType == ItemType.Mate) {
      if (data.UpLv == true) flag = true;
    }
    var children = this.ownedParent.children;
    for (var i = children.length - 1; i >= 0; i--) {
      var sc = children[i].getComponent("BelongItem");
      if (sc != null) {
        if (itemType == sc.itemType && data.Id == sc.Id) {
          if (itemType == ItemType.Car || itemType == ItemType.House) {
            if (data.ownNum > 0) {
              children[i].active = true;
              sc.Refresh(data);
            } else {
              children[i].active = false;
            }
          } else if (itemType == ItemType.Mate) {
            if (data.UpLv == true) children[i].active = true;else children[i].active = false;
          }
          return true;
        }
      }
    }
    if (flag == true) return false;else return true;
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = OwnedPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXE93bmVkUGFuZWwuanMiXSwibmFtZXMiOlsiSXRlbVR5cGUiLCJyZXF1aXJlIiwiT3duZWRDYXJQYW5lbCIsIk93bmVkTWF0ZVBhbmVsIiwiT3duZWRIb3VzZVBhbmVsIiwiT3duZWRQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwib3duZWRDYXJTY3JvbGwiLCJvd25lZE1hdGVTY3JvbGwiLCJvd25lZEhvdXNlU2Nyb2xsIiwidG9nTWF0ZSIsIlRvZ2dsZSIsInRvZ0NhciIsInRvZ0hvdXNlIiwiT3Blbk1hdGVQYW5lbCIsIk1nciIsIkF1ZGlvTWdyIiwicGxheVNGWCIsIm5vZGUiLCJhY3RpdmUiLCJTaG93UGFuZWwiLCJPcGVuSG91c2VQYW5lbCIsIk9wZW5DYXJQYW5lbCIsImlzQ2hlY2tlZCIsImp1ZGVJc0luaXRBbmRSZWZyZXNoIiwiaXRlbVR5cGUiLCJkYXRhIiwiZmxhZyIsIkNhciIsIm93bk51bSIsIkhvdXNlIiwiTWF0ZSIsIlVwTHYiLCJjaGlsZHJlbiIsIm93bmVkUGFyZW50IiwiaSIsImxlbmd0aCIsInNjIiwiZ2V0Q29tcG9uZW50IiwiSWQiLCJSZWZyZXNoIiwiQ2xvc2VQYW5lbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLGFBQWEsR0FBR0QsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUM1QyxJQUFJRSxjQUFjLEdBQUdGLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztBQUM5QyxJQUFJRyxlQUFlLEdBQUdILE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztBQUVoRCxJQUFJSSxVQUFVLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3RCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1RDLGNBQWMsRUFB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QUFDa0MsSUFBSSxFQUNqQztZQUNJLElBQUdMLElBQUksQ0FBQ00sSUFBSSxJQUFJLElBQUksRUFDaEJDLFFBQVEsQ0FBQ0UsQ0FBQyxDQUFDLENBQUNoQixNQUFNLEdBQUcsSUFBSSxDQUFDLEtBRTFCYyxRQUFRLENBQUNFLENBQUMsQ0FBQyxDQUFDaEIsTUFBTSxHQUFHLEtBQUs7VUFDbEM7VUFDQSxPQUFPLElBQUk7UUFDZjtNQUNKO0lBQ0o7SUFDQSxJQUFHUSxJQUFJLElBQUksSUFBSSxFQUNYLE9BQU8sS0FBSyxDQUFDLEtBRWIsT0FBTyxJQUFJO0VBQ25CLENBQUM7RUFFRGMsVUFBVSxFQUFDLFNBQUFBLFdBQUEsRUFBVTtJQUNqQnRDLEVBQUUsQ0FBQ1ksR0FBRyxDQUFDQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0VBQzVCO0FBQ0osQ0FBQyxDQUFDO0FBQ0Z1QixNQUFNLENBQUNDLE9BQU8sR0FBR3pDLFVBQVUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtVHlwZSA9IHJlcXVpcmUoXCJJdGVtVHlwZVwiKTtcclxudmFyIE93bmVkQ2FyUGFuZWwgPSByZXF1aXJlKFwiT3duZWRDYXJQYW5lbFwiKTtcclxudmFyIE93bmVkTWF0ZVBhbmVsID0gcmVxdWlyZShcIk93bmVkTWF0ZVBhbmVsXCIpO1xyXG52YXIgT3duZWRIb3VzZVBhbmVsID0gcmVxdWlyZShcIk93bmVkSG91c2VQYW5lbFwiKTtcclxuXHJcbnZhciBPd25lZFBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgIG93bmVkQ2FyU2Nyb2xsOk93bmVkQ2FyUGFuZWwsXHJcbiAgICAgICBvd25lZE1hdGVTY3JvbGw6T3duZWRNYXRlUGFuZWwsXHJcbiAgICAgICBvd25lZEhvdXNlU2Nyb2xsOk93bmVkSG91c2VQYW5lbCxcclxuXHJcbiAgICAgICB0b2dNYXRlOmNjLlRvZ2dsZSxcclxuICAgICAgIHRvZ0NhcjpjYy5Ub2dnbGUsXHJcbiAgICAgICB0b2dIb3VzZTpjYy5Ub2dnbGUsXHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5NYXRlUGFuZWw6ZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5vd25lZE1hdGVTY3JvbGwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMub3duZWRIb3VzZVNjcm9sbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMub3duZWRDYXJTY3JvbGwubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5vd25lZE1hdGVTY3JvbGwuU2hvd1BhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIE9wZW5Ib3VzZVBhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMub3duZWRNYXRlU2Nyb2xsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vd25lZEhvdXNlU2Nyb2xsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm93bmVkQ2FyU2Nyb2xsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMub3duZWRIb3VzZVNjcm9sbC5TaG93UGFuZWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgT3BlbkNhclBhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMub3duZWRNYXRlU2Nyb2xsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vd25lZEhvdXNlU2Nyb2xsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vd25lZENhclNjcm9sbC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMub3duZWRDYXJTY3JvbGwuU2hvd1BhbmVsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy50b2dNYXRlLmlzQ2hlY2tlZCA9PSB0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5PcGVuTWF0ZVBhbmVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy50b2dIb3VzZS5pc0NoZWNrZWQgPT0gdHJ1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuT3BlbkhvdXNlUGFuZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLnRvZ0Nhci5pc0NoZWNrZWQgPT0gdHJ1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuT3BlbkNhclBhbmVsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIHZhciBjYXJMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLkNhcik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNhckxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYodGhpcy5qdWRlSXNJbml0QW5kUmVmcmVzaChJdGVtVHlwZS5DYXIsIGNhckxpc3RbaV0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIuS4jeeUqOWGjeWunuS+i+WMlu+8jOW3sue7j+acieS6hlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vY2MubG9nKFwi5a6e5L6L5YyW6L2m5a2QXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMub3duZWRQcmUpO1xyXG4gICAgICAgICAgICAgICAgb2JqLnBhcmVudCA9IHRoaXMub3duZWRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBvYmouZ2V0Q29tcG9uZW50KFwiQmVsb25nSXRlbVwiKS5pbml0KGNhckxpc3RbaV0sIEl0ZW1UeXBlLkNhcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBob3VzZUxpc3QgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0T3duRGF0YUxpc3RCeVR5cGUoSXRlbVR5cGUuSG91c2UpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBob3VzZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYodGhpcy5qdWRlSXNJbml0QW5kUmVmcmVzaChJdGVtVHlwZS5Ib3VzZSwgaG91c2VMaXN0W2ldKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCLkuI3nlKjlho3lrp7kvovljJbvvIzlt7Lnu4/mnInkuoZcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIuWunuS+i+WMluaIv+WtkFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLm93bmVkUHJlKTtcclxuICAgICAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLm93bmVkUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkJlbG9uZ0l0ZW1cIikuaW5pdChob3VzZUxpc3RbaV0sIEl0ZW1UeXBlLkhvdXNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1hdGVMaXN0ID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldE93bkRhdGFMaXN0QnlUeXBlKEl0ZW1UeXBlLk1hdGUpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBtYXRlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmp1ZGVJc0luaXRBbmRSZWZyZXNoKEl0ZW1UeXBlLk1hdGUsIG1hdGVMaXN0W2ldKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9jYy5sb2coXCLkuI3nlKjlho3lrp7kvovljJbvvIzlt7Lnu4/mnInkuoZcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL2NjLmxvZyhcIuWunuS+i+WMluS8tOS+o1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYy5pbnN0YW50aWF0ZSh0aGlzLm93bmVkUHJlKTtcclxuICAgICAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLm93bmVkUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgb2JqLmdldENvbXBvbmVudChcIkJlbG9uZ0l0ZW1cIikuaW5pdChtYXRlTGlzdFtpXSwgSXRlbVR5cGUuTWF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgIH0sXHJcblxyXG4gICAgLy/liKTmlq3ov5nkuKogb2Jq5piv5ZCm5bey57uP5a6e5L6L5YyW5LqGXHJcbiAgICBqdWRlSXNJbml0QW5kUmVmcmVzaDpmdW5jdGlvbihpdGVtVHlwZSxkYXRhKXtcclxuICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmKGl0ZW1UeXBlID09IEl0ZW1UeXBlLkNhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmKGRhdGEub3duTnVtID4gMClcclxuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGl0ZW1UeXBlID09IEl0ZW1UeXBlLkhvdXNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCIrKysrKysrKysrK1wiICsgZGF0YS5vd25OdW0pO1xyXG4gICAgICAgICAgICBpZihkYXRhLm93bk51bSA+IDApXHJcbiAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihpdGVtVHlwZSA9PSBJdGVtVHlwZS5NYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYoZGF0YS5VcEx2ID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMub3duZWRQYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IFxyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJCZWxvbmdJdGVtXCIpO1xyXG4gICAgICAgICAgICBpZihzYyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihpdGVtVHlwZSA9PSBzYy5pdGVtVHlwZSAmJiBkYXRhLklkID09IHNjLklkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW1UeXBlID09IEl0ZW1UeXBlLkNhciB8fCBpdGVtVHlwZSA9PSBJdGVtVHlwZS5Ib3VzZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGEub3duTnVtID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLlJlZnJlc2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGl0ZW1UeXBlID09IEl0ZW1UeXBlLk1hdGUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhLlVwTHYgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmbGFnID09IHRydWUpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LCAgXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE93bmVkUGFuZWw7Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/StartUpPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '50b1fERmNlNX52By1S1GCzm', 'StartUpPanel');
// Scripts/UI/StartUpPanel.js

"use strict";

var StartUpPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    title: cc.Label,
    desLbl: cc.Label,
    costLbl: cc.Label,
    iconSp: cc.Sprite,
    cost: cc.Integer
  },
  ShowPanel: function ShowPanel(data) {
    this.title.string = data.name;
    this.desLbl.string = "升级" + data.name + "****";
    //this.iconSp.spriteFrame = ;
    var cost = cc.Mgr.MapDataMgr.getUpgradeCostByTwoId(data.Id, data.subId, data.toLv);
    this.costLbl.string = cost;
    this.cost = cost;
  },
  ClosePanel: function ClosePanel() {
    this.node.active = false;
  },
  ClickUpgrade: function ClickUpgrade() {}
});
module.exports = StartUpPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFN0YXJ0VXBQYW5lbC5qcyJdLCJuYW1lcyI6WyJTdGFydFVwUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsInRpdGxlIiwiTGFiZWwiLCJkZXNMYmwiLCJjb3N0TGJsIiwiaWNvblNwIiwiU3ByaXRlIiwiY29zdCIsIkludGVnZXIiLCJTaG93UGFuZWwiLCJkYXRhIiwic3RyaW5nIiwibmFtZSIsIk1nciIsIk1hcERhdGFNZ3IiLCJnZXRVcGdyYWRlQ29zdEJ5VHdvSWQiLCJJZCIsInN1YklkIiwidG9MdiIsIkNsb3NlUGFuZWwiLCJub2RlIiwiYWN0aXZlIiwiQ2xpY2tVcGdyYWRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxJQUFJQSxZQUFZLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO0VBQ3hCLFdBQVNELEVBQUUsQ0FBQ0UsU0FBUztFQUVyQkMsVUFBVSxFQUFFO0lBQ1JDLEtBQUssRUFBQ0osRUFBRSxDQUFDSyxLQUFLO0lBQ2RDLE1BQU0sRUFBQ04sRUFBRSxDQUFDSyxLQUFLO0lBQ2ZFLE9BQU8sRUFBQ1AsRUFBRSxDQUFDSyxLQUFLO0lBQ2hCRyxNQUFNLEVBQUNSLEVBQUUsQ0FBQ1MsTUFBTTtJQUNoQkMsSUFBSSxFQUFDVixFQUFFLENBQUNXO0VBQ1osQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBVUMsSUFBSSxFQUFFO0lBQ3RCLElBQUksQ0FBQ1QsS0FBSyxDQUFDVSxNQUFNLEdBQUdELElBQUksQ0FBQ0UsSUFBSTtJQUM3QixJQUFJLENBQUNULE1BQU0sQ0FBQ1EsTUFBTSxHQUFHLElBQUksR0FBQ0QsSUFBSSxDQUFDRSxJQUFJLEdBQUMsTUFBTTtJQUMxQztJQUNBLElBQUlMLElBQUksR0FBR1YsRUFBRSxDQUFDZ0IsR0FBRyxDQUFDQyxVQUFVLENBQUNDLHFCQUFxQixDQUFDTCxJQUFJLENBQUNNLEVBQUUsRUFBRU4sSUFBSSxDQUFDTyxLQUFLLEVBQUVQLElBQUksQ0FBQ1EsSUFBSSxDQUFDO0lBQ2xGLElBQUksQ0FBQ2QsT0FBTyxDQUFDTyxNQUFNLEdBQUdKLElBQUk7SUFDMUIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLElBQUk7RUFDcEIsQ0FBQztFQUVEWSxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ2pCLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztFQUM1QixDQUFDO0VBRURDLFlBQVksRUFBQyxTQUFBQSxhQUFBLEVBQVUsQ0FFdkI7QUFFSixDQUFDLENBQUM7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUc1QixZQUFZIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIFN0YXJ0VXBQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgdGl0bGU6Y2MuTGFiZWwsXHJcbiAgICAgICAgZGVzTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIGNvc3RMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgaWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBjb3N0OmNjLkludGVnZXIsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMudGl0bGUuc3RyaW5nID0gZGF0YS5uYW1lO1xyXG4gICAgICAgIHRoaXMuZGVzTGJsLnN0cmluZyA9IFwi5Y2H57qnXCIrZGF0YS5uYW1lK1wiKioqKlwiO1xyXG4gICAgICAgIC8vdGhpcy5pY29uU3Auc3ByaXRlRnJhbWUgPSA7XHJcbiAgICAgICAgdmFyIGNvc3QgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXRVcGdyYWRlQ29zdEJ5VHdvSWQoZGF0YS5JZCwgZGF0YS5zdWJJZCwgZGF0YS50b0x2KTtcclxuICAgICAgICB0aGlzLmNvc3RMYmwuc3RyaW5nID0gY29zdDtcclxuICAgICAgICB0aGlzLmNvc3QgPSBjb3N0O1xyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja1VwZ3JhZGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBTdGFydFVwUGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/SkillUpPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'abd95Irad5B94St4fgii0Dd', 'SkillUpPanel');
// Scripts/UI/SkillUpPanel.js

"use strict";

var SkillPanel = require("SkillPanel");
var ItemType = require("ItemType");
var SkillUpPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    skillPanel: SkillPanel,
    titleLbl: cc.Label,
    Data: null,
    DesNull: cc.Label,
    DesNormal: cc.Node,
    des1: cc.Label,
    des2: cc.Label,
    costLbl: cc.Label
  },
  ShowPanel: function ShowPanel(data) {
    this.Data = null;
    this.Data = data;
    this.titleLbl.string = data.name;
    //cc.log("草泥马哦" + this.Data.level);
    if (data.Uplv == data.level) {
      this.DesNull.node.active = true;
      this.DesNormal.active = false;
      this.DesNull.string = cc.Mgr.global.getTranslation("Tf_" + data.desId) + "\n技能已升至满级";
    } else {
      this.DesNull.node.active = false;
      this.DesNormal.active = true;
      var bonuscur = cc.Mgr.MapDataMgr.getSkillAddBonusByTwoIdAndLv(data.Id, data.subId, data.level);
      var bonusnext = cc.Mgr.MapDataMgr.getSkillAddBonusByTwoIdAndLv(data.Id, data.subId, data.level + 1);
      this.des1.string = cc.Mgr.global.getTranslation("Tf_" + data.desId);
      this.costLbl.string = cc.Mgr.MapDataMgr.getUpgradeCostByTwoId(data.Id, data.subId, data.level + 1);
      if (data.level == 0) {
        this.des1.string = cc.Mgr.global.getTranslation("Tf_" + data.desId);
        if (bonusnext < 1) this.des2.string = bonusnext * 100 + "%";else this.des2.string = bonusnext;
      } else {
        if (bonusnext < 1) this.des2.string = bonuscur * 100 + "% - " + bonusnext * 100;else this.des2.string = bonuscur + "—" + bonusnext;
      }
    }
  },
  ClickUpGrade: function ClickUpGrade() {
    if (this.Data.Uplv == this.Data.level) {
      this.ClosePanel();
      return;
    }
    var re = cc.Mgr.UserDataMgr.UpGradeSkill(this.Data.Id, this.Data.subId, this.Data.level + 1);
    if (re == false) {
      cc.Mgr.AudioMgr.playSFX("click");
      this.DesNull.node.active = true;
      this.DesNormal.active = false;
      this.DesNull.string = "升级技能失败\n(技能点不足或者未点亮上一个天赋)";
    } else {
      this.skillPanel.RefreshPanel();
      //cc.Mgr.UserDataMgr.SkillBonusPoint -= cc.Mgr.MapDataMgr.getUpgradeCostByTwoId(this.Data.Id, this.Data.subId, (this.Data.level + 1));
      this.ClosePanel();
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = SkillUpPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFNraWxsVXBQYW5lbC5qcyJdLCJuYW1lcyI6WyJTa2lsbFBhbmVsIiwicmVxdWlyZSIsIkl0ZW1UeXBlIiwiU2tpbGxVcFBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJza2lsbFBhbmVsIiwidGl0bGVMYmwiLCJMYWJlbCIsIkRhdGEiLCJEZXNOdWxsIiwiRGVzTm9ybWFsIiwiTm9kZSIsImRlczEiLCJkZXMyIiwiY29zdExibCIsIlNob3dQYW5lbCIsImRhdGEiLCJzdHJpbmciLCJuYW1lIiwiVXBsdiIsImxldmVsIiwibm9kZSIsImFjdGl2ZSIsIk1nciIsImdsb2JhbCIsImdldFRyYW5zbGF0aW9uIiwiZGVzSWQiLCJib251c2N1ciIsIk1hcERhdGFNZ3IiLCJnZXRTa2lsbEFkZEJvbnVzQnlUd29JZEFuZEx2IiwiSWQiLCJzdWJJZCIsImJvbnVzbmV4dCIsImdldFVwZ3JhZGVDb3N0QnlUd29JZCIsIkNsaWNrVXBHcmFkZSIsIkNsb3NlUGFuZWwiLCJyZSIsIlVzZXJEYXRhTWdyIiwiVXBHcmFkZVNraWxsIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwiUmVmcmVzaFBhbmVsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxVQUFVLEdBQUdDLE9BQU8sQ0FBQyxZQUFZLENBQUM7QUFDdEMsSUFBSUMsUUFBUSxHQUFHRCxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlFLFlBQVksR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDeEIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsVUFBVSxFQUFDUixVQUFVO0lBQ3JCUyxRQUFRLEVBQUNMLEVBQUUsQ0FBQ00sS0FBSztJQUNqQkMsSUFBSSxFQUFDLElBQUk7SUFDVEMsT0FBTyxFQUFDUixFQUFFLENBQUNNLEtBQUs7SUFDaEJH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QUNuQixJQUFHLElBQUksQ0FBQzFCLElBQUksQ0FBQ1csSUFBSSxJQUFJLElBQUksQ0FBQ1gsSUFBSSxDQUFDWSxLQUFLLEVBQ3BDO01BQ0ksSUFBSSxDQUFDZSxVQUFVLEVBQUU7TUFDakI7SUFDSjtJQUVBLElBQUlDLEVBQUUsR0FBR25DLEVBQUUsQ0FBQ3NCLEdBQUcsQ0FBQ2MsV0FBVyxDQUFDQyxZQUFZLENBQUMsSUFBSSxDQUFDOUIsSUFBSSxDQUFDc0IsRUFBRSxFQUFFLElBQUksQ0FBQ3RCLElBQUksQ0FBQ3VCLEtBQUssRUFBRyxJQUFJLENBQUN2QixJQUFJLENBQUNZLEtBQUssR0FBRyxDQUFDLENBQUU7SUFDOUYsSUFBR2dCLEVBQUUsSUFBSSxLQUFLLEVBQ2Q7TUFDSW5DLEVBQUUsQ0FBQ3NCLEdBQUcsQ0FBQ2dCLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQztNQUNoQyxJQUFJLENBQUMvQixPQUFPLENBQUNZLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUk7TUFDL0IsSUFBSSxDQUFDWixTQUFTLENBQUNZLE1BQU0sR0FBRyxLQUFLO01BQzdCLElBQUksQ0FBQ2IsT0FBTyxDQUFDUSxNQUFNLEdBQUcsMkJBQTJCO0lBQ3JELENBQUMsTUFFRDtNQUNJLElBQUksQ0FBQ1osVUFBVSxDQUFDb0MsWUFBWSxFQUFFO01BQzlCO01BQ0EsSUFBSSxDQUFDTixVQUFVLEVBQUU7SUFDckI7RUFFSixDQUFDO0VBRURBLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQVU7SUFDakJsQyxFQUFFLENBQUNzQixHQUFHLENBQUNnQixRQUFRLENBQUNDLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEMsSUFBSSxDQUFDbkIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztFQUM1QjtBQUNKLENBQUMsQ0FBQztBQUNGb0IsTUFBTSxDQUFDQyxPQUFPLEdBQUczQyxZQUFZIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU2tpbGxQYW5lbCA9IHJlcXVpcmUoXCJTa2lsbFBhbmVsXCIpO1xyXG52YXIgSXRlbVR5cGUgPSByZXF1aXJlKFwiSXRlbVR5cGVcIik7XHJcbnZhciBTa2lsbFVwUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHNraWxsUGFuZWw6U2tpbGxQYW5lbCxcclxuICAgICAgICB0aXRsZUxibDpjYy5MYWJlbCxcclxuICAgICAgICBEYXRhOm51bGwsXHJcbiAgICAgICAgRGVzTnVsbDpjYy5MYWJlbCxcclxuICAgICAgICBEZXNOb3JtYWw6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgZGVzMTpjYy5MYWJlbCxcclxuICAgICAgICBkZXMyOmNjLkxhYmVsLFxyXG4gICAgICAgIGNvc3RMYmw6Y2MuTGFiZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLkRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy50aXRsZUxibC5zdHJpbmcgPSBkYXRhLm5hbWU7XHJcbiAgICAgICAgLy9jYy5sb2coXCLojYnms6Xpqazlk6ZcIiArIHRoaXMuRGF0YS5sZXZlbCk7XHJcbiAgICAgICAgaWYoZGF0YS5VcGx2ID09IGRhdGEubGV2ZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkRlc051bGwubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkRlc05vcm1hbC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5EZXNOdWxsLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJUZl9cIitkYXRhLmRlc0lkKSsgXCJcXG7mioDog73lt7LljYfoh7Pmu6HnuqdcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5EZXNOdWxsLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuRGVzTm9ybWFsLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBib251c2N1ciA9IGNjLk1nci5NYXBEYXRhTWdyLmdldFNraWxsQWRkQm9udXNCeVR3b0lkQW5kTHYoZGF0YS5JZCwgZGF0YS5zdWJJZCwgZGF0YS5sZXZlbCk7XHJcbiAgICAgICAgICAgIHZhciBib251c25leHQgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXRTa2lsbEFkZEJvbnVzQnlUd29JZEFuZEx2KGRhdGEuSWQsIGRhdGEuc3ViSWQsIChkYXRhLmxldmVsKzEpKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuZGVzMS5zdHJpbmcgPSBjYy5NZ3IuZ2xvYmFsLmdldFRyYW5zbGF0aW9uKFwiVGZfXCIrZGF0YS5kZXNJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29zdExibC5zdHJpbmcgPSBjYy5NZ3IuTWFwRGF0YU1nci5nZXRVcGdyYWRlQ29zdEJ5VHdvSWQoZGF0YS5JZCwgZGF0YS5zdWJJZCwgKGRhdGEubGV2ZWwgKyAxKSk7XHJcbiAgICAgICAgICAgIGlmKGRhdGEubGV2ZWwgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXMxLnN0cmluZyA9IGNjLk1nci5nbG9iYWwuZ2V0VHJhbnNsYXRpb24oXCJUZl9cIitkYXRhLmRlc0lkKTtcclxuICAgICAgICAgICAgICAgIGlmKGJvbnVzbmV4dCA8IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXMyLnN0cmluZyA9IChib251c25leHQgKiAxMDApICsgXCIlXCI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXMyLnN0cmluZyA9IGJvbnVzbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGJvbnVzbmV4dCA8IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXMyLnN0cmluZyA9IChib251c2N1ciAqIDEwMCkgKyBcIiUgLSBcIiArIChib251c25leHQgKiAxMDApO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzMi5zdHJpbmcgPSBib251c2N1ciArXCLigJRcIitib251c25leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrVXBHcmFkZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuRGF0YS5VcGx2ID09IHRoaXMuRGF0YS5sZXZlbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuQ2xvc2VQYW5lbCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmUgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuVXBHcmFkZVNraWxsKHRoaXMuRGF0YS5JZCwgdGhpcy5EYXRhLnN1YklkLCAodGhpcy5EYXRhLmxldmVsICsgMSkpO1xyXG4gICAgICAgIGlmKHJlID09IGZhbHNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICAgICAgdGhpcy5EZXNOdWxsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5EZXNOb3JtYWwuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuRGVzTnVsbC5zdHJpbmcgPSBcIuWNh+e6p+aKgOiDveWksei0pVxcbijmioDog73ngrnkuI3otrPmiJbogIXmnKrngrnkuq7kuIrkuIDkuKrlpKnotYspXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpbGxQYW5lbC5SZWZyZXNoUGFuZWwoKTtcclxuICAgICAgICAgICAgLy9jYy5NZ3IuVXNlckRhdGFNZ3IuU2tpbGxCb251c1BvaW50IC09IGNjLk1nci5NYXBEYXRhTWdyLmdldFVwZ3JhZGVDb3N0QnlUd29JZCh0aGlzLkRhdGEuSWQsIHRoaXMuRGF0YS5zdWJJZCwgKHRoaXMuRGF0YS5sZXZlbCArIDEpKTtcclxuICAgICAgICAgICAgdGhpcy5DbG9zZVBhbmVsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gU2tpbGxVcFBhbmVsO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/SkillPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9414ep1VQNEB67ZE0tH76tF', 'SkillPanel');
// Scripts/UI/SkillPanel.js

"use strict";

var AdsParam = require("AdsParam");
var CommonTipPanel = require("CommonTipPanel");
var SkillPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    skillParent_1: cc.Node,
    skillParent_2: cc.Node,
    skillParent_3: cc.Node,
    skillParent_4: cc.Node,
    itemPre: cc.Prefab,
    SkillPointLbl: cc.Label,
    CommonTip: CommonTipPanel
  },
  InitPanel: function InitPanel() {
    var list_1 = cc.Mgr.UserDataMgr.getSkillListById(1);
    var list_2 = cc.Mgr.UserDataMgr.getSkillListById(2);
    var list_3 = cc.Mgr.UserDataMgr.getSkillListById(3);
    var list_4 = cc.Mgr.UserDataMgr.getSkillListById(4);
    for (var i = list_1.length - 1; i >= 0; i--) {
      var data = list_1[i];
      var obj = cc.instantiate(this.itemPre);
      obj.parent = this.skillParent_1;
      obj.active = true;
      obj.getComponent("SkillItem").ShowData(data, list_1.length);
    }
    for (var i = list_2.length - 1; i >= 0; i--) {
      var data = list_2[i];
      var obj = cc.instantiate(this.itemPre);
      obj.parent = this.skillParent_2;
      obj.active = true;
      obj.getComponent("SkillItem").ShowData(data, list_2.length);
    }
    for (var i = list_3.length - 1; i >= 0; i--) {
      var data = list_3[i];
      var obj = cc.instantiate(this.itemPre);
      obj.parent = this.skillParent_3;
      obj.active = true;
      obj.getComponent("SkillItem").ShowData(data, list_3.length);
    }
    for (var i = list_4.length - 1; i >= 0; i--) {
      var data = list_4[i];
      var obj = cc.instantiate(this.itemPre);
      obj.parent = this.skillParent_4;
      obj.active = true;
      obj.getComponent("SkillItem").ShowData(data, list_4.length);
    }
  },
  RefreshPanel: function RefreshPanel() {
    this.SkillPointLbl.string = cc.Mgr.UserDataMgr.SkillBonusPoint;
    var children_1 = this.skillParent_1.children;
    var children_2 = this.skillParent_2.children;
    var children_3 = this.skillParent_3.children;
    var children_4 = this.skillParent_4.children;
    var list_1 = cc.Mgr.UserDataMgr.getSkillListById(1);
    var list_2 = cc.Mgr.UserDataMgr.getSkillListById(2);
    var list_3 = cc.Mgr.UserDataMgr.getSkillListById(3);
    var list_4 = cc.Mgr.UserDataMgr.getSkillListById(4);
    for (var i = children_1.length - 1; i >= 0; i--) {
      var sc = children_1[i].getComponent("SkillItem");
      if (sc != null) {
        if (list_1[list_1.length - i - 1] != null) {
          sc.ShowData(list_1[list_1.length - i - 1], list_1.length);
        }
      }
    }
    for (var i = children_2.length - 1; i >= 0; i--) {
      var sc = children_2[i].getComponent("SkillItem");
      if (sc != null) {
        if (list_2[list_2.length - i - 1] != null) {
          sc.ShowData(list_2[list_2.length - i - 1], list_2.length);
        }
      }
    }
    for (var i = children_3.length - 1; i >= 0; i--) {
      var sc = children_3[i].getComponent("SkillItem");
      if (sc != null) {
        if (list_3[list_3.length - i - 1] != null) {
          sc.ShowData(list_3[list_3.length - i - 1], list_3.length);
        }
      }
    }
    for (var i = children_4.length - 1; i >= 0; i--) {
      var sc = children_4[i].getComponent("SkillItem");
      if (sc != null) {
        if (list_4[list_4.length - i - 1] != null) {
          sc.ShowData(list_4[list_4.length - i - 1], list_4.length);
        }
      }
    }
  },
  ShowPanel: function ShowPanel() {
    var children = this.skillParent_1.children;
    this.SkillPointLbl.string = cc.Mgr.UserDataMgr.SkillBonusPoint;
    if (children.length == 0) {
      //cc.log("第一次初始化");
      this.InitPanel();
    } else {
      //cc.log("刷新============");
      this.RefreshPanel();
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    cc.Mgr.UserDataMgr.SaveUserData();
    cc.Mgr.UserDataMgr.initData();
    this.node.active = false;
  },
  ShowAds: function ShowAds() {
    cc.Mgr.AudioMgr.playSFX("click");
    if (cc.Mgr.UserDataMgr.VideoAdsTimes >= 3) {
      this.CommonTip.node.active = true;
      var param = {};
      param.text = "今天的广告次数已经用完。明天再来";
      var testDate = new Date();
      cc.Mgr.UserDataMgr.VideoLastTime = testDate.toDateString();
      this.CommonTip.ShowPanel(param);
    } else {
      var self = this;
      cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointA, function (out) {
        if (out == 0) {
          cc.Mgr.UserDataMgr.SkillBonusPoint += 150;
          cc.Mgr.UserDataMgr.VideoAdsTimes += 1;
          self.RefreshPanel();
          self.SkillPointLbl.string = cc.Mgr.UserDataMgr.SkillBonusPoint;
        } else {
          console.log("视频广告没有看完或者加载出错");
        }
      });
    }

    //this.CommonTip.node.active = true;
    //var param = {};
    //param.text = "目前广告还未开放，敬请期待";
    //this.CommonTip.ShowPanel(param);
  }
});

module.exports = SkillPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFNraWxsUGFuZWwuanMiXSwibmFtZXMiOlsiQWRzUGFyYW0iLCJyZXF1aXJlIiwiQ29tbW9uVGlwUGFuZWwiLCJTa2lsbFBhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJza2lsbFBhcmVudF8xIiwiTm9kZSIsInNraWxsUGFyZW50XzIiLCJza2lsbFBhcmVudF8zIiwic2tpbGxQYXJlbnRfNCIsIml0ZW1QcmUiLCJQcmVmYWIiLCJTa2lsbFBvaW50TGJsIiwiTGFiZWwiLCJDb21tb25UaXAiLCJJbml0UGFuZWwiLCJsaXN0XzEiLCJNZ3IiLCJVc2VyRGF0YU1nciIsImdldFNraWxsTGlzdEJ5SWQiLCJsaXN0XzIiLCJsaXN0XzMiLCJsaXN0XzQiLCJpIiwibGVuZ3RoIiwiZGF0YSIsIm9iaiIsImluc3RhbnRpYXRlIiwicGFyZW50IiwiYWN0aXZlIiwiZ2V0Q29tcG9uZW50IiwiU2hvd0RhdGEiLCJSZWZyZXNoUGFuZWwiLCJzdHJpbmciLCJTa2lsbEJvbnVzUG9pbnQiLCJjaGlsZHJlbl8xIiwiY2hpbGRyZW4iLCJjaGlsZHJlbl8yIiwiY2hpbGRyZW5fMyIsImNoaWxkcmVuXzQiLCJzYyIsIlNob3dQYW5lbCIsIkNsb3NlUGFuZWwiLCJBdWRpb01nciIsInBsYXlTRlgiLCJTYXZlVXNlckRhdGEiLCJpbml0RGF0YSIsIm5vZGUiLCJTaG93QWRzIiwiVmlkZW9BZHNUaW1lcyIsInBhcmFtIiwidGV4dCIsInRlc3REYXRlIiwiRGF0ZSIsIlZpZGVvTGFzdFRpbWUiLCJ0b0RhdGVTdHJpbmciLCJzZWxmIiwiQWRzTWdyIiwiU2hvd1ZpZGVvQWRzIiwiUG9pbnRBIiwib3V0IiwiY29uc29sZSIsImxvZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlD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QUUsQ0FBQ2dCLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDb0MsYUFBYSxHQUFHRixRQUFRLENBQUNHLFlBQVksRUFBRTtNQUMxRCxJQUFJLENBQUN6QyxTQUFTLENBQUMyQixTQUFTLENBQUNTLEtBQUssQ0FBQztJQUNuQyxDQUFDLE1BRUQ7TUFDSSxJQUFJTSxJQUFJLEdBQUcsSUFBSTtNQUNmdkQsRUFBRSxDQUFDZ0IsR0FBRyxDQUFDd0MsTUFBTSxDQUFDQyxZQUFZLENBQUM3RCxRQUFRLENBQUM4RCxNQUFNLEVBQUUsVUFBU0MsR0FBRyxFQUFDO1FBQ3JELElBQUdBLEdBQUcsSUFBSSxDQUFDLEVBQ1g7VUFDSTNELEVBQUUsQ0FBQ2dCLEdBQUcsQ0FBQ0MsV0FBVyxDQUFDZ0IsZUFBZSxJQUFJLEdBQUc7VUFDekNqQyxFQUFFLENBQUNnQixHQUFHLENBQUNDLFdBQVcsQ0FBQytCLGFBQWEsSUFBSSxDQUFDO1VBQ3JDTyxJQUFJLENBQUN4QixZQUFZLEVBQUU7VUFDbkJ3QixJQUFJLENBQUM1QyxhQUFhLENBQUNxQixNQUFNLEdBQUdoQyxFQUFFLENBQUNnQixHQUFHLENBQUNDLFdBQVcsQ0FBQ2dCLGVBQWU7UUFDbEUsQ0FBQyxNQUVEO1VBQ0kyQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQztRQUNqQztNQUNKLENBQUMsQ0FBQztJQUVOOztJQUdBO0lBQ0E7SUFDQTtJQUNBO0VBQ0o7QUFFSixDQUFDLENBQUM7O0FBQ0ZDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHaEUsVUFBVSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEFkc1BhcmFtID0gcmVxdWlyZShcIkFkc1BhcmFtXCIpO1xyXG52YXIgQ29tbW9uVGlwUGFuZWwgPSByZXF1aXJlKFwiQ29tbW9uVGlwUGFuZWxcIik7XHJcbnZhciBTa2lsbFBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBza2lsbFBhcmVudF8xOmNjLk5vZGUsXHJcbiAgICAgICAgc2tpbGxQYXJlbnRfMjpjYy5Ob2RlLFxyXG4gICAgICAgIHNraWxsUGFyZW50XzM6Y2MuTm9kZSxcclxuICAgICAgICBza2lsbFBhcmVudF80OmNjLk5vZGUsXHJcblxyXG4gICAgICAgIGl0ZW1QcmU6Y2MuUHJlZmFiLFxyXG5cclxuICAgICAgICBTa2lsbFBvaW50TGJsOmNjLkxhYmVsLFxyXG5cclxuICAgICAgICBDb21tb25UaXA6Q29tbW9uVGlwUGFuZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIEluaXRQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBsaXN0XzEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0U2tpbGxMaXN0QnlJZCgxKTtcclxuICAgICAgICB2YXIgbGlzdF8yID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldFNraWxsTGlzdEJ5SWQoMik7XHJcbiAgICAgICAgdmFyIGxpc3RfMyA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRTa2lsbExpc3RCeUlkKDMpO1xyXG4gICAgICAgIHZhciBsaXN0XzQgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0U2tpbGxMaXN0QnlJZCg0KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3RfMS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGxpc3RfMVtpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuaXRlbVByZSk7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLnNraWxsUGFyZW50XzE7XHJcbiAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBvYmouZ2V0Q29tcG9uZW50KFwiU2tpbGxJdGVtXCIpLlNob3dEYXRhKGRhdGEsIGxpc3RfMS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3RfMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGxpc3RfMltpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuaXRlbVByZSk7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLnNraWxsUGFyZW50XzI7XHJcbiAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBvYmouZ2V0Q29tcG9uZW50KFwiU2tpbGxJdGVtXCIpLlNob3dEYXRhKGRhdGEsIGxpc3RfMi5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3RfMy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGxpc3RfM1tpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuaXRlbVByZSk7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLnNraWxsUGFyZW50XzM7XHJcbiAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBvYmouZ2V0Q29tcG9uZW50KFwiU2tpbGxJdGVtXCIpLlNob3dEYXRhKGRhdGEsIGxpc3RfMy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3RfNC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGxpc3RfNFtpXTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGNjLmluc3RhbnRpYXRlKHRoaXMuaXRlbVByZSk7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzLnNraWxsUGFyZW50XzQ7XHJcbiAgICAgICAgICAgIG9iai5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBvYmouZ2V0Q29tcG9uZW50KFwiU2tpbGxJdGVtXCIpLlNob3dEYXRhKGRhdGEsIGxpc3RfNC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgUmVmcmVzaFBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5Ta2lsbFBvaW50TGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5Ta2lsbEJvbnVzUG9pbnQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNoaWxkcmVuXzEgPSB0aGlzLnNraWxsUGFyZW50XzEuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuXzIgPSB0aGlzLnNraWxsUGFyZW50XzIuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuXzMgPSB0aGlzLnNraWxsUGFyZW50XzMuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuXzQgPSB0aGlzLnNraWxsUGFyZW50XzQuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIHZhciBsaXN0XzEgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0U2tpbGxMaXN0QnlJZCgxKTtcclxuICAgICAgICB2YXIgbGlzdF8yID0gY2MuTWdyLlVzZXJEYXRhTWdyLmdldFNraWxsTGlzdEJ5SWQoMik7XHJcbiAgICAgICAgdmFyIGxpc3RfMyA9IGNjLk1nci5Vc2VyRGF0YU1nci5nZXRTa2lsbExpc3RCeUlkKDMpO1xyXG4gICAgICAgIHZhciBsaXN0XzQgPSBjYy5NZ3IuVXNlckRhdGFNZ3IuZ2V0U2tpbGxMaXN0QnlJZCg0KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuXzEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIHNjID0gY2hpbGRyZW5fMVtpXS5nZXRDb21wb25lbnQoXCJTa2lsbEl0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGxpc3RfMVtsaXN0XzEubGVuZ3RoIC0gaSAtIDFdICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2MuU2hvd0RhdGEobGlzdF8xW2xpc3RfMS5sZW5ndGggLSBpIC0gMV0sIGxpc3RfMS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW5fMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgc2MgPSBjaGlsZHJlbl8yW2ldLmdldENvbXBvbmVudChcIlNraWxsSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYoc2MgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYobGlzdF8yW2xpc3RfMi5sZW5ndGggLSBpIC0gMV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzYy5TaG93RGF0YShsaXN0XzJbbGlzdF8yLmxlbmd0aCAtIGkgLSAxXSwgbGlzdF8yLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbl8zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBzYyA9IGNoaWxkcmVuXzNbaV0uZ2V0Q29tcG9uZW50KFwiU2tpbGxJdGVtXCIpO1xyXG4gICAgICAgICAgICBpZihzYyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihsaXN0XzNbbGlzdF8zLmxlbmd0aCAtIGkgLSAxXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjLlNob3dEYXRhKGxpc3RfM1tsaXN0XzMubGVuZ3RoIC0gaSAtIDFdLCBsaXN0XzMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuXzQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIHNjID0gY2hpbGRyZW5fNFtpXS5nZXRDb21wb25lbnQoXCJTa2lsbEl0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmKHNjICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKGxpc3RfNFtsaXN0XzQubGVuZ3RoIC0gaSAtIDFdICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2MuU2hvd0RhdGEobGlzdF80W2xpc3RfNC5sZW5ndGggLSBpIC0gMV0sIGxpc3RfNC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnNraWxsUGFyZW50XzEuY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5Ta2lsbFBvaW50TGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5Ta2lsbEJvbnVzUG9pbnQ7XHJcbiAgICAgICAgaWYoY2hpbGRyZW4ubGVuZ3RoID09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2NjLmxvZyhcIuesrOS4gOasoeWIneWni+WMllwiKTtcclxuICAgICAgICAgICAgdGhpcy5Jbml0UGFuZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCLliLfmlrA9PT09PT09PT09PT1cIik7XHJcbiAgICAgICAgICAgIHRoaXMuUmVmcmVzaFBhbmVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuTWdyLkF1ZGlvTWdyLnBsYXlTRlgoXCJjbGlja1wiKTtcclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuU2F2ZVVzZXJEYXRhKCk7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLmluaXREYXRhKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBTaG93QWRzOmZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgICAgICBjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5WaWRlb0Fkc1RpbWVzID49IDMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkNvbW1vblRpcC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLku4rlpKnnmoTlub/lkYrmrKHmlbDlt7Lnu4/nlKjlrozjgILmmI7lpKnlho3mnaVcIjtcclxuICAgICAgICAgICAgdmFyIHRlc3REYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLlZpZGVvTGFzdFRpbWUgPSB0ZXN0RGF0ZS50b0RhdGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5Db21tb25UaXAuU2hvd1BhbmVsKHBhcmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBjYy5NZ3IuQWRzTWdyLlNob3dWaWRlb0FkcyhBZHNQYXJhbS5Qb2ludEEsIGZ1bmN0aW9uKG91dCl7XHJcbiAgICAgICAgICAgICAgICBpZihvdXQgPT0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuU2tpbGxCb251c1BvaW50ICs9IDE1MDtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuVmlkZW9BZHNUaW1lcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuUmVmcmVzaFBhbmVsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5Ta2lsbFBvaW50TGJsLnN0cmluZyA9IGNjLk1nci5Vc2VyRGF0YU1nci5Ta2lsbEJvbnVzUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLop4bpopHlub/lkYrmsqHmnInnnIvlrozmiJbogIXliqDovb3lh7rplJlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vdGhpcy5Db21tb25UaXAubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIC8vdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgLy9wYXJhbS50ZXh0ID0gXCLnm67liY3lub/lkYrov5jmnKrlvIDmlL7vvIzmlazor7fmnJ/lvoVcIjtcclxuICAgICAgICAvL3RoaXMuQ29tbW9uVGlwLlNob3dQYW5lbChwYXJhbSk7XHJcbiAgICB9LFxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gU2tpbGxQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/TimePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '575c9fQPihMwrEcUY5hj7SP', 'TimePanel');
// Scripts/UI/TimePanel.js

"use strict";

var TimePanel = cc.Class({
  "extends": cc.Component,
  properties: {
    ClockAnima: cc.Animation
  },
  PlayAnima: function PlayAnima() {
    this.ClockAnima.play("Clock");
  },
  ClockEnd: function ClockEnd() {
    this.node.active = false;
    cc.director.GlobalEvent.emit(cc.Mgr.Event.ClockEnd, {});
    //cc.log("闹钟结束======================================");
  }
});

module.exports = TimePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFRpbWVQYW5lbC5qcyJdLCJuYW1lcyI6WyJUaW1lUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkNsb2NrQW5pbWEiLCJBbmltYXRpb24iLCJQbGF5QW5pbWEiLCJwbGF5IiwiQ2xvY2tFbmQiLCJub2RlIiwiYWN0aXZlIiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJNZ3IiLCJFdmVudCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBSUEsU0FBUyxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUNyQixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxVQUFVLEVBQUNKLEVBQUUsQ0FBQ0s7RUFDbEIsQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFVO0lBQ2hCLElBQUksQ0FBQ0YsVUFBVSxDQUFDRyxJQUFJLENBQUMsT0FBTyxDQUFDO0VBQ2pDLENBQUM7RUFFREMsUUFBUSxFQUFDLFNBQUFBLFNBQUEsRUFBVTtJQUNmLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztJQUN4QlYsRUFBRSxDQUFDVyxRQUFRLENBQUNDLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDYixFQUFFLENBQUNjLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDUCxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkQ7RUFDSjtBQUNKLENBQUMsQ0FBQzs7QUFDRlEsTUFBTSxDQUFDQyxPQUFPLEdBQUdsQixTQUFTIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxudmFyIFRpbWVQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgQ2xvY2tBbmltYTpjYy5BbmltYXRpb24sXHJcbiAgICB9LFxyXG5cclxuICAgIFBsYXlBbmltYTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuQ2xvY2tBbmltYS5wbGF5KFwiQ2xvY2tcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIENsb2NrRW5kOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50LkNsb2NrRW5kLCB7fSk7XHJcbiAgICAgICAgLy9jYy5sb2coXCLpl7npkp/nu5PmnZ89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/TempBonus.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '820e66e25ZNJ6kWheas5yC1', 'TempBonus');
// Scripts/UI/TempBonus.js

"use strict";

//临时加成类型
var TempBonus = cc.Enum({
  NULL: 0,
  BetBonus: 1,
  LoveBonus: 2,
  StockBonus: 3,
  AssetBonus: 4 //财神
});

module.exports = TempBonus;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFRlbXBCb251cy5qcyJdLCJuYW1lcyI6WyJUZW1wQm9udXMiLCJjYyIsIkVudW0iLCJOVUxMIiwiQmV0Qm9udXMiLCJMb3ZlQm9udXMiLCJTdG9ja0JvbnVzIiwiQXNzZXRCb251cyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFJQSxTQUFTLEdBQUdDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDO0VBQ3BCQyxJQUFJLEVBQUMsQ0FBQztFQUNOQyxRQUFRLEVBQUMsQ0FBQztFQUNWQyxTQUFTLEVBQUMsQ0FBQztFQUNYQyxVQUFVLEVBQUMsQ0FBQztFQUNaQyxVQUFVLEVBQUMsQ0FBQyxDQUFFO0FBQ2xCLENBQUMsQ0FBQzs7QUFDRkMsTUFBTSxDQUFDQyxPQUFPLEdBQUdULFNBQVMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8v5Li05pe25Yqg5oiQ57G75Z6LXHJcbnZhciBUZW1wQm9udXMgPSBjYy5FbnVtKHtcclxuICAgIE5VTEw6MCxcclxuICAgIEJldEJvbnVzOjEsXHJcbiAgICBMb3ZlQm9udXM6MixcclxuICAgIFN0b2NrQm9udXM6MyxcclxuICAgIEFzc2V0Qm9udXM6NCwgLy/otKLnpZ5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gVGVtcEJvbnVzO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/TutorialPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9be414DADdLBatqtP6i0G8v', 'TutorialPanel');
// Scripts/UI/TutorialPanel.js

"use strict";

var TutorialStep = require("TutorialStep");
var TutorialPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    DesLbl: cc.Label,
    step: 1,
    //记录引导步骤

    Finger: cc.Node,
    EffectCircle: cc.Node,
    TpObj: cc.Node,
    DesObj: cc.Node,
    //下面是引导点位置
    pos11: cc.Node,
    pos12: cc.Node,
    pos13: cc.Node,
    pos14: cc.Node,
    pos15: cc.Node,
    pos21: cc.Node,
    pos22: cc.Node,
    pos31: cc.Node,
    pos32: cc.Node,
    callFunc: null
  },
  ShowPanel: function ShowPanel(dt) {
    this.step = dt.step;
    //cc.log("设定位置============" + this.step);
    var des = "tutorial_" + this.step;
    this.DesLbl.string = cc.Mgr.global.getTranslation(des);
    switch (this.step) {
      case 11:
        this.SetTpObjPos(this.pos11.getPosition(), 11);
        break;
      case 12:
        this.SetTpObjPos(this.pos12.getPosition(), 12);
        break;
      case 13:
        this.SetTpObjPos(this.pos13.getPosition(), 13);
        break;
      case 14:
        this.SetTpObjPos(this.pos14.getPosition(), 14);
        break;
      case 15:
        this.SetTpObjPos(this.pos15.getPosition(), 15);
        break;
      case 21:
        this.SetTpObjPos(this.pos21.getPosition(), 21);
        break;
      case 22:
        this.SetTpObjPos(this.pos22.getPosition(), 22);
        break;
      case 31:
        this.SetTpObjPos(this.pos31.getPosition(), 31);
        break;
      case 32:
        this.SetTpObjPos(this.pos32.getPosition(), 32);
        break;
      case 41:
        this.SetTpObjPos(this.pos32.getPosition(), 41);
        break;
      case 51:
        this.SetTpObjPos(this.pos32.getPosition(), 51);
        break;
      default:
        this.ClosePanel();
        break;
    }
  },
  ClosePanel: function ClosePanel() {
    this.node.active = false;
  },
  SetCallFunc: function SetCallFunc(func) {
    this.callFunc = null;
    this.callFunc = func;
  },
  SetTpObjPos: function SetTpObjPos(pos, tutorrialId) {
    //cc.log("设定位置============");
    this.TpObj.setPosition(pos);
    if (tutorrialId == 12 || tutorrialId == 15) this.DesObj.setPosition(30, 145);else this.DesObj.setPosition(-110, 145);
    if (tutorrialId == TutorialStep.DateToMarry_1 || tutorrialId == TutorialStep.MateDate_2 || tutorrialId == TutorialStep.Business_2 || tutorrialId == TutorialStep.StockBonus_1) {
      this.Finger.active = false;
      this.EffectCircle.active = false;
    } else {
      this.Finger.active = true;
      this.EffectCircle.active = true;
    }
  },
  StartTutorialStep: function StartTutorialStep() {
    if (this.callFunc != null && typeof this.callFunc == "function") {
      this.callFunc();
      //cc.log("_________________________________________");
    }
  },

  StartSpNextTutorialStep: function StartSpNextTutorialStep() {
    if (this.step == TutorialStep.DateToMarry_1 || this.step == TutorialStep.MateDate_2 || this.step == TutorialStep.Business_2 || this.step == TutorialStep.StockBonus_1) {
      cc.Mgr.AudioMgr.playSFX("click");
      if (this.callFunc != null && typeof this.callFunc == "function") {
        this.callFunc();
      }
    }
  }
});
module.exports = TutorialPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFR1dG9yaWFsUGFuZWwuanMiXSwibmFtZXMiOlsiVHV0b3JpYWxTdGVwIiwicmVxdWlyZSIsIlR1dG9yaWFsUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkRlc0xibCIsIkxhYmVsIiwic3RlcCIsIkZpbmdlciIsIk5vZGUiLCJFZmZlY3RDaXJjbGUiLCJUcE9iaiIsIkRlc09iaiIsInBvczExIiwicG9zMTIiLCJwb3MxMyIsInBvczE0IiwicG9zMTUiLCJwb3MyMSIsInBvczIyIiwicG9zMzEiLCJwb3MzMiIsImNhbGxGdW5jIiwiU2hvd1BhbmVsIiwiZHQiLCJkZXMiLCJzdHJpbmciLCJNZ3IiLCJnbG9iYWwiLCJnZXRUcmFuc2xhdGlvbiIsIlNldFRwT2JqUG9zIiwiZ2V0UG9zaXRpb24iLCJDbG9zZVBhbmVsIiwibm9kZSIsImFjdGl2ZSIsIlNldENhbGxGdW5jIiwiZnVuYyIsInBvcyIsInR1dG9ycmlhbElkIiwic2V0UG9zaXRpb24iLCJEYXRlVG9NYXJyeV8xIiwiTWF0ZURhdGVfMiIsIkJ1c2luZXNzXzIiLCJTdG9ja0JvbnVzXzEiLCJTdGFydFR1dG9yaWFsU3RlcCIsIlN0YXJ0U3BOZXh0VHV0b3JpYWxTdGVwIiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZLEdBQUdDLE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDMUMsSUFBSUMsYUFBYSxHQUFHQyxFQUFFLENBQUNDLEtBQUssQ0FBQztFQUN6QixXQUFTRCxFQUFFLENBQUNFLFNBQVM7RUFFckJDLFVBQVUsRUFBRTtJQUNSQyxNQUFNLEVBQUNKLEVBQUUsQ0FBQ0ssS0FBSztJQUNmQyxJQUFJLEVBQUMsQ0FBQztJQUFFOztJQUVSQyxNQUFNLEVBQUNQLEVBQUUsQ0FBQ1EsSUFBSTtJQUNkQyxZQUFZLEVBQUNULEVB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QUksQ0FBQ0EsUUFBUSxJQUFJLFVBQVUsRUFDOUQ7TUFDSSxJQUFJLENBQUNBLFFBQVEsRUFBRTtNQUNmO0lBQ0o7RUFDSixDQUFDOztFQUVEdUIsdUJBQXVCLEVBQUMsU0FBQUEsd0JBQUEsRUFDeEI7SUFDSSxJQUFHLElBQUksQ0FBQ3RDLElBQUksSUFBSVQsWUFBWSxDQUFDMEMsYUFBYSxJQUFJLElBQUksQ0FBQ2pDLElBQUksSUFBSVQsWUFBWSxDQUFDMkMsVUFBVSxJQUFJLElBQUksQ0FBQ2xDLElBQUksSUFBSVQsWUFBWSxDQUFDNEMsVUFBVSxJQUFJLElBQUksQ0FBQ25DLElBQUksSUFBSVQsWUFBWSxDQUFDNkMsWUFBWSxFQUNwSztNQUNJMUMsRUFBRSxDQUFDMEIsR0FBRyxDQUFDbUIsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO01BQ2hDLElBQUcsSUFBSSxDQUFDekIsUUFBUSxJQUFJLElBQUksSUFBSSxPQUFPLElBQUksQ0FBQ0EsUUFBUSxJQUFJLFVBQVUsRUFDOUQ7UUFDSSxJQUFJLENBQUNBLFFBQVEsRUFBRTtNQUNuQjtJQUNKO0VBQ0o7QUFDSixDQUFDLENBQUM7QUFDRjBCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHakQsYUFBYSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFR1dG9yaWFsU3RlcCA9IHJlcXVpcmUoXCJUdXRvcmlhbFN0ZXBcIik7IFxyXG52YXIgVHV0b3JpYWxQYW5lbCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgRGVzTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIHN0ZXA6MSwgLy/orrDlvZXlvJXlr7zmraXpqqRcclxuXHJcbiAgICAgICAgRmluZ2VyOmNjLk5vZGUsXHJcbiAgICAgICAgRWZmZWN0Q2lyY2xlOmNjLk5vZGUsXHJcblxyXG4gICAgICAgIFRwT2JqOmNjLk5vZGUsXHJcbiAgICAgICAgRGVzT2JqOmNjLk5vZGUsXHJcbiAgICAgICAgLy/kuIvpnaLmmK/lvJXlr7zngrnkvY3nva5cclxuICAgICAgICBwb3MxMTpjYy5Ob2RlLFxyXG4gICAgICAgIHBvczEyOmNjLk5vZGUsXHJcbiAgICAgICAgcG9zMTM6Y2MuTm9kZSxcclxuICAgICAgICBwb3MxNDpjYy5Ob2RlLFxyXG4gICAgICAgIHBvczE1OmNjLk5vZGUsXHJcblxyXG4gICAgICAgIHBvczIxOmNjLk5vZGUsXHJcbiAgICAgICAgcG9zMjI6Y2MuTm9kZSxcclxuXHJcbiAgICAgICAgcG9zMzE6Y2MuTm9kZSxcclxuICAgICAgICBwb3MzMjpjYy5Ob2RlLFxyXG5cclxuICAgICAgICBjYWxsRnVuYzpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24oZHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gZHQuc3RlcDtcclxuICAgICAgICAvL2NjLmxvZyhcIuiuvuWumuS9jee9rj09PT09PT09PT09PVwiICsgdGhpcy5zdGVwKTtcclxuICAgICAgICB2YXIgZGVzID0gXCJ0dXRvcmlhbF9cIit0aGlzLnN0ZXA7XHJcbiAgICAgICAgdGhpcy5EZXNMYmwuc3RyaW5nID0gY2MuTWdyLmdsb2JhbC5nZXRUcmFuc2xhdGlvbihkZXMpO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLnN0ZXApe1xyXG4gICAgICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgICB0aGlzLlNldFRwT2JqUG9zKHRoaXMucG9zMTEuZ2V0UG9zaXRpb24oKSwxMSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICB0aGlzLlNldFRwT2JqUG9zKHRoaXMucG9zMTIuZ2V0UG9zaXRpb24oKSwxMik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICB0aGlzLlNldFRwT2JqUG9zKHRoaXMucG9zMTMuZ2V0UG9zaXRpb24oKSwxMyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE0OlxyXG4gICAgICAgICAgICB0aGlzLlNldFRwT2JqUG9zKHRoaXMucG9zMTQuZ2V0UG9zaXRpb24oKSwxNCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgICAgICB0aGlzLlNldFRwT2JqUG9zKHRoaXMucG9zMTUuZ2V0UG9zaXRpb24oKSwgMTUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMTpcclxuICAgICAgICAgICAgdGhpcy5TZXRUcE9ialBvcyh0aGlzLnBvczIxLmdldFBvc2l0aW9uKCksMjEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMjpcclxuICAgICAgICAgICAgdGhpcy5TZXRUcE9ialBvcyh0aGlzLnBvczIyLmdldFBvc2l0aW9uKCksMjIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzMTpcclxuICAgICAgICAgICAgdGhpcy5TZXRUcE9ialBvcyh0aGlzLnBvczMxLmdldFBvc2l0aW9uKCksIDMxKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICAgIHRoaXMuU2V0VHBPYmpQb3ModGhpcy5wb3MzMi5nZXRQb3NpdGlvbigpLCAzMik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQxOlxyXG4gICAgICAgICAgICB0aGlzLlNldFRwT2JqUG9zKHRoaXMucG9zMzIuZ2V0UG9zaXRpb24oKSwgNDEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1MTpcclxuICAgICAgICAgICAgdGhpcy5TZXRUcE9ialBvcyh0aGlzLnBvczMyLmdldFBvc2l0aW9uKCksIDUxKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRoaXMuQ2xvc2VQYW5lbCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIENsb3NlUGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIFNldENhbGxGdW5jOmZ1bmN0aW9uKGZ1bmMpe1xyXG4gICAgICAgIHRoaXMuY2FsbEZ1bmMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FsbEZ1bmMgPSBmdW5jO1xyXG4gICAgfSxcclxuXHJcbiAgICBTZXRUcE9ialBvczpmdW5jdGlvbihwb3MsIHR1dG9ycmlhbElkKVxyXG4gICAge1xyXG4gICAgICAgIC8vY2MubG9nKFwi6K6+5a6a5L2N572uPT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIHRoaXMuVHBPYmouc2V0UG9zaXRpb24ocG9zKTtcclxuICAgICAgICBpZih0dXRvcnJpYWxJZCA9PSAxMiB8fCB0dXRvcnJpYWxJZCA9PSAxNSlcclxuICAgICAgICAgICAgdGhpcy5EZXNPYmouc2V0UG9zaXRpb24oMzAsMTQ1KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuRGVzT2JqLnNldFBvc2l0aW9uKC0xMTAsMTQ1KTtcclxuXHJcblxyXG4gICAgICAgIGlmKHR1dG9ycmlhbElkID09IFR1dG9yaWFsU3RlcC5EYXRlVG9NYXJyeV8xIHx8IHR1dG9ycmlhbElkID09IFR1dG9yaWFsU3RlcC5NYXRlRGF0ZV8yIHx8IHR1dG9ycmlhbElkID09IFR1dG9yaWFsU3RlcC5CdXNpbmVzc18yIHx8IHR1dG9ycmlhbElkID09IFR1dG9yaWFsU3RlcC5TdG9ja0JvbnVzXzEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkZpbmdlci5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5FZmZlY3RDaXJjbGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuRmluZ2VyLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuRWZmZWN0Q2lyY2xlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBTdGFydFR1dG9yaWFsU3RlcDpmdW5jdGlvbigpXHJcbiAgICB7XHJcbiAgICAgICAgaWYodGhpcy5jYWxsRnVuYyAhPSBudWxsICYmIHR5cGVvZiB0aGlzLmNhbGxGdW5jID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbEZ1bmMoKTtcclxuICAgICAgICAgICAgLy9jYy5sb2coXCJfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFN0YXJ0U3BOZXh0VHV0b3JpYWxTdGVwOmZ1bmN0aW9uKClcclxuICAgIHtcclxuICAgICAgICBpZih0aGlzLnN0ZXAgPT0gVHV0b3JpYWxTdGVwLkRhdGVUb01hcnJ5XzEgfHwgdGhpcy5zdGVwID09IFR1dG9yaWFsU3RlcC5NYXRlRGF0ZV8yIHx8IHRoaXMuc3RlcCA9PSBUdXRvcmlhbFN0ZXAuQnVzaW5lc3NfMiB8fCB0aGlzLnN0ZXAgPT0gVHV0b3JpYWxTdGVwLlN0b2NrQm9udXNfMSlcclxuICAgICAgICB7ICAgXHJcbiAgICAgICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuY2FsbEZ1bmMgIT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5jYWxsRnVuYyA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEZ1bmMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFR1dG9yaWFsUGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/TreatPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e7bb2HogENG7ryEv7NMveQT', 'TreatPanel');
// Scripts/UI/TreatPanel.js

"use strict";

var AdsParam = require("AdsParam");
var TreatPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    costLbl: cc.Label
  },
  ShowPanel: function ShowPanel() {
    this.costLbl.string = Math.floor(2000 * Math.pow(1.18, cc.Mgr.UserDataMgr.Age - 20) * (1 - cc.Mgr.UserDataMgr.HpPoint / 100));
  },
  callbackFunc: function callbackFunc() {
    var self = this;
    self.showRewardVideo();
    cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointB, function (out) {
      if (out == 0) {
        cc.Mgr.UserDataMgr.HpPoint = 100;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.TreatSuccess, {});
        self.ClosePanel();
      }
    });
  },
  showRewardVideo: function showRewardVideo() {
    this.js2android('show_reward_video', '1');
  },
  ///激励视频播放完成回调方法 continue_game
  /// Native.android2js("continue_game", ()=>{
  ///     //激励视频播放完成，原生端回调
  /// });
  js2android: function js2android(name, data) {
    console.log("name:" + name + "-data:" + data);
    if (window.injectedObject && window.injectedObject.setJsContent) {
      window.injectedObject.setJsContent(name, data);
    }
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  },
  ClickOpen: function ClickOpen() {
    var needMoney = Math.floor(2000 * Math.pow(1.18, cc.Mgr.UserDataMgr.Age - 20) * (1 - cc.Mgr.UserDataMgr.HpPoint / 100));
    if (cc.Mgr.UserDataMgr.Cash < needMoney) {
      var param = {};
      param.forWhat = "";
      param.text = "金钱不够,连住院接受治疗都是奢侈";
      cc.director.GlobalEvent.emit(cc.Mgr.Event.OpenCommonTip, param);
      return;
    }
    cc.Mgr.UserDataMgr.Cash -= needMoney;
    cc.Mgr.UserDataMgr.HpPoint = 100;
    ////cc.log("---------------------------------------" + cc.Mgr.UserDataMgr.HpPoint);
    cc.director.GlobalEvent.emit(cc.Mgr.Event.TreatSuccess, {});
    this.ClosePanel();
  }
});
module.exports = TreatPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFRyZWF0UGFuZWwuanMiXSwibmFtZXMiOlsiQWRzUGFyYW0iLCJyZXF1aXJlIiwiVHJlYXRQYW5lbCIsImNjIiwiQ2xhc3MiLCJDb21wb25lbnQiLCJwcm9wZXJ0aWVzIiwiY29zdExibCIsIkxhYmVsIiwiU2hvd1BhbmVsIiwic3RyaW5nIiwiTWF0aCIsImZsb29yIiwicG93IiwiTWdyIiwiVXNlckRhdGFNZ3IiLCJBZ2UiLCJIcFBvaW50IiwiY2FsbGJhY2tGdW5jIiwic2VsZiIsInNob3dSZXdhcmRWaWRlbyIsIkFkc01nciIsIlNob3dWaWRlb0FkcyIsIlBvaW50QiIsIm91dCIsImRpcmVjdG9yIiwiR2xvYmFsRXZlbnQiLCJlbWl0IiwiRXZlbnQiLCJUcmVhdFN1Y2Nlc3MiLCJDbG9zZVBhbmVsIiwianMyYW5kcm9pZCIsIm5hbWUiLCJkYXRhIiwiY29uc29sZSIsImxvZyIsIndpbmRvdyIsImluamVjdGVkT2JqZWN0Iiwic2V0SnNDb250ZW50IiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibm9kZSIsImFjdGl2ZSIsIkNsaWNrT3BlbiIsIm5lZWRNb25leSIsIkNhc2giLCJwYXJhbSIsImZvcldoYXQiLCJ0ZXh0IiwiT3BlbkNvbW1vblRpcCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLFVBQVUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDdEIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsT0FBTyxFQUFDSixFQUFFLENBQUNLO0VBQ2YsQ0FBQztFQUVEQyxTQUFTLEVBQUMsU0FBQUEsVUFBQSxFQUFVO0lBQ2hCLElBQUksQ0FBQ0YsT0FBTyxDQUFDRyxNQUFNLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFDLElBQUksR0FBRUQs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RUFBRSxDQUFDVyxHQUFHLENBQUNjLEtBQUssQ0FBQ0MsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hELElBQUksQ0FBQ0MsVUFBVSxFQUFFO0VBQ3JCO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZvQixNQUFNLENBQUNDLE9BQU8sR0FBR2pELFVBQVUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBBZHNQYXJhbSA9IHJlcXVpcmUoXCJBZHNQYXJhbVwiKTtcclxudmFyIFRyZWF0UGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGNvc3RMYmw6Y2MuTGFiZWwsXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuY29zdExibC5zdHJpbmcgPSBNYXRoLmZsb29yKDIwMDAqIE1hdGgucG93KDEuMTgsIGNjLk1nci5Vc2VyRGF0YU1nci5BZ2UtMjApICooMS1jYy5NZ3IuVXNlckRhdGFNZ3IuSHBQb2ludC8xMDApKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2FsbGJhY2tGdW5jOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYuc2hvd1Jld2FyZFZpZGVvKCk7XHJcbiAgICAgICAgY2MuTWdyLkFkc01nci5TaG93VmlkZW9BZHMoQWRzUGFyYW0uUG9pbnRCLCBmdW5jdGlvbihvdXQpe1xyXG4gICAgICAgICAgICBpZihvdXQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQgPSAxMDA7XHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5UcmVhdFN1Y2Nlc3MsIHt9KTtcclxuICAgICAgICAgICAgICAgIHNlbGYuQ2xvc2VQYW5lbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7IFxyXG4gICAgfSxcclxuICAgIHNob3dSZXdhcmRWaWRlbygpIHtcclxuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ3Nob3dfcmV3YXJkX3ZpZGVvJywgJzEnKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLy/mv4DlirHop4bpopHmkq3mlL7lrozmiJDlm57osIPmlrnms5UgY29udGludWVfZ2FtZVxyXG4gICAgLy8vIE5hdGl2ZS5hbmRyb2lkMmpzKFwiY29udGludWVfZ2FtZVwiLCAoKT0+e1xyXG4gICAgLy8vICAgICAvL+a/gOWKseinhumikeaSreaUvuWujOaIkO+8jOWOn+eUn+err+Wbnuiwg1xyXG4gICAgLy8vIH0pO1xyXG4gICAganMyYW5kcm9pZChuYW1lLCBkYXRhKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhgbmFtZToke25hbWV9LWRhdGE6JHtkYXRhfWApO1xyXG4gICAgICAgIGlmKHdpbmRvdy5pbmplY3RlZE9iamVjdCAmJiB3aW5kb3cuaW5qZWN0ZWRPYmplY3Quc2V0SnNDb250ZW50KXtcclxuICAgICAgICAgICAgd2luZG93LmluamVjdGVkT2JqZWN0LnNldEpzQ29udGVudChuYW1lLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLk1nci5BdWRpb01nci5wbGF5U0ZYKFwiY2xpY2tcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9ZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrT3BlbjpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5lZWRNb25leSA9IE1hdGguZmxvb3IoMjAwMCogTWF0aC5wb3coMS4xOCwgY2MuTWdyLlVzZXJEYXRhTWdyLkFnZS0yMCkgKigxLWNjLk1nci5Vc2VyRGF0YU1nci5IcFBvaW50LzEwMCkpO1xyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIDwgbmVlZE1vbmV5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtLmZvcldoYXQgPSBcIlwiO1xyXG4gICAgICAgICAgICBwYXJhbS50ZXh0ID0gXCLph5HpkrHkuI3lpJ8s6L+e5L2P6Zmi5o6l5Y+X5rK755aX6YO95piv5aWi5L6IXCI7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLkdsb2JhbEV2ZW50LmVtaXQoY2MuTWdyLkV2ZW50Lk9wZW5Db21tb25UaXAsIHBhcmFtKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5NZ3IuVXNlckRhdGFNZ3IuQ2FzaCAtPSBuZWVkTW9uZXk7XHJcbiAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQgPSAxMDA7XHJcbiAgICAgICAgLy8vL2NjLmxvZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiICsgY2MuTWdyLlVzZXJEYXRhTWdyLkhwUG9pbnQpO1xyXG5cdCAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5UcmVhdFN1Y2Nlc3MsIHt9KTtcclxuICAgICAgICB0aGlzLkNsb3NlUGFuZWwoKTtcclxuICAgIH0sXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWF0UGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/WatchAdsPanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4b05cODMcNOPb1EdqseG9qv', 'WatchAdsPanel');
// Scripts/UI/WatchAdsPanel.js

"use strict";

var TempBonus = require("TempBonus");
var AdsParam = require("AdsParam");
var MateUnLockType = require("MateUnLockType");
var WatchAdsPanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    LoveGod: cc.Sprite,
    BetGod: cc.Sprite,
    MammomGod: cc.Sprite,
    StockGod: cc.Sprite,
    BtnLbl: cc.Sprite,
    BtnIconSp: cc.Sprite,
    BtnBgSp: cc.Sprite,
    forWhat: {
      "default": TempBonus.NULL,
      type: TempBonus
    },
    //是为了干嘛用的

    CloseAni: cc.Animation
  },
  ShowPanel: function ShowPanel(data) {
    this.LoveGod.node.active = false;
    this.BetGod.node.active = false;
    this.MammomGod.node.active = false;
    this.StockGod.node.active = false;
    // this.CloseAni.play("ShowLater");

    if (data.Sp == "aishen") {
      this.forWhat = TempBonus.LoveBonus;
      this.LoveGod.node.active = true;
      this.ShowBtnActive(cc.Mgr.global.hasActiveAiShen);
    }
    if (data.Sp == "dushen") {
      this.forWhat = TempBonus.BetBonus;
      this.BetGod.node.active = true;
      this.ShowBtnActive(cc.Mgr.global.hasActiveDuShen);
    }
    if (data.Sp == "caishen") {
      this.forWhat = TempBonus.AssetBonus;
      this.MammomGod.node.active = true;
      this.ShowBtnActive(cc.Mgr.global.hasActiveCaiShen);
    }
    if (data.Sp == "gushen") {
      this.forWhat = TempBonus.StockBonus;
      this.StockGod.node.active = true;
      this.ShowBtnActive(cc.Mgr.global.hasActiveGuShen);
    }
  },
  ShowBtnActive: function ShowBtnActive(active) {
    if (active) {
      this.BtnLbl.spriteFrame = this.Atlas.getSpriteFrame("active_txt_y");
      this.BtnLbl.node.setPosition(cc.v2(0, 2));
      this.BtnIconSp.node.active = false;
      this.BtnBgSp.spriteFrame = this.Atlas.getSpriteFrame("btn_gray");
    } else {
      this.BtnLbl.spriteFrame = this.Atlas.getSpriteFrame("video_active_txt");
      this.BtnLbl.node.setPosition(cc.v2(36, 2));
      this.BtnIconSp.node.active = true;
      this.BtnBgSp.spriteFrame = this.Atlas.getSpriteFrame("blueBtnBg");
    }
  },
  showRewardVideo: function showRewardVideo() {
    this.js2android('show_reward_video', '1');
  },
  ///激励视频播放完成回调方法 continue_game
  /// Native.android2js("continue_game", ()=>{
  ///     //激励视频播放完成，原生端回调
  /// });
  js2android: function js2android(name, data) {
    console.log("name:" + name + "-data:" + data);
    if (window.injectedObject && window.injectedObject.setJsContent) {
      window.injectedObject.setJsContent(name, data);
    }
  },
  ClickBtn: function ClickBtn() {
    this.showRewardVideo();
    //cc.Mgr.global.TempAdsBonus = this.forWhat;
    if (this.forWhat == TempBonus.LoveBonus) {
      if (cc.Mgr.global.hasActiveAiShen) return;
      var self = this;
      cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointG, function (out) {
        if (out == 0) {
          cc.Mgr.UserDataMgr.UnLockOneMate(MateUnLockType.ToDate, cc.Mgr.UserDataMgr.Sex);
          cc.Mgr.global.TempAdsBonus = TempBonus.NULL;
          cc.Mgr.global.hasActiveAiShen = true;
          self.node.active = false;
        }
      });
    } else if (this.forWhat == TempBonus.BetBonus) {
      if (cc.Mgr.global.hasActiveDuShen) return;
      var self = this;
      cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointH, function (out) {
        if (out == 0) {
          cc.Mgr.global.TempAdsBetBonus = TempBonus.BetBonus;
          cc.Mgr.global.hasActiveDuShen = true;
          self.node.active = false;
        }
      });
    } else if (this.forWhat == TempBonus.StockBonus) {
      if (cc.Mgr.global.hasActiveGuShen) return;
      var self = this;
      cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointI, function (out) {
        if (out == 0) {
          cc.Mgr.global.TempAdsStockBonus = TempBonus.StockBonus;
          cc.Mgr.global.hasActiveGuShen = true;
          self.node.active = false;
        }
      });
    } else if (this.forWhat == TempBonus.AssetBonus) {
      if (cc.Mgr.global.hasActiveCaiShen) return;
      var self = this;
      cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointJ, function (out) {
        if (out == 0) {
          cc.Mgr.global.TempAdsAssetBonus = TempBonus.AssetBonus;
          cc.Mgr.global.hasActiveCaiShen = true;
          self.node.active = false;
        }
      });
    }
  },
  ClosePanel: function ClosePanel() {
    this.node.active = false;
  }
});
module.exports = WatchAdsPanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFdhdGNoQWRzUGFuZWwuanMiXSwibmFtZXMiOlsiVGVtcEJvbnVzIiwicmVxdWlyZSIsIkFkc1BhcmFtIiwiTWF0ZVVuTG9ja1R5cGUiLCJXYXRjaEFkc1BhbmVsIiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJBdGxhcyIsIlNwcml0ZUF0bGFzIiwiTG92ZUdvZCIsIlNwcml0ZSIsIkJldEdvZCIsIk1hbW1vbUdvZCIsIlN0b2NrR29kIiwiQnRuTGJsIiwiQnRuSWNvblNwIiwiQnRuQmdTcCIsImZvcldoYXQiLCJOVUxMIiwidHlwZSIsIkNsb3NlQW5pIiwiQW5pbWF0aW9uIiwiU2hvd1BhbmVsIiwiZGF0YSIsIm5vZGUiLCJhY3RpdmUiLCJTcCIsIkxvdmVCb251cyIsIlNob3dCdG5BY3RpdmUiLCJNZ3IiLCJnbG9iYWwiLCJoYXNBY3RpdmVBaVNoZW4iLCJCZXRCb251cyIsImhhc0FjdGl2ZUR1U2hlbiIsIkFzc2V0Qm9udXMiLCJoYXNBY3RpdmVDYWlTaGVuIiwiU3RvY2tCb251cyIsImhhc0FjdGl2ZUd1U2hlbiIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJzZXRQb3NpdGlvbiIsInYyIiwic2hvd1Jld2FyZFZpZGVvIiwianMyYW5kcm9pZCIsIm5hbWUiLCJjb25zb2xlIiwibG9nIiwid2luZG93IiwiaW5qZWN0ZWRPYmplY3QiLCJzZXRKc0NvbnRlbnQiLCJDbGlja0J0biIsInNlbGYiLCJBZHNNZ3IiLCJTaG93VmlkZW9BZHMiLCJQb2ludEciLCJvdXQiLCJVc2VyRGF0YU1nciIsIlVuTG9ja09uZU1hdGUiLCJUb0RhdGUiLCJTZXgiLCJUZW1wQWRzQm9udXMiLCJQb2ludEgiLCJUZW1wQWRzQmV0Qm9udXMiLCJQb2ludEkiLCJUZW1wQWRzU3RvY2tCb251cyIsIlBvaW50SiIsIlRlbXBBZHNBc3NldEJvbnVzIiwiQ2xvc2VQYW5lbCIsIm1vZHVsZSIsImV4cG9ydHMi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Q0FBQ1IsT0FBTyxJQUFJbkIsU0FBUyxDQUFDb0MsVUFBVSxFQUM1QztNQUNPLElBQUcvQixFQUFFLENBQUMwQixHQUFHLENBQUNDLE1BQU0sQ0FBQ0ssZ0JBQWdCLEVBQzdCO01BRUosSUFBSWdCLElBQUksR0FBRyxJQUFJO01BQ2ZoRCxFQUFFLENBQUMwQixHQUFHLENBQUN1QixNQUFNLENBQUNDLFlBQVksQ0FBQ3JELFFBQVEsQ0FBQ2lFLE1BQU0sRUFBRSxVQUFTVixHQUFHLEVBQUM7UUFDckQsSUFBR0EsR0FBRyxJQUFJLENBQUMsRUFDWDtVQUNJcEQsRUFBRSxDQUFDMEIsR0FBRyxDQUFDQyxNQUFNLENBQUNvQyxpQkFBaUIsR0FBR3BFLFNBQVMsQ0FBQ29DLFVBQVU7VUFDdEQvQixFQUFFLENBQUMwQixHQUFHLENBQUNDLE1BQU0sQ0FBQ0ssZ0JBQWdCLEdBQUcsSUFBSTtVQUNyQ2dCLElBQUksQ0FBQzNCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDNUI7TUFDSixDQUFDLENBQUM7SUFDVDtFQUNELENBQUM7RUFFRDBDLFVBQVUsRUFBQyxTQUFBQSxXQUFBLEVBQ1g7SUFDSSxJQUFJLENBQUMzQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO0VBQzVCO0FBQ0osQ0FBQyxDQUFDO0FBQ0YyQyxNQUFNLENBQUNDLE9BQU8sR0FBR25FLGFBQWEiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBUZW1wQm9udXMgPSByZXF1aXJlKFwiVGVtcEJvbnVzXCIpO1xyXG52YXIgQWRzUGFyYW0gPSByZXF1aXJlKFwiQWRzUGFyYW1cIik7XHJcbnZhciBNYXRlVW5Mb2NrVHlwZSA9IHJlcXVpcmUoXCJNYXRlVW5Mb2NrVHlwZVwiKTtcclxudmFyIFdhdGNoQWRzUGFuZWwgPSBjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIEF0bGFzOmNjLlNwcml0ZUF0bGFzLFxyXG4gICAgICAgIExvdmVHb2Q6Y2MuU3ByaXRlLFxyXG4gICAgICAgIEJldEdvZDpjYy5TcHJpdGUsXHJcbiAgICAgICAgTWFtbW9tR29kOmNjLlNwcml0ZSxcclxuICAgICAgICBTdG9ja0dvZDpjYy5TcHJpdGUsXHJcblxyXG4gICAgICAgIEJ0bkxibDpjYy5TcHJpdGUsXHJcbiAgICAgICAgQnRuSWNvblNwOmNjLlNwcml0ZSxcclxuICAgICAgICBCdG5CZ1NwOmNjLlNwcml0ZSxcclxuXHJcbiAgICAgICAgZm9yV2hhdDp7XHJcbiAgICAgICAgXHRkZWZhdWx0OlRlbXBCb251cy5OVUxMLFxyXG4gICAgICAgIFx0dHlwZTpUZW1wQm9udXMsXHJcbiAgICAgICAgfSwvL+aYr+S4uuS6huW5suWYm+eUqOeahFxyXG5cclxuICAgICAgICBDbG9zZUFuaTpjYy5BbmltYXRpb24sXHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dQYW5lbDpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLkxvdmVHb2Qubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLkJldEdvZC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuTWFtbW9tR29kLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5TdG9ja0dvZC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHRoaXMuQ2xvc2VBbmkucGxheShcIlNob3dMYXRlclwiKTtcclxuXHJcbiAgICAgICAgaWYoZGF0YS5TcCA9PSBcImFpc2hlblwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICBcdHRoaXMuZm9yV2hhdCA9IFRlbXBCb251cy5Mb3ZlQm9udXM7XHJcbiAgICAgICAgICAgIHRoaXMuTG92ZUdvZC5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuU2hvd0J0bkFjdGl2ZShjYy5NZ3IuZ2xvYmFsLmhhc0FjdGl2ZUFpU2hlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRhdGEuU3AgPT0gXCJkdXNoZW5cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgXHR0aGlzLmZvcldoYXQgPSBUZW1wQm9udXMuQmV0Qm9udXM7XHJcbiAgICAgICAgICAgIHRoaXMuQmV0R29kLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5TaG93QnRuQWN0aXZlKGNjLk1nci5nbG9iYWwuaGFzQWN0aXZlRHVTaGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZGF0YS5TcCA9PSBcImNhaXNoZW5cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgXHR0aGlzLmZvcldoYXQgPSBUZW1wQm9udXMuQXNzZXRCb251cztcclxuICAgICAgICAgICAgdGhpcy5NYW1tb21Hb2Qubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLlNob3dCdG5BY3RpdmUoY2MuTWdyLmdsb2JhbC5oYXNBY3RpdmVDYWlTaGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZGF0YS5TcCA9PSBcImd1c2hlblwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICBcdHRoaXMuZm9yV2hhdCA9IFRlbXBCb251cy5TdG9ja0JvbnVzO1xyXG4gICAgICAgICAgICB0aGlzLlN0b2NrR29kLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5TaG93QnRuQWN0aXZlKGNjLk1nci5nbG9iYWwuaGFzQWN0aXZlR3VTaGVuKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFNob3dCdG5BY3RpdmU6ZnVuY3Rpb24oYWN0aXZlKXtcclxuICAgICAgICBpZihhY3RpdmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLkJ0bkxibC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJhY3RpdmVfdHh0X3lcIik7XHJcbiAgICAgICAgICAgIHRoaXMuQnRuTGJsLm5vZGUuc2V0UG9zaXRpb24oY2MudjIoMCwyKSk7XHJcbiAgICAgICAgICAgIHRoaXMuQnRuSWNvblNwLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuQnRuQmdTcC5zcHJpdGVGcmFtZSA9IHRoaXMuQXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJidG5fZ3JheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5CdG5MYmwuc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKFwidmlkZW9fYWN0aXZlX3R4dFwiKTtcclxuICAgICAgICAgICAgdGhpcy5CdG5MYmwubm9kZS5zZXRQb3NpdGlvbihjYy52MigzNiwyKSk7XHJcbiAgICAgICAgICAgIHRoaXMuQnRuSWNvblNwLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5CdG5CZ1NwLnNwcml0ZUZyYW1lID0gdGhpcy5BdGxhcy5nZXRTcHJpdGVGcmFtZShcImJsdWVCdG5CZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3dSZXdhcmRWaWRlbygpIHtcclxuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ3Nob3dfcmV3YXJkX3ZpZGVvJywgJzEnKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLy/mv4DlirHop4bpopHmkq3mlL7lrozmiJDlm57osIPmlrnms5UgY29udGludWVfZ2FtZVxyXG4gICAgLy8vIE5hdGl2ZS5hbmRyb2lkMmpzKFwiY29udGludWVfZ2FtZVwiLCAoKT0+e1xyXG4gICAgLy8vICAgICAvL+a/gOWKseinhumikeaSreaUvuWujOaIkO+8jOWOn+eUn+err+Wbnuiwg1xyXG4gICAgLy8vIH0pO1xyXG4gICAganMyYW5kcm9pZChuYW1lLCBkYXRhKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhgbmFtZToke25hbWV9LWRhdGE6JHtkYXRhfWApO1xyXG4gICAgICAgIGlmKHdpbmRvdy5pbmplY3RlZE9iamVjdCAmJiB3aW5kb3cuaW5qZWN0ZWRPYmplY3Quc2V0SnNDb250ZW50KXtcclxuICAgICAgICAgICAgd2luZG93LmluamVjdGVkT2JqZWN0LnNldEpzQ29udGVudChuYW1lLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIENsaWNrQnRuOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5zaG93UmV3YXJkVmlkZW8oKTtcclxuICAgIFx0Ly9jYy5NZ3IuZ2xvYmFsLlRlbXBBZHNCb251cyA9IHRoaXMuZm9yV2hhdDtcclxuICAgIFx0aWYodGhpcy5mb3JXaGF0ID09IFRlbXBCb251cy5Mb3ZlQm9udXMpXHJcbiAgICBcdHtcclxuICAgICAgICAgICAgaWYoY2MuTWdyLmdsb2JhbC5oYXNBY3RpdmVBaVNoZW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNjLk1nci5BZHNNZ3IuU2hvd1ZpZGVvQWRzKEFkc1BhcmFtLlBvaW50RywgZnVuY3Rpb24ob3V0KXtcclxuICAgICAgICAgICAgICAgIGlmKG91dCA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5VbkxvY2tPbmVNYXRlKE1hdGVVbkxvY2tUeXBlLlRvRGF0ZSwgY2MuTWdyLlVzZXJEYXRhTWdyLlNleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuTWdyLmdsb2JhbC5UZW1wQWRzQm9udXMgPSBUZW1wQm9udXMuTlVMTDtcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLmhhc0FjdGl2ZUFpU2hlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTsgXHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZSBpZih0aGlzLmZvcldoYXQgPT0gVGVtcEJvbnVzLkJldEJvbnVzKVxyXG4gICAgXHR7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5nbG9iYWwuaGFzQWN0aXZlRHVTaGVuKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNjLk1nci5BZHNNZ3IuU2hvd1ZpZGVvQWRzKEFkc1BhcmFtLlBvaW50SCwgZnVuY3Rpb24ob3V0KXtcclxuICAgICAgICAgICAgICAgIGlmKG91dCA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5nbG9iYWwuVGVtcEFkc0JldEJvbnVzID0gVGVtcEJvbnVzLkJldEJvbnVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5nbG9iYWwuaGFzQWN0aXZlRHVTaGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2UgaWYodGhpcy5mb3JXaGF0ID09IFRlbXBCb251cy5TdG9ja0JvbnVzKVxyXG4gICAgXHR7XHJcbiAgICAgICAgICAgIGlmKGNjLk1nci5nbG9iYWwuaGFzQWN0aXZlR3VTaGVuKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNjLk1nci5BZHNNZ3IuU2hvd1ZpZGVvQWRzKEFkc1BhcmFtLlBvaW50SSwgZnVuY3Rpb24ob3V0KXtcclxuICAgICAgICAgICAgICAgIGlmKG91dCA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5nbG9iYWwuVGVtcEFkc1N0b2NrQm9udXMgPSBUZW1wQm9udXMuU3RvY2tCb251cztcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLmhhc0FjdGl2ZUd1U2hlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIFx0fVxyXG4gICAgXHRlbHNlIGlmKHRoaXMuZm9yV2hhdCA9PSBUZW1wQm9udXMuQXNzZXRCb251cylcclxuICAgIFx0e1xyXG4gICAgICAgICAgICBpZihjYy5NZ3IuZ2xvYmFsLmhhc0FjdGl2ZUNhaVNoZW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNjLk1nci5BZHNNZ3IuU2hvd1ZpZGVvQWRzKEFkc1BhcmFtLlBvaW50SiwgZnVuY3Rpb24ob3V0KXtcclxuICAgICAgICAgICAgICAgIGlmKG91dCA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLk1nci5nbG9iYWwuVGVtcEFkc0Fzc2V0Qm9udXMgPSBUZW1wQm9udXMuQXNzZXRCb251cztcclxuICAgICAgICAgICAgICAgICAgICBjYy5NZ3IuZ2xvYmFsLmhhc0FjdGl2ZUNhaVNoZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICBcdH1cclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gV2F0Y2hBZHNQYW5lbDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/AddCapacity.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1fbafyHMUZGWphXBhh7ao50', 'AddCapacity');
// Scripts/UI/AddCapacity.js

"use strict";

var AdsParam = require("AdsParam");
var AddCapacity = cc.Class({
  "extends": cc.Component,
  properties: {
    AddLbl: cc.Label,
    DesLbl: cc.Label,
    Slider: cc.Slider,
    Progress: cc.ProgressBar,
    AddNum: 10,
    CanAddNum: cc.Integer
  },
  ShowPanel: function ShowPanel() {
    this.AddNum = 10;
    this.AddLbl.string = 10;
    this.DesLbl.string = 200; //this.AddNum * cc.Mgr.global.AddCapacityCost;;
    this.Slider.progress = 0;
    this.Progress.progress = 0;
    this.CanAddNum = Math.floor(cc.Mgr.UserDataMgr.Cash / cc.Mgr.global.AddCapacityCost);
  },
  showRewardVideo: function showRewardVideo() {
    this.js2android('show_reward_video', '1');
  },
  ///激励视频播放完成回调方法 continue_game
  /// Native.android2js("continue_game", ()=>{
  ///     //激励视频播放完成，原生端回调
  /// });
  js2android: function js2android(name, data) {
    console.log("name:" + name + "-data:" + data);
    if (window.injectedObject && window.injectedObject.setJsContent) {
      window.injectedObject.setJsContent(name, data);
    }
  },
  OnSliderChange: function OnSliderChange() {
    this.AddNum = 10; //Math.floor(this.Slider.progress * this.CanAddNum);
    this.Progress.progress = this.Slider.progress;
    var money = this.AddNum * cc.Mgr.global.AddCapacityCost;
    this.DesLbl.string = "需要消耗" + money + "元现金";
    this.AddLbl.string = this.AddNum;
  },
  ClickAdd: function ClickAdd() {
    if (cc.Mgr.UserDataMgr.WareHouseAllCapcity >= 200) {
      this.ClosePanel();
      return;
    }
    var self = this;
    self.showRewardVideo();
    cc.Mgr.AdsMgr.ShowVideoAds(AdsParam.PointF, function (out) {
      if (out == 0) {
        cc.Mgr.UserDataMgr.WareHouseCapcity += self.AddNum;
        cc.Mgr.UserDataMgr.WareHouseAllCapcity += self.AddNum;
        cc.director.GlobalEvent.emit(cc.Mgr.Event.AddWareHouseCapacity, {});
        self.ClosePanel();
      }
    });
  },
  ClosePanel: function ClosePanel() {
    cc.Mgr.AudioMgr.playSFX("click");
    this.node.active = false;
  }
});
module.exports = AddCapacity;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXEFkZENhcGFjaXR5LmpzIl0sIm5hbWVzIjpbIkFkc1BhcmFtIiwicmVxdWlyZSIsIkFkZENhcGFjaXR5IiwiY2MiLCJDbGFzcyIsIkNvbXBvbmVudCIsInByb3BlcnRpZXMiLCJBZGRMYmwiLCJMYWJlbCIsIkRlc0xibCIsIlNsaWRlciIsIlByb2dyZXNzIiwiUHJvZ3Jlc3NCYXIiLCJBZGROdW0iLCJDYW5BZGROdW0iLCJJbnRlZ2VyIiwiU2hvd1BhbmVsIiwic3RyaW5nIiwicHJvZ3Jlc3MiLCJNYXRoIiwiZmxvb3IiLCJNZ3IiLCJVc2VyRGF0YU1nciIsIkNhc2giLCJnbG9iYWwiLCJBZGRDYXBhY2l0eUNvc3QiLCJzaG93UmV3YXJkVmlkZW8iLCJqczJhbmRyb2lkIiwibmFtZSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwid2luZG93IiwiaW5qZWN0ZWRPYmplY3QiLCJzZXRKc0NvbnRlbnQiLCJPblNsaWRlckNoYW5nZSIsIm1vbmV5IiwiQ2xpY2tBZGQiLCJXYXJlSG91c2VBbGxDYXBjaXR5IiwiQ2xvc2VQYW5lbCIsInNlbGYiLCJBZHNNZ3IiLCJTaG93VmlkZW9BZHMiLCJQb2ludEYiLCJvdXQiLCJXYXJlSG91c2VDYXBjaXR5IiwiZGlyZWN0b3IiLCJHbG9iYWxFdmVudCIsImVtaXQiLCJFdmVudCIsIkFkZFdhcmVIb3VzZUNhcGFjaXR5IiwiQXVkaW9NZ3IiLCJwbGF5U0ZYIiwibm9kZSIsImFjdGl2ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ2xDLElBQUlDLFdBQVcsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDdkIsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsTUFBTSxFQUFDSixFQUFFLENBQUNLLEtBQUs7SUFDZkMsTUFBTSxF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Q0FBQyxDQUFDLENBQUM7UUFDbkVWLElBQUksQ0FBQ0QsVUFBVSxFQUFFO01BQ3JCO0lBQ0osQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUVEQSxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFVO0lBQ3BCcEMsRUFBRSxDQUFDa0IsR0FBRyxDQUFDOEIsUUFBUSxDQUFDQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQzdCLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztFQUM1QjtBQUVKLENBQUMsQ0FBQztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR3RELFdBQVciLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbInZhciBBZHNQYXJhbSA9IHJlcXVpcmUoXCJBZHNQYXJhbVwiKTtcclxudmFyIEFkZENhcGFjaXR5ID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBBZGRMYmw6Y2MuTGFiZWwsXHJcbiAgICAgICAgRGVzTGJsOmNjLkxhYmVsLFxyXG4gICAgICAgIFNsaWRlcjpjYy5TbGlkZXIsXHJcbiAgICAgICAgUHJvZ3Jlc3M6Y2MuUHJvZ3Jlc3NCYXIsXHJcbiAgICAgICAgQWRkTnVtOjEwLFxyXG4gICAgICAgIENhbkFkZE51bTpjYy5JbnRlZ2VyLFxyXG4gICAgfSxcclxuXHJcbiAgICBTaG93UGFuZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLkFkZE51bSA9IDEwO1xyXG4gICAgICAgIHRoaXMuQWRkTGJsLnN0cmluZyA9IDEwO1xyXG4gICAgICAgIHRoaXMuRGVzTGJsLnN0cmluZyA9IDIwMCA7Ly90aGlzLkFkZE51bSAqIGNjLk1nci5nbG9iYWwuQWRkQ2FwYWNpdHlDb3N0OztcclxuICAgICAgICB0aGlzLlNsaWRlci5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5Qcm9ncmVzcy5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5DYW5BZGROdW0gPSBNYXRoLmZsb29yKGNjLk1nci5Vc2VyRGF0YU1nci5DYXNoIC8gY2MuTWdyLmdsb2JhbC5BZGRDYXBhY2l0eUNvc3QpO1xyXG4gICAgfSxcclxuICAgIHNob3dSZXdhcmRWaWRlbygpIHtcclxuICAgICAgICB0aGlzLmpzMmFuZHJvaWQoJ3Nob3dfcmV3YXJkX3ZpZGVvJywgJzEnKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLy/mv4DlirHop4bpopHmkq3mlL7lrozmiJDlm57osIPmlrnms5UgY29udGludWVfZ2FtZVxyXG4gICAgLy8vIE5hdGl2ZS5hbmRyb2lkMmpzKFwiY29udGludWVfZ2FtZVwiLCAoKT0+e1xyXG4gICAgLy8vICAgICAvL+a/gOWKseinhumikeaSreaUvuWujOaIkO+8jOWOn+eUn+err+Wbnuiwg1xyXG4gICAgLy8vIH0pO1xyXG4gICAganMyYW5kcm9pZChuYW1lLCBkYXRhKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhgbmFtZToke25hbWV9LWRhdGE6JHtkYXRhfWApO1xyXG4gICAgICAgIGlmKHdpbmRvdy5pbmplY3RlZE9iamVjdCAmJiB3aW5kb3cuaW5qZWN0ZWRPYmplY3Quc2V0SnNDb250ZW50KXtcclxuICAgICAgICAgICAgd2luZG93LmluamVjdGVkT2JqZWN0LnNldEpzQ29udGVudChuYW1lLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIE9uU2xpZGVyQ2hhbmdlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICBcclxuICAgICAgICB0aGlzLkFkZE51bSA9IDEwOy8vTWF0aC5mbG9vcih0aGlzLlNsaWRlci5wcm9ncmVzcyAqIHRoaXMuQ2FuQWRkTnVtKTtcclxuICAgICAgICB0aGlzLlByb2dyZXNzLnByb2dyZXNzID0gdGhpcy5TbGlkZXIucHJvZ3Jlc3M7XHJcbiAgICAgICAgdmFyIG1vbmV5ID0gdGhpcy5BZGROdW0gKiBjYy5NZ3IuZ2xvYmFsLkFkZENhcGFjaXR5Q29zdDtcclxuXHJcbiAgICAgICAgdGhpcy5EZXNMYmwuc3RyaW5nID0gXCLpnIDopoHmtojogJdcIittb25leStcIuWFg+eOsOmHkVwiO1xyXG4gICAgICAgIHRoaXMuQWRkTGJsLnN0cmluZyA9IHRoaXMuQWRkTnVtO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbGlja0FkZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKGNjLk1nci5Vc2VyRGF0YU1nci5XYXJlSG91c2VBbGxDYXBjaXR5ID49IDIwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuQ2xvc2VQYW5lbCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLnNob3dSZXdhcmRWaWRlbygpO1xyXG4gICAgICAgIGNjLk1nci5BZHNNZ3IuU2hvd1ZpZGVvQWRzKEFkc1BhcmFtLlBvaW50RiwgZnVuY3Rpb24ob3V0KXtcclxuICAgICAgICAgICAgaWYob3V0ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNjLk1nci5Vc2VyRGF0YU1nci5XYXJlSG91c2VDYXBjaXR5ICs9IHNlbGYuQWRkTnVtO1xyXG4gICAgICAgICAgICAgICAgY2MuTWdyLlVzZXJEYXRhTWdyLldhcmVIb3VzZUFsbENhcGNpdHkgKz0gc2VsZi5BZGROdW07XHJcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5HbG9iYWxFdmVudC5lbWl0KGNjLk1nci5FdmVudC5BZGRXYXJlSG91c2VDYXBhY2l0eSwge30pO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5DbG9zZVBhbmVsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgQ2xvc2VQYW5lbDpmdW5jdGlvbigpe1xyXG4gICAgXHRjYy5NZ3IuQXVkaW9NZ3IucGxheVNGWChcImNsaWNrXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBBZGRDYXBhY2l0eTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/UI/UnlockMatePanel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9bbd2ZpGbFOe7CAGZkMPc2h', 'UnlockMatePanel');
// Scripts/UI/UnlockMatePanel.js

"use strict";

var UnlockMatePanel = cc.Class({
  "extends": cc.Component,
  properties: {
    Atlas: cc.SpriteAtlas,
    Sp: cc.Sprite,
    desLbl: cc.RichText
  },
  ShowPanel: function ShowPanel(data) {
    this.Sp.spriteFrame = this.Atlas.getSpriteFrame(data.icon);
    this.desLbl.string = "<color=#16a0e8>" + data.des + "</c>";
  },
  ClosePanel: function ClosePanel() {
    this.node.active = false;
  }
});
module.exports = UnlockMatePanel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcVUlcXFVubG9ja01hdGVQYW5lbC5qcyJdLCJuYW1lcyI6WyJVbmxvY2tNYXRlUGFuZWwiLCJjYyIsIkNsYXNzIiwiQ29tcG9uZW50IiwicHJvcGVydGllcyIsIkF0bGFzIiwiU3ByaXRlQXRsYXMiLCJTcCIsIlNwcml0ZSIsImRlc0xibCIsIlJpY2hUZXh0IiwiU2hvd1BhbmVsIiwiZGF0YSIsInNwcml0ZUZyYW1lIiwiZ2V0U3ByaXRlRnJhbWUiLCJpY29uIiwic3RyaW5nIiwiZGVzIiwiQ2xvc2VQYW5lbCIsIm5vZGUiLCJhY3RpdmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQUlBLGVBQWUsR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDM0IsV0FBU0QsRUFBRSxDQUFDRSxTQUFTO0VBRXJCQyxVQUFVLEVBQUU7SUFDUkMsS0FBSyxFQUFDSixFQUFFLENBQUNLLFdBQVc7SUFDcEJDLEVBQUUsRUFBQ04sRUFBRSxDQUFDTyxNQUFNO0lBQ1pDLE1BQU0sRUFBQ1IsRUFBRSxDQUFDUztFQUVkLENBQUM7RUFFREMsU0FBUyxFQUFDLFNBQUFBLFVBQVNDLElBQUksRUFBQztJQUNwQixJQUFJLENBQUNMLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxjQUFjLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDO0lBQzFELElBQUksQ0FBQ04sTUFBTSxDQUFDTyxNQUFNLEdBQUcsaUJBQWlCLEdBQUNKLElBQUksQ0FBQ0ssR0FBRyxHQUFHLE1BQU07RUFDNUQsQ0FBQztFQUVEQyxVQUFVLEVBQUMsU0FBQUEsV0FBQSxFQUFZO0lBQ25CLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztFQUM1QjtBQUdKLENBQUMsQ0FBQztBQUNGQyxNQUFNLENBQUNDLE9BQU8sR0FBR3RCLGVBQWUiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgVW5sb2NrTWF0ZVBhbmVsID0gY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBBdGxhczpjYy5TcHJpdGVBdGxhcyxcclxuICAgICAgICBTcDpjYy5TcHJpdGUsXHJcbiAgICAgICAgZGVzTGJsOmNjLlJpY2hUZXh0LFxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgU2hvd1BhbmVsOmZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgIHRoaXMuU3Auc3ByaXRlRnJhbWUgPSB0aGlzLkF0bGFzLmdldFNwcml0ZUZyYW1lKGRhdGEuaWNvbik7XHJcbiAgICAgICAgdGhpcy5kZXNMYmwuc3RyaW5nID0gXCI8Y29sb3I9IzE2YTBlOD5cIitkYXRhLmRlcyArIFwiPC9jPlwiO1xyXG4gICAgfSxcclxuXHJcbiAgICBDbG9zZVBhbmVsOmZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIFxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBVbmxvY2tNYXRlUGFuZWw7XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/sdk/eyouClient.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '986f5W4x0xMRYP+4Hd9Lz8z', 'eyouClient');
// Scripts/sdk/eyouClient.js

"use strict";

exports.__esModule = true;
exports["default"] = void 0;
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var BASE_URL = 'https://games.hndibei.com';
var EyouClientV2 = /*#__PURE__*/function () {
  function EyouClientV2() {
    var N = null,
      h = 0x1,
      E = null,
      i = null,
      b = '-1',
      g = '-1',
      B = 0x4,
      n = null,
      D = null,
      R = null,
      x = null,
      P = null,
      K = null,
      y = null;
    var f = function f(Z) {
        N = Z;
        var l = wx['getSystemInfoSync']();
        B = l['platform'] === 'android' ? '4' : l['platform'] === 'ios' ? '5' : '6';
        var a = wx['getLaunchOptionsSync']()['query'];
        E = a['channel'], i = a['sub_channel'];
        var O = {
          '10908': ['ad_id', 'clue_token'],
          '10918': ['ad_id', 'clue_token'],
          '10912': ['weixinadinfo'],
          '10913': ['ksUnitId', 'callback'],
          '10914': ['uid', 'bd_vid'],
          '10916': ['aid', 'trackid'],
          '10917': ['campaignid', 'uctrackid'],
          '10919': ['promotion_id', 'clue_token'],
          '10920': ['ADID', 'imp', 'mark_id']
        };
        if (O['hasOwnProperty'](E)) {
          var _O$E = O[E],
            j = _O$E[0],
            I = _O$E[1],
            Q = _O$E[2];
          if (j === 'weixinadinfo') {
            var s = a['weixinadinfo'];
            if (s) {
              var p = s['split']('.');
              b = p[0x0], g = p[0x1];
            }
          } else b = a[j], g = a[I], !g && Q && (g = a[Q]);
        } else E = '10906', i = '' + N + h + E + B + '0';
      },
      c = function c() {
        return new Promise(function (Z, l) {
          wx['login']({
            'success': function success(_ref) {
              var a = _ref.code;
              a ? Z(a) : l(new Error('获取code失败'));
            },
            'fail': l
          });
        });
      },
      C = function C(Z, l) {
        return new Promise(function (a, O) {
          wx['request']({
            'url': Z,
            'method': 'POST',
            'header': {
              'Content-Type': 'application/json'
            },
            'data': JSON['stringify'](l),
            'fail': O,
            'success': function success(j) {
              a(j['data']);
            },
            'complete': function complete(j) {
              console['log']('---------------------------------请求\x20BEGIN--------------------------------'), console['log']('Url:>', Z), console['log']('请求参数:>', l), console['log']('响应:>', j['data'] || j['errMsg']), console['log']('---------------------------------请求\x20END--------------------------------');
            }
          });
        });
      },
      t = BASE_URL + '/market-wechat-game-server/wxTransfer/showTransfer',
      L = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(Z) {
          var l, a, _a$data, O, j, I, Q, s;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                l = {
                  'gameId': N,
                  'platformId': h,
                  'transferNodeType': Z,
                  'userId': D,
                  'sys': B
                };
                _context.next = 4;
                return C(t, l);
              case 4:
                a = _context.sent;
                if (a['code'] === CodeStatus['SUCCESS']) {
                  _a$data = a['data'], O = _a$data.transferType, j = _a$data.showText, I = _a$data.copyText, Q = _a$data.pictureUrl, s = _a$data.showTip;
                  if (O === 0x1) wx['showModal']({
                    'title': '公告',
                    'content': j,
                    'confirmText': '复制链接',
                    'success': function success(p) {
                      p['confirm'] && wx['setClipboardData']({
                        'data': I
                      });
                    }
                  });else {
                    if (O === 0x2) wx['previewImage']({
                      'urls': [Q + '?time=' + Math['floor'](Date['now']() / 0x3e8)]
                    });else O === 0x3 && s('公告', s);
                  }
                } else console['log']('公告展示失败:', a['message']);
                return _context.abrupt("return", {
                  'success': !![],
                  'result': a
                });
              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", (console['error']('[展示公告]异常:', _context.t0), {
                  'success': ![],
                  'error': error
                }));
              case 12:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[0, 9]]);
        }));
        return function L(_x) {
          return _ref2.apply(this, arguments);
        };
      }(),
      m = function m(Z, l) {
        Z['gameId'] = N, (Z['platformId'] = h, Z['sys'] = B), Y(Z)['then'](function (a) {
          if (a['payType'] == 0x1) a['balance'] > 0x0 ? A('充值提示', '账户余额:' + a['balance'] + '元,\x20还需充值:' + a['needPay'] + '元', function () {
            return M(a);
          }) : M(a, l);else {
            if (a['payType'] == 0x2) q(a, l);else {
              if (a['payType'] == 0x4) wx['showModal']({
                'title': '充值提示',
                'content': '即将展示充值二维码,\x20请扫描二维码完成支付',
                'success': function success(O) {
                  O['confirm'] && wx['previewImage']({
                    'urls': [a['payUrl']]
                  });
                }
              });else throw new Error('非法支付类型');
            }
          }
        });
      },
      M = function M(Z, l) {
        if (Z['needPay'] == 0x0) {
          k(Z, l);
          return;
        }
        wx['requestMidasPayment']({
          'mode': 'game',
          'env': 0x0,
          'offerId': Z['offerId'],
          'currencyType': 'CNY',
          'platform': 'android',
          'buyQuantity': Z['needPay'] * Z['midasRate'],
          'zoneId': '1',
          'success': function success(a) {
            k(Z, l);
          },
          'fail': function fail(a) {
            A('微信支付失败', a);
          }
        });
      },
      q = function q(Z, l) {
        wx['openCustomerServiceConversation']({
          'showMessageCard': !![],
          'sessionFrom': Z['payUrl'],
          'sendMessagePath': '/index.wxml?url=' + Z['payUrl'],
          'sendMessageTitle': '发送卡片充值',
          'sendMessageImg': Z['payIconUrl']
        });
      },
      X = BASE_URL + '/market-wechat-game-server/wxClient/deduct',
      k = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(Z, l) {
          var a, O, j, I, Q;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                a = {
                  'orderId': Z['orderId'],
                  'gameId': N,
                  'platformId': h,
                  'userId': Z['userId']
                }, O = 0x3;
                j = 0x0, I = ![];
              case 2:
                if (!(j < O && !I)) {
                  _context2.next = 22;
                  break;
                }
                _context2.prev = 3;
                _context2.next = 6;
                return C(X, a);
              case 6:
                Q = _context2.sent;
                _context2.t0 = Q['code'] === CodeStatus['GAME_SESSION_KEY_TIME_OUT_ERR'];
                if (!_context2.t0) {
                  _context2.next = 11;
                  break;
                }
                _context2.next = 11;
                return v();
              case 11:
                if (!(Q['code'] === CodeStatus['SUCCESS'])) {
                  _context2.next = 14;
                  break;
                }
                l(Q);
                return _context2.abrupt("break", 22);
              case 14:
                _context2.next = 19;
                break;
              case 16:
                _context2.prev = 16;
                _context2.t1 = _context2["catch"](3);
                console['error']('[扣款失败]异常:>', _context2.t1);
              case 19:
                j++;
                _context2.next = 2;
                break;
              case 22:
              case "end":
                return _context2.stop();
            }
          }, _callee2, null, [[3, 16]]);
        }));
        return function k(_x2, _x3) {
          return _ref3.apply(this, arguments);
        };
      }(),
      W = BASE_URL + '/market-wechat-game-server/wxClient/pullPay',
      Y = /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(Z) {
          var l, a, O, j, I;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                l = 0x3;
                a = 0x0, O = ![], j = ![];
              case 2:
                if (!(a < l && !O)) {
                  _context3.next = 25;
                  break;
                }
                _context3.prev = 3;
                _context3.next = 6;
                return C(W, Z);
              case 6:
                I = _context3.sent;
                if (!(I['code'] === CodeStatus['SUCCESS'])) {
                  _context3.next = 11;
                  break;
                }
                return _context3.abrupt("return", I['data']);
              case 11:
                if (!(I['code'] === CodeStatus['GAME_SESSION_KEY_TIME_OUT_ERR'])) {
                  _context3.next = 16;
                  break;
                }
                _context3.next = 14;
                return v();
              case 14:
                _context3.next = 17;
                break;
              case 16:
                !j && (A('支付拉起失败', I['message']), j = !![]);
              case 17:
                _context3.next = 22;
                break;
              case 19:
                _context3.prev = 19;
                _context3.t0 = _context3["catch"](3);
                !j && (A('支付拉起失败', '网络超时'), j = !![]);
              case 22:
                a++;
                _context3.next = 2;
                break;
              case 25:
                throw new Error('支付拉起失败');
              case 26:
              case "end":
                return _context3.stop();
            }
          }, _callee3, null, [[3, 19]]);
        }));
        return function Y(_x4) {
          return _ref4.apply(this, arguments);
        };
      }(),
      u = BASE_URL + '/market-wechat-game-server/wxClient/refreshSession',
      v = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var Z, l, a, O, j, I;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                Z = 0x3;
                l = 0x0, a = ![];
              case 2:
                if (!(l < Z && !a)) {
                  _context4.next = 19;
                  break;
                }
                _context4.prev = 3;
                _context4.next = 6;
                return c();
              case 6:
                O = _context4.sent;
                j = {
                  'gameId': N,
                  'platformId': h,
                  'code': O
                };
                _context4.next = 10;
                return C(u, j);
              case 10:
                I = _context4.sent;
                a = I['code'] === CodeStatus['SUCCESS'];
                _context4.next = 17;
                break;
              case 14:
                _context4.prev = 14;
                _context4.t0 = _context4["catch"](3);
                console['error']('[刷新会话失败]异常:>', _context4.t0), l++;
              case 17:
                _context4.next = 2;
                break;
              case 19:
                if (a) {
                  _context4.next = 21;
                  break;
                }
                throw new Error('刷新会话失败');
              case 21:
              case "end":
                return _context4.stop();
            }
          }, _callee4, null, [[3, 14]]);
        }));
        return function v() {
          return _ref5.apply(this, arguments);
        };
      }(),
      J = BASE_URL + '/market-wechat-game-server/wxClient/adAction',
      A = function A(Z, l, a, O) {
        wx['showModal']({
          'title': Z,
          'content': l,
          'success': function success(j) {
            if (j['confirm'] && a) a();else j['cancel'] && O && O();
          }
        });
      },
      H = function H(Z, l, a) {
        var O = {
          'gameId': N,
          'platformId': h,
          'channelId': E,
          'subChannelId': i,
          'aid': b,
          'traceId': g,
          'sys': B,
          'userId': D,
          'adType': Z,
          'adUnitId': l,
          'adActionType': a
        };
        C(J, O)['catch'](function (j) {
          console['log']('发送广告行为失败:>', j);
        });
      },
      U = BASE_URL + '/market-wechat-game-server/wxClient/initGame';
    this['init'] = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(Z, l) {
        var a, O, j;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              f(Z);
              _context5.next = 4;
              return c();
            case 4:
              a = _context5.sent;
              O = {
                'code': a,
                'gameId': N,
                'platformId': h,
                'channelId': E,
                'subChannelId': i,
                'aid': b,
                'traceId': g,
                'sys': B
              };
              _context5.next = 8;
              return C(U, O);
            case 8:
              j = _context5.sent;
              j['code'] === CodeStatus['SUCCESS'] && (D = j['data']['userId'], console['log'](D), R = j['data']['unionId'], n = a, j['data'] = null), l(j);
              _context5.next = 15;
              break;
            case 12:
              _context5.prev = 12;
              _context5.t0 = _context5["catch"](0);
              console['error']('[初始化游戏]异常:>', _context5.t0);
            case 15:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 12]]);
      }));
      return function (_x5, _x6) {
        return _ref6.apply(this, arguments);
      };
    }(), this['login'] = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(Z) {
        var l;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return L(0x1);
            case 3:
              l = _context6.sent;
              (!l['success'] || l['result']['code'] != 0x0 || l['result']['data']['transferType'] != 0x3) && Z({
                'code': CodeStatus['SUCCESS'],
                'message': '操作成功',
                'data': {
                  'code': n
                }
              });
              _context6.next = 10;
              break;
            case 7:
              _context6.prev = 7;
              _context6.t0 = _context6["catch"](0);
              console['error']('[登录游戏]异常:>', _context6.t0);
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6, null, [[0, 7]]);
      }));
      return function (_x7) {
        return _ref7.apply(this, arguments);
      };
    }(), this['pay'] = /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(Z, l) {
        var a;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return L(0x2);
            case 3:
              a = _context7.sent;
              (!a['success'] || a['result']['code'] != 0x0) && m(Z, l);
              _context7.next = 10;
              break;
            case 7:
              _context7.prev = 7;
              _context7.t0 = _context7["catch"](0);
              console['error']('[支付拉起]异常:>', _context7.t0);
            case 10:
            case "end":
              return _context7.stop();
          }
        }, _callee7, null, [[0, 7]]);
      }));
      return function (_x8, _x9) {
        return _ref8.apply(this, arguments);
      };
    }();
    var d = BASE_URL + '/market-wechat-game-server/wxClient/uploadRoleInfo';
    this['uploadRoleInfo'] = /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(Z, l) {
        var a;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              Z['gameId'] = N, Z['platformId'] = h;
              _context8.next = 4;
              return C(d, Z);
            case 4:
              a = _context8.sent;
              l(a);
              _context8.next = 11;
              break;
            case 8:
              _context8.prev = 8;
              _context8.t0 = _context8["catch"](0);
              console['error']('上报角色数据异常:>', _context8.t0);
            case 11:
            case "end":
              return _context8.stop();
          }
        }, _callee8, null, [[0, 8]]);
      }));
      return function (_x10, _x11) {
        return _ref9.apply(this, arguments);
      };
    }();
    var V = BASE_URL + '/market-wechat-game-server/wxServer/msgSecCheck';
    this['msgSecCheck'] = /*#__PURE__*/function () {
      var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(Z, l) {
        var a;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              Z['gameId'] = N, Z['platformId'] = h;
              _context9.prev = 1;
              _context9.next = 4;
              return C(V, Z);
            case 4:
              a = _context9.sent;
              l(a);
              _context9.next = 11;
              break;
            case 8:
              _context9.prev = 8;
              _context9.t0 = _context9["catch"](1);
              console['error']('[文本安全检测]异常:>', _context9.t0);
            case 11:
            case "end":
              return _context9.stop();
          }
        }, _callee9, null, [[1, 8]]);
      }));
      return function (_x12, _x13) {
        return _ref10.apply(this, arguments);
      };
    }(), this['createRewardedVideoAd'] = function (Z, l) {
      if (!wx['createRewardedVideoAd']) {
        A('提示', '基础库版本号过低,\x20暂不支持展示激励视频');
        return;
      }
      if (x != Z['adUnitId']) {
        if (P) {
          P['destory'](), x = null, P = null, createRewardedVideoAd(Z, l);
          return;
        }
        var a = {
          'adUnitId': Z['adUnitId']
        };
        Z['multiton'] && (a['multiton'] = Z['multiton']), P = wx['createRewardedVideoAd'](a), P['onError'](function (O) {
          return console['log']('激励视频程序出错:>', O);
        }), P['onClose'](function (O) {
          O && O['isEnded'] || O === undefined ? (H(AdType['REWARDED_VIDEO_AD'], x, AdActionType['FINISHED']), Z['onClose'] && Z['onClose']({
            'code': CodeStatus['SUCCESS'],
            'message': '播放完成',
            'data': null
          })) : Z['onClose'] && Z['onClose']({
            'code': CodeStatus['FAILED'],
            'message': '播放未完成',
            'data': null
          });
        }), x = Z['adUnitId'];
      }
      l({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': null
      });
    }, this['showRewardedVideoAd'] = function () {
      P && P['show']()['then'](function () {
        return H(AdType['REWARDED_VIDEO_AD'], x, AdActionType['SHOW']);
      })['catch'](function () {
        P['load']()['then'](function () {
          return P['show']()['then'](function () {
            return H(AdType['REWARDED_VIDEO_AD'], x, AdActionType['SHOW']);
          });
        })['catch'](function (Z) {
          return console['log']('激励视频\x20广告显示失败');
        });
      });
    }, this['createBannerAd'] = function (Z, l) {
      if (!wx['createBannerAd']) {
        A('提示', '基础库版本号过低,\x20暂不支持展示Banner广告');
        return;
      }
      if (K != Z['adUnitId']) {
        if (y) {
          y['destory'](), K = null, y = null, createBannerAd(Z, l);
          return;
        }
        var a = {
          'adUnitId': Z['adUnitId'],
          'style': Z['style']
        };
        Z['adIntervals'] && (a['adIntervals'] = Z['adIntervals']), y = wx['createBannerAd'](a), y['onLoad'](function () {
          H(AdType['BANNER_AD'], K, AdActionType['FINISHED']);
        }), y['onError'](function (O) {
          return console['log']('banner广告程序出错:>', O);
        }), K = Z['adUnitId'];
      }
      l({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': null
      });
    }, this['showBannerAd'] = function () {
      y && y['show']();
    }, this['hideBannerAd'] = function () {
      y && y['hide']();
    }, this['setStorageSync'] = function (Z, l) {
      wx['setStorageSync'](Z, l);
    }, this['removeStorageSync'] = function (Z) {
      wx['removeStorageSync'](Z);
    }, this['getStorageSync'] = function (Z) {
      return wx['getStorageSync'](Z);
    };
  }
  EyouClientV2['getIns'] = function getIns() {
    return !this['ins'] && (this['ins'] = new EyouClientV2()), this['ins'];
  };
  return EyouClientV2;
}();
exports["default"] = EyouClientV2;
var CodeStatus = function CodeStatus() {};
CodeStatus['SUCCESS'] = 0x0;
CodeStatus['FAILED'] = -0x1;
CodeStatus['GAME_SESSION_KEY_TIME_OUT_ERR'] = 0x2729;
var AdType = function AdType() {};
AdType['REWARDED_VIDEO_AD'] = 0x1;
AdType['BANNER_AD'] = 0x2;
var AdActionType = function AdActionType() {};
AdActionType['SHOW'] = 0x1;
AdActionType['FINISHED'] = 0x2;
module.exports = exports["default"];

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcc2RrXFxleW91Q2xpZW50LmpzIl0sIm5hbWVzIjpbIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJleHBvcnRzIiwiT3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwiZGVzYyIsInZhbHVlIiwiJFN5bWJvbCIsIlN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsImNvbnRleHQiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJ0eXBlIiwiY2FsbCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJfaW52b2tlIiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInJlc3VsdCIsIl9fYXdhaXQiLCJ0aGVuIiwidW53cmFwcGVkIiwiZXJyb3IiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsImRvbmUiLCJtZXRob2ROYW1lIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaW5mbyIsInJlc3VsdE5hbWUiLCJuZXh0IiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmFibGUiLCJpdGVyYXRvck1ldGhvZCIsImlzTmFOIiwibGVuZ3RoIiwiaSIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJtYXJrIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJhd3JhcCIsImFzeW5jIiwiUHJvbWlzZSIsIml0ZXIiLCJrZXlzIiwidmFsIiwib2JqZWN0IiwicmV2ZXJzZSIsInBvcCIsInNraXBUZW1wUmVzZXQiLCJwcmV2IiwiY2hhckF0Iiwic2xpY2UiLCJzdG9wIiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJfbmV4dCIsIl90aHJvdyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiQkFTRV9VUkwiLCJFeW91Q2xpZW50VjIiLCJOIiwiaCIsIkUiLCJiIiwiZyIsIkIiLCJuIiwiRCIsIlIiLCJ4IiwiUCIsIksiLCJ5IiwiZiIsIloiLCJsIiwid3giLCJhIiwiTyIsIl9PJEUiLCJqIiwiSSIsIlEiLCJzIiwicCIsImMiLCJzdWNjZXNzIiwiX3JlZiIsImNvZGUiLCJDIiwiSlNPTiIsImNvbnNvbGUiLCJ0IiwiTCIsIl9yZWYyIiwiX2NhbGxlZSIsIl9hJGRhdGEiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwiQ29kZVN0YXR1cyIsInRyYW5zZmVyVHlwZSIsInNob3dUZXh0IiwiY29weVRleHQiLCJwaWN0dXJlVXJsIiwic2hvd1RpcCIsIk1hdGgiLCJEYXRlIiwidDAiLCJfeCIsIm0iLCJZIiwiQSIsIk0iLCJxIiwiayIsImZhaWwiLCJYIiwiX3JlZjMiLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsInYiLCJ0MSIsIl94MiIsIl94MyIsIlciLCJfcmVmNCIsIl9jYWxsZWUzIiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiX3g0IiwidSIsIl9yZWY1IiwiX2NhbGxlZTQiLCJfY2FsbGVlNCQiLCJfY29udGV4dDQiLCJKIiwiSCIsIlUiLCJfcmVmNiIsIl9jYWxsZWU1IiwiX2NhbGxlZTUkIiwiX2NvbnRleHQ1IiwiX3g1IiwiX3g2IiwiX3JlZjciLCJfY2FsbGVlNiIsIl9jYWxsZWU2JCIsIl9jb250ZXh0NiIsIl94NyIsIl9yZWY4IiwiX2NhbGxlZTciLCJfY2FsbGVlNyQiLCJfY29udGV4dDciLCJfeDgiLCJfeDkiLCJkIiwiX3JlZjkiLCJfY2FsbGVlOCIsIl9jYWxsZWU4JCIsIl9jb250ZXh0OCIsIl94MTAiLCJfeDExIiwiViIsIl9yZWYxMCIsIl9jYWxsZWU5IiwiX2NhbGxlZTkkIiwiX2NvbnRleHQ5IiwiX3gxMiIsIl94MTMiLCJjcmVhdGVSZXdhcmRlZFZpZGVvQWQiLCJBZFR5cGUiLCJBZEFjdGlvblR5cGUiLCJjcmVhdGVCYW5uZXJBZCIsImdldElucyIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0FDQSxxSkFBQUEsbUJBQUEsWUFBQUEsb0JBQUEsV0FBQUMsT0FBQSxTQUFBQSxPQUFBLE9BQUFDLEVBQUEsR0FBQUMsTUFBQSxDQUFBQyxTQUFBLEVBQUFDLE1BQUEsR0FBQUgsRUFBQSxDQUFBSSxjQUFBLEVBQUFDLGNBQUEsR0FBQUosTUFBQSxDQUFBSSxjQUFBLGNBQUFDLEdBQUEsRUFBQUMsR0FBQSxFQUFBQyxJQUFBLElBQUFGLEdBQUEsQ0FBQUMsR0FBQSxJQUFBQyxJQUFBLENBQUFDLEtBQUEsS0FBQUMsT0FBQSx3QkFBQUMsTUFBQSxHQUFBQSxNQUFBLE9BQUFDLGNBQUEsR0FBQUYsT0FBQSxDQUFBRyxRQUFBLGtCQUFBQyxtQkFBQSxHQUFBSixPQUFBLENBQUFLLGFBQUEsdUJBQUFDLGlCQUFBLEdBQUFOLE9BQUEsQ0FBQU8sV0FBQSw4QkFBQUMsT0FBQVosR0FBQSxFQUFBQyxHQUFBLEVBQUFFLEtBQUEsV0FBQVIsTUFBQSxDQUFBSSxjQUFBLENBQUFDLEdBQUEsRUFBQUMsR0FBQSxJQUFBRSxLQUFBLEVBQUFBLEtBQUEsRUFBQVUsVUFBQSxNQUFBQyxZQUFBLE1BQUFDLFFBQUEsU0FBQWYsR0FBQSxDQUFBQyxHQUFBLFdBQUFXLE1BQUEsbUJBQUFJLEdBQUEsSUFBQUosTUFBQSxZQUFBQSxPQUFBWixHQUFBLEVBQUFDLEdBQUEsRUFBQUUsS0FBQSxXQUFBSCxHQUFBLENBQUFDLEdBQUEsSUFBQUUsS0FBQSxnQkFBQWMsS0FBQUMsT0FBQSxFQUFBQyxPQUFBLEVBQUFDLElBQUEsRUFBQUMsV0FBQSxRQUFBQyxjQUFBLEdBQUFILE9BQUEsSUFBQUEsT0FBQSxDQUFBdkIsU0FBQSxZQUFBMkIsU0FBQSxHQUFBSixPQUFBLEdBQUFJLFNBQUEsRUFBQUMsU0FBQSxHQUFBN0IsTUFBQSxDQUFBOEIsTUFBQSxDQUFBSCxjQUFBLENBQUExQixTQUFBLEdBQUE4QixPQUFBLE9BQUFDLE9BQUEsQ0FBQU4sV0FBQSxnQkFBQXRCLGNBQUEsQ0FBQXlCLFNBQUEsZUFBQXJCLEtBQUEsRUFBQXlCLGdCQUFBLENBQUFWLE9BQUEsRUFBQUUsSUFBQSxFQUFBTSxPQUFBLE1BQUFGLFNBQUEsYUFBQUssU0FBQUMsRUFBQSxFQUFBOUIsR0FBQSxFQUFBK0IsR0FBQSxtQkFBQUMsSUFBQSxZQUFBRCxHQUFBLEVBQUFELEVBQUEsQ0FBQUcsSUFBQSxDQUFBakMsR0FBQSxFQUFBK0IsR0FBQSxjQUFBZixHQUFBLGFBQUFnQixJQUFBLFdBQUFELEdBQUEsRUFBQWYsR0FBQSxRQUFBdkIsT0FBQSxDQUFBd0IsSUFBQSxHQUFBQSxJQUFBLE1BQUFpQixnQkFBQSxnQkFBQVgsVUFBQSxjQUFBWSxrQkFBQSxjQUFBQywyQkFBQSxTQUFBQyxpQkFBQSxPQUFBekIsTUFBQSxDQUFBeUIsaUJBQUEsRUFBQS9CLGNBQUEscUNBQUFnQyxRQUFBLEdBQUEzQyxNQUFBLENBQUE0QyxjQUFBLEVBQUFDLHVCQUFBLEdBQUFGLFFBQUEsSUFBQUEsUUFBQSxDQUFBQSxRQUFBLENBQUFHLE1BQUEsUUFBQUQsdUJBQUEsSUFBQUEsdUJBQUEsS0FBQTlDLEVBQUEsSUFBQUcsTUFBQSxDQUFBb0MsSUFBQSxDQUFBTyx1QkFBQSxFQUFBbEMsY0FBQSxNQUFBK0IsaUJBQUEsR0FBQUcsdUJBQUEsT0FBQUUsRUFBQSxHQUFBTiwwQkFBQSxDQUFBeEMsU0FBQSxHQUFBMkIsU0FBQSxDQUFBM0IsU0FBQSxHQUFBRCxNQUFBLENBQUE4QixNQUFBLENBQUFZLGlCQUFBLFlBQUFNLHNCQUFBL0MsU0FBQSxnQ0FBQWdELE9BQUEsV0FBQUMsTUFBQSxJQUFBakMsTUFBQSxDQUFBaEIsU0FBQSxFQUFBaUQsTUFBQSxZQUFBZCxHQUFBLGdCQUFBZSxPQUFBLENBQUFELE1BQUEsRUFBQWQsR0FBQSxzQkFBQWdCLGNBQUF2QixTQUFBLEVBQUF3QixXQUFBLGFBQUFDLE9BQUFKLE1BQUEsRUFBQWQsR0FBQSxFQUFBbUIsT0FBQSxFQUFBQyxNQUFBLFFBQUFDLE1BQUEsR0FBQXZCLFFBQUEsQ0FBQUwsU0FBQSxDQUFBcUIsTUFBQSxHQUFBckIsU0FBQSxFQUFBTyxHQUFBLG1CQUFBcUIsTUFBQSxDQUFBcEIsSUFBQSxRQUFBcUIsTUFBQSxHQUFBRCxNQUFBLENBQUFyQixHQUFBLEVBQUE1QixLQUFBLEdBQUFrRCxNQUFBLENBQUFsRCxLQUFBLFNBQUFBLEtBQUEsdUJBQUFBLEtBQUEsSUFBQU4sTUFBQSxDQUFBb0MsSUFBQSxDQUFBOUIsS0FBQSxlQUFBNkMsV0FBQSxDQUFBRSxPQUFBLENBQUEvQyxLQUFBLENBQUFtRCxPQUFBLEVBQUFDLElBQUEsV0FBQXBELEtBQUEsSUFBQThDLE1BQUEsU0FBQTlDLEtBQUEsRUFBQStDLE9BQUEsRUFBQUMsTUFBQSxnQkFBQW5DLEdBQUEsSUFBQWlDLE1BQUEsVUFBQWpDLEdBQUEsRUFBQWtDLE9BQUEsRUFBQUMsTUFBQSxRQUFBSCxXQUFBLENBQUFFLE9BQUEsQ0FBQS9DLEtBQUEsRUFBQW9ELElBQUEsV0FBQUMsU0FBQSxJQUFBSCxNQUFBLENBQUFsRCxLQUFBLEdBQUFxRCxTQUFBLEVBQUFOLE9BQUEsQ0FBQUcsTUFBQSxnQkFBQUksS0FBQSxXQUFBUixNQUFBLFVBQUFRLEtBQUEsRUFBQVAsT0FBQSxFQUFBQyxNQUFBLFNBQUFBLE1BQUEsQ0FBQUMsTUFBQSxDQUFBckIsR0FBQSxTQUFBMkIsZUFBQSxFQUFBM0QsY0FBQSxvQkFBQUksS0FBQSxXQUFBQSxNQUFBMEMsTUFBQSxFQUFBZCxHQUFBLGFBQUE0QiwyQkFBQSxlQUFBWCxXQUFBLFdBQUFFLE9BQUEsRUFBQUMsTUFBQSxJQUFBRixNQUFBLENBQUFKLE1BQUEsRUFBQWQsR0FBQSxFQUFBbUIsT0FBQSxFQUFBQyxNQUFBLGdCQUFBTyxlQUFBLEdBQUFBLGVBQUEsR0FBQUEsZUFBQSxDQUFBSCxJQUFBLENBQUFJLDBCQUFBLEVBQUFBLDBCQUFBLElBQUFBLDBCQUFBLHFCQUFBL0IsaUJBQUFWLE9BQUEsRUFBQUUsSUFBQSxFQUFBTSxPQUFBLFFBQUFrQyxLQUFBLHNDQUFBZixNQUFBLEVBQUFkLEdBQUEsd0JBQUE2QixLQUFBLFlBQUFDLEtBQUEsc0RBQUFELEtBQUEsb0JBQUFmLE1BQUEsUUFBQWQsR0FBQSxTQUFBK0IsVUFBQSxXQUFBcEMsT0FBQSxDQUFBbUIsTUFBQSxHQUFBQSxNQUFBLEVBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQUEsR0FBQSxVQUFBZ0MsUUFBQSxHQUFBckMsT0FBQSxDQUFBcUMsUUFBQSxNQUFBQSxRQUFBLFFBQUFDLGNBQUEsR0FBQUMsbUJBQUEsQ0FBQUYsUUFBQSxFQUFBckMsT0FBQSxPQUFBc0MsY0FBQSxRQUFBQSxjQUFBLEtBQUE5QixnQkFBQSxtQkFBQThCLGNBQUEscUJBQUF0QyxPQUFBLENBQUFtQixNQUFBLEVBQUFuQixPQUFBLENBQUF3QyxJQUFBLEdBQUF4QyxPQUFBLENBQUF5QyxLQUFBLEdBQUF6QyxPQUFBLENBQUFLLEdBQUEsc0JBQUFMLE9BQUEsQ0FBQW1CLE1BQUEsNkJBQUFlLEtBQUEsUUFBQUEsS0FBQSxnQkFBQWxDLE9BQUEsQ0FBQUssR0FBQSxFQUFBTCxPQUFBLENBQUEwQyxpQkFBQSxDQUFBMUMsT0FBQSxDQUFBSyxHQUFBLHVCQUFBTCxPQUFBLENBQUFtQixNQUFBLElBQUFuQixPQUFBLENBQUEyQyxNQUFBLFdBQUEzQyxPQUFBLENBQUFLLEdBQUEsR0FBQTZCLEtBQUEsb0JBQUFSLE1BQUEsR0FBQXZCLFFBQUEsQ0FBQVgsT0FBQSxFQUFBRSxJQUFBLEVBQUFNLE9BQUEsb0JBQUEwQixNQUFBLENBQUFwQixJQUFBLFFBQUE0QixLQUFBLEdBQUFsQyxPQUFBLENBQUE0QyxJQUFBLG1DQUFBbEIsTUFBQSxDQUFBckIsR0FBQSxLQUFBRyxnQkFBQSxxQkFBQS9CLEtBQUEsRUFBQWlELE1BQUEsQ0FBQXJCLEdBQUEsRUFBQXVDLElBQUEsRUFBQTVDLE9BQUEsQ0FBQTRDLElBQUEsa0JBQUFsQixNQUFBLENBQUFwQixJQUFBLEtBQUE0QixLQUFBLGdCQUFBbEMsT0FBQSxDQUFBbUIsTUFBQSxZQUFBbkIsT0FBQSxDQUFBSyxHQUFBLEdBQUFxQixNQUFBLENBQUFyQixHQUFBLG1CQUFBa0Msb0JBQUFGLFFBQUEsRUFBQXJDLE9BQUEsUUFBQTZDLFVBQUEsR0FBQTdDLE9BQUEsQ0FBQW1CLE1BQUEsRUFBQUEsTUFBQSxHQUFBa0IsUUFBQSxDQUFBeEQsUUFBQSxDQUFBZ0UsVUFBQSxPQUFBQyxTQUFBLEtBQUEzQixNQUFBLFNBQUFuQixPQUFBLENBQUFxQyxRQUFBLHFCQUFBUSxVQUFBLElBQUFSLFFBQUEsQ0FBQXhELFFBQUEsZUFBQW1CLE9BQUEsQ0FBQW1CLE1BQUEsYUFBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBeUMsU0FBQSxFQUFBUCxtQkFBQSxDQUFBRixRQUFBLEVBQUFyQyxPQUFBLGVBQUFBLE9BQUEsQ0FBQW1CLE1BQUEsa0JBQUEwQixVQUFBLEtBQUE3QyxPQUFBLENBQUFtQixNQUFBLFlBQUFuQixPQUFBLENBQUFLLEdBQUEsT0FBQTBDLFNBQUEsdUNBQUFGLFVBQUEsaUJBQUFyQyxnQkFBQSxNQUFBa0IsTUFBQSxHQUFBdkIsUUFBQSxDQUFBZ0IsTUFBQSxFQUFBa0IsUUFBQSxDQUFBeEQsUUFBQSxFQUFBbUIsT0FBQSxDQUFBSyxHQUFBLG1CQUFBcUIsTUFBQSxDQUFBcEIsSUFBQSxTQUFBTixPQUFBLENBQUFtQixNQUFBLFlBQUFuQixPQUFBLENBQUFLLEdBQUEsR0FBQXFCLE1BQUEsQ0FBQXJCLEdBQUEsRUFBQUwsT0FBQSxDQUFBcUMsUUFBQSxTQUFBN0IsZ0JBQUEsTUFBQXdDLElBQUEsR0FBQXRCLE1BQUEsQ0FBQXJCLEdBQUEsU0FBQTJDLElBQUEsR0FBQUEsSUFBQSxDQUFBSixJQUFBLElBQUE1QyxPQUFBLENBQUFxQyxRQUFBLENBQUFZLFVBQUEsSUFBQUQsSUFBQSxDQUFBdkUsS0FBQSxFQUFBdUIsT0FBQSxDQUFBa0QsSUFBQSxHQUFBYixRQUFBLENBQUFjLE9BQUEsZUFBQW5ELE9BQUEsQ0FBQW1CLE1BQUEsS0FBQW5CLE9BQUEsQ0FBQW1CLE1BQUEsV0FBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBeUMsU0FBQSxHQUFBOUMsT0FBQSxDQUFBcUMsUUFBQSxTQUFBN0IsZ0JBQUEsSUFBQXdDLElBQUEsSUFBQWhELE9BQUEsQ0FBQW1CLE1BQUEsWUFBQW5CLE9BQUEsQ0FBQUssR0FBQSxPQUFBMEMsU0FBQSxzQ0FBQS9DLE9BQUEsQ0FBQXFDLFFBQUEsU0FBQTdCLGdCQUFBLGNBQUE0QyxhQUFBQyxJQUFBLFFBQUFDLEtBQUEsS0FBQUMsTUFBQSxFQUFBRixJQUFBLFlBQUFBLElBQUEsS0FBQUMsS0FBQSxDQUFBRSxRQUFBLEdBQUFILElBQUEsV0FBQUEsSUFBQSxLQUFBQyxLQUFBLENBQUFHLFVBQUEsR0FBQUosSUFBQSxLQUFBQyxLQUFBLENBQUFJLFFBQUEsR0FBQUwsSUFBQSxXQUFBTSxVQUFBLENBQUFDLElBQUEsQ0FBQU4sS0FBQSxjQUFBTyxjQUFBUCxLQUFBLFFBQUE1QixNQUFBLEdBQUE0QixLQUFBLENBQUFRLFVBQUEsUUFBQXBDLE1BQUEsQ0FBQXBCLElBQUEsb0JBQUFvQixNQUFBLENBQUFyQixHQUFBLEVBQUFpRCxLQUFBLENBQUFRLFVBQUEsR0FBQXBDLE1BQUEsYUFBQXpCLFFBQUFOLFdBQUEsU0FBQWdFLFVBQUEsTUFBQUosTUFBQSxhQUFBNUQsV0FBQSxDQUFBdUIsT0FBQSxDQUFBa0MsWUFBQSxjQUFBVyxLQUFBLGlCQUFBaEQsT0FBQWlELFFBQUEsUUFBQUEsUUFBQSxRQUFBQyxjQUFBLEdBQUFELFFBQUEsQ0FBQXBGLGNBQUEsT0FBQXFGLGNBQUEsU0FBQUEsY0FBQSxDQUFBMUQsSUFBQSxDQUFBeUQsUUFBQSw0QkFBQUEsUUFBQSxDQUFBZCxJQUFBLFNBQUFjLFFBQUEsT0FBQUUsS0FBQSxDQUFBRixRQUFBLENBQUFHLE1BQUEsU0FBQUMsQ0FBQSxPQUFBbEIsSUFBQSxZQUFBQSxLQUFBLGFBQUFrQixDQUFBLEdBQUFKLFFBQUEsQ0FBQUcsTUFBQSxPQUFBaEcsTUFBQSxDQUFBb0MsSUFBQSxDQUFBeUQsUUFBQSxFQUFBSSxDQUFBLFVBQUFsQixJQUFBLENBQUF6RSxLQUFBLEdBQUF1RixRQUFBLENBQUFJLENBQUEsR0FBQWxCLElBQUEsQ0FBQU4sSUFBQSxPQUFBTSxJQUFBLFNBQUFBLElBQUEsQ0FBQXpFLEtBQUEsR0FBQXFFLFNBQUEsRUFBQUksSUFBQSxDQUFBTixJQUFBLE9BQUFNLElBQUEsWUFBQUEsSUFBQSxDQUFBQSxJQUFBLEdBQUFBLElBQUEsZUFBQUEsSUFBQSxFQUFBZCxVQUFBLGVBQUFBLFdBQUEsYUFBQTNELEtBQUEsRUFBQXFFLFNBQUEsRUFBQUYsSUFBQSxpQkFBQW5DLGlCQUFBLENBQUF2QyxTQUFBLEdBQUF3QywwQkFBQSxFQUFBckMsY0FBQSxDQUFBMkMsRUFBQSxtQkFBQXZDLEtBQUEsRUFBQWlDLDBCQUFBLEVBQUF0QixZQUFBLFNBQUFmLGNBQUEsQ0FBQXFDLDBCQUFBLG1CQUFBakMsS0FBQSxFQUFBZ0MsaUJBQUEsRUFBQXJCLFlBQUEsU0FBQXFCLGlCQUFBLENBQUE0RCxXQUFBLEdBQUFuRixNQUFBLENBQUF3QiwwQkFBQSxFQUFBMUIsaUJBQUEsd0JBQUFqQixPQUFBLENBQUF1RyxtQkFBQSxhQUFBQyxNQUFBLFFBQUFDLElBQUEsd0JBQUFELE1BQUEsSUFBQUEsTUFBQSxDQUFBRSxXQUFBLFdBQUFELElBQUEsS0FBQUEsSUFBQSxLQUFBL0QsaUJBQUEsNkJBQUErRCxJQUFBLENBQUFILFdBQUEsSUFBQUcsSUFBQSxDQUFBRSxJQUFBLE9BQUEzRyxPQUFBLENBQUE0RyxJQUFBLGFBQUFKLE1BQUEsV0FBQXRHLE1BQUEsQ0FBQTJHLGNBQUEsR0FBQTNHLE1BQUEsQ0FBQTJHLGNBQUEsQ0FBQUwsTUFBQSxFQUFBN0QsMEJBQUEsS0FBQTZELE1BQUEsQ0FBQU0sU0FBQSxHQUFBbkUsMEJBQUEsRUFBQXhCLE1BQUEsQ0FBQXFGLE1BQUEsRUFBQXZGLGlCQUFBLHlCQUFBdUYsTUFBQSxDQUFBckcsU0FBQSxHQUFBRCxNQUFBLENBQUE4QixNQUFBLENBQUFpQixFQUFBLEdBQUF1RCxNQUFBLEtBQUF4RyxPQUFBLENBQUErRyxLQUFBLGFBQUF6RSxHQUFBLGFBQUF1QixPQUFBLEVBQUF2QixHQUFBLE9BQUFZLHFCQUFBLENBQUFJLGFBQUEsQ0FBQW5ELFNBQUEsR0FBQWdCLE1BQUEsQ0FBQW1DLGFBQUEsQ0FBQW5ELFNBQUEsRUFBQVksbUJBQUEsaUNBQUFmLE9BQUEsQ0FBQXNELGFBQUEsR0FBQUEsYUFBQSxFQUFBdEQsT0FBQSxDQUFBZ0gsS0FBQSxhQUFBdkYsT0FBQSxFQUFBQyxPQUFBLEVBQUFDLElBQUEsRUFBQUMsV0FBQSxFQUFBMkIsV0FBQSxlQUFBQSxXQUFBLEtBQUFBLFdBQUEsR0FBQTBELE9BQUEsT0FBQUMsSUFBQSxPQUFBNUQsYUFBQSxDQUFBOUIsSUFBQSxDQUFBQyxPQUFBLEVBQUFDLE9BQUEsRUFBQUMsSUFBQSxFQUFBQyxXQUFBLEdBQUEyQixXQUFBLFVBQUF2RCxPQUFBLENBQUF1RyxtQkFBQSxDQUFBN0UsT0FBQSxJQUFBd0YsSUFBQSxHQUFBQSxJQUFBLENBQUEvQixJQUFBLEdBQUFyQixJQUFBLFdBQUFGLE1BQUEsV0FBQUEsTUFBQSxDQUFBaUIsSUFBQSxHQUFBakIsTUFBQSxDQUFBbEQsS0FBQSxHQUFBd0csSUFBQSxDQUFBL0IsSUFBQSxXQUFBakMscUJBQUEsQ0FBQUQsRUFBQSxHQUFBOUIsTUFBQSxDQUFBOEIsRUFBQSxFQUFBaEMsaUJBQUEsZ0JBQUFFLE1BQUEsQ0FBQThCLEVBQUEsRUFBQXBDLGNBQUEsaUNBQUFNLE1BQUEsQ0FBQThCLEVBQUEsNkRBQUFqRCxPQUFBLENBQUFtSCxJQUFBLGFBQUFDLEdBQUEsUUFBQUMsTUFBQSxHQUFBbkgsTUFBQSxDQUFBa0gsR0FBQSxHQUFBRCxJQUFBLGdCQUFBM0csR0FBQSxJQUFBNkcsTUFBQSxFQUFBRixJQUFBLENBQUF0QixJQUFBLENBQUFyRixHQUFBLFVBQUEyRyxJQUFBLENBQUFHLE9BQUEsYUFBQW5DLEtBQUEsV0FBQWdDLElBQUEsQ0FBQWYsTUFBQSxTQUFBNUYsR0FBQSxHQUFBMkcsSUFBQSxDQUFBSSxHQUFBLFFBQUEvRyxHQUFBLElBQUE2RyxNQUFBLFNBQUFsQyxJQUFBLENBQUF6RSxLQUFBLEdBQUFGLEdBQUEsRUFBQTJFLElBQUEsQ0FBQU4sSUFBQSxPQUFBTSxJQUFBLFdBQUFBLElBQUEsQ0FBQU4sSUFBQSxPQUFBTSxJQUFBLFFBQUFuRixPQUFBLENBQUFnRCxNQUFBLEdBQUFBLE1BQUEsRUFBQWQsT0FBQSxDQUFBL0IsU0FBQSxLQUFBdUcsV0FBQSxFQUFBeEUsT0FBQSxFQUFBOEQsS0FBQSxXQUFBQSxNQUFBd0IsYUFBQSxhQUFBQyxJQUFBLFdBQUF0QyxJQUFBLFdBQUFWLElBQUEsUUFBQUMsS0FBQSxHQUFBSyxTQUFBLE9BQUFGLElBQUEsWUFBQVAsUUFBQSxjQUFBbEIsTUFBQSxnQkFBQWQsR0FBQSxHQUFBeUMsU0FBQSxPQUFBYSxVQUFBLENBQUF6QyxPQUFBLENBQUEyQyxhQUFBLElBQUEwQixhQUFBLFdBQUFiLElBQUEsa0JBQUFBLElBQUEsQ0FBQWUsTUFBQSxPQUFBdEgsTUFBQSxDQUFBb0MsSUFBQSxPQUFBbUUsSUFBQSxNQUFBUixLQUFBLEVBQUFRLElBQUEsQ0FBQWdCLEtBQUEsY0FBQWhCLElBQUEsSUFBQTVCLFNBQUEsTUFBQTZDLElBQUEsV0FBQUEsS0FBQSxTQUFBL0MsSUFBQSxXQUFBZ0QsVUFBQSxRQUFBakMsVUFBQSxJQUFBRyxVQUFBLGtCQUFBOEIsVUFBQSxDQUFBdEYsSUFBQSxRQUFBc0YsVUFBQSxDQUFBdkYsR0FBQSxjQUFBd0YsSUFBQSxLQUFBbkQsaUJBQUEsV0FBQUEsa0JBQUFvRCxTQUFBLGFBQUFsRCxJQUFBLFFBQUFrRCxTQUFBLE1BQUE5RixPQUFBLGtCQUFBK0YsT0FBQUMsR0FBQSxFQUFBQyxNQUFBLFdBQUF2RSxNQUFBLENBQUFwQixJQUFBLFlBQUFvQixNQUFBLENBQUFyQixHQUFBLEdBQUF5RixTQUFBLEVBQUE5RixPQUFBLENBQUFrRCxJQUFBLEdBQUE4QyxHQUFBLEVBQUFDLE1BQUEsS0FBQWpHLE9BQUEsQ0FBQW1CLE1BQUEsV0FBQW5CLE9BQUEsQ0FBQUssR0FBQSxHQUFBeUMsU0FBQSxLQUFBbUQsTUFBQSxhQUFBN0IsQ0FBQSxRQUFBVCxVQUFBLENBQUFRLE1BQUEsTUFBQUMsQ0FBQSxTQUFBQSxDQUFBLFFBQUFkLEtBQUEsUUFBQUssVUFBQSxDQUFBUyxDQUFBLEdBQUExQyxNQUFBLEdBQUE0QixLQUFBLENBQUFRLFVBQUEsaUJBQUFSLEtBQUEsQ0FBQUMsTUFBQSxTQUFBd0MsTUFBQSxhQUFBekMsS0FBQSxDQUFBQyxNQUFBLFNBQUFpQyxJQUFBLFFBQUFVLFFBQUEsR0FBQS9ILE1BQUEsQ0FBQW9DLElBQUEsQ0FBQStDLEtBQUEsZUFBQTZDLFVBQUEsR0FBQWhJLE1BQUEsQ0FBQW9DLElBQUEsQ0FBQStDLEtBQUEscUJBQUE0QyxRQUFBLElBQUFDLFVBQUEsYUFBQVgsSUFBQSxHQUFBbEMsS0FBQSxDQUFBRSxRQUFBLFNBQUF1QyxNQUFBLENBQUF6QyxLQUFBLENBQUFFLFFBQUEsZ0JBQUFnQyxJQUFBLEdBQUFsQyxLQUFBLENBQUFHLFVBQUEsU0FBQXNDLE1BQUEsQ0FBQXpDLEtBQUEsQ0FBQUcsVUFBQSxjQUFBeUMsUUFBQSxhQUFBVixJQUFBLEdBQUFsQyxLQUFBLENBQUFFLFFBQUEsU0FBQXVDLE1BQUEsQ0FBQXpDLEtBQUEsQ0FBQUUsUUFBQSxxQkFBQTJDLFVBQUEsWUFBQWhFLEtBQUEscURBQUFxRCxJQUFBLEdBQUFsQyxLQUFBLENBQUFHLFVBQUEsU0FBQXNDLE1BQUEsQ0FBQXpDLEtBQUEsQ0FBQUcsVUFBQSxZQUFBZCxNQUFBLFdBQUFBLE9BQUFyQyxJQUFBLEVBQUFELEdBQUEsYUFBQStELENBQUEsUUFBQVQsVUFBQSxDQUFBUSxNQUFBLE1BQUFDLENBQUEsU0FBQUEsQ0FBQSxRQUFBZCxLQUFBLFFBQUFLLFVBQUEsQ0FBQVMsQ0FBQSxPQUFBZCxLQUFBLENBQUFDLE1BQUEsU0FBQWlDLElBQUEsSUFBQXJILE1BQUEsQ0FBQW9DLElBQUEsQ0FBQStDLEtBQUEsd0JBQUFrQyxJQUFBLEdBQUFsQyxLQUFBLENBQUFHLFVBQUEsUUFBQTJDLFlBQUEsR0FBQTlDLEtBQUEsYUFBQThDLFlBQUEsaUJBQUE5RixJQUFBLG1CQUFBQSxJQUFBLEtBQUE4RixZQUFBLENBQUE3QyxNQUFBLElBQUFsRCxHQUFBLElBQUFBLEdBQUEsSUFBQStGLFlBQUEsQ0FBQTNDLFVBQUEsS0FBQTJDLFlBQUEsY0FBQTFFLE1BQUEsR0FBQTBFLFlBQUEsR0FBQUEsWUFBQSxDQUFBdEMsVUFBQSxjQUFBcEMsTUFBQSxDQUFBcEIsSUFBQSxHQUFBQSxJQUFBLEVBQUFvQixNQUFBLENBQUFyQixHQUFBLEdBQUFBLEdBQUEsRUFBQStGLFlBQUEsU0FBQWpGLE1BQUEsZ0JBQUErQixJQUFBLEdBQUFrRCxZQUFBLENBQUEzQyxVQUFBLEVBQUFqRCxnQkFBQSxTQUFBNkYsUUFBQSxDQUFBM0UsTUFBQSxNQUFBMkUsUUFBQSxXQUFBQSxTQUFBM0UsTUFBQSxFQUFBZ0MsUUFBQSxvQkFBQWhDLE1BQUEsQ0FBQXBCLElBQUEsUUFBQW9CLE1BQUEsQ0FBQXJCLEdBQUEscUJBQUFxQixNQUFBLENBQUFwQixJQUFBLG1CQUFBb0IsTUFBQSxDQUFBcEIsSUFBQSxRQUFBNEMsSUFBQSxHQUFBeEIsTUFBQSxDQUFBckIsR0FBQSxnQkFBQXFCLE1BQUEsQ0FBQXBCLElBQUEsU0FBQXVGLElBQUEsUUFBQXhGLEdBQUEsR0FBQXFCLE1BQUEsQ0FBQXJCLEdBQUEsT0FBQWMsTUFBQSxrQkFBQStCLElBQUEseUJBQUF4QixNQUFBLENBQUFwQixJQUFBLElBQUFvRCxRQUFBLFVBQUFSLElBQUEsR0FBQVEsUUFBQSxHQUFBbEQsZ0JBQUEsS0FBQThGLE1BQUEsV0FBQUEsT0FBQTdDLFVBQUEsYUFBQVcsQ0FBQSxRQUFBVCxVQUFBLENBQUFRLE1BQUEsTUFBQUMsQ0FBQSxTQUFBQSxDQUFBLFFBQUFkLEtBQUEsUUFBQUssVUFBQSxDQUFBUyxDQUFBLE9BQUFkLEtBQUEsQ0FBQUcsVUFBQSxLQUFBQSxVQUFBLGNBQUE0QyxRQUFBLENBQUEvQyxLQUFBLENBQUFRLFVBQUEsRUFBQVIsS0FBQSxDQUFBSSxRQUFBLEdBQUFHLGFBQUEsQ0FBQVAsS0FBQSxHQUFBOUMsZ0JBQUEseUJBQUErRixPQUFBaEQsTUFBQSxhQUFBYSxDQUFBLFFBQUFULFVBQUEsQ0FBQVEsTUFBQSxNQUFBQyxDQUFBLFNBQUFBLENBQUEsUUFBQWQsS0FBQSxRQUFBSyxVQUFBLENBQUFTLENBQUEsT0FBQWQsS0FBQSxDQUFBQyxNQUFBLEtBQUFBLE1BQUEsUUFBQTdCLE1BQUEsR0FBQTRCLEtBQUEsQ0FBQVEsVUFBQSxrQkFBQXBDLE1BQUEsQ0FBQXBCLElBQUEsUUFBQWtHLE1BQUEsR0FBQTlFLE1BQUEsQ0FBQXJCLEdBQUEsRUFBQXdELGFBQUEsQ0FBQVAsS0FBQSxZQUFBa0QsTUFBQSxnQkFBQXJFLEtBQUEsOEJBQUFzRSxhQUFBLFdBQUFBLGNBQUF6QyxRQUFBLEVBQUFmLFVBQUEsRUFBQUUsT0FBQSxnQkFBQWQsUUFBQSxLQUFBeEQsUUFBQSxFQUFBa0MsTUFBQSxDQUFBaUQsUUFBQSxHQUFBZixVQUFBLEVBQUFBLFVBQUEsRUFBQUUsT0FBQSxFQUFBQSxPQUFBLG9CQUFBaEMsTUFBQSxVQUFBZCxHQUFBLEdBQUF5QyxTQUFBLEdBQUF0QyxnQkFBQSxPQUFBekMsT0FBQTtBQUFBLFNBQUEySSxtQkFBQUMsR0FBQSxFQUFBbkYsT0FBQSxFQUFBQyxNQUFBLEVBQUFtRixLQUFBLEVBQUFDLE1BQUEsRUFBQXRJLEdBQUEsRUFBQThCLEdBQUEsY0FBQTJDLElBQUEsR0FBQTJELEdBQUEsQ0FBQXBJLEdBQUEsRUFBQThCLEdBQUEsT0FBQTVCLEtBQUEsR0FBQXVFLElBQUEsQ0FBQXZFLEtBQUEsV0FBQXNELEtBQUEsSUFBQU4sTUFBQSxDQUFBTSxLQUFBLGlCQUFBaUIsSUFBQSxDQUFBSixJQUFBLElBQUFwQixPQUFBLENBQUEvQyxLQUFBLFlBQUF1RyxPQUFBLENBQUF4RCxPQUFBLENBQUEvQyxLQUFBLEVBQUFvRCxJQUFBLENBQUErRSxLQUFBLEVBQUFDLE1BQUE7QUFBQSxTQUFBQyxrQkFBQTFHLEVBQUEsNkJBQUFWLElBQUEsU0FBQXFILElBQUEsR0FBQUMsU0FBQSxhQUFBaEMsT0FBQSxXQUFBeEQsT0FBQSxFQUFBQyxNQUFBLFFBQUFrRixHQUFBLEdBQUF2RyxFQUFBLENBQUE2RyxLQUFBLENBQUF2SCxJQUFBLEVBQUFxSCxJQUFBLFlBQUFILE1BQUFuSSxLQUFBLElBQUFpSSxrQkFBQSxDQUFBQyxHQUFBLEVBQUFuRixPQUFBLEVBQUFDLE1BQUEsRUFBQW1GLEtBQUEsRUFBQUMsTUFBQSxVQUFBcEksS0FBQSxjQUFBb0ksT0FBQXZILEdBQUEsSUFBQW9ILGtCQUFBLENBQUFDLEdBQUEsRUFBQW5GLE9BQUEsRUFBQUMsTUFBQSxFQUFBbUYsS0FBQSxFQUFBQyxNQUFBLFdBQUF2SCxHQUFBLEtBQUFzSCxLQUFBLENBQUE5RCxTQUFBO0FBREEsSUFBTW9FLFFBQVEsR0FBQywyQkFBMkI7QUFBQyxJQUFxQkMsWUFBWTtFQUFDLFNBQUFBLGFBQUEsRUFBYTtJQUFDLElBQUlDLENBQUMsR0FBQyxJQUFJO01BQUNDLENBQUMsR0FBQyxHQUFHO01BQUNDLENBQUMsR0FBQyxJQUFJO01BQUNsRCxDQUFDLEdBQUMsSUFBSTtNQUFDbUQsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLEdBQUc7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7TUFBQ0MsQ0FBQyxHQUFDLElBQUk7SUFBQyxJQUFNQyxDQUFDLEdBQUMsU0FBRkEsQ0FBQ0EsQ0FBQ0MsQ0FBQyxFQUFFO1FBQUNkLENBQUMsR0FBQ2MsQ0FBQztRQUFDLElBQU1DLENBQUMsR0FBQ0MsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7UUFBQ1gsQ0FBQyxHQUFDVSxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUcsU0FBUyxHQUFDLEdBQUcsR0FBQ0EsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFHLEtBQUssR0FBQyxHQUFHLEdBQUMsR0FBRztRQUFDLElBQU1FLENBQUMsR0FBQ0QsRUFBRSxDQUFDLHNCQUFzQixDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUM7UUFBQ2QsQ0FBQyxHQUFDZSxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUNqRSxDQUFDLEdBQUNpRSxDQUFDLENBQUMsYUFBYSxDQUFDO1FBQUMsSUFBTUMsQ0FBQyxHQUFDO1VBQUMsT0FBTyxFQUFDLENBQUMsT0FBTyxFQUFDLFlBQVksQ0FBQztVQUFDLE9BQU8sRUFBQyxDQUFDLE9BQU8sRUFBQyxZQUFZLENBQUM7VUFBQyxPQUFPLEVBQUMsQ0FBQyxjQUFjLENBQUM7VUFBQyxPQUFPLEVBQUMsQ0FBQyxVQUFVLEVBQUMsVUFBVSxDQUFDO1VBQUMsT0FBTyxFQUFDLENBQUMsS0FBSyxFQUFDLFFBQVEsQ0FBQztVQUFDLE9BQU8sRUFBQyxDQUFDLEtBQUssRUFBQyxTQUFTLENBQUM7VUFBQyxPQUFPLEVBQUMsQ0FBQyxZQUFZLEVBQUMsV0FBVyxDQUFDO1VBQUMsT0FBTyxFQUFDLENBQUMsY0FBYyxFQUFDLFlBQVksQ0FBQztVQUFDLE9BQU8sRUFBQyxDQUFDLE1BQU0sRUFBQyxLQUFLLEVBQUMsU0FBUztRQUFDLENBQUM7UUFBQyxJQUFHQSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQ2hCLENBQUMsQ0FBQyxFQUFDO1VBQUMsSUFBQWlCLElBQUEsR0FBY0QsQ0FBQyxDQUFDaEIsQ0FBQyxDQUFDO1lBQVhrQixDQUFDLEdBQUFELElBQUE7WUFBQ0UsQ0FBQyxHQUFBRixJQUFBO1lBQUNHLENBQUMsR0FBQUgsSUFBQTtVQUFPLElBQUdDLENBQUMsS0FBRyxjQUFjLEVBQUM7WUFBQyxJQUFNRyxDQUFDLEdBQUNOLENBQUMsQ0FBQyxjQUFjLENBQUM7WUFBQyxJQUFHTSxDQUFDLEVBQUM7Y0FBQyxJQUFNQyxDQUFDLEdBQUNELENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUM7Y0FBQ3BCLENBQUMsR0FBQ3FCLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBQ3BCLENBQUMsR0FBQ29CLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFBQztVQUFDLENBQUMsTUFBS3JCLENBQUMsR0FBQ2MsQ0FBQyxDQUFDRyxDQUFDLENBQUMsRUFBQ2hCLENBQUMsR0FBQ2EsQ0FBQyxDQUFDSSxDQUFDLENBQUMsRUFBQyxDQUFDakIsQ0FBQyxJQUFFa0IsQ0FBQyxLQUFHbEIsQ0FBQyxHQUFDYSxDQUFDLENBQUNLLENBQUMsQ0FBQyxDQUFDO1FBQUMsQ0FBQyxNQUFLcEIsQ0FBQyxHQUFDLE9BQU8sRUFBQ2xELENBQUMsR0FBQyxFQUFFLEdBQUNnRCxDQUFDLEdBQUNDLENBQUMsR0FBQ0MsQ0FBQyxHQUFDRyxDQUFDLEdBQUMsR0FBRztNQUFDLENBQUM7TUFBQ29CLENBQUMsR0FBQyxTQUFGQSxDQUFDQSxDQUFBLEVBQUs7UUFBQyxPQUFPLElBQUk3RCxPQUFPLENBQUMsVUFBQ2tELENBQUMsRUFBQ0MsQ0FBQyxFQUFHO1VBQUNDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUFDLFNBQVMsRUFBQyxTQUFBVSxRQUFBQyxJQUFBLEVBQVk7Y0FBQSxJQUFMVixDQUFDLEdBQUFVLElBQUEsQ0FBTkMsSUFBSTtjQUFPWCxDQUFDLEdBQUNILENBQUMsQ0FBQ0csQ0FBQyxDQUFDLEdBQUNGLENBQUMsQ0FBQyxJQUFJaEcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQUMsQ0FBQztZQUFDLE1BQU0sRUFBQ2dHO1VBQUMsQ0FBQyxDQUFDO1FBQUMsQ0FBQyxDQUFDO01BQUMsQ0FBQztNQUFDYyxDQUFDLEdBQUMsU0FBRkEsQ0FBQ0EsQ0FBRWYsQ0FBQyxFQUFDQyxDQUFDLEVBQUc7UUFBQyxPQUFPLElBQUluRCxPQUFPLENBQUMsVUFBQ3FELENBQUMsRUFBQ0MsQ0FBQyxFQUFHO1VBQUNGLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUFDLEtBQUssRUFBQ0YsQ0FBQztZQUFDLFFBQVEsRUFBQyxNQUFNO1lBQUMsUUFBUSxFQUFDO2NBQUMsY0FBYyxFQUFDO1lBQWtCLENBQUM7WUFBQyxNQUFNLEVBQUNnQixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUNmLENBQUMsQ0FBQztZQUFDLE1BQU0sRUFBQ0csQ0FBQztZQUFDLFNBQVMsRUFBQyxTQUFBUSxRQUFTTixDQUFDLEVBQUM7Y0FBQ0gsQ0FBQyxDQUFDRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7WUFBQyxDQUFDO1lBQUMsVUFBVSxFQUFDLFNBQUFuQyxTQUFTbUMsQ0FBQyxFQUFDO2NBQUNXLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyw4RUFBOEUsQ0FBQyxFQUFDQSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxFQUFDakIsQ0FBQyxDQUFDLEVBQUNpQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFDaEIsQ0FBQyxDQUFDLEVBQUNnQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFDWCxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUVBLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDVyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsNEVBQTRFLENBQUM7WUFBQztVQUFDLENBQUMsQ0FBQztRQUFDLENBQUMsQ0FBQztNQUFDLENBQUM7TUFBQ0MsQ0FBQyxHQUFDbEMsUUFBUSxHQUFDLG9EQUFvRDtNQUFDbUMsQ0FBQztRQUFBLElBQUFDLEtBQUEsR0FBQXhDLGlCQUFBLGVBQUFoSixtQkFBQSxHQUFBNkcsSUFBQSxDQUFDLFNBQUE0RSxRQUFNckIsQ0FBQztVQUFBLElBQUFDLENBQUEsRUFBQUUsQ0FBQSxFQUFBbUIsT0FBQSxFQUFBbEIsQ0FBQSxFQUFBRSxDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBO1VBQUEsT0FBQTdLLG1CQUFBLEdBQUF5QixJQUFBLFVBQUFrSyxTQUFBQyxRQUFBO1lBQUEsa0JBQUFBLFFBQUEsQ0FBQWxFLElBQUEsR0FBQWtFLFFBQUEsQ0FBQXhHLElBQUE7Y0FBQTtnQkFBQXdHLFFBQUEsQ0FBQWxFLElBQUE7Z0JBQWEyQyxDQUFDLEdBQUM7a0JBQUMsUUFBUSxFQUFDZixDQUFDO2tCQUFDLFlBQVksRUFBQ0MsQ0FBQztrQkFBQyxrQkFBa0IsRUFBQ2EsQ0FBQztrQkFBQyxRQUFRLEVBQUNQLENBQUM7a0JBQUMsS0FBSyxFQUFDRjtnQkFBQyxDQUFDO2dCQUFBaUMsUUFBQSxDQUFBeEcsSUFBQTtnQkFBQSxPQUFTK0YsQ0FBQyxDQUFDRyxDQUFDLEVBQUNqQixDQUFDLENBQUM7Y0FBQTtnQkFBZEUsQ0FBQyxHQUFBcUIsUUFBQSxDQUFBbEgsSUFBQTtnQkFBYyxJQUFHNkYsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFHc0IsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFDO2tCQUFBSCxPQUFBLEdBQXFFbkIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUF6REMsQ0FBQyxHQUFBa0IsT0FBQSxDQUFkSSxZQUFZLEVBQVlwQixDQUFDLEdBQUFnQixPQUFBLENBQVZLLFFBQVEsRUFBWXBCLENBQUMsR0FBQWUsT0FBQSxDQUFWTSxRQUFRLEVBQWNwQixDQUFDLEdBQUFjLE9BQUEsQ0FBWk8sVUFBVSxFQUFXcEIsQ0FBQyxHQUFBYSxPQUFBLENBQVRRLE9BQU87a0JBQWMsSUFBRzFCLENBQUMsS0FBRyxHQUFHLEVBQUNGLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFBQyxPQUFPLEVBQUMsSUFBSTtvQkFBQyxTQUFTLEVBQUNJLENBQUM7b0JBQUMsYUFBYSxFQUFDLE1BQU07b0JBQUMsU0FBUyxFQUFDLFNBQUFNLFFBQVNGLENBQUMsRUFBQztzQkFBQ0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFFUixFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQzt3QkFBQyxNQUFNLEVBQUNLO3NCQUFDLENBQUMsQ0FBQztvQkFBQztrQkFBQyxDQUFDLENBQUMsQ0FBQyxLQUFJO29CQUFDLElBQUdILENBQUMsS0FBRyxHQUFHLEVBQUNGLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQztzQkFBQyxNQUFNLEVBQUMsQ0FBQ00sQ0FBQyxHQUFDLFFBQVEsR0FBQ3VCLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEdBQUMsS0FBSyxDQUFDO29CQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs1QixDQUFDLEtBQUcsR0FBRyxJQUFFSyxDQUFDLENBQUMsSUFBSSxFQUFDQSxDQUFDLENBQUM7a0JBQUM7Z0JBQUMsQ0FBQyxNQUFLUSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxFQUFDZCxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQUMsT0FBQXFCLFFBQUEsQ0FBQS9HLE1BQUEsV0FBTTtrQkFBQyxTQUFTLEVBQUMsQ0FBQyxDQUFDLEVBQUU7a0JBQUMsUUFBUSxFQUFDMEY7Z0JBQUMsQ0FBQztjQUFBO2dCQUFBcUIsUUFBQSxDQUFBbEUsSUFBQTtnQkFBQWtFLFFBQUEsQ0FBQVMsRUFBQSxHQUFBVCxRQUFBO2dCQUFBLE9BQUFBLFFBQUEsQ0FBQS9HLE1BQUEsWUFBa0J3RyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFBTyxRQUFBLENBQUFTLEVBQUEsQ0FBRyxFQUFDO2tCQUFDLFNBQVMsRUFBQyxDQUFDLEVBQUU7a0JBQUMsT0FBTyxFQUFDcEk7Z0JBQUssQ0FBQztjQUFBO2NBQUE7Z0JBQUEsT0FBQTJILFFBQUEsQ0FBQS9ELElBQUE7WUFBQTtVQUFBLEdBQUE0RCxPQUFBO1FBQUEsQ0FBRztRQUFBLGdCQUExb0JGLENBQUNBLENBQUFlLEVBQUE7VUFBQSxPQUFBZCxLQUFBLENBQUFyQyxLQUFBLE9BQUFELFNBQUE7UUFBQTtNQUFBLEdBQXlvQjtNQUFDcUQsQ0FBQyxHQUFDLFNBQUZBLENBQUNBLENBQUVuQyxDQUFDLEVBQUNDLENBQUMsRUFBRztRQUFDRCxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUNkLENBQUMsR0FBRWMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFDYixDQUFDLEVBQUNhLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBQ1QsQ0FBQyxHQUFFNkMsQ0FBQyxDQUFDcEMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBQUcsQ0FBQyxFQUFFO1VBQUMsSUFBR0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFFLEdBQUcsRUFBQ0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFDLEdBQUcsR0FBQ2tDLENBQUMsQ0FBQyxNQUFNLEVBQUMsT0FBTyxHQUFDbEMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFDLGFBQWEsR0FBQ0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFDLEdBQUcsRUFBQztZQUFBLE9BQUltQyxDQUFDLENBQUNuQyxDQUFDLENBQUM7VUFBQSxFQUFDLEdBQUNtQyxDQUFDLENBQUNuQyxDQUFDLEVBQUNGLENBQUMsQ0FBQyxDQUFDLEtBQUk7WUFBQyxJQUFHRSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUUsR0FBRyxFQUFDb0MsQ0FBQyxDQUFDcEMsQ0FBQyxFQUFDRixDQUFDLENBQUMsQ0FBQyxLQUFJO2NBQUMsSUFBR0UsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFFLEdBQUcsRUFBQ0QsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUFDLE9BQU8sRUFBQyxNQUFNO2dCQUFDLFNBQVMsRUFBQywwQkFBMEI7Z0JBQUMsU0FBUyxFQUFDLFNBQUFVLFFBQVNSLENBQUMsRUFBQztrQkFBQ0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFFRixFQUFFLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBQUMsTUFBTSxFQUFDLENBQUNDLENBQUMsQ0FBQyxRQUFRLENBQUM7a0JBQUMsQ0FBQyxDQUFDO2dCQUFDO2NBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLElBQUlsRyxLQUFLLENBQUMsUUFBUSxDQUFDO1lBQUM7VUFBQztRQUFDLENBQUMsQ0FBQztNQUFDLENBQUM7TUFBQ3FJLENBQUMsR0FBQyxTQUFGQSxDQUFDQSxDQUFFdEMsQ0FBQyxFQUFDQyxDQUFDLEVBQUc7UUFBQyxJQUFHRCxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUUsR0FBRyxFQUFDO1VBQUN3QyxDQUFDLENBQUN4QyxDQUFDLEVBQUNDLENBQUMsQ0FBQztVQUFDO1FBQU87UUFBQ0MsRUFBRSxDQUFDLHFCQUFxQixDQUFDLENBQUM7VUFBQyxNQUFNLEVBQUMsTUFBTTtVQUFDLEtBQUssRUFBQyxHQUFHO1VBQUMsU0FBUyxFQUFDRixDQUFDLENBQUMsU0FBUyxDQUFDO1VBQUMsY0FBYyxFQUFDLEtBQUs7VUFBQyxVQUFVLEVBQUMsU0FBUztVQUFDLGFBQWEsRUFBQ0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFDQSxDQUFDLENBQUMsV0FBVyxDQUFDO1VBQUMsUUFBUSxFQUFDLEdBQUc7VUFBQyxTQUFTLEVBQUMsU0FBQVksUUFBQVQsQ0FBQyxFQUFFO1lBQUNxQyxDQUFDLENBQUN4QyxDQUFDLEVBQUNDLENBQUMsQ0FBQztVQUFDLENBQUM7VUFBQyxNQUFNLEVBQUMsU0FBQXdDLEtBQUF0QyxDQUFDLEVBQUU7WUFBQ2tDLENBQUMsQ0FBQyxRQUFRLEVBQUNsQyxDQUFDLENBQUM7VUFBQztRQUFDLENBQUMsQ0FBQztNQUFDLENBQUM7TUFBQ29DLENBQUMsR0FBQyxTQUFGQSxDQUFDQSxDQUFFdkMsQ0FBQyxFQUFDQyxDQUFDLEVBQUc7UUFBQ0MsRUFBRSxDQUFDLGlDQUFpQyxDQUFDLENBQUM7VUFBQyxpQkFBaUIsRUFBQyxDQUFDLENBQUMsRUFBRTtVQUFDLGFBQWEsRUFBQ0YsQ0FBQyxDQUFDLFFBQVEsQ0FBQztVQUFDLGlCQUFpQixFQUFDLGtCQUFrQixHQUFDQSxDQUFDLENBQUMsUUFBUSxDQUFDO1VBQUMsa0JBQWtCLEVBQUMsUUFBUTtVQUFDLGdCQUFnQixFQUFDQSxDQUFDLENBQUMsWUFBWTtRQUFDLENBQUMsQ0FBQztNQUFDLENBQUM7TUFBQzBDLENBQUMsR0FBQzFELFFBQVEsR0FBQyw0Q0FBNEM7TUFBQ3dELENBQUM7UUFBQSxJQUFBRyxLQUFBLEdBQUEvRCxpQkFBQSxlQUFBaEosbUJBQUEsR0FBQTZHLElBQUEsQ0FBQyxTQUFBbUcsU0FBTTVDLENBQUMsRUFBQ0MsQ0FBQztVQUFBLElBQUFFLENBQUEsRUFBQUMsQ0FBQSxFQUFBRSxDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQTtVQUFBLE9BQUE1SyxtQkFBQSxHQUFBeUIsSUFBQSxVQUFBd0wsVUFBQUMsU0FBQTtZQUFBLGtCQUFBQSxTQUFBLENBQUF4RixJQUFBLEdBQUF3RixTQUFBLENBQUE5SCxJQUFBO2NBQUE7Z0JBQVVtRixDQUFDLEdBQUM7a0JBQUMsU0FBUyxFQUFDSCxDQUFDLENBQUMsU0FBUyxDQUFDO2tCQUFDLFFBQVEsRUFBQ2QsQ0FBQztrQkFBQyxZQUFZLEVBQUNDLENBQUM7a0JBQUMsUUFBUSxFQUFDYSxDQUFDLENBQUMsUUFBUTtnQkFBQyxDQUFDLEVBQUNJLENBQUMsR0FBQyxHQUFHO2dCQUFLRSxDQUFDLEdBQUMsR0FBRyxFQUFDQyxDQUFDLEdBQUMsQ0FBQyxFQUFFO2NBQUE7Z0JBQUEsTUFBU0QsQ0FBQyxHQUFDRixDQUFDLElBQUUsQ0FBQ0csQ0FBQztrQkFBQXVDLFNBQUEsQ0FBQTlILElBQUE7a0JBQUE7Z0JBQUE7Z0JBQUE4SCxTQUFBLENBQUF4RixJQUFBO2dCQUFBd0YsU0FBQSxDQUFBOUgsSUFBQTtnQkFBQSxPQUFjK0YsQ0FBQyxDQUFDMkIsQ0FBQyxFQUFDdkMsQ0FBQyxDQUFDO2NBQUE7Z0JBQWRLLENBQUMsR0FBQXNDLFNBQUEsQ0FBQXhJLElBQUE7Z0JBQUF3SSxTQUFBLENBQUFiLEVBQUEsR0FBY3pCLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBR2lCLFVBQVUsQ0FBQywrQkFBK0IsQ0FBQztnQkFBQSxLQUFBcUIsU0FBQSxDQUFBYixFQUFBO2tCQUFBYSxTQUFBLENBQUE5SCxJQUFBO2tCQUFBO2dCQUFBO2dCQUFBOEgsU0FBQSxDQUFBOUgsSUFBQTtnQkFBQSxPQUFRK0gsQ0FBQyxFQUFFO2NBQUE7Z0JBQUEsTUFBSXZDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBR2lCLFVBQVUsQ0FBQyxTQUFTLENBQUM7a0JBQUFxQixTQUFBLENBQUE5SCxJQUFBO2tCQUFBO2dCQUFBO2dCQUFFaUYsQ0FBQyxDQUFDTyxDQUFDLENBQUM7Z0JBQUMsT0FBQXNDLFNBQUEsQ0FBQXJJLE1BQUE7Y0FBQTtnQkFBQXFJLFNBQUEsQ0FBQTlILElBQUE7Z0JBQUE7Y0FBQTtnQkFBQThILFNBQUEsQ0FBQXhGLElBQUE7Z0JBQUF3RixTQUFBLENBQUFFLEVBQUEsR0FBQUYsU0FBQTtnQkFBaUI3QixPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsWUFBWSxFQUFBNkIsU0FBQSxDQUFBRSxFQUFBLENBQUc7Y0FBQztnQkFBQzFDLENBQUMsRUFBRTtnQkFBQ3dDLFNBQUEsQ0FBQTlILElBQUE7Z0JBQUE7Y0FBQTtjQUFBO2dCQUFBLE9BQUE4SCxTQUFBLENBQUFyRixJQUFBO1lBQUE7VUFBQSxHQUFBbUYsUUFBQTtRQUFBLENBQUU7UUFBQSxnQkFBaFVKLENBQUNBLENBQUFTLEdBQUEsRUFBQUMsR0FBQTtVQUFBLE9BQUFQLEtBQUEsQ0FBQTVELEtBQUEsT0FBQUQsU0FBQTtRQUFBO01BQUEsR0FBK1Q7TUFBQ3FFLENBQUMsR0FBQ25FLFFBQVEsR0FBQyw2Q0FBNkM7TUFBQ29ELENBQUM7UUFBQSxJQUFBZ0IsS0FBQSxHQUFBeEUsaUJBQUEsZUFBQWhKLG1CQUFBLEdBQUE2RyxJQUFBLENBQUMsU0FBQTRHLFNBQU1yRCxDQUFDO1VBQUEsSUFBQUMsQ0FBQSxFQUFBRSxDQUFBLEVBQUFDLENBQUEsRUFBQUUsQ0FBQSxFQUFBQyxDQUFBO1VBQUEsT0FBQTNLLG1CQUFBLEdBQUF5QixJQUFBLFVBQUFpTSxVQUFBQyxTQUFBO1lBQUEsa0JBQUFBLFNBQUEsQ0FBQWpHLElBQUEsR0FBQWlHLFNBQUEsQ0FBQXZJLElBQUE7Y0FBQTtnQkFBU2lGLENBQUMsR0FBQyxHQUFHO2dCQUFLRSxDQUFDLEdBQUMsR0FBRyxFQUFDQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLEVBQUNFLENBQUMsR0FBQyxDQUFDLEVBQUU7Y0FBQTtnQkFBQSxNQUFPSCxDQUFDLEdBQUNGLENBQUMsSUFBRSxDQUFDRyxDQUFDO2tCQUFBbUQsU0FBQSxDQUFBdkksSUFBQTtrQkFBQTtnQkFBQTtnQkFBQXVJLFNBQUEsQ0FBQWpHLElBQUE7Z0JBQUFpRyxTQUFBLENBQUF2SSxJQUFBO2dCQUFBLE9BQW9CK0YsQ0FBQyxDQUFDb0MsQ0FBQyxFQUFDbkQsQ0FBQyxDQUFDO2NBQUE7Z0JBQWRPLENBQUMsR0FBQWdELFNBQUEsQ0FBQWpKLElBQUE7Z0JBQUEsTUFBaUJpRyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUdrQixVQUFVLENBQUMsU0FBUyxDQUFDO2tCQUFBOEIsU0FBQSxDQUFBdkksSUFBQTtrQkFBQTtnQkFBQTtnQkFBQSxPQUFBdUksU0FBQSxDQUFBOUksTUFBQSxXQUFROEYsQ0FBQyxDQUFDLE1BQU0sQ0FBQztjQUFBO2dCQUFBLE1BQU1BLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBR2tCLFVBQVUsQ0FBQywrQkFBK0IsQ0FBQztrQkFBQThCLFNBQUEsQ0FBQXZJLElBQUE7a0JBQUE7Z0JBQUE7Z0JBQUF1SSxTQUFBLENBQUF2SSxJQUFBO2dCQUFBLE9BQU8rSCxDQUFDLEVBQUU7Y0FBQTtnQkFBQVEsU0FBQSxDQUFBdkksSUFBQTtnQkFBQTtjQUFBO2dCQUFDLENBQUNzRixDQUFDLEtBQUcrQixDQUFDLENBQUMsUUFBUSxFQUFDOUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUNELENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2NBQUE7Z0JBQUFpRCxTQUFBLENBQUF2SSxJQUFBO2dCQUFBO2NBQUE7Z0JBQUF1SSxTQUFBLENBQUFqRyxJQUFBO2dCQUFBaUcsU0FBQSxDQUFBdEIsRUFBQSxHQUFBc0IsU0FBQTtnQkFBVyxDQUFDakQsQ0FBQyxLQUFHK0IsQ0FBQyxDQUFDLFFBQVEsRUFBQyxNQUFNLENBQUMsRUFBQy9CLENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2NBQUM7Z0JBQUNILENBQUMsRUFBRTtnQkFBQ29ELFNBQUEsQ0FBQXZJLElBQUE7Z0JBQUE7Y0FBQTtnQkFBQSxNQUFPLElBQUlmLEtBQUssQ0FBQyxRQUFRLENBQUM7Y0FBQTtjQUFBO2dCQUFBLE9BQUFzSixTQUFBLENBQUE5RixJQUFBO1lBQUE7VUFBQSxHQUFBNEYsUUFBQTtRQUFBLENBQUU7UUFBQSxnQkFBcFVqQixDQUFDQSxDQUFBb0IsR0FBQTtVQUFBLE9BQUFKLEtBQUEsQ0FBQXJFLEtBQUEsT0FBQUQsU0FBQTtRQUFBO01BQUEsR0FBbVU7TUFBQzJFLENBQUMsR0FBQ3pFLFFBQVEsR0FBQyxvREFBb0Q7TUFBQytELENBQUM7UUFBQSxJQUFBVyxLQUFBLEdBQUE5RSxpQkFBQSxlQUFBaEosbUJBQUEsR0FBQTZHLElBQUEsQ0FBQyxTQUFBa0gsU0FBQTtVQUFBLElBQUEzRCxDQUFBLEVBQUFDLENBQUEsRUFBQUUsQ0FBQSxFQUFBQyxDQUFBLEVBQUFFLENBQUEsRUFBQUMsQ0FBQTtVQUFBLE9BQUEzSyxtQkFBQSxHQUFBeUIsSUFBQSxVQUFBdU0sVUFBQUMsU0FBQTtZQUFBLGtCQUFBQSxTQUFBLENBQUF2RyxJQUFBLEdBQUF1RyxTQUFBLENBQUE3SSxJQUFBO2NBQUE7Z0JBQWdCZ0YsQ0FBQyxHQUFDLEdBQUc7Z0JBQUtDLENBQUMsR0FBQyxHQUFHLEVBQUNFLENBQUMsR0FBQyxDQUFDLEVBQUU7Y0FBQTtnQkFBQSxNQUFPRixDQUFDLEdBQUNELENBQUMsSUFBRSxDQUFDRyxDQUFDO2tCQUFBMEQsU0FBQSxDQUFBN0ksSUFBQTtrQkFBQTtnQkFBQTtnQkFBQTZJLFNBQUEsQ0FBQXZHLElBQUE7Z0JBQUF1RyxTQUFBLENBQUE3SSxJQUFBO2dCQUFBLE9BQW9CMkYsQ0FBQyxFQUFFO2NBQUE7Z0JBQVhQLENBQUMsR0FBQXlELFNBQUEsQ0FBQXZKLElBQUE7Z0JBQVdnRyxDQUFDLEdBQUM7a0JBQUMsUUFBUSxFQUFDcEIsQ0FBQztrQkFBQyxZQUFZLEVBQUNDLENBQUM7a0JBQUMsTUFBTSxFQUFDaUI7Z0JBQUMsQ0FBQztnQkFBQXlELFNBQUEsQ0FBQTdJLElBQUE7Z0JBQUEsT0FBUytGLENBQUMsQ0FBQzBDLENBQUMsRUFBQ25ELENBQUMsQ0FBQztjQUFBO2dCQUFkQyxDQUFDLEdBQUFzRCxTQUFBLENBQUF2SixJQUFBO2dCQUFjNkYsQ0FBQyxHQUFDSSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUdrQixVQUFVLENBQUMsU0FBUyxDQUFDO2dCQUFDb0MsU0FBQSxDQUFBN0ksSUFBQTtnQkFBQTtjQUFBO2dCQUFBNkksU0FBQSxDQUFBdkcsSUFBQTtnQkFBQXVHLFNBQUEsQ0FBQTVCLEVBQUEsR0FBQTRCLFNBQUE7Z0JBQVU1QyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsY0FBYyxFQUFBNEMsU0FBQSxDQUFBNUIsRUFBQSxDQUFHLEVBQUNoQyxDQUFDLEVBQUU7Y0FBQztnQkFBQTRELFNBQUEsQ0FBQTdJLElBQUE7Z0JBQUE7Y0FBQTtnQkFBQSxJQUFNbUYsQ0FBQztrQkFBQTBELFNBQUEsQ0FBQTdJLElBQUE7a0JBQUE7Z0JBQUE7Z0JBQUEsTUFBTyxJQUFJZixLQUFLLENBQUMsUUFBUSxDQUFDO2NBQUE7Y0FBQTtnQkFBQSxPQUFBNEosU0FBQSxDQUFBcEcsSUFBQTtZQUFBO1VBQUEsR0FBQWtHLFFBQUE7UUFBQSxDQUFFO1FBQUEsZ0JBQTNQWixDQUFDQSxDQUFBO1VBQUEsT0FBQVcsS0FBQSxDQUFBM0UsS0FBQSxPQUFBRCxTQUFBO1FBQUE7TUFBQSxHQUEwUDtNQUFDZ0YsQ0FBQyxHQUFDOUUsUUFBUSxHQUFDLDhDQUE4QztNQUFDcUQsQ0FBQyxHQUFDLFNBQUZBLENBQUNBLENBQUVyQyxDQUFDLEVBQUNDLENBQUMsRUFBQ0UsQ0FBQyxFQUFDQyxDQUFDLEVBQUc7UUFBQ0YsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1VBQUMsT0FBTyxFQUFDRixDQUFDO1VBQUMsU0FBUyxFQUFDQyxDQUFDO1VBQUMsU0FBUyxFQUFDLFNBQUFXLFFBQVNOLENBQUMsRUFBQztZQUFDLElBQUdBLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBRUgsQ0FBQyxFQUFDQSxDQUFDLEVBQUUsQ0FBQyxLQUFLRyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUVGLENBQUMsSUFBRUEsQ0FBQyxFQUFFO1VBQUM7UUFBQyxDQUFDLENBQUM7TUFBQyxDQUFDO01BQUMyRCxDQUFDLEdBQUMsU0FBRkEsQ0FBQ0EsQ0FBRS9ELENBQUMsRUFBQ0MsQ0FBQyxFQUFDRSxDQUFDLEVBQUc7UUFBQyxJQUFJQyxDQUFDLEdBQUM7VUFBQyxRQUFRLEVBQUNsQixDQUFDO1VBQUMsWUFBWSxFQUFDQyxDQUFDO1VBQUMsV0FBVyxFQUFDQyxDQUFDO1VBQUMsY0FBYyxFQUFDbEQsQ0FBQztVQUFDLEtBQUssRUFBQ21ELENBQUM7VUFBQyxTQUFTLEVBQUNDLENBQUM7VUFBQyxLQUFLLEVBQUNDLENBQUM7VUFBQyxRQUFRLEVBQUNFLENBQUM7VUFBQyxRQUFRLEVBQUNPLENBQUM7VUFBQyxVQUFVLEVBQUNDLENBQUM7VUFBQyxjQUFjLEVBQUNFO1FBQUMsQ0FBQztRQUFDWSxDQUFDLENBQUMrQyxDQUFDLEVBQUMxRCxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFBRSxDQUFDLEVBQUU7VUFBQ1csT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLFlBQVksRUFBQ1gsQ0FBQyxDQUFDO1FBQUMsQ0FBQyxDQUFDO01BQUMsQ0FBQztNQUFDMEQsQ0FBQyxHQUFDaEYsUUFBUSxHQUFDLDhDQUE4QztJQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7TUFBQSxJQUFBaUYsS0FBQSxHQUFBckYsaUJBQUEsZUFBQWhKLG1CQUFBLEdBQUE2RyxJQUFBLENBQUMsU0FBQXlILFNBQU1sRSxDQUFDLEVBQUNDLENBQUM7UUFBQSxJQUFBRSxDQUFBLEVBQUFDLENBQUEsRUFBQUUsQ0FBQTtRQUFBLE9BQUExSyxtQkFBQSxHQUFBeUIsSUFBQSxVQUFBOE0sVUFBQUMsU0FBQTtVQUFBLGtCQUFBQSxTQUFBLENBQUE5RyxJQUFBLEdBQUE4RyxTQUFBLENBQUFwSixJQUFBO1lBQUE7Y0FBQW9KLFNBQUEsQ0FBQTlHLElBQUE7Y0FBUXlDLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDO2NBQUNvRSxTQUFBLENBQUFwSixJQUFBO2NBQUEsT0FBYzJGLENBQUMsRUFBRTtZQUFBO2NBQVhSLENBQUMsR0FBQWlFLFNBQUEsQ0FBQTlKLElBQUE7Y0FBVzhGLENBQUMsR0FBQztnQkFBQyxNQUFNLEVBQUNELENBQUM7Z0JBQUMsUUFBUSxFQUFDakIsQ0FBQztnQkFBQyxZQUFZLEVBQUNDLENBQUM7Z0JBQUMsV0FBVyxFQUFDQyxDQUFDO2dCQUFDLGNBQWMsRUFBQ2xELENBQUM7Z0JBQUMsS0FBSyxFQUFDbUQsQ0FBQztnQkFBQyxTQUFTLEVBQUNDLENBQUM7Z0JBQUMsS0FBSyxFQUFDQztjQUFDLENBQUM7Y0FBQTZFLFNBQUEsQ0FBQXBKLElBQUE7Y0FBQSxPQUFTK0YsQ0FBQyxDQUFDaUQsQ0FBQyxFQUFDNUQsQ0FBQyxDQUFDO1lBQUE7Y0FBZEUsQ0FBQyxHQUFBOEQsU0FBQSxDQUFBOUosSUFBQTtjQUFjZ0csQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFHbUIsVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFHaEMsQ0FBQyxHQUFDYSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUNXLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQ3hCLENBQUMsQ0FBQyxFQUFDQyxDQUFDLEdBQUNZLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBQ2QsQ0FBQyxHQUFDVyxDQUFDLEVBQUNHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBQyxJQUFJLENBQUMsRUFBQ0wsQ0FBQyxDQUFDSyxDQUFDLENBQUM7Y0FBQzhELFNBQUEsQ0FBQXBKLElBQUE7Y0FBQTtZQUFBO2NBQUFvSixTQUFBLENBQUE5RyxJQUFBO2NBQUE4RyxTQUFBLENBQUFuQyxFQUFBLEdBQUFtQyxTQUFBO2NBQVVuRCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsYUFBYSxFQUFBbUQsU0FBQSxDQUFBbkMsRUFBQSxDQUFHO1lBQUM7WUFBQTtjQUFBLE9BQUFtQyxTQUFBLENBQUEzRyxJQUFBO1VBQUE7UUFBQSxHQUFBeUcsUUFBQTtNQUFBLENBQUU7TUFBQSxpQkFBQUcsR0FBQSxFQUFBQyxHQUFBO1FBQUEsT0FBQUwsS0FBQSxDQUFBbEYsS0FBQSxPQUFBRCxTQUFBO01BQUE7SUFBQSxLQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7TUFBQSxJQUFBeUYsS0FBQSxHQUFBM0YsaUJBQUEsZUFBQWhKLG1CQUFBLEdBQUE2RyxJQUFBLENBQUMsU0FBQStILFNBQU14RSxDQUFDO1FBQUEsSUFBQUMsQ0FBQTtRQUFBLE9BQUFySyxtQkFBQSxHQUFBeUIsSUFBQSxVQUFBb04sVUFBQUMsU0FBQTtVQUFBLGtCQUFBQSxTQUFBLENBQUFwSCxJQUFBLEdBQUFvSCxTQUFBLENBQUExSixJQUFBO1lBQUE7Y0FBQTBKLFNBQUEsQ0FBQXBILElBQUE7Y0FBQW9ILFNBQUEsQ0FBQTFKLElBQUE7Y0FBQSxPQUFxQm1HLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFBQTtjQUFkbEIsQ0FBQyxHQUFBeUUsU0FBQSxDQUFBcEssSUFBQTtjQUFjLENBQUMsQ0FBQzJGLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBRUEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFFLEdBQUcsSUFBRUEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFFLEdBQUcsS0FBR0QsQ0FBQyxDQUFDO2dCQUFDLE1BQU0sRUFBQ3lCLFVBQVUsQ0FBQyxTQUFTLENBQUM7Z0JBQUMsU0FBUyxFQUFDLE1BQU07Z0JBQUMsTUFBTSxFQUFDO2tCQUFDLE1BQU0sRUFBQ2pDO2dCQUFDO2NBQUMsQ0FBQyxDQUFDO2NBQUNrRixTQUFBLENBQUExSixJQUFBO2NBQUE7WUFBQTtjQUFBMEosU0FBQSxDQUFBcEgsSUFBQTtjQUFBb0gsU0FBQSxDQUFBekMsRUFBQSxHQUFBeUMsU0FBQTtjQUFVekQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQVksRUFBQXlELFNBQUEsQ0FBQXpDLEVBQUEsQ0FBRztZQUFDO1lBQUE7Y0FBQSxPQUFBeUMsU0FBQSxDQUFBakgsSUFBQTtVQUFBO1FBQUEsR0FBQStHLFFBQUE7TUFBQSxDQUFFO01BQUEsaUJBQUFHLEdBQUE7UUFBQSxPQUFBSixLQUFBLENBQUF4RixLQUFBLE9BQUFELFNBQUE7TUFBQTtJQUFBLEtBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztNQUFBLElBQUE4RixLQUFBLEdBQUFoRyxpQkFBQSxlQUFBaEosbUJBQUEsR0FBQTZHLElBQUEsQ0FBQyxTQUFBb0ksU0FBTTdFLENBQUMsRUFBQ0MsQ0FBQztRQUFBLElBQUFFLENBQUE7UUFBQSxPQUFBdkssbUJBQUEsR0FBQXlCLElBQUEsVUFBQXlOLFVBQUFDLFNBQUE7VUFBQSxrQkFBQUEsU0FBQSxDQUFBekgsSUFBQSxHQUFBeUgsU0FBQSxDQUFBL0osSUFBQTtZQUFBO2NBQUErSixTQUFBLENBQUF6SCxJQUFBO2NBQUF5SCxTQUFBLENBQUEvSixJQUFBO2NBQUEsT0FBc0JtRyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQUE7Y0FBZGhCLENBQUMsR0FBQTRFLFNBQUEsQ0FBQXpLLElBQUE7Y0FBYyxDQUFDLENBQUM2RixDQUFDLENBQUMsU0FBUyxDQUFDLElBQUVBLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBRSxHQUFHLEtBQUdnQyxDQUFDLENBQUNuQyxDQUFDLEVBQUNDLENBQUMsQ0FBQztjQUFDOEUsU0FBQSxDQUFBL0osSUFBQTtjQUFBO1lBQUE7Y0FBQStKLFNBQUEsQ0FBQXpILElBQUE7Y0FBQXlILFNBQUEsQ0FBQTlDLEVBQUEsR0FBQThDLFNBQUE7Y0FBVTlELE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLEVBQUE4RCxTQUFBLENBQUE5QyxFQUFBLENBQUc7WUFBQztZQUFBO2NBQUEsT0FBQThDLFNBQUEsQ0FBQXRILElBQUE7VUFBQTtRQUFBLEdBQUFvSCxRQUFBO01BQUEsQ0FBRTtNQUFBLGlCQUFBRyxHQUFBLEVBQUFDLEdBQUE7UUFBQSxPQUFBTCxLQUFBLENBQUE3RixLQUFBLE9BQUFELFNBQUE7TUFBQTtJQUFBO0lBQUMsSUFBTW9HLENBQUMsR0FBQ2xHLFFBQVEsR0FBQyxvREFBb0Q7SUFBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7TUFBQSxJQUFBbUcsS0FBQSxHQUFBdkcsaUJBQUEsZUFBQWhKLG1CQUFBLEdBQUE2RyxJQUFBLENBQUMsU0FBQTJJLFNBQU1wRixDQUFDLEVBQUNDLENBQUM7UUFBQSxJQUFBRSxDQUFBO1FBQUEsT0FBQXZLLG1CQUFBLEdBQUF5QixJQUFBLFVBQUFnTyxVQUFBQyxTQUFBO1VBQUEsa0JBQUFBLFNBQUEsQ0FBQWhJLElBQUEsR0FBQWdJLFNBQUEsQ0FBQXRLLElBQUE7WUFBQTtjQUFBc0ssU0FBQSxDQUFBaEksSUFBQTtjQUFRMEMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFDZCxDQUFDLEVBQUNjLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBQ2IsQ0FBQztjQUFDbUcsU0FBQSxDQUFBdEssSUFBQTtjQUFBLE9BQWMrRixDQUFDLENBQUNtRSxDQUFDLEVBQUNsRixDQUFDLENBQUM7WUFBQTtjQUFkRyxDQUFDLEdBQUFtRixTQUFBLENBQUFoTCxJQUFBO2NBQWMyRixDQUFDLENBQUNFLENBQUMsQ0FBQztjQUFDbUYsU0FBQSxDQUFBdEssSUFBQTtjQUFBO1lBQUE7Y0FBQXNLLFNBQUEsQ0FBQWhJLElBQUE7Y0FBQWdJLFNBQUEsQ0FBQXJELEVBQUEsR0FBQXFELFNBQUE7Y0FBVXJFLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLEVBQUFxRSxTQUFBLENBQUFyRCxFQUFBLENBQUc7WUFBQztZQUFBO2NBQUEsT0FBQXFELFNBQUEsQ0FBQTdILElBQUE7VUFBQTtRQUFBLEdBQUEySCxRQUFBO01BQUEsQ0FBRTtNQUFBLGlCQUFBRyxJQUFBLEVBQUFDLElBQUE7UUFBQSxPQUFBTCxLQUFBLENBQUFwRyxLQUFBLE9BQUFELFNBQUE7TUFBQTtJQUFBO0lBQUMsSUFBTTJHLENBQUMsR0FBQ3pHLFFBQVEsR0FBQyxpREFBaUQ7SUFBQyxJQUFJLENBQUMsYUFBYSxDQUFDO01BQUEsSUFBQTBHLE1BQUEsR0FBQTlHLGlCQUFBLGVBQUFoSixtQkFBQSxHQUFBNkcsSUFBQSxDQUFDLFNBQUFrSixTQUFNM0YsQ0FBQyxFQUFDQyxDQUFDO1FBQUEsSUFBQUUsQ0FBQTtRQUFBLE9BQUF2SyxtQkFBQSxHQUFBeUIsSUFBQSxVQUFBdU8sVUFBQUMsU0FBQTtVQUFBLGtCQUFBQSxTQUFBLENBQUF2SSxJQUFBLEdBQUF1SSxTQUFBLENBQUE3SyxJQUFBO1lBQUE7Y0FBSWdGLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBQ2QsQ0FBQyxFQUFDYyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUNiLENBQUM7Y0FBQzBHLFNBQUEsQ0FBQXZJLElBQUE7Y0FBQXVJLFNBQUEsQ0FBQTdLLElBQUE7Y0FBQSxPQUFrQitGLENBQUMsQ0FBQzBFLENBQUMsRUFBQ3pGLENBQUMsQ0FBQztZQUFBO2NBQWRHLENBQUMsR0FBQTBGLFNBQUEsQ0FBQXZMLElBQUE7Y0FBYzJGLENBQUMsQ0FBQ0UsQ0FBQyxDQUFDO2NBQUMwRixTQUFBLENBQUE3SyxJQUFBO2NBQUE7WUFBQTtjQUFBNkssU0FBQSxDQUFBdkksSUFBQTtjQUFBdUksU0FBQSxDQUFBNUQsRUFBQSxHQUFBNEQsU0FBQTtjQUFVNUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGNBQWMsRUFBQTRFLFNBQUEsQ0FBQTVELEVBQUEsQ0FBRztZQUFDO1lBQUE7Y0FBQSxPQUFBNEQsU0FBQSxDQUFBcEksSUFBQTtVQUFBO1FBQUEsR0FBQWtJLFFBQUE7TUFBQSxDQUFFO01BQUEsaUJBQUFHLElBQUEsRUFBQUMsSUFBQTtRQUFBLE9BQUFMLE1BQUEsQ0FBQTNHLEtBQUEsT0FBQUQsU0FBQTtNQUFBO0lBQUEsS0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsR0FBQyxVQUFDa0IsQ0FBQyxFQUFDQyxDQUFDLEVBQUc7TUFBQyxJQUFHLENBQUNDLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFDO1FBQUNtQyxDQUFDLENBQUMsSUFBSSxFQUFDLHlCQUF5QixDQUFDO1FBQUM7TUFBTztNQUFDLElBQUcxQyxDQUFDLElBQUVLLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBQztRQUFDLElBQUdKLENBQUMsRUFBQztVQUFDQSxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBQ0QsQ0FBQyxHQUFDLElBQUksRUFBQ0MsQ0FBQyxHQUFDLElBQUksRUFBQ29HLHFCQUFxQixDQUFDaEcsQ0FBQyxFQUFDQyxDQUFDLENBQUM7VUFBQztRQUFPO1FBQUMsSUFBSUUsQ0FBQyxHQUFDO1VBQUMsVUFBVSxFQUFDSCxDQUFDLENBQUMsVUFBVTtRQUFDLENBQUM7UUFBQ0EsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFHRyxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUNILENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFDSixDQUFDLEdBQUNNLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBQ1AsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFVBQUFRLENBQUM7VUFBQSxPQUFFYSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxFQUFDYixDQUFDLENBQUM7UUFBQSxFQUFDLEVBQUNSLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxVQUFBUSxDQUFDLEVBQUU7VUFBQ0EsQ0FBQyxJQUFFQSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUVBLENBQUMsS0FBR3hGLFNBQVMsSUFBRW1KLENBQUMsQ0FBQ2tDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFDdEcsQ0FBQyxFQUFDdUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUNsRyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUVBLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUFDLE1BQU0sRUFBQ3lCLFVBQVUsQ0FBQyxTQUFTLENBQUM7WUFBQyxTQUFTLEVBQUMsTUFBTTtZQUFDLE1BQU0sRUFBQztVQUFJLENBQUMsQ0FBQyxJQUFFekIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFFQSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7WUFBQyxNQUFNLEVBQUN5QixVQUFVLENBQUMsUUFBUSxDQUFDO1lBQUMsU0FBUyxFQUFDLE9BQU87WUFBQyxNQUFNLEVBQUM7VUFBSSxDQUFDLENBQUM7UUFBQyxDQUFDLENBQUMsRUFBQzlCLENBQUMsR0FBQ0ssQ0FBQyxDQUFDLFVBQVUsQ0FBQztNQUFDO01BQUNDLENBQUMsQ0FBQztRQUFDLE1BQU0sRUFBQ3dCLFVBQVUsQ0FBQyxTQUFTLENBQUM7UUFBQyxTQUFTLEVBQUMsTUFBTTtRQUFDLE1BQU0sRUFBQztNQUFJLENBQUMsQ0FBQztJQUFDLENBQUMsRUFBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBQyxZQUFJO01BQUM3QixDQUFDLElBQUVBLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQUEsT0FBSW1FLENBQUMsQ0FBQ2tDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFDdEcsQ0FBQyxFQUFDdUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQUEsRUFBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQUk7UUFBQ3RHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1VBQUEsT0FBSUEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7WUFBQSxPQUFJbUUsQ0FBQyxDQUFDa0MsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEVBQUN0RyxDQUFDLEVBQUN1RyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7VUFBQSxFQUFDO1FBQUEsRUFBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFVBQUFsRyxDQUFDO1VBQUEsT0FBRWlCLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQztRQUFBLEVBQUM7TUFBQyxDQUFDLENBQUM7SUFBQyxDQUFDLEVBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUMsVUFBQ2pCLENBQUMsRUFBQ0MsQ0FBQyxFQUFHO01BQUMsSUFBRyxDQUFDQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsRUFBQztRQUFDbUMsQ0FBQyxDQUFDLElBQUksRUFBQyw2QkFBNkIsQ0FBQztRQUFDO01BQU87TUFBQyxJQUFHeEMsQ0FBQyxJQUFFRyxDQUFDLENBQUMsVUFBVSxDQUFDLEVBQUM7UUFBQyxJQUFHRixDQUFDLEVBQUM7VUFBQ0EsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUNELENBQUMsR0FBQyxJQUFJLEVBQUNDLENBQUMsR0FBQyxJQUFJLEVBQUNxRyxjQUFjLENBQUNuRyxDQUFDLEVBQUNDLENBQUMsQ0FBQztVQUFDO1FBQU87UUFBQyxJQUFJRSxDQUFDLEdBQUM7VUFBQyxVQUFVLEVBQUNILENBQUMsQ0FBQyxVQUFVLENBQUM7VUFBQyxPQUFPLEVBQUNBLENBQUMsQ0FBQyxPQUFPO1FBQUMsQ0FBQztRQUFDQSxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUdHLENBQUMsQ0FBQyxhQUFhLENBQUMsR0FBQ0gsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUNGLENBQUMsR0FBQ0ksRUFBRSxDQUFDLGdCQUFnQixDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFDTCxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBSTtVQUFDaUUsQ0FBQyxDQUFDa0MsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFDcEcsQ0FBQyxFQUFDcUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQUMsQ0FBQyxDQUFDLEVBQUNwRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBQU0sQ0FBQztVQUFBLE9BQUVhLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsRUFBQ2IsQ0FBQyxDQUFDO1FBQUEsRUFBQyxFQUFDUCxDQUFDLEdBQUNHLENBQUMsQ0FBQyxVQUFVLENBQUM7TUFBQztNQUFDQyxDQUFDLENBQUM7UUFBQyxNQUFNLEVBQUN3QixVQUFVLENBQUMsU0FBUyxDQUFDO1FBQUMsU0FBUyxFQUFDLE1BQU07UUFBQyxNQUFNLEVBQUM7TUFBSSxDQUFDLENBQUM7SUFBQyxDQUFDLEVBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFDLFlBQUk7TUFBQzNCLENBQUMsSUFBRUEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQUMsQ0FBQyxFQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBQyxZQUFJO01BQUNBLENBQUMsSUFBRUEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQUMsQ0FBQyxFQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFDLFVBQUNFLENBQUMsRUFBQ0MsQ0FBQyxFQUFHO01BQUNDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDRixDQUFDLEVBQUNDLENBQUMsQ0FBQztJQUFDLENBQUMsRUFBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBQyxVQUFBRCxDQUFDLEVBQUU7TUFBQ0UsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUNGLENBQUMsQ0FBQztJQUFDLENBQUMsRUFBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBQyxVQUFBQSxDQUFDLEVBQUU7TUFBQyxPQUFPRSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQ0YsQ0FBQyxDQUFDO0lBQUMsQ0FBQztFQUFDO0VBQUNmLFlBQUEsQ0FBTyxRQUFRLElBQWYsU0FBQW1ILE9BQUEsRUFBa0I7SUFBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBQyxJQUFJbkgsWUFBWSxFQUFFLENBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0VBQUMsQ0FBQztFQUFBLE9BQUFBLFlBQUE7QUFBQTtBQUFBcEosT0FBQSxjQUFBb0osWUFBQTtBQUFBLElBQU93QyxVQUFVLFlBQUFBLFdBQUE7QUFBVkEsVUFBVSxDQUFTLFNBQVMsSUFBRSxHQUFHO0FBQWpDQSxVQUFVLENBQWdDLFFBQVEsSUFBRSxDQUFDLEdBQUc7QUFBeERBLFVBQVUsQ0FBdUQsK0JBQStCLElBQUUsTUFBTTtBQUFBLElBQVF3RSxNQUFNLFlBQUFBLE9BQUE7QUFBTkEsTUFBTSxDQUFTLG1CQUFtQixJQUFFLEdBQUc7QUFBdkNBLE1BQU0sQ0FBMEMsV0FBVyxJQUFFLEdBQUc7QUFBQSxJQUFRQyxZQUFZLFlBQUFBLGFBQUE7QUFBWkEsWUFBWSxDQUFTLE1BQU0sSUFBRSxHQUFHO0FBQWhDQSxZQUFZLENBQTZCLFVBQVUsSUFBRSxHQUFHO0FBQUFHLE1BQUEsQ0FBQXhRLE9BQUEsR0FBQUEsT0FBQSIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQkFTRV9VUkw9J2h0dHBzOi8vZ2FtZXMuaG5kaWJlaS5jb20nO2V4cG9ydCBkZWZhdWx0IGNsYXNzIEV5b3VDbGllbnRWMntjb25zdHJ1Y3Rvcigpe2xldCBOPW51bGwsaD0weDEsRT1udWxsLGk9bnVsbCxiPSctMScsZz0nLTEnLEI9MHg0LG49bnVsbCxEPW51bGwsUj1udWxsLHg9bnVsbCxQPW51bGwsSz1udWxsLHk9bnVsbDtjb25zdCBmPVo9PntOPVo7Y29uc3QgbD13eFsnZ2V0U3lzdGVtSW5mb1N5bmMnXSgpO0I9bFsncGxhdGZvcm0nXT09PSdhbmRyb2lkJz8nNCc6bFsncGxhdGZvcm0nXT09PSdpb3MnPyc1JzonNic7Y29uc3QgYT13eFsnZ2V0TGF1bmNoT3B0aW9uc1N5bmMnXSgpWydxdWVyeSddO0U9YVsnY2hhbm5lbCddLGk9YVsnc3ViX2NoYW5uZWwnXTtjb25zdCBPPXsnMTA5MDgnOlsnYWRfaWQnLCdjbHVlX3Rva2VuJ10sJzEwOTE4JzpbJ2FkX2lkJywnY2x1ZV90b2tlbiddLCcxMDkxMic6Wyd3ZWl4aW5hZGluZm8nXSwnMTA5MTMnOlsna3NVbml0SWQnLCdjYWxsYmFjayddLCcxMDkxNCc6Wyd1aWQnLCdiZF92aWQnXSwnMTA5MTYnOlsnYWlkJywndHJhY2tpZCddLCcxMDkxNyc6WydjYW1wYWlnbmlkJywndWN0cmFja2lkJ10sJzEwOTE5JzpbJ3Byb21vdGlvbl9pZCcsJ2NsdWVfdG9rZW4nXSwnMTA5MjAnOlsnQURJRCcsJ2ltcCcsJ21hcmtfaWQnXX07aWYoT1snaGFzT3duUHJvcGVydHknXShFKSl7Y29uc3QgW2osSSxRXT1PW0VdO2lmKGo9PT0nd2VpeGluYWRpbmZvJyl7Y29uc3Qgcz1hWyd3ZWl4aW5hZGluZm8nXTtpZihzKXtjb25zdCBwPXNbJ3NwbGl0J10oJy4nKTtiPXBbMHgwXSxnPXBbMHgxXTt9fWVsc2UgYj1hW2pdLGc9YVtJXSwhZyYmUSYmKGc9YVtRXSk7fWVsc2UgRT0nMTA5MDYnLGk9JycrTitoK0UrQisnMCc7fSxjPSgpPT57cmV0dXJuIG5ldyBQcm9taXNlKChaLGwpPT57d3hbJ2xvZ2luJ10oeydzdWNjZXNzJzooe2NvZGU6YX0pPT57YT9aKGEpOmwobmV3IEVycm9yKCfojrflj5Zjb2Rl5aSx6LSlJykpO30sJ2ZhaWwnOmx9KTt9KTt9LEM9KFosbCk9PntyZXR1cm4gbmV3IFByb21pc2UoKGEsTyk9Pnt3eFsncmVxdWVzdCddKHsndXJsJzpaLCdtZXRob2QnOidQT1NUJywnaGVhZGVyJzp7J0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nfSwnZGF0YSc6SlNPTlsnc3RyaW5naWZ5J10obCksJ2ZhaWwnOk8sJ3N1Y2Nlc3MnOmZ1bmN0aW9uKGope2EoalsnZGF0YSddKTt9LCdjb21wbGV0ZSc6ZnVuY3Rpb24oail7Y29uc29sZVsnbG9nJ10oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLeivt+axglxceDIwQkVHSU4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpLGNvbnNvbGVbJ2xvZyddKCdVcmw6PicsWiksY29uc29sZVsnbG9nJ10oJ+ivt+axguWPguaVsDo+JyxsKSxjb25zb2xlWydsb2cnXSgn5ZON5bqUOj4nLGpbJ2RhdGEnXXx8alsnZXJyTXNnJ10pLGNvbnNvbGVbJ2xvZyddKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS3or7fmsYJcXHgyMEVORC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7fX0pO30pO30sdD1CQVNFX1VSTCsnL21hcmtldC13ZWNoYXQtZ2FtZS1zZXJ2ZXIvd3hUcmFuc2Zlci9zaG93VHJhbnNmZXInLEw9YXN5bmMgWj0+e3RyeXtjb25zdCBsPXsnZ2FtZUlkJzpOLCdwbGF0Zm9ybUlkJzpoLCd0cmFuc2Zlck5vZGVUeXBlJzpaLCd1c2VySWQnOkQsJ3N5cyc6Qn0sYT1hd2FpdCBDKHQsbCk7aWYoYVsnY29kZSddPT09Q29kZVN0YXR1c1snU1VDQ0VTUyddKXtjb25zdCB7dHJhbnNmZXJUeXBlOk8sc2hvd1RleHQ6aixjb3B5VGV4dDpJLHBpY3R1cmVVcmw6USxzaG93VGlwOnN9PWFbJ2RhdGEnXTtpZihPPT09MHgxKXd4WydzaG93TW9kYWwnXSh7J3RpdGxlJzon5YWs5ZGKJywnY29udGVudCc6aiwnY29uZmlybVRleHQnOiflpI3liLbpk77mjqUnLCdzdWNjZXNzJzpmdW5jdGlvbihwKXtwWydjb25maXJtJ10mJnd4WydzZXRDbGlwYm9hcmREYXRhJ10oeydkYXRhJzpJfSk7fX0pO2Vsc2V7aWYoTz09PTB4Mil3eFsncHJldmlld0ltYWdlJ10oeyd1cmxzJzpbUSsnP3RpbWU9JytNYXRoWydmbG9vciddKERhdGVbJ25vdyddKCkvMHgzZTgpXX0pO2Vsc2UgTz09PTB4MyYmcygn5YWs5ZGKJyxzKTt9fWVsc2UgY29uc29sZVsnbG9nJ10oJ+WFrOWRiuWxleekuuWksei0pTonLGFbJ21lc3NhZ2UnXSk7cmV0dXJueydzdWNjZXNzJzohIVtdLCdyZXN1bHQnOmF9O31jYXRjaChwKXtyZXR1cm4gY29uc29sZVsnZXJyb3InXSgnW+WxleekuuWFrOWRil3lvILluLg6JyxwKSx7J3N1Y2Nlc3MnOiFbXSwnZXJyb3InOmVycm9yfTt9fSxtPShaLGwpPT57WlsnZ2FtZUlkJ109TiwoWlsncGxhdGZvcm1JZCddPWgsWlsnc3lzJ109QiksWShaKVsndGhlbiddKGE9PntpZihhWydwYXlUeXBlJ109PTB4MSlhWydiYWxhbmNlJ10+MHgwP0EoJ+WFheWAvOaPkOekuicsJ+i0puaIt+S9meminTonK2FbJ2JhbGFuY2UnXSsn5YWDLFxceDIw6L+Y6ZyA5YWF5YC8OicrYVsnbmVlZFBheSddKyflhYMnLCgpPT5NKGEpKTpNKGEsbCk7ZWxzZXtpZihhWydwYXlUeXBlJ109PTB4MilxKGEsbCk7ZWxzZXtpZihhWydwYXlUeXBlJ109PTB4NCl3eFsnc2hvd01vZGFsJ10oeyd0aXRsZSc6J+WFheWAvOaPkOekuicsJ2NvbnRlbnQnOifljbPlsIblsZXnpLrlhYXlgLzkuoznu7TnoIEsXFx4MjDor7fmiavmj4/kuoznu7TnoIHlrozmiJDmlK/ku5gnLCdzdWNjZXNzJzpmdW5jdGlvbihPKXtPWydjb25maXJtJ10mJnd4WydwcmV2aWV3SW1hZ2UnXSh7J3VybHMnOlthWydwYXlVcmwnXV19KTt9fSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ+mdnuazleaUr+S7mOexu+WeiycpO319fSk7fSxNPShaLGwpPT57aWYoWlsnbmVlZFBheSddPT0weDApe2soWixsKTtyZXR1cm47fXd4WydyZXF1ZXN0TWlkYXNQYXltZW50J10oeydtb2RlJzonZ2FtZScsJ2Vudic6MHgwLCdvZmZlcklkJzpaWydvZmZlcklkJ10sJ2N1cnJlbmN5VHlwZSc6J0NOWScsJ3BsYXRmb3JtJzonYW5kcm9pZCcsJ2J1eVF1YW50aXR5JzpaWyduZWVkUGF5J10qWlsnbWlkYXNSYXRlJ10sJ3pvbmVJZCc6JzEnLCdzdWNjZXNzJzphPT57ayhaLGwpO30sJ2ZhaWwnOmE9PntBKCflvq7kv6HmlK/ku5jlpLHotKUnLGEpO319KTt9LHE9KFosbCk9Pnt3eFsnb3BlbkN1c3RvbWVyU2VydmljZUNvbnZlcnNhdGlvbiddKHsnc2hvd01lc3NhZ2VDYXJkJzohIVtdLCdzZXNzaW9uRnJvbSc6WlsncGF5VXJsJ10sJ3NlbmRNZXNzYWdlUGF0aCc6Jy9pbmRleC53eG1sP3VybD0nK1pbJ3BheVVybCddLCdzZW5kTWVzc2FnZVRpdGxlJzon5Y+R6YCB5Y2h54mH5YWF5YC8Jywnc2VuZE1lc3NhZ2VJbWcnOlpbJ3BheUljb25VcmwnXX0pO30sWD1CQVNFX1VSTCsnL21hcmtldC13ZWNoYXQtZ2FtZS1zZXJ2ZXIvd3hDbGllbnQvZGVkdWN0JyxrPWFzeW5jKFosbCk9Pntjb25zdCBhPXsnb3JkZXJJZCc6Wlsnb3JkZXJJZCddLCdnYW1lSWQnOk4sJ3BsYXRmb3JtSWQnOmgsJ3VzZXJJZCc6WlsndXNlcklkJ119LE89MHgzO2xldCBqPTB4MCxJPSFbXSxRO3doaWxlKGo8TyYmIUkpe3RyeXtRPWF3YWl0IEMoWCxhKTtRWydjb2RlJ109PT1Db2RlU3RhdHVzWydHQU1FX1NFU1NJT05fS0VZX1RJTUVfT1VUX0VSUiddJiZhd2FpdCB2KCk7aWYoUVsnY29kZSddPT09Q29kZVN0YXR1c1snU1VDQ0VTUyddKXtsKFEpO2JyZWFrO319Y2F0Y2gocyl7Y29uc29sZVsnZXJyb3InXSgnW+aJo+asvuWksei0pV3lvILluLg6Picscyk7fWorKzt9fSxXPUJBU0VfVVJMKycvbWFya2V0LXdlY2hhdC1nYW1lLXNlcnZlci93eENsaWVudC9wdWxsUGF5JyxZPWFzeW5jIFo9Pntjb25zdCBsPTB4MztsZXQgYT0weDAsTz0hW10saj0hW107d2hpbGUoYTxsJiYhTyl7dHJ5e2NvbnN0IEk9YXdhaXQgQyhXLFopO2lmKElbJ2NvZGUnXT09PUNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSlyZXR1cm4gSVsnZGF0YSddO2Vsc2UgSVsnY29kZSddPT09Q29kZVN0YXR1c1snR0FNRV9TRVNTSU9OX0tFWV9USU1FX09VVF9FUlInXT9hd2FpdCB2KCk6IWomJihBKCfmlK/ku5jmi4notbflpLHotKUnLElbJ21lc3NhZ2UnXSksaj0hIVtdKTt9Y2F0Y2goUSl7IWomJihBKCfmlK/ku5jmi4notbflpLHotKUnLCfnvZHnu5zotoXml7YnKSxqPSEhW10pO31hKys7fXRocm93IG5ldyBFcnJvcign5pSv5LuY5ouJ6LW35aSx6LSlJyk7fSx1PUJBU0VfVVJMKycvbWFya2V0LXdlY2hhdC1nYW1lLXNlcnZlci93eENsaWVudC9yZWZyZXNoU2Vzc2lvbicsdj1hc3luYygpPT57Y29uc3QgWj0weDM7bGV0IGw9MHgwLGE9IVtdO3doaWxlKGw8WiYmIWEpe3RyeXtjb25zdCBPPWF3YWl0IGMoKSxqPXsnZ2FtZUlkJzpOLCdwbGF0Zm9ybUlkJzpoLCdjb2RlJzpPfSxJPWF3YWl0IEModSxqKTthPUlbJ2NvZGUnXT09PUNvZGVTdGF0dXNbJ1NVQ0NFU1MnXTt9Y2F0Y2goUSl7Y29uc29sZVsnZXJyb3InXSgnW+WIt+aWsOS8muivneWksei0pV3lvILluLg6PicsUSksbCsrO319aWYoIWEpdGhyb3cgbmV3IEVycm9yKCfliLfmlrDkvJror53lpLHotKUnKTt9LEo9QkFTRV9VUkwrJy9tYXJrZXQtd2VjaGF0LWdhbWUtc2VydmVyL3d4Q2xpZW50L2FkQWN0aW9uJyxBPShaLGwsYSxPKT0+e3d4WydzaG93TW9kYWwnXSh7J3RpdGxlJzpaLCdjb250ZW50JzpsLCdzdWNjZXNzJzpmdW5jdGlvbihqKXtpZihqWydjb25maXJtJ10mJmEpYSgpO2Vsc2UgalsnY2FuY2VsJ10mJk8mJk8oKTt9fSk7fSxIPShaLGwsYSk9PntsZXQgTz17J2dhbWVJZCc6TiwncGxhdGZvcm1JZCc6aCwnY2hhbm5lbElkJzpFLCdzdWJDaGFubmVsSWQnOmksJ2FpZCc6YiwndHJhY2VJZCc6Zywnc3lzJzpCLCd1c2VySWQnOkQsJ2FkVHlwZSc6WiwnYWRVbml0SWQnOmwsJ2FkQWN0aW9uVHlwZSc6YX07QyhKLE8pWydjYXRjaCddKGo9Pntjb25zb2xlWydsb2cnXSgn5Y+R6YCB5bm/5ZGK6KGM5Li65aSx6LSlOj4nLGopO30pO30sVT1CQVNFX1VSTCsnL21hcmtldC13ZWNoYXQtZ2FtZS1zZXJ2ZXIvd3hDbGllbnQvaW5pdEdhbWUnO3RoaXNbJ2luaXQnXT1hc3luYyhaLGwpPT57dHJ5e2YoWik7Y29uc3QgYT1hd2FpdCBjKCksTz17J2NvZGUnOmEsJ2dhbWVJZCc6TiwncGxhdGZvcm1JZCc6aCwnY2hhbm5lbElkJzpFLCdzdWJDaGFubmVsSWQnOmksJ2FpZCc6YiwndHJhY2VJZCc6Zywnc3lzJzpCfSxqPWF3YWl0IEMoVSxPKTtqWydjb2RlJ109PT1Db2RlU3RhdHVzWydTVUNDRVNTJ10mJihEPWpbJ2RhdGEnXVsndXNlcklkJ10sY29uc29sZVsnbG9nJ10oRCksUj1qWydkYXRhJ11bJ3VuaW9uSWQnXSxuPWEsalsnZGF0YSddPW51bGwpLGwoaik7fWNhdGNoKEkpe2NvbnNvbGVbJ2Vycm9yJ10oJ1vliJ3lp4vljJbmuLjmiI9d5byC5bi4Oj4nLEkpO319LHRoaXNbJ2xvZ2luJ109YXN5bmMgWj0+e3RyeXtjb25zdCBsPWF3YWl0IEwoMHgxKTsoIWxbJ3N1Y2Nlc3MnXXx8bFsncmVzdWx0J11bJ2NvZGUnXSE9MHgwfHxsWydyZXN1bHQnXVsnZGF0YSddWyd0cmFuc2ZlclR5cGUnXSE9MHgzKSYmWih7J2NvZGUnOkNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSwnbWVzc2FnZSc6J+aTjeS9nOaIkOWKnycsJ2RhdGEnOnsnY29kZSc6bn19KTt9Y2F0Y2goYSl7Y29uc29sZVsnZXJyb3InXSgnW+eZu+W9lea4uOaIj13lvILluLg6PicsYSk7fX0sdGhpc1sncGF5J109YXN5bmMoWixsKT0+e3RyeXtjb25zdCBhPWF3YWl0IEwoMHgyKTsoIWFbJ3N1Y2Nlc3MnXXx8YVsncmVzdWx0J11bJ2NvZGUnXSE9MHgwKSYmbShaLGwpO31jYXRjaChPKXtjb25zb2xlWydlcnJvciddKCdb5pSv5LuY5ouJ6LW3XeW8guW4uDo+JyxPKTt9fTtjb25zdCBkPUJBU0VfVVJMKycvbWFya2V0LXdlY2hhdC1nYW1lLXNlcnZlci93eENsaWVudC91cGxvYWRSb2xlSW5mbyc7dGhpc1sndXBsb2FkUm9sZUluZm8nXT1hc3luYyhaLGwpPT57dHJ5e1pbJ2dhbWVJZCddPU4sWlsncGxhdGZvcm1JZCddPWg7Y29uc3QgYT1hd2FpdCBDKGQsWik7bChhKTt9Y2F0Y2goTyl7Y29uc29sZVsnZXJyb3InXSgn5LiK5oql6KeS6Imy5pWw5o2u5byC5bi4Oj4nLE8pO319O2NvbnN0IFY9QkFTRV9VUkwrJy9tYXJrZXQtd2VjaGF0LWdhbWUtc2VydmVyL3d4U2VydmVyL21zZ1NlY0NoZWNrJzt0aGlzWydtc2dTZWNDaGVjayddPWFzeW5jKFosbCk9PntaWydnYW1lSWQnXT1OLFpbJ3BsYXRmb3JtSWQnXT1oO3RyeXtjb25zdCBhPWF3YWl0IEMoVixaKTtsKGEpO31jYXRjaChPKXtjb25zb2xlWydlcnJvciddKCdb5paH5pys5a6J5YWo5qOA5rWLXeW8guW4uDo+JyxPKTt9fSx0aGlzWydjcmVhdGVSZXdhcmRlZFZpZGVvQWQnXT0oWixsKT0+e2lmKCF3eFsnY3JlYXRlUmV3YXJkZWRWaWRlb0FkJ10pe0EoJ+aPkOekuicsJ+WfuuehgOW6k+eJiOacrOWPt+i/h+S9jixcXHgyMOaaguS4jeaUr+aMgeWxleekuua/gOWKseinhumikScpO3JldHVybjt9aWYoeCE9WlsnYWRVbml0SWQnXSl7aWYoUCl7UFsnZGVzdG9yeSddKCkseD1udWxsLFA9bnVsbCxjcmVhdGVSZXdhcmRlZFZpZGVvQWQoWixsKTtyZXR1cm47fWxldCBhPXsnYWRVbml0SWQnOlpbJ2FkVW5pdElkJ119O1pbJ211bHRpdG9uJ10mJihhWydtdWx0aXRvbiddPVpbJ211bHRpdG9uJ10pLFA9d3hbJ2NyZWF0ZVJld2FyZGVkVmlkZW9BZCddKGEpLFBbJ29uRXJyb3InXShPPT5jb25zb2xlWydsb2cnXSgn5r+A5Yqx6KeG6aKR56iL5bqP5Ye66ZSZOj4nLE8pKSxQWydvbkNsb3NlJ10oTz0+e08mJk9bJ2lzRW5kZWQnXXx8Tz09PXVuZGVmaW5lZD8oSChBZFR5cGVbJ1JFV0FSREVEX1ZJREVPX0FEJ10seCxBZEFjdGlvblR5cGVbJ0ZJTklTSEVEJ10pLFpbJ29uQ2xvc2UnXSYmWlsnb25DbG9zZSddKHsnY29kZSc6Q29kZVN0YXR1c1snU1VDQ0VTUyddLCdtZXNzYWdlJzon5pKt5pS+5a6M5oiQJywnZGF0YSc6bnVsbH0pKTpaWydvbkNsb3NlJ10mJlpbJ29uQ2xvc2UnXSh7J2NvZGUnOkNvZGVTdGF0dXNbJ0ZBSUxFRCddLCdtZXNzYWdlJzon5pKt5pS+5pyq5a6M5oiQJywnZGF0YSc6bnVsbH0pO30pLHg9WlsnYWRVbml0SWQnXTt9bCh7J2NvZGUnOkNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSwnbWVzc2FnZSc6J+aTjeS9nOaIkOWKnycsJ2RhdGEnOm51bGx9KTt9LHRoaXNbJ3Nob3dSZXdhcmRlZFZpZGVvQWQnXT0oKT0+e1AmJlBbJ3Nob3cnXSgpWyd0aGVuJ10oKCk9PkgoQWRUeXBlWydSRVdBUkRFRF9WSURFT19BRCddLHgsQWRBY3Rpb25UeXBlWydTSE9XJ10pKVsnY2F0Y2gnXSgoKT0+e1BbJ2xvYWQnXSgpWyd0aGVuJ10oKCk9PlBbJ3Nob3cnXSgpWyd0aGVuJ10oKCk9PkgoQWRUeXBlWydSRVdBUkRFRF9WSURFT19BRCddLHgsQWRBY3Rpb25UeXBlWydTSE9XJ10pKSlbJ2NhdGNoJ10oWj0+Y29uc29sZVsnbG9nJ10oJ+a/gOWKseinhumikVxceDIw5bm/5ZGK5pi+56S65aSx6LSlJykpO30pO30sdGhpc1snY3JlYXRlQmFubmVyQWQnXT0oWixsKT0+e2lmKCF3eFsnY3JlYXRlQmFubmVyQWQnXSl7QSgn5o+Q56S6Jywn5Z+656GA5bqT54mI5pys5Y+36L+H5L2OLFxceDIw5pqC5LiN5pSv5oyB5bGV56S6QmFubmVy5bm/5ZGKJyk7cmV0dXJuO31pZihLIT1aWydhZFVuaXRJZCddKXtpZih5KXt5WydkZXN0b3J5J10oKSxLPW51bGwseT1udWxsLGNyZWF0ZUJhbm5lckFkKFosbCk7cmV0dXJuO31sZXQgYT17J2FkVW5pdElkJzpaWydhZFVuaXRJZCddLCdzdHlsZSc6Wlsnc3R5bGUnXX07WlsnYWRJbnRlcnZhbHMnXSYmKGFbJ2FkSW50ZXJ2YWxzJ109WlsnYWRJbnRlcnZhbHMnXSkseT13eFsnY3JlYXRlQmFubmVyQWQnXShhKSx5WydvbkxvYWQnXSgoKT0+e0goQWRUeXBlWydCQU5ORVJfQUQnXSxLLEFkQWN0aW9uVHlwZVsnRklOSVNIRUQnXSk7fSkseVsnb25FcnJvciddKE89PmNvbnNvbGVbJ2xvZyddKCdiYW5uZXLlub/lkYrnqIvluo/lh7rplJk6PicsTykpLEs9WlsnYWRVbml0SWQnXTt9bCh7J2NvZGUnOkNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSwnbWVzc2FnZSc6J+aTjeS9nOaIkOWKnycsJ2RhdGEnOm51bGx9KTt9LHRoaXNbJ3Nob3dCYW5uZXJBZCddPSgpPT57eSYmeVsnc2hvdyddKCk7fSx0aGlzWydoaWRlQmFubmVyQWQnXT0oKT0+e3kmJnlbJ2hpZGUnXSgpO30sdGhpc1snc2V0U3RvcmFnZVN5bmMnXT0oWixsKT0+e3d4WydzZXRTdG9yYWdlU3luYyddKFosbCk7fSx0aGlzWydyZW1vdmVTdG9yYWdlU3luYyddPVo9Pnt3eFsncmVtb3ZlU3RvcmFnZVN5bmMnXShaKTt9LHRoaXNbJ2dldFN0b3JhZ2VTeW5jJ109Wj0+e3JldHVybiB3eFsnZ2V0U3RvcmFnZVN5bmMnXShaKTt9O31zdGF0aWNbJ2dldElucyddKCl7cmV0dXJuIXRoaXNbJ2lucyddJiYodGhpc1snaW5zJ109bmV3IEV5b3VDbGllbnRWMigpKSx0aGlzWydpbnMnXTt9fWNsYXNzIENvZGVTdGF0dXN7c3RhdGljIFsnU1VDQ0VTUyddPTB4MDtzdGF0aWMgWydGQUlMRUQnXT0tMHgxO3N0YXRpYyBbJ0dBTUVfU0VTU0lPTl9LRVlfVElNRV9PVVRfRVJSJ109MHgyNzI5O31jbGFzcyBBZFR5cGV7c3RhdGljIFsnUkVXQVJERURfVklERU9fQUQnXT0weDE7c3RhdGljIFsnQkFOTkVSX0FEJ109MHgyO31jbGFzcyBBZEFjdGlvblR5cGV7c3RhdGljIFsnU0hPVyddPTB4MTtzdGF0aWMgWydGSU5JU0hFRCddPTB4Mjt9Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/sdk/EyouClientKs.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd4113FlKipGP5suXrbEeDsg', 'EyouClientKs');
// Scripts/sdk/EyouClientKs.js

"use strict";

exports.__esModule = true;
exports["default"] = void 0;
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var BASE_URL = 'https://games.hndibei.com';
var EyouClientKs = /*#__PURE__*/function () {
  function EyouClientKs() {
    console['log']('EyouClientKs\x20实例已创建');
    var Q = null,
      e = 0x9,
      I = null,
      Y = null,
      U = '-1',
      s = '-1',
      b = '4',
      j = null,
      E = null,
      H = null,
      w = null,
      X = null,
      B = null;
    var o = new Map();
    var p = null;
    var m = function m() {
        return new Promise(function (q, l) {
          ks['login']({
            'force': !![],
            'success': function success(_ref) {
              var G = _ref.code;
              G ? (console['log']('code:>', G), q(G)) : l(new Error('获取code失败'));
            },
            'fail': l
          });
        });
      },
      O = function O(q) {
        Q = q;
        var l = ks['getSystemInfoSync']();
        b = l['platform'] === 'android' ? '4' : l['platform'] === 'ios' ? '5' : '6';
        var G = ks['getLaunchOptionsSync']()['query'];
        G && (I = G['channel'], Y = G['sub_channel']);
        var V = {
          '10913': ['unit_id', 'callback']
        };
        if (V['hasOwnProperty'](I)) {
          var _V$I = V[I],
            R = _V$I[0],
            z = _V$I[1];
          U = G[R], s = G[z];
        } else I = '10906', Y = '' + Q + e + I + b + '0';
      },
      n = function n(q, l) {
        q['gameId'] = Q, (q['platformId'] = e, q['sys'] = b), T(q)['then'](function (G) {
          console['log']('拉起支付返参:', res);
          if (G['payType'] == 0xc) G['balance'] > 0x0 ? u('充值提示', '账户余额:' + G['balance'] + '元,\x20还需充值:' + G['needPay'] + '元', function () {
            return J(G);
          }) : J(G, l);else {
            if (G['payType'] == 0x2 || G['payType'] == 0xa) customerPullPay(G, l);else {
              if (G['payType'] == 0x4) ks['showModal']({
                'title': '充值提示',
                'content': '即将展示充值二维码,\x20请扫描二维码完成支付',
                'success': function success(V) {
                  V['confirm'] && ks['previewImage']({
                    'urls': [G['payUrl']]
                  });
                }
              });else throw new Error('非法支付类型');
            }
          }
        });
      },
      J = function J(q, l) {
        if (q['needPay'] == 0x0) {
          M(q, l);
          return;
        }
        var G = {};
        G['success'] = function (R) {
          M(q, l);
        }, G['fail'] = function (R) {
          u('快手支付失败', R);
        };
        var V = ks['getSystemInfoSync']();
        G['zone_id'] = '1', G['os'] = q['os'], G['currency_type'] = 'CNY', G['buy_quantity'] = q['needPay'] * q['rate'], G['third_party_trade_no'] = q['orderId'], G['sign'] = q['sign'], V['platform'] === 'ios' && (G['product_type'] = 0x1), ks['requestGamePayment'](G);
      },
      y = BASE_URL + '/market-multi-game-server/kuaiShouClient/pullPay',
      T = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(q) {
          var l, G, V, R, z;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                l = 0x3;
                G = 0x0, V = ![], R = ![];
              case 2:
                if (!(G < l && !V)) {
                  _context.next = 20;
                  break;
                }
                _context.prev = 3;
                _context.next = 6;
                return c(y, q);
              case 6:
                z = _context.sent;
                if (!(z['code'] === CodeStatus['SUCCESS'])) {
                  _context.next = 11;
                  break;
                }
                return _context.abrupt("return", z['data']);
              case 11:
                !R && (u('支付拉起失败', z['message']), R = !![]);
              case 12:
                _context.next = 17;
                break;
              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](3);
                !R && (u('支付拉起失败', '网络超时'), R = !![]);
              case 17:
                G++;
                _context.next = 2;
                break;
              case 20:
                throw new Error('支付拉起失败');
              case 21:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[3, 14]]);
        }));
        return function T(_x) {
          return _ref2.apply(this, arguments);
        };
      }(),
      u = function u(q, l, G, V) {
        ks['showModal']({
          'title': q,
          'content': l,
          'success': function success(R) {
            if (R['confirm'] && G) G();else R['cancel'] && V && V();
          }
        });
      },
      x = BASE_URL + '/market-multi-game-server/kuaiShouClient/deduct',
      M = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(q, l) {
          var G, V;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                G = {
                  'orderId': q['orderId'],
                  'gameId': Q,
                  'platformId': e,
                  'userId': q['userId']
                };
                _context2.next = 4;
                return c(x, G);
              case 4:
                V = _context2.sent;
                V['code'] === CodeStatus['SUCCESS'] && l(V);
                _context2.next = 11;
                break;
              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);
                console['error']('[扣款失败]异常:>', _context2.t0);
              case 11:
              case "end":
                return _context2.stop();
            }
          }, _callee2, null, [[0, 8]]);
        }));
        return function M(_x2, _x3) {
          return _ref3.apply(this, arguments);
        };
      }(),
      N = BASE_URL + '/market-multi-game-server/kuaiShouClient/adAction',
      v = function v(q, l, G) {
        var V = {
          'gameId': Q,
          'platformId': e,
          'channelId': I,
          'subChannelId': Y,
          'aid': U,
          'traceId': s,
          'sys': b,
          'userId': E,
          'adType': q,
          'adUnitId': l,
          'adActionType': G
        };
        c(N, V)['catch'](function (R) {
          console['log']('发送广告行为失败:>', R);
        });
      },
      C = function C() {
        if (!p) throw new Error('未创建录屏管理器');
      },
      c = function c(q, l) {
        return new Promise(function (G, V) {
          ks['request']({
            'url': q,
            'method': 'POST',
            'header': {
              'Content-Type': 'application/json;charset=UTF-8'
            },
            'data': JSON['stringify'](l),
            'fail': V,
            'success': function success(R) {
              G(R['data']);
            },
            'complete': function complete(R) {
              console['log']('---------------------------------请求\x20BEGIN--------------------------------'), console['log']('Url:>', q), console['log']('请求参数:>', l);
              var z = R && (R['data'] || R['errMsg']) ? R['data'] || R['errMsg'] : 'No\x20response\x20data';
              console['log']('响应:>', z), console['log']('---------------------------------请求\x20END--------------------------------');
            }
          });
        });
      },
      P = BASE_URL + '/market-multi-game-server/kuaiShouClient/initGame';
    this['init'] = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(q, l) {
        var G, V;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              ks['onShareAppMessage'](function (R) {
                return {
                  'templateId': w,
                  'query': '',
                  'success': function success() {
                    console['log']('分享成功');
                  },
                  'fail': function fail(z) {
                    console['log']('分享失败', z);
                  }
                };
              });
              _context3.next = 4;
              return m();
            case 4:
              j = _context3.sent;
              O(q);
              G = {
                'code': j,
                'gameId': Q,
                'platformId': e,
                'channelId': I,
                'subChannelId': Y,
                'aid': U,
                'traceId': s,
                'sys': b
              };
              _context3.next = 9;
              return c(P, G);
            case 9:
              V = _context3.sent;
              V['code'] === CodeStatus['SUCCESS'] && (E = V['data']['userId'], H = V['data']['unionId'], w = V['data']['shareTemplateId'], V['data'] = null), l(j);
              _context3.next = 16;
              break;
            case 13:
              _context3.prev = 13;
              _context3.t0 = _context3["catch"](0);
              console['error']('[初始化游戏]异常:>', _context3.t0);
            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, null, [[0, 13]]);
      }));
      return function (_x4, _x5) {
        return _ref4.apply(this, arguments);
      };
    }(), this['login'] = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(q) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              q({
                'code': CodeStatus['SUCCESS'],
                'message': '操作成功',
                'data': {
                  'code': j
                }
              });
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return function (_x6) {
        return _ref5.apply(this, arguments);
      };
    }();
    var d = BASE_URL + '/market-multi-game-server/kuaiShouClient/uploadRoleInfo';
    this['uploadRoleInfo'] = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(q, l) {
        var G;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              q['gameId'] = Q, q['platformId'] = e;
              _context5.next = 4;
              return c(d, q);
            case 4:
              G = _context5.sent;
              l(G);
              _context5.next = 11;
              break;
            case 8:
              _context5.prev = 8;
              _context5.t0 = _context5["catch"](0);
              console['error']('上报角色数据异常:>', _context5.t0);
            case 11:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 8]]);
      }));
      return function (_x7, _x8) {
        return _ref6.apply(this, arguments);
      };
    }(), this['pay'] = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(q, l) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              try {
                n(q, l);
              } catch (G) {
                console['error']('[支付拉起]异常:>', G);
              }
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return function (_x9, _x10) {
        return _ref7.apply(this, arguments);
      };
    }();
    var t = BASE_URL + '/market-multi-game-server/kuaiShouClient/antidirt';
    this['antidirt'] = /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(q, l) {
        var G, V;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              G = {
                'gameId': Q,
                'platformId': e,
                'contents': q
              };
              _context7.next = 4;
              return c(t, G);
            case 4:
              V = _context7.sent;
              l(V);
              _context7.next = 11;
              break;
            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](0);
              console['error']('[内容安全检测]异常:>', _context7.t0);
            case 11:
            case "end":
              return _context7.stop();
          }
        }, _callee7, null, [[0, 8]]);
      }));
      return function (_x11, _x12) {
        return _ref8.apply(this, arguments);
      };
    }(), this['createRewardedVideoAd'] = function (q, l) {
      var G = {
        'adUnitId': q['adUnitId']
      };
      q['multiton'] && (G['multiton'] = q['multiton'], G['multitonRewardMsg'] = q['multitonRewardMsg'], G['multitonRewardTimes'] = q['multitonRewardTimes']), q['progressTip'] && (G['progressTip'] = q['progressTip']), B = ks['createRewardedVideoAd'](G), B['onClose'](function (V) {
        V && V['isEnded'] && (v(AdType['REWARDED_VIDEO_AD'], X, AdActionType['FINISHED']), console['log']('正常播放结束，可以下发游戏奖励')), q['onClose'] && q['onClose'](V), B['destroy']();
      }), q['onError'] && B['onError'](function (V) {
        q['onError'] && q['onError'](V), B['destroy']();
      }), X = q['adUnitId'], l({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': null
      });
    }, this['showRewardedVideoAd'] = function () {
      B && (B['load'](), B['show']()['then'](function () {
        return v(AdType['REWARDED_VIDEO_AD'], X, AdActionType['SHOW']);
      })['catch'](function (q) {
        B['load']()['then'](function () {
          B['show']()['then'](function () {
            return v(AdType['REWARDED_VIDEO_AD'], X, AdActionType['SHOW']);
          });
        })['catch'](function (l) {
          return console['log']('激励视频\x20广告显示失败');
        });
      }));
    }, this['createGameRecorder'] = function (q, l) {
      p = ks['getGameRecorder'](), q['onStart'] && p['on']('start', q['onStart']), q['onResume'] && p['on']('resume', q['onResume']), q['onPause'] && p['on']('pause', q['onPause']), q['onStop'] && p['on']('stop', q['onStop']), q['onError'] && p['on']('error', q['onError']), q['onAbort'] && p['on']('abort', q['onAbort']), l({
        'code': CodeStatus['SUCCESS'],
        'message': '操作成功',
        'data': null
      });
    }, this['gameRecorderStart'] = function (q) {
      C(), p['start'](q);
    }, this['gameRecorderPause'] = function () {
      C(), p['pause']();
    }, this['gameRecorderResume'] = function () {
      C(), p['resume']();
    }, this['gameRecorderStop'] = function () {
      C(), console['log']('触发停止录屏'), p['stop']();
    }, this['publishVideo'] = function (q) {
      C(), p['publishVideo']({
        'video': q['videoID'],
        'callback': function callback(l) {
          if (l != null && l != undefined) {
            console['log']('分享录屏失败:\x20', l);
            return;
          }
          console['log']('分享录屏成功');
        }
      });
    }, this['shareAppMessage'] = function (q, l) {
      ks['shareAppMessage'](_extends({}, q, {
        'templateId': w,
        'success': function success() {
          l({
            'code': CodeStatus['SUCCESS'],
            'message': '操作成功',
            'data': null
          });
        },
        'fail': function fail(G) {
          console['log']('[分享失败]:>', G), l({
            'code': CodeStatus['FAIL'],
            'message': '操作失败',
            'data': null
          });
        }
      }));
    }, this['addShortcut'] = function (q) {
      ks['addShortcut']({
        'complete': q
      });
    }, this['checkShortcut'] = function (q) {
      ks['checkShortcut']({
        'complete': q
      });
    }, this['addCommonUse'] = function (q) {
      ks['addCommonUse']({
        'complete': q
      });
    }, this['checkCommonUse'] = function (q) {
      ks['checkCommonUse']({
        'complete': q
      });
    };
  }
  EyouClientKs['getIns'] = function getIns() {
    return !this['ins'] && (console['log']('初始化'), this['ins'] = new EyouClientKs()), this['ins'];
  };
  return EyouClientKs;
}();
exports["default"] = EyouClientKs;
var CodeStatus = function CodeStatus() {};
CodeStatus['SUCCESS'] = 0x0;
CodeStatus['FAIL'] = -0x1;
var AdType = function AdType() {};
AdType['REWARDED_VIDEO_AD'] = 0x1;
AdType['BANNER_AD'] = 0x2;
var AdActionType = function AdActionType() {};
AdActionType['SHOW'] = 0x1;
AdActionType['FINISHED'] = 0x2;
module.exports = exports["default"];

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcc2RrXFxFeW91Q2xpZW50S3MuanMiXSwibmFtZXMiOlsiX3JlZ2VuZXJhdG9yUnVudGltZSIsImV4cG9ydHMiLCJPcCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJkZXNjIiwidmFsdWUiLCIkU3ltYm9sIiwiU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJpdGVyYXRvciIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImRlZmluZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImVyciIsIndyYXAiLCJpbm5lckZuIiwib3V0ZXJGbiIsInNlbGYiLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiY3JlYXRlIiwiY29udGV4dCIsIkNvbnRleHQiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJmbiIsImFyZyIsInR5cGUiLCJjYWxsIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsInZhbHVlcyIsIkdwIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiZm9yRWFjaCIsIm1ldGhvZCIsIl9pbnZva2UiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVjb3JkIiwicmVzdWx0IiwiX19hd2FpdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwic3RhdGUiLCJFcnJvciIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwiZG9uZSIsIm1ldGhvZE5hbWUiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHQiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsImVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicHVzaCIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiaXNOYU4iLCJsZW5ndGgiLCJpIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXN5bmMiLCJQcm9taXNlIiwiaXRlciIsImtleXMiLCJ2YWwiLCJvYmplY3QiLCJyZXZlcnNlIiwicG9wIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwiX2NhdGNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsIl9uZXh0IiwiX3Rocm93IiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJCQVNFX1VSTCIsIkV5b3VDbGllbnRLcyIsImNvbnNvbGUiLCJRIiwiZSIsIkkiLCJZIiwiVSIsInMiLCJiIiwiaiIsIkUiLCJIIiwidyIsIlgiLCJCIiwibyIsIk1hcCIsInAiLCJtIiwicSIsImwiLCJrcyIsInN1Y2Nlc3MiLCJfcmVmIiwiRyIsImNvZGUiLCJPIiwiViIsIl9WJEkiLCJSIiwieiIsIm4iLCJUIiwicmVzIiwidSIsIkoiLCJjdXN0b21lclB1bGxQYXkiLCJNIiwieSIsIl9yZWYyIiwiX2NhbGxlZSIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJjIiwiQ29kZVN0YXR1cyIsInQwIiwiX3giLCJ4IiwiX3JlZjMiLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsIl94MiIsIl94MyIsIk4iLCJ2IiwiQyIsIkpTT04iLCJQIiwiX3JlZjQiLCJfY2FsbGVlMyIsIl9jYWxsZWUzJCIsIl9jb250ZXh0MyIsImZhaWwiLCJfeDQiLCJfeDUiLCJfcmVmNSIsIl9jYWxsZWU0IiwiX2NhbGxlZTQkIiwiX2NvbnRleHQ0IiwiX3g2IiwiZCIsIl9yZWY2IiwiX2NhbGxlZTUiLCJfY2FsbGVlNSQiLCJfY29udGV4dDUiLCJfeDciLCJfeDgiLCJfcmVmNyIsIl9jYWxsZWU2IiwiX2NhbGxlZTYkIiwiX2NvbnRleHQ2IiwiX3g5IiwiX3gxMCIsInQiLCJfcmVmOCIsIl9jYWxsZWU3IiwiX2NhbGxlZTckIiwiX2NvbnRleHQ3IiwiX3gxMSIsIl94MTIiLCJBZFR5cGUiLCJBZEFjdGlvblR5cGUiLCJjYWxsYmFjayIsIl9leHRlbmRzIiwiZ2V0SW5zIiwibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0FDQSxxSkFBQUEsbUJBQUEsWUFBQUEsb0JBQUEsV0FBQUMsT0FBQSxTQUFBQSxPQUFBLE9BQUFDLEVBQUEsR0FBQUMsTUFBQSxDQUFBQyxTQUFBLEVBQUFDLE1BQUEsR0FBQUgsRUFBQSxDQUFBSSxjQUFBLEVBQUFDLGNBQUEsR0FBQUosTUFBQSxDQUFBSSxjQUFBLGNBQUFDLEdBQUEsRUFBQUMsR0FBQSxFQUFBQyxJ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QSxDQUFDLEVBQUU7TUFBQ0UsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQUMsVUFBVSxFQUFDRjtNQUFDLENBQUMsQ0FBQztJQUFDLENBQUMsRUFBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBQyxVQUFBQSxDQUFDLEVBQUU7TUFBQ0UsRUFBRSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFBQyxVQUFVLEVBQUNGO01BQUMsQ0FBQyxDQUFDO0lBQUMsQ0FBQztFQUFDO0VBQUNuQixZQUFBLENBQU8sUUFBUSxJQUFmLFNBQUErRixPQUFBLEVBQWtCO0lBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBRzlGLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUMsSUFBSUQsWUFBWSxFQUFFLENBQUMsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0VBQUMsQ0FBQztFQUFBLE9BQUFBLFlBQUE7QUFBQTtBQUFBcEosT0FBQSxjQUFBb0osWUFBQTtBQUFBLElBQU80QyxVQUFVLFlBQUFBLFdBQUE7QUFBVkEsVUFBVSxDQUFTLFNBQVMsSUFBRSxHQUFHO0FBQWpDQSxVQUFVLENBQWdDLE1BQU0sSUFBRSxDQUFDLEdBQUc7QUFBQSxJQUFRK0MsTUFBTSxZQUFBQSxPQUFBO0FBQU5BLE1BQU0sQ0FBUyxtQkFBbUIsSUFBRSxHQUFHO0FBQXZDQSxNQUFNLENBQTBDLFdBQVcsSUFBRSxHQUFHO0FBQUEsSUFBUUMsWUFBWSxZQUFBQSxhQUFBO0FBQVpBLFlBQVksQ0FBUyxNQUFNLElBQUUsR0FBRztBQUFoQ0EsWUFBWSxDQUE2QixVQUFVLElBQUUsR0FBRztBQUFBSSxNQUFBLENBQUFwUCxPQUFBLEdBQUFBLE9BQUEiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJBU0VfVVJMPSdodHRwczovL2dhbWVzLmhuZGliZWkuY29tJztleHBvcnQgZGVmYXVsdCBjbGFzcyBFeW91Q2xpZW50S3N7Y29uc3RydWN0b3IoKXtjb25zb2xlWydsb2cnXSgnRXlvdUNsaWVudEtzXFx4MjDlrp7kvovlt7LliJvlu7onKTtsZXQgUT1udWxsLGU9MHg5LEk9bnVsbCxZPW51bGwsVT0nLTEnLHM9Jy0xJyxiPSc0JyxqPW51bGwsRT1udWxsLEg9bnVsbCx3PW51bGwsWD1udWxsLEI9bnVsbDtjb25zdCBvPW5ldyBNYXAoKTtsZXQgcD1udWxsO2NvbnN0IG09KCk9PntyZXR1cm4gbmV3IFByb21pc2UoKHEsbCk9Pntrc1snbG9naW4nXSh7J2ZvcmNlJzohIVtdLCdzdWNjZXNzJzooe2NvZGU6R30pPT57Rz8oY29uc29sZVsnbG9nJ10oJ2NvZGU6PicsRykscShHKSk6bChuZXcgRXJyb3IoJ+iOt+WPlmNvZGXlpLHotKUnKSk7fSwnZmFpbCc6bH0pO30pO30sTz1xPT57UT1xO2NvbnN0IGw9a3NbJ2dldFN5c3RlbUluZm9TeW5jJ10oKTtiPWxbJ3BsYXRmb3JtJ109PT0nYW5kcm9pZCc/JzQnOmxbJ3BsYXRmb3JtJ109PT0naW9zJz8nNSc6JzYnO2NvbnN0IEc9a3NbJ2dldExhdW5jaE9wdGlvbnNTeW5jJ10oKVsncXVlcnknXTtHJiYoST1HWydjaGFubmVsJ10sWT1HWydzdWJfY2hhbm5lbCddKTtjb25zdCBWPXsnMTA5MTMnOlsndW5pdF9pZCcsJ2NhbGxiYWNrJ119O2lmKFZbJ2hhc093blByb3BlcnR5J10oSSkpe2NvbnN0IFtSLHpdPVZbSV07VT1HW1JdLHM9R1t6XTt9ZWxzZSBJPScxMDkwNicsWT0nJytRK2UrSStiKycwJzt9LG49KHEsbCk9PntxWydnYW1lSWQnXT1RLChxWydwbGF0Zm9ybUlkJ109ZSxxWydzeXMnXT1iKSxUKHEpWyd0aGVuJ10oRz0+e2NvbnNvbGVbJ2xvZyddKCfmi4notbfmlK/ku5jov5Tlj4I6JyxyZXMpO2lmKEdbJ3BheVR5cGUnXT09MHhjKUdbJ2JhbGFuY2UnXT4weDA/dSgn5YWF5YC85o+Q56S6Jywn6LSm5oi35L2Z6aKdOicrR1snYmFsYW5jZSddKyflhYMsXFx4MjDov5jpnIDlhYXlgLw6JytHWyduZWVkUGF5J10rJ+WFgycsKCk9PkooRykpOkooRyxsKTtlbHNle2lmKEdbJ3BheVR5cGUnXT09MHgyfHxHWydwYXlUeXBlJ109PTB4YSljdXN0b21lclB1bGxQYXkoRyxsKTtlbHNle2lmKEdbJ3BheVR5cGUnXT09MHg0KWtzWydzaG93TW9kYWwnXSh7J3RpdGxlJzon5YWF5YC85o+Q56S6JywnY29udGVudCc6J+WNs+WwhuWxleekuuWFheWAvOS6jOe7tOeggSxcXHgyMOivt+aJq+aPj+S6jOe7tOeggeWujOaIkOaUr+S7mCcsJ3N1Y2Nlc3MnOmZ1bmN0aW9uKFYpe1ZbJ2NvbmZpcm0nXSYma3NbJ3ByZXZpZXdJbWFnZSddKHsndXJscyc6W0dbJ3BheVVybCddXX0pO319KTtlbHNlIHRocm93IG5ldyBFcnJvcign6Z2e5rOV5pSv5LuY57G75Z6LJyk7fX19KTt9LEo9KHEsbCk9PntpZihxWyduZWVkUGF5J109PTB4MCl7TShxLGwpO3JldHVybjt9bGV0IEc9e307R1snc3VjY2VzcyddPVI9PntNKHEsbCk7fSxHWydmYWlsJ109Uj0+e3UoJ+W/q+aJi+aUr+S7mOWksei0pScsUik7fTtjb25zdCBWPWtzWydnZXRTeXN0ZW1JbmZvU3luYyddKCk7R1snem9uZV9pZCddPScxJyxHWydvcyddPXFbJ29zJ10sR1snY3VycmVuY3lfdHlwZSddPSdDTlknLEdbJ2J1eV9xdWFudGl0eSddPXFbJ25lZWRQYXknXSpxWydyYXRlJ10sR1sndGhpcmRfcGFydHlfdHJhZGVfbm8nXT1xWydvcmRlcklkJ10sR1snc2lnbiddPXFbJ3NpZ24nXSxWWydwbGF0Zm9ybSddPT09J2lvcycmJihHWydwcm9kdWN0X3R5cGUnXT0weDEpLGtzWydyZXF1ZXN0R2FtZVBheW1lbnQnXShHKTt9LHk9QkFTRV9VUkwrJy9tYXJrZXQtbXVsdGktZ2FtZS1zZXJ2ZXIva3VhaVNob3VDbGllbnQvcHVsbFBheScsVD1hc3luYyBxPT57Y29uc3QgbD0weDM7bGV0IEc9MHgwLFY9IVtdLFI9IVtdO3doaWxlKEc8bCYmIVYpe3RyeXtjb25zdCB6PWF3YWl0IGMoeSxxKTtpZih6Wydjb2RlJ109PT1Db2RlU3RhdHVzWydTVUNDRVNTJ10pcmV0dXJuIHpbJ2RhdGEnXTtlbHNlIVImJih1KCfmlK/ku5jmi4notbflpLHotKUnLHpbJ21lc3NhZ2UnXSksUj0hIVtdKTt9Y2F0Y2goUyl7IVImJih1KCfmlK/ku5jmi4notbflpLHotKUnLCfnvZHnu5zotoXml7YnKSxSPSEhW10pO31HKys7fXRocm93IG5ldyBFcnJvcign5pSv5LuY5ouJ6LW35aSx6LSlJyk7fSx1PShxLGwsRyxWKT0+e2tzWydzaG93TW9kYWwnXSh7J3RpdGxlJzpxLCdjb250ZW50JzpsLCdzdWNjZXNzJzpmdW5jdGlvbihSKXtpZihSWydjb25maXJtJ10mJkcpRygpO2Vsc2UgUlsnY2FuY2VsJ10mJlYmJlYoKTt9fSk7fSx4PUJBU0VfVVJMKycvbWFya2V0LW11bHRpLWdhbWUtc2VydmVyL2t1YWlTaG91Q2xpZW50L2RlZHVjdCcsTT1hc3luYyhxLGwpPT57dHJ5e2NvbnN0IEc9eydvcmRlcklkJzpxWydvcmRlcklkJ10sJ2dhbWVJZCc6USwncGxhdGZvcm1JZCc6ZSwndXNlcklkJzpxWyd1c2VySWQnXX07bGV0IFY9YXdhaXQgYyh4LEcpO1ZbJ2NvZGUnXT09PUNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSYmbChWKTt9Y2F0Y2goUil7Y29uc29sZVsnZXJyb3InXSgnW+aJo+asvuWksei0pV3lvILluLg6PicsUik7fX0sTj1CQVNFX1VSTCsnL21hcmtldC1tdWx0aS1nYW1lLXNlcnZlci9rdWFpU2hvdUNsaWVudC9hZEFjdGlvbicsdj0ocSxsLEcpPT57bGV0IFY9eydnYW1lSWQnOlEsJ3BsYXRmb3JtSWQnOmUsJ2NoYW5uZWxJZCc6SSwnc3ViQ2hhbm5lbElkJzpZLCdhaWQnOlUsJ3RyYWNlSWQnOnMsJ3N5cyc6YiwndXNlcklkJzpFLCdhZFR5cGUnOnEsJ2FkVW5pdElkJzpsLCdhZEFjdGlvblR5cGUnOkd9O2MoTixWKVsnY2F0Y2gnXShSPT57Y29uc29sZVsnbG9nJ10oJ+WPkemAgeW5v+WRiuihjOS4uuWksei0pTo+JyxSKTt9KTt9LEM9KCk9PntpZighcCl0aHJvdyBuZXcgRXJyb3IoJ+acquWIm+W7uuW9leWxj+euoeeQhuWZqCcpO30sYz0ocSxsKT0+e3JldHVybiBuZXcgUHJvbWlzZSgoRyxWKT0+e2tzWydyZXF1ZXN0J10oeyd1cmwnOnEsJ21ldGhvZCc6J1BPU1QnLCdoZWFkZXInOnsnQ29udGVudC1UeXBlJzonYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J30sJ2RhdGEnOkpTT05bJ3N0cmluZ2lmeSddKGwpLCdmYWlsJzpWLCdzdWNjZXNzJzpmdW5jdGlvbihSKXtHKFJbJ2RhdGEnXSk7fSwnY29tcGxldGUnOmZ1bmN0aW9uKFIpe2NvbnNvbGVbJ2xvZyddKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS3or7fmsYJcXHgyMEJFR0lOLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKSxjb25zb2xlWydsb2cnXSgnVXJsOj4nLHEpLGNvbnNvbGVbJ2xvZyddKCfor7fmsYLlj4LmlbA6PicsbCk7Y29uc3Qgej1SJiYoUlsnZGF0YSddfHxSWydlcnJNc2cnXSk/UlsnZGF0YSddfHxSWydlcnJNc2cnXTonTm9cXHgyMHJlc3BvbnNlXFx4MjBkYXRhJztjb25zb2xlWydsb2cnXSgn5ZON5bqUOj4nLHopLGNvbnNvbGVbJ2xvZyddKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS3or7fmsYJcXHgyMEVORC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7fX0pO30pO30sUD1CQVNFX1VSTCsnL21hcmtldC1tdWx0aS1nYW1lLXNlcnZlci9rdWFpU2hvdUNsaWVudC9pbml0R2FtZSc7dGhpc1snaW5pdCddPWFzeW5jKHEsbCk9Pnt0cnl7a3NbJ29uU2hhcmVBcHBNZXNzYWdlJ10oUj0+e3JldHVybnsndGVtcGxhdGVJZCc6dywncXVlcnknOicnLCdzdWNjZXNzJzooKT0+e2NvbnNvbGVbJ2xvZyddKCfliIbkuqvmiJDlip8nKTt9LCdmYWlsJzp6PT57Y29uc29sZVsnbG9nJ10oJ+WIhuS6q+Wksei0pScseik7fX07fSksaj1hd2FpdCBtKCksTyhxKTtjb25zdCBHPXsnY29kZSc6aiwnZ2FtZUlkJzpRLCdwbGF0Zm9ybUlkJzplLCdjaGFubmVsSWQnOkksJ3N1YkNoYW5uZWxJZCc6WSwnYWlkJzpVLCd0cmFjZUlkJzpzLCdzeXMnOmJ9LFY9YXdhaXQgYyhQLEcpO1ZbJ2NvZGUnXT09PUNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSYmKEU9VlsnZGF0YSddWyd1c2VySWQnXSxIPVZbJ2RhdGEnXVsndW5pb25JZCddLHc9VlsnZGF0YSddWydzaGFyZVRlbXBsYXRlSWQnXSxWWydkYXRhJ109bnVsbCksbChqKTt9Y2F0Y2goUil7Y29uc29sZVsnZXJyb3InXSgnW+WIneWni+WMlua4uOaIj13lvILluLg6PicsUik7fX0sdGhpc1snbG9naW4nXT1hc3luYyBxPT57cSh7J2NvZGUnOkNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSwnbWVzc2FnZSc6J+aTjeS9nOaIkOWKnycsJ2RhdGEnOnsnY29kZSc6an19KTt9O2NvbnN0IGQ9QkFTRV9VUkwrJy9tYXJrZXQtbXVsdGktZ2FtZS1zZXJ2ZXIva3VhaVNob3VDbGllbnQvdXBsb2FkUm9sZUluZm8nO3RoaXNbJ3VwbG9hZFJvbGVJbmZvJ109YXN5bmMocSxsKT0+e3RyeXtxWydnYW1lSWQnXT1RLHFbJ3BsYXRmb3JtSWQnXT1lO2NvbnN0IEc9YXdhaXQgYyhkLHEpO2woRyk7fWNhdGNoKFYpe2NvbnNvbGVbJ2Vycm9yJ10oJ+S4iuaKpeinkuiJsuaVsOaNruW8guW4uDo+JyxWKTt9fSx0aGlzWydwYXknXT1hc3luYyhxLGwpPT57dHJ5e24ocSxsKTt9Y2F0Y2goRyl7Y29uc29sZVsnZXJyb3InXSgnW+aUr+S7mOaLiei1t13lvILluLg6PicsRyk7fX07Y29uc3QgdD1CQVNFX1VSTCsnL21hcmtldC1tdWx0aS1nYW1lLXNlcnZlci9rdWFpU2hvdUNsaWVudC9hbnRpZGlydCc7dGhpc1snYW50aWRpcnQnXT1hc3luYyhxLGwpPT57dHJ5e2xldCBHPXsnZ2FtZUlkJzpRLCdwbGF0Zm9ybUlkJzplLCdjb250ZW50cyc6cX07Y29uc3QgVj1hd2FpdCBjKHQsRyk7bChWKTt9Y2F0Y2goUil7Y29uc29sZVsnZXJyb3InXSgnW+WGheWuueWuieWFqOajgOa1i13lvILluLg6PicsUik7fX0sdGhpc1snY3JlYXRlUmV3YXJkZWRWaWRlb0FkJ109KHEsbCk9PntsZXQgRz17J2FkVW5pdElkJzpxWydhZFVuaXRJZCddfTtxWydtdWx0aXRvbiddJiYoR1snbXVsdGl0b24nXT1xWydtdWx0aXRvbiddLEdbJ211bHRpdG9uUmV3YXJkTXNnJ109cVsnbXVsdGl0b25SZXdhcmRNc2cnXSxHWydtdWx0aXRvblJld2FyZFRpbWVzJ109cVsnbXVsdGl0b25SZXdhcmRUaW1lcyddKSxxWydwcm9ncmVzc1RpcCddJiYoR1sncHJvZ3Jlc3NUaXAnXT1xWydwcm9ncmVzc1RpcCddKSxCPWtzWydjcmVhdGVSZXdhcmRlZFZpZGVvQWQnXShHKSxCWydvbkNsb3NlJ10oVj0+e1YmJlZbJ2lzRW5kZWQnXSYmKHYoQWRUeXBlWydSRVdBUkRFRF9WSURFT19BRCddLFgsQWRBY3Rpb25UeXBlWydGSU5JU0hFRCddKSxjb25zb2xlWydsb2cnXSgn5q2j5bi45pKt5pS+57uT5p2f77yM5Y+v5Lul5LiL5Y+R5ri45oiP5aWW5YqxJykpLHFbJ29uQ2xvc2UnXSYmcVsnb25DbG9zZSddKFYpLEJbJ2Rlc3Ryb3knXSgpO30pLHFbJ29uRXJyb3InXSYmQlsnb25FcnJvciddKFY9PntxWydvbkVycm9yJ10mJnFbJ29uRXJyb3InXShWKSxCWydkZXN0cm95J10oKTt9KSxYPXFbJ2FkVW5pdElkJ10sbCh7J2NvZGUnOkNvZGVTdGF0dXNbJ1NVQ0NFU1MnXSwnbWVzc2FnZSc6J+aTjeS9nOaIkOWKnycsJ2RhdGEnOm51bGx9KTt9LHRoaXNbJ3Nob3dSZXdhcmRlZFZpZGVvQWQnXT0oKT0+e0ImJihCWydsb2FkJ10oKSxCWydzaG93J10oKVsndGhlbiddKCgpPT52KEFkVHlwZVsnUkVXQVJERURfVklERU9fQUQnXSxYLEFkQWN0aW9uVHlwZVsnU0hPVyddKSlbJ2NhdGNoJ10ocT0+e0JbJ2xvYWQnXSgpWyd0aGVuJ10oKCk9PntCWydzaG93J10oKVsndGhlbiddKCgpPT52KEFkVHlwZVsnUkVXQVJERURfVklERU9fQUQnXSxYLEFkQWN0aW9uVHlwZVsnU0hPVyddKSk7fSlbJ2NhdGNoJ10obD0+Y29uc29sZVsnbG9nJ10oJ+a/gOWKseinhumikVxceDIw5bm/5ZGK5pi+56S65aSx6LSlJykpO30pKTt9LHRoaXNbJ2NyZWF0ZUdhbWVSZWNvcmRlciddPShxLGwpPT57cD1rc1snZ2V0R2FtZVJlY29yZGVyJ10oKSxxWydvblN0YXJ0J10mJnBbJ29uJ10oJ3N0YXJ0JyxxWydvblN0YXJ0J10pLHFbJ29uUmVzdW1lJ10mJnBbJ29uJ10oJ3Jlc3VtZScscVsnb25SZXN1bWUnXSkscVsnb25QYXVzZSddJiZwWydvbiddKCdwYXVzZScscVsnb25QYXVzZSddKSxxWydvblN0b3AnXSYmcFsnb24nXSgnc3RvcCcscVsnb25TdG9wJ10pLHFbJ29uRXJyb3InXSYmcFsnb24nXSgnZXJyb3InLHFbJ29uRXJyb3InXSkscVsnb25BYm9ydCddJiZwWydvbiddKCdhYm9ydCcscVsnb25BYm9ydCddKSxsKHsnY29kZSc6Q29kZVN0YXR1c1snU1VDQ0VTUyddLCdtZXNzYWdlJzon5pON5L2c5oiQ5YqfJywnZGF0YSc6bnVsbH0pO30sdGhpc1snZ2FtZVJlY29yZGVyU3RhcnQnXT1xPT57QygpLHBbJ3N0YXJ0J10ocSk7fSx0aGlzWydnYW1lUmVjb3JkZXJQYXVzZSddPSgpPT57QygpLHBbJ3BhdXNlJ10oKTt9LHRoaXNbJ2dhbWVSZWNvcmRlclJlc3VtZSddPSgpPT57QygpLHBbJ3Jlc3VtZSddKCk7fSx0aGlzWydnYW1lUmVjb3JkZXJTdG9wJ109KCk9PntDKCksY29uc29sZVsnbG9nJ10oJ+inpuWPkeWBnOatouW9leWxjycpLHBbJ3N0b3AnXSgpO30sdGhpc1sncHVibGlzaFZpZGVvJ109cT0+e0MoKSxwWydwdWJsaXNoVmlkZW8nXSh7J3ZpZGVvJzpxWyd2aWRlb0lEJ10sJ2NhbGxiYWNrJzpsPT57aWYobCE9bnVsbCYmbCE9dW5kZWZpbmVkKXtjb25zb2xlWydsb2cnXSgn5YiG5Lqr5b2V5bGP5aSx6LSlOlxceDIwJyxsKTtyZXR1cm47fWNvbnNvbGVbJ2xvZyddKCfliIbkuqvlvZXlsY/miJDlip8nKTt9fSk7fSx0aGlzWydzaGFyZUFwcE1lc3NhZ2UnXT0ocSxsKT0+e2tzWydzaGFyZUFwcE1lc3NhZ2UnXSh7Li4ucSwndGVtcGxhdGVJZCc6dywnc3VjY2Vzcyc6KCk9PntsKHsnY29kZSc6Q29kZVN0YXR1c1snU1VDQ0VTUyddLCdtZXNzYWdlJzon5pON5L2c5oiQ5YqfJywnZGF0YSc6bnVsbH0pO30sJ2ZhaWwnOkc9Pntjb25zb2xlWydsb2cnXSgnW+WIhuS6q+Wksei0pV06PicsRyksbCh7J2NvZGUnOkNvZGVTdGF0dXNbJ0ZBSUwnXSwnbWVzc2FnZSc6J+aTjeS9nOWksei0pScsJ2RhdGEnOm51bGx9KTt9fSk7fSx0aGlzWydhZGRTaG9ydGN1dCddPXE9Pntrc1snYWRkU2hvcnRjdXQnXSh7J2NvbXBsZXRlJzpxfSk7fSx0aGlzWydjaGVja1Nob3J0Y3V0J109cT0+e2tzWydjaGVja1Nob3J0Y3V0J10oeydjb21wbGV0ZSc6cX0pO30sdGhpc1snYWRkQ29tbW9uVXNlJ109cT0+e2tzWydhZGRDb21tb25Vc2UnXSh7J2NvbXBsZXRlJzpxfSk7fSx0aGlzWydjaGVja0NvbW1vblVzZSddPXE9Pntrc1snY2hlY2tDb21tb25Vc2UnXSh7J2NvbXBsZXRlJzpxfSk7fTt9c3RhdGljWydnZXRJbnMnXSgpe3JldHVybiF0aGlzWydpbnMnXSYmKGNvbnNvbGVbJ2xvZyddKCfliJ3lp4vljJYnKSx0aGlzWydpbnMnXT1uZXcgRXlvdUNsaWVudEtzKCkpLHRoaXNbJ2lucyddO319Y2xhc3MgQ29kZVN0YXR1c3tzdGF0aWMgWydTVUNDRVNTJ109MHgwO3N0YXRpYyBbJ0ZBSUwnXT0tMHgxO31jbGFzcyBBZFR5cGV7c3RhdGljIFsnUkVXQVJERURfVklERU9fQUQnXT0weDE7c3RhdGljIFsnQkFOTkVSX0FEJ109MHgyO31jbGFzcyBBZEFjdGlvblR5cGV7c3RhdGljIFsnU0hPVyddPTB4MTtzdGF0aWMgWydGSU5JU0hFRCddPTB4Mjt9Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/Scripts/Core/AdsMgr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4d97apM83VPAZkyD9a+RThG', 'AdsMgr');
// Scripts/Core/AdsMgr.js

"use strict";

var AdsParam = require("AdsParam");
var eyouClientTiktok = require("EyouClientTiktok");
var eyouClientKs = require("EyouClientKs");
var eyouClient = require('eyouClient');
var AdsMgr = cc.Class({
  statics: {
    //微信 wx
    //头条 tt
    //百度 baidu

    //对应的平台的  bannerId  采用加后缀的方式
    bannerId_baidu: "6191742",
    bannerId_wx: "adunit-42bcaae6cafaa7c6",
    bannerId_tt: "6152042",
    //百度广告id  激励视频
    bdVideoId_1: "6191756",
    bdVideoId_2: "6191755",
    bdVideoId_3: "6191754",
    bdVideoId_4: "6191753",
    bdVideoId_5: "6191752",
    bdVideoId_6: "6191751",
    bdVideoId_7: "6191749",
    bdVideoId_8: "6191748",
    bdVideoId_9: "6191747",
    bdVideoId_10: "6191744",
    //微信广告id  激励视频
    wxVideoId_1: "",
    wxVideoId_2: "",
    wxVideoId_3: "",
    wxVideoId_4: "",
    wxVideoId_5: "",
    wxVideoId_6: "",
    wxVideoId_7: "",
    wxVideoId_8: "",
    wxVideoId_9: "",
    wxVideoId_10: "",
    allScreen: false,
    //首先确定使用的平台
    Init: function Init() {
      this.allScreen = false;
    },
    //获取广告点ID
    getBannerAdId: function getBannerAdId() {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        return this.bannerId_wx;
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        return this.bannerId_baidu;
      } else if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        return this.bannerId_tt;
      }
      return null;
    },
    //获取广告点ID  这里配置 视频奖励广告 Id 由于会有多个广告点  根据后台设置来顶
    getVideoAdId: function getVideoAdId(adName) {
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      var adId;
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        switch (adName) {
          case AdsParam.PointA:
            adId = this.wxVideoId_1;
            break;
          case AdsParam.PointB:
            adId = this.wxVideoId_2;
            break;
          case AdsParam.PointC:
            adId = this.wxVideoId_3;
            break;
          case AdsParam.PointD:
            adId = this.wxVideoId_4;
            break;
          case AdsParam.PointE:
            adId = this.wxVideoId_5;
            break;
          case AdsParam.PointF:
            adId = this.wxVideoId_6;
            break;
          case AdsParam.PointG:
            adId = this.wxVideoId_7;
            break;
          case AdsParam.PointH:
            adId = this.wxVideoId_8;
            break;
          case AdsParam.PointI:
            adId = this.wxVideoId_9;
            break;
          case AdsParam.PointJ:
            adId = this.wxVideoId_10;
            break;
        }
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        switch (adName) {
          case AdsParam.PointA:
            adId = this.bdVideoId_1;
            break;
          case AdsParam.PointB:
            adId = this.bdVideoId_2;
            break;
          case AdsParam.PointC:
            adId = this.bdVideoId_3;
            break;
          case AdsParam.PointD:
            adId = this.bdVideoId_4;
            break;
          case AdsParam.PointE:
            adId = this.bdVideoId_5;
            break;
          case AdsParam.PointF:
            adId = this.bdVideoId_6;
            break;
          case AdsParam.PointG:
            adId = this.bdVideoId_7;
            break;
          case AdsParam.PointH:
            adId = this.bdVideoId_8;
            break;
          case AdsParam.PointI:
            adId = this.bdVideoId_9;
            break;
          case AdsParam.PointJ:
            adId = this.bdVideoId_10;
            break;
        }
      }
      return adId;
    },
    ShowBannerAds: function ShowBannerAds() {
      var self = this;
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (this.bannerAdShowNum == null) this.bannerAdShowNum = 0;
      this.bannerAdShowNum++;
      if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        if (this.bannerAdCtrl != null && this.bannerAdShowNum % 5 != 0) {
          return;
        }
        this.bannerAdShowNum = 0;
        if (this.bannerAdCtrl != null) this.bannerAdCtrl.destroy();
        var WXAD = {};
        WXAD.W = wx.getSystemInfoSync().windowWidth;
        WXAD.H = wx.getSystemInfoSync().windowHeight;
        var adWidth = 0;
        if (this.allScreen) adWidth = WXAD.W;else adWidth = 300;
        this.bannerAdCtrl = wx.createBannerAd({
          adUnitId: this.getBannerAdId(),
          style: {
            left: 0,
            top: 0 /*/(WXAD.H/10)*8*/,
            width: adWidth
          }
        });
        this.bannerAdCtrl.onResize(function (res) {
          console.log("重置广告宽度 " + WXAD.H + " , " + self.bannerAdCtrl.style.realHeight);
          self.bannerAdCtrl.style.top = WXAD.H - self.bannerAdCtrl.style.realHeight;
          self.bannerAdCtrl.style.left = (WXAD.W - self.bannerAdCtrl.style.realWidth) / 2;
          self.bannerAdCtrl.show();
        });
        this.bannerAdCtrl.onError(function (err) {
          console.log(err);
        });
        console.log("显示广告");
      } else if (cc.sys.platform === cc.sys.BAIDU_GAME) {
        if (swan.getSystemInfoSync().platform == 'ios')
          //目前 ios 不支持视频广告
          {
            return;
          }
        if (this.bannerAdCtrl != null) this.bannerAdCtrl.destroy();
        var _WXAD = {};
        _WXAD.W = swan.getSystemInfoSync().windowWidth;
        _WXAD.H = swan.getSystemInfoSync().windowHeight;
        console.log("百度的 bannerId = " + this.getBannerAdId());
        this.bannerAdCtrl = swan.createBannerAd({
          adUnitId: this.getBannerAdId(),
          appSid: 'c0fb407f',
          style: {
            left: 0,
            top: 0,
            width: 321
          }
        });
        if (this.allScreen) self.bannerAdCtrl.style.width = _WXAD.H;else self.bannerAdCtrl.style.width = 300;
        this.bannerAdCtrl.onResize(function (res) {
          console.log("重置广告宽度 ");
          self.bannerAdCtrl.style.top = _WXAD.H - res.height;
          self.bannerAdCtrl.style.left = (_WXAD.W - res.width) / 2;
          self.bannerAdCtrl.show();
        });
        this.bannerAdCtrl.onLoad(function () {
          console.log(' banner 加载完成');
          self.bannerAdCtrl.show();
        });
        this.bannerAdCtrl.onError(function (err) {
          console.log(err);
        });
        console.log("显示广告");
      }
    },
    HideBannerAd: function HideBannerAd() {
      if (this.bannerAdCtrl != null) this.bannerAdCtrl.hide();
    },
    RecoverShowBanner: function RecoverShowBanner() {
      if (this.bannerAdCtrl != null) this.bannerAdCtrl.show();else this.ShowBannerAds();
    },
    DestroyBanner: function DestroyBanner() {
      if (this.bannerAdCtrl != null) this.bannerAdCtrl.destroy();
    },
    //cb 回调参数 0 播放完成，1 不放未完成 ，-1 视频加载出错
    // ShowVideoAds:function(adName,cb)
    // {
    //     this.cb = cb
    //     if(cc.sys.platform === cc.sys.WECHAT_GAME)
    //     {
    //         let videoAd = wx.createRewardedVideoAd({
    //             adUnitId: this.getVideoAdId(adName)
    //         })
    //
    //         videoAd.load()
    //         .then(() => videoAd.show())
    //         .catch(err => console.log(err.errMsg))
    //
    //         videoAd.onError(err => {
    //             console.log("广告加载出错 " + err.errMsg)
    //             this.cb(-1);
    //         });
    //
    //         videoAd.onLoad(()=>{ console.log("加载事件回调") });
    //
    //         videoAd.onClose(res =>{
    //             console.log("是否观看完整了 " + res.isEnded)
    //             this.cb(res.isEnded?0:1);
    //             videoAd.offLoad();
    //             videoAd.offError();
    //             videoAd.offClose();
    //
    //         });
    //
    //     }
    //     else if(cc.sys.platform === cc.sys.BAIDU_GAME)
    //     {
    //         console.log("百度的视频广告  " + this.getVideoAdId(adName));
    //
    //         let videoAd = swan.createRewardedVideoAd({
    //             adUnitId: this.getVideoAdId(adName),
    //             appSid: 'c0fb407f',
    //         })
    //
    //         videoAd.load()
    //         .then(() => videoAd.show())
    //         .catch(err => console.log(err.errMsg))
    //
    //         videoAd.onError(err => {
    //             console.log("广告加载出错 " + err.errMsg)
    //             this.cb(-1);
    //         });
    //
    //         videoAd.onLoad(()=>{ console.log("加载事件回调") });
    //
    //         videoAd.onClose(res =>{
    //             console.log("是否观看完整了 " + res.isEnded)
    //             this.cb(res.isEnded?0:1);
    //             videoAd.offLoad();
    //             videoAd.offError();
    //             videoAd.offClose();
    //
    //         });
    //
    //     }
    //     else
    //     {
    //         this.cb(0);
    //     }
    // },

    //cb 回调参数 0 播放完成，1 不放未完成 ，-1 视频加载出错
    ShowVideoAds: function ShowVideoAds(adName, cb) {
      var _this = this;
      this.cb = cb;
      var isKuaiShou = false;
      if (typeof ks !== 'undefined') {
        //运行在快手平台
        isKuaiShou = true;
      }
      if (cc.sys.platform === cc.sys.BYTEDANCE_GAME) {
        var rewardedVideoAdInfo = {
          adUnitId: '1135h0gc8ciah182j2',
          onClose: function onClose(onCloseRes) {
            _this.cb(onCloseRes && onCloseRes.isEnded ? 0 : 1);
          },
          onError: function onError(error) {
            return _this.cb(-1);
          }
        };
        eyouClientTiktok.getIns().createRewardedVideoAd(rewardedVideoAdInfo, function (createRewardedVideoAdRes) {
          if (createRewardedVideoAdRes.code === 0) {
            eyouClientTiktok.getIns().showRewardedVideoAd();
          } else {
            _this.cb(-1);
          }
        });
      } else if (cc.sys.platform === cc.sys.WECHAT_GAME && !isKuaiShou) {
        var _rewardedVideoAdInfo = {
          adUnitId: 'adunit-3cf372fd7487fd87',
          onClose: function onClose(onCloseRes) {
            _this.cb(onCloseRes && onCloseRes.code === 0 ? 0 : 1);
          }
        };
        eyouClient.getIns().createRewardedVideoAd(_rewardedVideoAdInfo, function (createRewardedVideoAdRes) {
          if (createRewardedVideoAdRes.code === 0) {
            eyouClient.getIns().showRewardedVideoAd();
          }
        });
      } else if (isKuaiShou) {
        console.log("快手广告");
        var _rewardedVideoAdInfo2 = {
          adUnitId: '2300009525_01',
          onClose: function onClose(onCloseRes) {
            _this.cb(onCloseRes && onCloseRes.isEnded ? 0 : 1);
          },
          onError: function onError(error) {
            return _this.cb(-1);
          }
        };
        eyouClientKs.getIns().createRewardedVideoAd(_rewardedVideoAdInfo2, function (createRewardedVideoAdRes) {
          console.log("创建激励视频组件回调:>", createRewardedVideoAdRes);
          if (createRewardedVideoAdRes.code === 0) {
            eyouClientKs.getIns().showRewardedVideoAd();
          } else {
            _this.cb(-1);
          }
        });
      }
    }
  }
});
module.exports = AdsMgr;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcU2NyaXB0c1xcQ29yZVxcQWRzTWdyLmpzIl0sIm5hbWVzIjpbIkFkc1BhcmFtIiwicmVxdWlyZSIsImV5b3VDbGllbnRUaWt0b2siLCJleW91Q2xpZW50S3MiLCJleW91Q2xpZW50IiwiQWRzTWdyIiwiY2MiLCJDbGFzcyIsInN0YXRpY3MiLCJiYW5uZXJJZF9iYWlkdSIsImJhbm5lcklkX3d4IiwiYmFubmVySWRfdHQiLCJiZFZpZGVvSWRfMSIsImJkVmlkZW9JZF8yIiwiYmRWaWRlb0lkXzMiLCJiZFZpZGVvSWRfNCIsImJkVmlkZW9JZF81IiwiYmRWaWRlb0lkXzYiLCJiZFZpZGVvSWRfNyIsImJkVmlkZW9JZF84IiwiYmRWaWRlb0lkXzkiLCJiZFZpZGVvSWRfMTAiLCJ3eFZpZGVvSWRfMSIsInd4VmlkZW9JZF8yIiwid3hWaWRlb0lkXzMiLCJ3eFZpZGVvSWRfNCIsInd4VmlkZW9JZF81Iiwid3hWaWRlb0lkXzYiLCJ3eFZpZGVvSWRfNyIsInd4VmlkZW9JZF84Iiwid3hWaWRlb0lkXzkiLCJ3eFZpZGVvSWRfMTAiLCJhbGxTY3JlZW4iLCJJbml0IiwiZ2V0QmFubmVyQWRJZCIsImlzS3VhaVNob3UiLCJrcyIsInN5cyIsInBsYXRmb3JtIiwiV0VDSEFUX0dBTUUiLCJCQUlEVV9HQU1FIiwiQllURURBTkNFX0dBTUUiLCJnZXRWaWRlb0FkSWQiLCJhZE5hbWUiLCJhZElkIiwiUG9pbnRBIiwiUG9pbnRCIiwiUG9pbnRDIiwiUG9pbnREIiwiUG9pbnRFIiwiUG9pbnRGIiwiUG9pbnRHIiwiUG9pbnRIIiwiUG9pbnRJIiwiUG9pbnRKIiwiU2hvd0Jhbm5lckFkcyIsInNlbGYiLCJiYW5uZXJBZFNob3dOdW0iLCJiYW5uZXJBZEN0cmwiLCJkZXN0cm95IiwiV1hBRCIsIlciLCJ3eCIsImdldFN5c3RlbUluZm9TeW5jIiwid2luZG93V2lkdGgiLCJIIiwid2luZG93SGVpZ2h0IiwiYWRXaWR0aCIsImNyZWF0ZUJhbm5lckFkIiwiYWRVbml0SWQiLCJzdHlsZSIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsIm9uUmVzaXplIiwicmVzIiwiY29uc29sZSIsImxvZyIsInJlYWxIZWlnaHQiLCJyZWFsV2lkdGgiLCJzaG93Iiwib25FcnJvciIsImVyciIsInN3YW4iLCJhcHBTaWQiLCJoZWlnaHQiLCJvbkxvYWQiLCJIaWRlQmFubmVyQWQiLCJoaWRlIiwiUmVjb3ZlclNob3dCYW5uZXIiLCJEZXN0cm95QmFubmVyIiwiU2hvd1ZpZGVvQWRzIiwiY2IiLCJfdGhpcyIsInJld2FyZGVkVmlkZW9BZEluZm8iLCJvbkNsb3NlIiwib25DbG9zZVJlcyIsImlzRW5kZWQiLCJlcnJvciIsImdldElucyIsImNyZWF0ZVJld2FyZGVkVmlkZW9BZCIsImNyZWF0ZVJld2FyZGVkVmlkZW9BZFJlcyIsImNvZGUiLCJzaG93UmV3YXJkZWRWaWRlb0FkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbEMsSUFBSUMsZ0JBQWdCLEdBQUdELE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztBQUNsRCxJQUFJRSxZQUFZLEdBQUdGLE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDMUMsSUFBSUcsVUFBVSxHQUFHSCxPQUFPLENBQUMsWUFBWSxDQUFDO0FBQ3RDLElBQUlJLE1BQU0sR0FBR0MsRUFBRSxDQUFDQyxLQUFLLENBQUM7RUFDbEJDLE9BQU8sRUFBQztJQUNQO0lBQ0c7SUFDQTs7SUFFQTtJQUNBQyxjQUFjLEVBQUMsU0FBUztJQUN4QkMsV0FBVyxFQUFDLHlCQUF5QjtJQUNyQ0MsV0FBVyxFQUFDLFNBQVM7SUFFckI7SUFDQUMsV0FBVyxFQUFDLFNBQVM7SUFDckJDLFdBQVcsRUFBQyxTQUFTO0lBQ3JCQyxXQUFXLEVBQUMsU0FBUztJQUNyQkMsV0FBVyxFQUFDLFNBQVM7SUFDckJDLFdBQVcsRUFBQyxTQUFTO0lBQ3JCQyxXQUFXLEVBQUMsU0FBUztJQUNy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bEQsQ0FBQztVQUNEaEIsT0FBTyxFQUFFLFNBQUFBLFFBQUFpQixLQUFLO1lBQUEsT0FBSUwsS0FBSSxDQUFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFBQTtRQUM5QixDQUFDO1FBQ0R6RixZQUFZLENBQUNnRyxNQUFNLEVBQUUsQ0FBQ0MscUJBQXFCLENBQUNOLHFCQUFtQixFQUFFLFVBQUFPLHdCQUF3QixFQUFJO1VBQzVGekIsT0FBTyxDQUFDQyxHQUFHLENBQUMsY0FBYyxFQUFFd0Isd0JBQXdCLENBQUM7VUFDckQsSUFBSUEsd0JBQXdCLENBQUNDLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDeENuRyxZQUFZLENBQUNnRyxNQUFNLEVBQUUsQ0FBQ0ksbUJBQW1CLEVBQUU7VUFDNUMsQ0FBQyxNQUFNO1lBQ05WLEtBQUksQ0FBQ0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQ1o7UUFDRCxDQUFDLENBQUM7TUFDSDtJQUNEO0VBQ0U7QUFDSixDQUFDLENBQUM7QUFDRlksTUFBTSxDQUFDQyxPQUFPLEdBQUdwRyxNQUFNIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQWRzUGFyYW0gPSByZXF1aXJlKFwiQWRzUGFyYW1cIik7XHJcbnZhciBleW91Q2xpZW50VGlrdG9rID0gcmVxdWlyZShcIkV5b3VDbGllbnRUaWt0b2tcIik7XHJcbnZhciBleW91Q2xpZW50S3MgPSByZXF1aXJlKFwiRXlvdUNsaWVudEtzXCIpO1xyXG52YXIgZXlvdUNsaWVudCA9IHJlcXVpcmUoJ2V5b3VDbGllbnQnKTtcclxudmFyIEFkc01nciA9IGNjLkNsYXNzKHtcclxuICAgIHN0YXRpY3M6e1xyXG4gICAgXHQvL+W+ruS/oSB3eFxyXG4gICAgICAgIC8v5aS05p2hIHR0XHJcbiAgICAgICAgLy/nmb7luqYgYmFpZHVcclxuXHJcbiAgICAgICAgLy/lr7nlupTnmoTlubPlj7DnmoQgIGJhbm5lcklkICDph4fnlKjliqDlkI7nvIDnmoTmlrnlvI9cclxuICAgICAgICBiYW5uZXJJZF9iYWlkdTpcIjYxOTE3NDJcIixcclxuICAgICAgICBiYW5uZXJJZF93eDpcImFkdW5pdC00MmJjYWFlNmNhZmFhN2M2XCIsXHJcbiAgICAgICAgYmFubmVySWRfdHQ6XCI2MTUyMDQyXCIsXHJcblxyXG4gICAgICAgIC8v55m+5bqm5bm/5ZGKaWQgIOa/gOWKseinhumikVxyXG4gICAgICAgIGJkVmlkZW9JZF8xOlwiNjE5MTc1NlwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF8yOlwiNjE5MTc1NVwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF8zOlwiNjE5MTc1NFwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF80OlwiNjE5MTc1M1wiLFxyXG4gICAgICAgIGJkVmlkZW9JZF81OlwiNjE5MTc1MlwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF82OlwiNjE5MTc1MVwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF83OlwiNjE5MTc0OVwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF84OlwiNjE5MTc0OFwiLFxyXG4gICAgICAgIGJkVmlkZW9JZF85OlwiNjE5MTc0N1wiLFxyXG4gICAgICAgIGJkVmlkZW9JZF8xMDpcIjYxOTE3NDRcIixcclxuICAgICAgICAvL+W+ruS/oeW5v+WRimlkICDmv4DlirHop4bpopFcclxuICAgICAgICB3eFZpZGVvSWRfMTpcIlwiLFxyXG4gICAgICAgIHd4VmlkZW9JZF8yOlwiXCIsXHJcbiAgICAgICAgd3hWaWRlb0lkXzM6XCJcIixcclxuICAgICAgICB3eFZpZGVvSWRfNDpcIlwiLFxyXG4gICAgICAgIHd4VmlkZW9JZF81OlwiXCIsXHJcbiAgICAgICAgd3hWaWRlb0lkXzY6XCJcIixcclxuICAgICAgICB3eFZpZGVvSWRfNzpcIlwiLFxyXG4gICAgICAgIHd4VmlkZW9JZF84OlwiXCIsXHJcbiAgICAgICAgd3hWaWRlb0lkXzk6XCJcIixcclxuICAgICAgICB3eFZpZGVvSWRfMTA6XCJcIixcclxuXHJcbiAgICAgICAgYWxsU2NyZWVuOmZhbHNlLFxyXG5cclxuICAgIFx0Ly/pppblhYjnoa7lrprkvb/nlKjnmoTlubPlj7BcclxuICAgIFx0SW5pdDpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsU2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICBcdC8v6I635Y+W5bm/5ZGK54K5SURcclxuXHQgICAgZ2V0QmFubmVyQWRJZDpmdW5jdGlvbigpXHJcblx0ICAgIHtcclxuXHRcdFx0bGV0IGlzS3VhaVNob3UgPSBmYWxzZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvL+i/kOihjOWcqOW/q+aJi+W5s+WPsFxyXG5cdFx0XHRcdGlzS3VhaVNob3UgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmJhbm5lcklkX3d4O1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJBSURVX0dBTUUpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5iYW5uZXJJZF9iYWlkdTtcclxuXHRcdFx0fSBlbHNlIGlmIChjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5CWVRFREFOQ0VfR0FNRSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmJhbm5lcklkX3R0O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgLy/ojrflj5blub/lkYrngrlJRCAg6L+Z6YeM6YWN572uIOinhumikeWlluWKseW5v+WRiiBJZCDnlLHkuo7kvJrmnInlpJrkuKrlub/lkYrngrkgIOagueaNruWQjuWPsOiuvue9ruadpemhtlxyXG5cdCAgICBnZXRWaWRlb0FkSWQ6ZnVuY3Rpb24oYWROYW1lKVxyXG5cdCAgICB7XHJcblx0XHRcdGxldCBpc0t1YWlTaG91ID0gZmFsc2U7XHJcblx0XHRcdGlmICh0eXBlb2Yga3MgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly/ov5DooYzlnKjlv6vmiYvlubPlj7BcclxuXHRcdFx0XHRpc0t1YWlTaG91ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdCAgICAgICAgdmFyIGFkSWQ7XHJcblx0ICAgICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICBzd2l0Y2goYWROYW1lKVxyXG5cdCAgICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEE6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy53eFZpZGVvSWRfMTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIEFkc1BhcmFtLlBvaW50QjpcclxuXHQgICAgICAgICAgICAgICAgICAgIGFkSWQgPSB0aGlzLnd4VmlkZW9JZF8yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnRDOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMud3hWaWRlb0lkXzM7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy53eFZpZGVvSWRfNDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIEFkc1BhcmFtLlBvaW50RTpcclxuXHQgICAgICAgICAgICAgICAgICAgIGFkSWQgPSB0aGlzLnd4VmlkZW9JZF81O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnRGOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMud3hWaWRlb0lkXzY7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy53eFZpZGVvSWRfNztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIEFkc1BhcmFtLlBvaW50SDpcclxuXHQgICAgICAgICAgICAgICAgICAgIGFkSWQgPSB0aGlzLnd4VmlkZW9JZF84O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnRJOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMud3hWaWRlb0lkXzk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEo6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy53eFZpZGVvSWRfMTA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJBSURVX0dBTUUpXHJcblx0ICAgICAgICB7XHJcblx0ICAgICAgICAgICAgc3dpdGNoKGFkTmFtZSlcclxuXHQgICAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnRBOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMuYmRWaWRlb0lkXzE7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEI6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy5iZFZpZGVvSWRfMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIEFkc1BhcmFtLlBvaW50QzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGFkSWQgPSB0aGlzLmJkVmlkZW9JZF8zO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnREOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMuYmRWaWRlb0lkXzQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEU6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy5iZFZpZGVvSWRfNTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIEFkc1BhcmFtLlBvaW50RjpcclxuXHQgICAgICAgICAgICAgICAgICAgIGFkSWQgPSB0aGlzLmJkVmlkZW9JZF82O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnRHOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMuYmRWaWRlb0lkXzc7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSBBZHNQYXJhbS5Qb2ludEg6XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZElkID0gdGhpcy5iZFZpZGVvSWRfODtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIEFkc1BhcmFtLlBvaW50STpcclxuXHQgICAgICAgICAgICAgICAgICAgIGFkSWQgPSB0aGlzLmJkVmlkZW9JZF85O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgQWRzUGFyYW0uUG9pbnRKOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRJZCA9IHRoaXMuYmRWaWRlb0lkXzEwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGFkSWQ7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBTaG93QmFubmVyQWRzOmZ1bmN0aW9uKClcclxuXHQgICAge1xyXG5cdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRsZXQgaXNLdWFpU2hvdSA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcblx0XHRcdFx0aXNLdWFpU2hvdSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHQgICAgICAgIGlmKHRoaXMuYmFubmVyQWRTaG93TnVtID09IG51bGwpXHJcblx0ICAgICAgICAgICAgdGhpcy5iYW5uZXJBZFNob3dOdW0gPSAwO1xyXG5cdCAgICAgICAgdGhpcy5iYW5uZXJBZFNob3dOdW0gKys7XHJcblx0ICAgICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICBpZih0aGlzLmJhbm5lckFkQ3RybCAhPW51bGwgJiYgdGhpcy5iYW5uZXJBZFNob3dOdW0lNSE9MClcclxuXHQgICAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5iYW5uZXJBZFNob3dOdW0gPSAwO1xyXG5cclxuXHQgICAgICAgICAgICBpZih0aGlzLmJhbm5lckFkQ3RybCAhPW51bGwpXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuYmFubmVyQWRDdHJsLmRlc3Ryb3koKTtcclxuXHQgICAgICAgICAgICBsZXQgV1hBRD17fTtcclxuXHQgICAgICAgICAgICBXWEFELlcgPSB3eC5nZXRTeXN0ZW1JbmZvU3luYygpLndpbmRvd1dpZHRoO1xyXG5cdCAgICAgICAgICAgIFdYQUQuSCA9IHd4LmdldFN5c3RlbUluZm9TeW5jKCkud2luZG93SGVpZ2h0O1xyXG5cclxuXHQgICAgICAgICAgICBsZXQgYWRXaWR0aCA9IDA7XHJcblx0ICAgICAgICAgICAgaWYodGhpcy5hbGxTY3JlZW4pXHJcblx0ICAgICAgICAgICAgICAgIGFkV2lkdGggPSBXWEFELlc7XHJcblx0ICAgICAgICAgICAgZWxzZVxyXG5cdCAgICAgICAgICAgICAgICBhZFdpZHRoID0gMzAwO1xyXG5cdCAgICAgICAgICAgIHRoaXMuYmFubmVyQWRDdHJsID0gd3guY3JlYXRlQmFubmVyQWQoe1xyXG5cdCAgICAgICAgICAgICAgICBhZFVuaXRJZDogdGhpcy5nZXRCYW5uZXJBZElkKCksXHJcblx0ICAgICAgICAgICAgICAgIHN0eWxlOiB7IFxyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgIHRvcDogMC8qLyhXWEFELkgvMTApKjgqLyxcclxuXHQgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBhZFdpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5iYW5uZXJBZEN0cmwub25SZXNpemUocmVzPT57XHJcblx0ICAgIFxyXG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIumHjee9ruW5v+WRiuWuveW6piBcIiArIFdYQUQuSCArIFwiICwgXCIgKyBzZWxmLmJhbm5lckFkQ3RybC5zdHlsZS5yZWFsSGVpZ2h0KTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5iYW5uZXJBZEN0cmwuc3R5bGUudG9wID0gV1hBRC5ILXNlbGYuYmFubmVyQWRDdHJsLnN0eWxlLnJlYWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYuYmFubmVyQWRDdHJsLnN0eWxlLmxlZnQgPSAoV1hBRC5XLXNlbGYuYmFubmVyQWRDdHJsLnN0eWxlLnJlYWxXaWR0aCkvMjtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5iYW5uZXJBZEN0cmwuc2hvdygpO1xyXG5cdCAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB9KTsgXHJcblx0ICAgICAgICAgICAgdGhpcy5iYW5uZXJBZEN0cmwub25FcnJvcihlcnIgPT4geyBjb25zb2xlLmxvZyhlcnIpIH0pOyBcclxuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaYvuekuuW5v+WRilwiKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuXHQgICAgICAgIHtcclxuXHQgICAgICAgICAgICBpZihzd2FuLmdldFN5c3RlbUluZm9TeW5jKCkucGxhdGZvcm0gPT0gJ2lvcycpIC8v55uu5YmNIGlvcyDkuI3mlK/mjIHop4bpopHlub/lkYpcclxuXHQgICAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYodGhpcy5iYW5uZXJBZEN0cmwgIT1udWxsKVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmJhbm5lckFkQ3RybC5kZXN0cm95KCk7XHJcblx0ICAgICAgICAgICAgbGV0IFdYQUQ9e307XHJcblxyXG5cdCAgICAgICAgICAgIFdYQUQuVyA9IHN3YW4uZ2V0U3lzdGVtSW5mb1N5bmMoKS53aW5kb3dXaWR0aDtcclxuXHQgICAgICAgICAgICBXWEFELkggPSBzd2FuLmdldFN5c3RlbUluZm9TeW5jKCkud2luZG93SGVpZ2h0O1xyXG5cclxuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcIueZvuW6pueahCBiYW5uZXJJZCA9IFwiICsgdGhpcy5nZXRCYW5uZXJBZElkKCkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuYmFubmVyQWRDdHJsID0gc3dhbi5jcmVhdGVCYW5uZXJBZCh7XHJcblx0ICAgICAgICAgICAgICAgIGFkVW5pdElkOiB0aGlzLmdldEJhbm5lckFkSWQoKSxcclxuXHQgICAgICAgICAgICAgICAgYXBwU2lkOidjMGZiNDA3ZicsXHJcblx0ICAgICAgICAgICAgICAgIHN0eWxlOiB7IFxyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzMjEsXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgaWYodGhpcy5hbGxTY3JlZW4pXHJcblx0ICAgICAgICAgICAgICAgIHNlbGYuYmFubmVyQWRDdHJsLnN0eWxlLndpZHRoID0gV1hBRC5IO1xyXG5cdCAgICAgICAgICAgIGVsc2VcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5iYW5uZXJBZEN0cmwuc3R5bGUud2lkdGggPSAzMDA7XHJcblx0ICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB0aGlzLmJhbm5lckFkQ3RybC5vblJlc2l6ZShyZXM9PntcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLph43nva7lub/lkYrlrr3luqYgXCIpO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLmJhbm5lckFkQ3RybC5zdHlsZS50b3AgPSBXWEFELkgtcmVzLmhlaWdodDtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5iYW5uZXJBZEN0cmwuc3R5bGUubGVmdCA9IChXWEFELlctcmVzLndpZHRoKS8yO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLmJhbm5lckFkQ3RybC5zaG93KCk7XHJcblx0ICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIH0pOyBcclxuXHJcblx0ICAgICAgICAgICAgdGhpcy5iYW5uZXJBZEN0cmwub25Mb2FkKCgpID0+IHtcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyBiYW5uZXIg5Yqg6L295a6M5oiQJyk7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYuYmFubmVyQWRDdHJsLnNob3coKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB0aGlzLmJhbm5lckFkQ3RybC5vbkVycm9yKGVyciA9PiB7IGNvbnNvbGUubG9nKGVycikgfSk7IFxyXG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5pi+56S65bm/5ZGKXCIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgSGlkZUJhbm5lckFkOmZ1bmN0aW9uKCl7XHJcblx0ICAgIFx0aWYodGhpcy5iYW5uZXJBZEN0cmwgIT0gbnVsbClcclxuXHQgICAgXHRcdHRoaXMuYmFubmVyQWRDdHJsLmhpZGUoKTtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIFJlY292ZXJTaG93QmFubmVyOmZ1bmN0aW9uKCl7XHJcblx0ICAgIFx0aWYodGhpcy5iYW5uZXJBZEN0cmwgIT0gbnVsbClcclxuXHQgICAgXHRcdHRoaXMuYmFubmVyQWRDdHJsLnNob3coKTtcclxuXHQgICAgXHRlbHNlXHJcblx0ICAgIFx0XHR0aGlzLlNob3dCYW5uZXJBZHMoKTtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIERlc3Ryb3lCYW5uZXI6ZnVuY3Rpb24oKXtcclxuXHQgICAgXHRpZih0aGlzLmJhbm5lckFkQ3RybCAhPW51bGwpXHJcblx0ICAgICAgICAgICAgdGhpcy5iYW5uZXJBZEN0cmwuZGVzdHJveSgpO1xyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgLy9jYiDlm57osIPlj4LmlbAgMCDmkq3mlL7lrozmiJDvvIwxIOS4jeaUvuacquWujOaIkCDvvIwtMSDop4bpopHliqDovb3lh7rplJlcclxuXHQgICAgLy8gU2hvd1ZpZGVvQWRzOmZ1bmN0aW9uKGFkTmFtZSxjYilcclxuXHQgICAgLy8ge1xyXG5cdCAgICAvLyAgICAgdGhpcy5jYiA9IGNiXHJcblx0ICAgIC8vICAgICBpZihjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSlcclxuXHQgICAgLy8gICAgIHtcclxuXHQgICAgLy8gICAgICAgICBsZXQgdmlkZW9BZCA9IHd4LmNyZWF0ZVJld2FyZGVkVmlkZW9BZCh7XHJcblx0ICAgIC8vICAgICAgICAgICAgIGFkVW5pdElkOiB0aGlzLmdldFZpZGVvQWRJZChhZE5hbWUpXHJcblx0ICAgIC8vICAgICAgICAgfSlcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICAgICAgICB2aWRlb0FkLmxvYWQoKVxyXG5cdCAgICAvLyAgICAgICAgIC50aGVuKCgpID0+IHZpZGVvQWQuc2hvdygpKVxyXG5cdCAgICAvLyAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyLmVyck1zZykpXHJcblx0XHQvL1xyXG5cdCAgICAvLyAgICAgICAgIHZpZGVvQWQub25FcnJvcihlcnIgPT4ge1xyXG5cdCAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuW5v+WRiuWKoOi9veWHuumUmSBcIiArIGVyci5lcnJNc2cpXHJcblx0ICAgIC8vICAgICAgICAgICAgIHRoaXMuY2IoLTEpO1xyXG5cdCAgICAvLyAgICAgICAgIH0pO1xyXG5cdFx0Ly9cclxuXHQgICAgLy8gICAgICAgICB2aWRlb0FkLm9uTG9hZCgoKT0+eyBjb25zb2xlLmxvZyhcIuWKoOi9veS6i+S7tuWbnuiwg1wiKSB9KTtcclxuXHRcdC8vXHJcblx0ICAgIC8vICAgICAgICAgdmlkZW9BZC5vbkNsb3NlKHJlcyA9PntcclxuXHQgICAgLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCLmmK/lkKbop4LnnIvlrozmlbTkuoYgXCIgKyByZXMuaXNFbmRlZClcclxuXHQgICAgLy8gICAgICAgICAgICAgdGhpcy5jYihyZXMuaXNFbmRlZD8wOjEpO1xyXG5cdCAgICAvLyAgICAgICAgICAgICB2aWRlb0FkLm9mZkxvYWQoKTtcclxuXHQgICAgLy8gICAgICAgICAgICAgdmlkZW9BZC5vZmZFcnJvcigpO1xyXG5cdCAgICAvLyAgICAgICAgICAgICB2aWRlb0FkLm9mZkNsb3NlKCk7XHJcblx0XHQvL1xyXG5cdCAgICAvLyAgICAgICAgIH0pO1xyXG5cdFx0Ly9cclxuXHQgICAgLy8gICAgIH1cclxuXHQgICAgLy8gICAgIGVsc2UgaWYoY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuQkFJRFVfR0FNRSlcclxuXHQgICAgLy8gICAgIHtcclxuXHQgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhcIueZvuW6pueahOinhumikeW5v+WRiiAgXCIgKyB0aGlzLmdldFZpZGVvQWRJZChhZE5hbWUpKTtcclxuXHRcdC8vXHJcblx0ICAgIC8vICAgICAgICAgbGV0IHZpZGVvQWQgPSBzd2FuLmNyZWF0ZVJld2FyZGVkVmlkZW9BZCh7XHJcblx0ICAgIC8vICAgICAgICAgICAgIGFkVW5pdElkOiB0aGlzLmdldFZpZGVvQWRJZChhZE5hbWUpLFxyXG5cdCAgICAvLyAgICAgICAgICAgICBhcHBTaWQ6ICdjMGZiNDA3ZicsXHJcblx0ICAgIC8vICAgICAgICAgfSlcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICAgICAgICB2aWRlb0FkLmxvYWQoKVxyXG5cdCAgICAvLyAgICAgICAgIC50aGVuKCgpID0+IHZpZGVvQWQuc2hvdygpKVxyXG5cdCAgICAvLyAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyLmVyck1zZykpXHJcblx0XHQvL1xyXG5cdCAgICAvLyAgICAgICAgIHZpZGVvQWQub25FcnJvcihlcnIgPT4ge1xyXG5cdCAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuW5v+WRiuWKoOi9veWHuumUmSBcIiArIGVyci5lcnJNc2cpXHJcblx0ICAgIC8vICAgICAgICAgICAgIHRoaXMuY2IoLTEpO1xyXG5cdCAgICAvLyAgICAgICAgIH0pO1xyXG5cdFx0Ly9cclxuXHQgICAgLy8gICAgICAgICB2aWRlb0FkLm9uTG9hZCgoKT0+eyBjb25zb2xlLmxvZyhcIuWKoOi9veS6i+S7tuWbnuiwg1wiKSB9KTtcclxuXHRcdC8vXHJcblx0ICAgIC8vICAgICAgICAgdmlkZW9BZC5vbkNsb3NlKHJlcyA9PntcclxuXHQgICAgLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCLmmK/lkKbop4LnnIvlrozmlbTkuoYgXCIgKyByZXMuaXNFbmRlZClcclxuXHQgICAgLy8gICAgICAgICAgICAgdGhpcy5jYihyZXMuaXNFbmRlZD8wOjEpO1xyXG5cdCAgICAvLyAgICAgICAgICAgICB2aWRlb0FkLm9mZkxvYWQoKTtcclxuXHQgICAgLy8gICAgICAgICAgICAgdmlkZW9BZC5vZmZFcnJvcigpO1xyXG5cdCAgICAvLyAgICAgICAgICAgICB2aWRlb0FkLm9mZkNsb3NlKCk7XHJcblx0XHQvL1xyXG5cdCAgICAvLyAgICAgICAgIH0pO1xyXG5cdFx0Ly9cclxuXHQgICAgLy8gICAgIH1cclxuXHQgICAgLy8gICAgIGVsc2VcclxuXHQgICAgLy8gICAgIHtcclxuXHQgICAgLy8gICAgICAgICB0aGlzLmNiKDApO1xyXG5cdCAgICAvLyAgICAgfVxyXG5cdCAgICAvLyB9LFxyXG5cclxuXHRcdC8vY2Ig5Zue6LCD5Y+C5pWwIDAg5pKt5pS+5a6M5oiQ77yMMSDkuI3mlL7mnKrlrozmiJAg77yMLTEg6KeG6aKR5Yqg6L295Ye66ZSZXHJcblx0XHRTaG93VmlkZW9BZHM6ZnVuY3Rpb24oYWROYW1lLGNiKSB7XHJcblx0XHRcdHRoaXMuY2IgPSBjYlxyXG5cdFx0XHRsZXQgaXNLdWFpU2hvdSA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodHlwZW9mIGtzICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdC8v6L+Q6KGM5Zyo5b+r5omL5bmz5Y+wXHJcblx0XHRcdFx0aXNLdWFpU2hvdSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGNjLnN5cy5wbGF0Zm9ybSA9PT0gY2Muc3lzLkJZVEVEQU5DRV9HQU1FKSB7XHJcblx0XHRcdFx0bGV0IHJld2FyZGVkVmlkZW9BZEluZm8gPSB7XHJcblx0XHRcdFx0XHRhZFVuaXRJZDogJzExMzVoMGdjOGNpYWgxODJqMicsXHJcblx0XHRcdFx0XHRvbkNsb3NlOiBvbkNsb3NlUmVzID0+IHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jYihvbkNsb3NlUmVzICYmIG9uQ2xvc2VSZXMuaXNFbmRlZCA/IDAgOiAxKVxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdG9uRXJyb3I6IGVycm9yID0+IHRoaXMuY2IoLTEpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGV5b3VDbGllbnRUaWt0b2suZ2V0SW5zKCkuY3JlYXRlUmV3YXJkZWRWaWRlb0FkKHJld2FyZGVkVmlkZW9BZEluZm8sIGNyZWF0ZVJld2FyZGVkVmlkZW9BZFJlcyA9PiB7XHJcblx0XHRcdFx0XHRpZiAoY3JlYXRlUmV3YXJkZWRWaWRlb0FkUmVzLmNvZGUgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0ZXlvdUNsaWVudFRpa3Rvay5nZXRJbnMoKS5zaG93UmV3YXJkZWRWaWRlb0FkKClcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2IoLTEpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fSBlbHNlIGlmIChjYy5zeXMucGxhdGZvcm0gPT09IGNjLnN5cy5XRUNIQVRfR0FNRSAmJiAhaXNLdWFpU2hvdSkge1xyXG5cdFx0XHRcdGxldCByZXdhcmRlZFZpZGVvQWRJbmZvID0ge1xyXG5cdFx0XHRcdFx0YWRVbml0SWQ6ICdhZHVuaXQtM2NmMzcyZmQ3NDg3ZmQ4NycsXHJcblx0XHRcdFx0XHRvbkNsb3NlOiBvbkNsb3NlUmVzID0+IHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jYihvbkNsb3NlUmVzICYmIG9uQ2xvc2VSZXMuY29kZSA9PT0gMCA/IDAgOiAxKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRleW91Q2xpZW50LmdldElucygpLmNyZWF0ZVJld2FyZGVkVmlkZW9BZChyZXdhcmRlZFZpZGVvQWRJbmZvLCBjcmVhdGVSZXdhcmRlZFZpZGVvQWRSZXMgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGNyZWF0ZVJld2FyZGVkVmlkZW9BZFJlcy5jb2RlID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGV5b3VDbGllbnQuZ2V0SW5zKCkuc2hvd1Jld2FyZGVkVmlkZW9BZCgpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fWVsc2UgaWYgKGlzS3VhaVNob3Upe1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwi5b+r5omL5bm/5ZGKXCIpXHJcblx0XHRcdFx0bGV0IHJld2FyZGVkVmlkZW9BZEluZm8gPSB7XHJcblx0XHRcdFx0XHRhZFVuaXRJZDogJzIzMDAwMDk1MjVfMDEnLFxyXG5cdFx0XHRcdFx0b25DbG9zZTogb25DbG9zZVJlcyA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2Iob25DbG9zZVJlcyAmJiBvbkNsb3NlUmVzLmlzRW5kZWQgPyAwIDogMSlcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRvbkVycm9yOiBlcnJvciA9PiB0aGlzLmNiKC0xKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRleW91Q2xpZW50S3MuZ2V0SW5zKCkuY3JlYXRlUmV3YXJkZWRWaWRlb0FkKHJld2FyZGVkVmlkZW9BZEluZm8sIGNyZWF0ZVJld2FyZGVkVmlkZW9BZFJlcyA9PiB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIuWIm+W7uua/gOWKseinhumikee7hOS7tuWbnuiwgzo+XCIsIGNyZWF0ZVJld2FyZGVkVmlkZW9BZFJlcyk7XHJcblx0XHRcdFx0XHRpZiAoY3JlYXRlUmV3YXJkZWRWaWRlb0FkUmVzLmNvZGUgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0ZXlvdUNsaWVudEtzLmdldElucygpLnNob3dSZXdhcmRlZFZpZGVvQWQoKVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jYigtMSlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG4gICAgfSwgXHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEFkc01ncjtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/crypto-browserify/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/create-hash/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/create-hmac/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/randombytes/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this,require("../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/pbkdf2/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports.pbkdf2 = require('./lib/async')
exports.pbkdf2Sync = require('./lib/sync')

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/diffie-hellman/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (Buffer){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this,require("buffer").Buffer)
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/create-ecdh/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (Buffer){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this,require("buffer").Buffer)
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/randomfill/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this,require("../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/pbkdf2/lib/sync-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Buffer = require('safe-buffer').Buffer

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var toBuffer = require('./to-buffer')

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/diffie-hellman/lib/primes.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/md5.js/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/inherits/inherits_browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/ripemd160/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/cipher-base/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/create-hash/md5.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/create-hmac/legacy.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/safe-buffer/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/pbkdf2/lib/async.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (global){
var Buffer = require('safe-buffer').Buffer

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var sync = require('./sync')
var toBuffer = require('./to-buffer')

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask
  } else if (global.setImmediate) {
    nextTick = global.setImmediate
  } else {
    nextTick = global.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/process/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/publicEncrypt.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/privateDecrypt.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/diffie-hellman/lib/generatePrime.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/diffie-hellman/lib/dh.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this,require("buffer").Buffer)
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/buffer/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/algos.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('./browser/algorithms.json')

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/browser/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var stream = require('readable-stream')
var inherits = require('inherits')
var sign = require('./sign')
var verify = require('./verify')

var algorithms = require('./algorithms.json')
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-cipher/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/create-ecdh/node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/pbkdf2/lib/precondition.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/pbkdf2/lib/default-encoding.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
var defaultEncoding
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8'
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding

}).call(this,require("../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/pbkdf2/lib/to-buffer.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/sha.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/sha256.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/sha384.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/sha512.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/stream-browserify/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/sha1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/string_decoder/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/sha224.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/parse-asn1/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
var Buffer = require('safe-buffer').Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/xor.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/withPublic.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/mgf.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/base64-js/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/ieee754/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/evp_bytestokey/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/curves.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/ec/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/curve/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/eddsa/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/miller-rabin/lib/mr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/brorand/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/utils.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/package.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {
  "_from": "elliptic@^6.5.3",
  "_id": "elliptic@6.5.4",
  "_inBundle": false,
  "_integrity": "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
  "_location": "/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "elliptic@^6.5.3",
    "name": "elliptic",
    "escapedName": "elliptic",
    "rawSpec": "^6.5.3",
    "saveSpec": null,
    "fetchSpec": "^6.5.3"
  },
  "_requiredBy": [
    "/browserify-sign",
    "/create-ecdh"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
  "_shasum": "da37cebd31e79a1367e941b592ed1fbebd58abbb",
  "_spec": "elliptic@^6.5.3",
  "_where": "C:\\Users\\nantas\\fireball-x\\fireball_2.4.12\\dist\\resources\\app\\node_modules\\browserify-sign",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  },
  "deprecated": false,
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.5.4"
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/buffer/node_modules/isarray/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browser-resolve/empty.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/browser/algorithms.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/browser/sign.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var EC = require('elliptic').ec
var BN = require('bn.js')
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [0, 1]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return Buffer.from(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r)
  if (s[0] & 0x80) s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [0x30, total, 0x02, r.length]
  res = res.concat(r, [0x02, s.length], s)
  return Buffer.from(res)
}

function getKey (x, q, hash, algo) {
  x = Buffer.from(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = Buffer.alloc(hlen)
  v.fill(1)
  var k = Buffer.alloc(hlen)
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = Buffer.from(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = Buffer.alloc(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/browser/verify.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer
var BN = require('bn.js')
var EC = require('elliptic').ec
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [1]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = Buffer.from(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = Buffer.from(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/public-encrypt/node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/sha.js/hash.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/events/events.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/parse-asn1/asn1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict'

var asn1 = require('asn1.js')

exports.certificate = require('./certificate')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/writable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
var Stream = require("stream")
var Writable = require("./lib/_stream_writable.js")

if (process.env.READABLE_STREAM === 'disable') {
  module.exports = Stream && Stream.Writable || Writable
} else {
  module.exports = Writable
}

}).call(this,require("../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/parse-asn1/aesid.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/parse-asn1/fixProc.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
var Buffer = require('safe-buffer').Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/transform.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('./readable').Transform

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/passthrough.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('./readable').PassThrough

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-rsa/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (Buffer){
var BN = require('bn.js')
var randomBytes = require('randombytes')

function blind (priv) {
  var r = getr(priv)
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed()
  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
}

function getr (priv) {
  var len = priv.modulus.byteLength()
  var r
  do {
    r = new BN(randomBytes(len))
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
  return r
}

function crt (msg, priv) {
  var blinds = blind(priv)
  var len = priv.modulus.byteLength()
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus)
  var c1 = blinded.toRed(BN.mont(priv.prime1))
  var c2 = blinded.toRed(BN.mont(priv.prime2))
  var qinv = priv.coefficient
  var p = priv.prime1
  var q = priv.prime2
  var m1 = c1.redPow(priv.exponent1).fromRed()
  var m2 = c2.redPow(priv.exponent2).fromRed()
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q)
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len)
}
crt.getr = getr

module.exports = crt

}).call(this,require("buffer").Buffer)
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/duplex.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('./readable').Duplex

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/readable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
var Stream = require('stream');
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = require('./lib/_stream_readable.js');
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = require('./lib/_stream_writable.js');
  exports.Duplex = require('./lib/_stream_duplex.js');
  exports.Transform = require('./lib/_stream_transform.js');
  exports.PassThrough = require('./lib/_stream_passthrough.js');
}

}).call(this,require("../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-des/modes.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/ec/key.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/readable-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/curve/base.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/ec/signature.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/curve/short.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/curve/mont.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/curve/edwards.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/eddsa/key.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/lib/elliptic/eddsa/signature.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-des/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/minimalistic-assert/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/readable-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hmac-drbg/lib/hmac-drbg.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/minimalistic-crypto-utils/lib/utils.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/_stream_writable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require("../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/elliptic/node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/parse-asn1/certificate.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict'

var asn = require('asn1.js')

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/miller-rabin/node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this,require("../../../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/readable-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/_stream_transform.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/_stream_duplex.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/browser/curves.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/_stream_passthrough.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/_stream_readable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, { hasUnpiped: false });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require("../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require("../../../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this,require("../../../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/common.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/ripemd.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/utils.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/hmac.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/des.js/lib/des.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/end-of-stream.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/process-nextick-args/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require("../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/util-deprecate/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this,require("../../../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/internal/streams/stream-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('events').EventEmitter;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/decrypter.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/list.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/encrypter.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_passthrough.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_writable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this,require("../../../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_readable.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require("../../../../process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('events').EventEmitter;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/errors-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/api.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const encoders = require('./encoders');
const decoders = require('./decoders');
const inherits = require('inherits');

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }
  inherits(Generated, Base);
  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this,require("../../../../../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/base/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/encoders/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/constants/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const constants = exports;

// Helper
constants._reverse = function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/decoders/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/core-util-is/lib/util.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/ecb.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/node_modules/safe-buffer/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/cfb8.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/cbc.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/cfb.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/end-of-stream.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/node_modules/isarray/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/internal/streams/BufferList.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
'use strict';

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}).call(this,require("../../../../../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/lib/internal/streams/destroy.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, _this, err);
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/cfb1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha/224.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/ctr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/modes/ofb.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/pipeline.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash-base/node_modules/string_decoder/lib/string_decoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/des.js/lib/des/cipher.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha/256.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha/384.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha/1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha/512.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/des.js/lib/des/des.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var utils = require('./utils');
var Cipher = require('./cipher');

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/des.js/lib/des/utils.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/des.js/lib/des/ede.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var Cipher = require('./cipher');
var DES = require('./des');

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/des.js/lib/des/cbc.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/node_modules/bn.js/lib/bn.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/base/reporter.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;

  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;

  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;

  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/base/node.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const Reporter = require('../base/reporter').Reporter;
const EncoderBuffer = require('../base/buffer').EncoderBuffer;
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const assert = require('minimalistic-assert');

// Supported tags
const tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
const overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;
  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

const stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      const res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  let result = state['default'];
  let present = true;

  let prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    let tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  let prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    const start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      let save;
      if (state.any)
        save = input.save();
      const body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) {
      // no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
        ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
      ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  const state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;

  Object.keys(state.choice).some(function(key) {
    const save = input.save();
    const node = state.choice[key];
    try {
      const value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  const result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  let result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default'];
    else
      return;
  }

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;

  const node = state.choice[data.type];
  if (!node) {
    assert(
      false,
      data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/constants/der.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

// Helper
function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/encoders/der.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    const header = Buffer.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    const buf = Buffer.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null)
    return false;

  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  let res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/decoders/der.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const inherits = require('inherits');

const bignum = require('bn.js');
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer,
    'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  let len = derDecodeLen(buffer,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  const state = buffer.save();
  const res = this._skipUntilEnd(
    buffer,
    'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    let res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len);
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
  options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    let str = '';
    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  const first = (identifiers[0] / 40) | 0;
  const second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();

  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  const tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  const num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/encoders/pem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const inherits = require('inherits');

const DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);

  const p = buf.toString('base64');
  const out = [ '-----BEGIN ' + options.label + '-----' ];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/base/buffer.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const inherits = require('inherits');
const Reporter = require('../base/reporter').Reporter;
const Buffer = require('safer-buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    Buffer.isBuffer(data.base) &&
    data.constructor.name === 'DecoderBuffer' &&
    typeof data.offset === 'number' &&
    typeof data.length === 'number' &&
    typeof data.save === 'function' &&
    typeof data.restore === 'function' &&
    typeof data.isEmpty === 'function' &&
    typeof data.readUInt8 === 'function' &&
    typeof data.skip === 'function' &&
    typeof data.raw === 'function';

  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  const res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    data.constructor.name === 'EncoderBuffer' &&
    typeof data.length === 'number' &&
    typeof data.join === 'function';

  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = Buffer.alloc(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/asn1.js/lib/asn1/decoders/pem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;

const DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);

  const label = options.label.toUpperCase();

  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  const base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9+/=]+/gi, '');

  const input = Buffer.from(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/buffer-xor/index.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this,require("../../../../../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = require('events').EventEmitter;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/from-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/hash.js/lib/hash/sha/common.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/authCipher.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/aes.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
'use strict';

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}).call(this,require("../../../../../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/streamCipher.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/buffer_list.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/safer-buffer/safer.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
/* eslint-disable node/no-deprecated-api */

'use strict'

var buffer = require('buffer')
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

}).call(this,require("../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/incr32.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-sign/node_modules/string_decoder/lib/string_decoder.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/browserify-aes/ghash.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------
